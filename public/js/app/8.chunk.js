webpackJsonp([8],{

/***/ 1059:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar core_1 = __webpack_require__(5);\r\nvar createjs = __webpack_require__(1343);\r\nvar AppleDropComponent = (function () {\r\n    function AppleDropComponent() {\r\n    }\r\n    AppleDropComponent.prototype.ngAfterViewInit = function () {\r\n        var stage = new createjs.Stage(\"canvas\");\r\n        console.log(stage);\r\n        var circle = new createjs.Shape();\r\n        circle.graphics.beginFill(\"DeepSkyBlue\").drawCircle(0, 0, 10);\r\n        circle.x = 50;\r\n        circle.y = 50;\r\n        stage.addChild(circle);\r\n        stage.update();\r\n        // createjs.Tween.get(circle, { loop: true })\r\n        // .to({ x: 100 }, 1000, createjs.Ease.getPowInOut(4))\r\n        // .to({ alpha: 0, y: 175 }, 500, createjs.Ease.getPowInOut(2))\r\n        // .to({ alpha: 0, y: 225 }, 100)\r\n        // .to({ alpha: 1, y: 200 }, 500, createjs.Ease.getPowInOut(2))\r\n        // .to({ x: 100 }, 800, createjs.Ease.getPowInOut(2));\r\n        createjs.Ticker.setFPS(60);\r\n        createjs.Ticker.addEventListener(\"tick\", stage);\r\n        //     var canvas = document.getElementById(\"canvas\"),\r\n        //     ctx = canvas.getContext(\"2d\");\r\n        // canvas.width = 934;\r\n        // canvas.height = 622;\r\n        // var background = new Image();\r\n        // background.src = require('../../../assets/games/appleDrop/background.jpg');\r\n        // background.onload = function(){\r\n        //     ctx.drawImage(background,0,0);   \r\n        // }\r\n    };\r\n    AppleDropComponent = __decorate([\r\n        core_1.Component({\r\n            selector: 'sq-apple-drop',\r\n            template: __webpack_require__(1300),\r\n            styles: [__webpack_require__(1323)]\r\n        })\r\n    ], AppleDropComponent);\r\n    return AppleDropComponent;\r\n}());\r\nexports.AppleDropComponent = AppleDropComponent;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA1OS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2Fzc2V0cy9hcHAvc3R1ZGVudC9nYW1lcy9hcHBsZS1kcm9wL2FwcGxlLWRyb3AuY29tcG9uZW50LnRzPzExMzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBWaWV3Q2hpbGQsIFJlbmRlcmVyLCBBZnRlclZpZXdJbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCAqIGFzIGNyZWF0ZWpzIGZyb20gJ2NyZWF0ZWpzLW1vZHVsZSc7XHJcblxyXG5pbXBvcnQgeyBBcGlTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzL2FwaS5zZXJ2aWNlJztcclxuXHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ3NxLWFwcGxlLWRyb3AnLFxyXG4gIHRlbXBsYXRlOiByZXF1aXJlKCcuL2FwcGxlLWRyb3AuY29tcG9uZW50Lmh0bWwnKSxcclxuICBzdHlsZXM6IFtyZXF1aXJlKCcuL2FwcGxlLWRyb3AuY29tcG9uZW50LmNzcycpXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgQXBwbGVEcm9wQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XHJcbiAgXHJcbiAgLy8gcHJpdmF0ZSBjYW52YXM7XHJcbiAgcHJpdmF0ZSBjb250ZXh0O1xyXG5cclxuXHJcbiAgbmdBZnRlclZpZXdJbml0KCkge1xyXG4gICAgdmFyIHN0YWdlID0gbmV3IGNyZWF0ZWpzLlN0YWdlKFwiY2FudmFzXCIpO1xyXG4gICAgY29uc29sZS5sb2coc3RhZ2UpO1xyXG4gICAgdmFyIGNpcmNsZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xyXG4gICAgY2lyY2xlLmdyYXBoaWNzLmJlZ2luRmlsbChcIkRlZXBTa3lCbHVlXCIpLmRyYXdDaXJjbGUoMCwgMCwgMTApO1xyXG4gICAgY2lyY2xlLnggPSA1MDtcclxuICAgIGNpcmNsZS55ID0gNTA7XHJcbiAgICBzdGFnZS5hZGRDaGlsZChjaXJjbGUpO1xyXG5cclxuICAgIFxyXG4gICAgc3RhZ2UudXBkYXRlKCk7XHJcbiBcclxuICAgIC8vIGNyZWF0ZWpzLlR3ZWVuLmdldChjaXJjbGUsIHsgbG9vcDogdHJ1ZSB9KVxyXG4gICAgLy8gLnRvKHsgeDogMTAwIH0sIDEwMDAsIGNyZWF0ZWpzLkVhc2UuZ2V0UG93SW5PdXQoNCkpXHJcbiAgICAvLyAudG8oeyBhbHBoYTogMCwgeTogMTc1IH0sIDUwMCwgY3JlYXRlanMuRWFzZS5nZXRQb3dJbk91dCgyKSlcclxuICAgIC8vIC50byh7IGFscGhhOiAwLCB5OiAyMjUgfSwgMTAwKVxyXG4gICAgLy8gLnRvKHsgYWxwaGE6IDEsIHk6IDIwMCB9LCA1MDAsIGNyZWF0ZWpzLkVhc2UuZ2V0UG93SW5PdXQoMikpXHJcbiAgICAvLyAudG8oeyB4OiAxMDAgfSwgODAwLCBjcmVhdGVqcy5FYXNlLmdldFBvd0luT3V0KDIpKTtcclxuIFxyXG4gICAgY3JlYXRlanMuVGlja2VyLnNldEZQUyg2MCk7XHJcbiAgICBjcmVhdGVqcy5UaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgc3RhZ2UpO1xyXG5cclxuLy8gICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhbnZhc1wiKSxcclxuLy8gICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG4vLyBjYW52YXMud2lkdGggPSA5MzQ7XHJcbi8vIGNhbnZhcy5oZWlnaHQgPSA2MjI7XHJcblxyXG5cclxuLy8gdmFyIGJhY2tncm91bmQgPSBuZXcgSW1hZ2UoKTtcclxuLy8gYmFja2dyb3VuZC5zcmMgPSByZXF1aXJlKCcuLi8uLi8uLi9hc3NldHMvZ2FtZXMvYXBwbGVEcm9wL2JhY2tncm91bmQuanBnJyk7XHJcblxyXG4vLyBiYWNrZ3JvdW5kLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XHJcbi8vICAgICBjdHguZHJhd0ltYWdlKGJhY2tncm91bmQsMCwwKTsgICBcclxuLy8gfVxyXG4gIH1cclxuXHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXItcm91dGVyLWxvYWRlci9zcmMhLi9hc3NldHMvYXBwL3N0dWRlbnQvZ2FtZXMvYXBwbGUtZHJvcC9hcHBsZS1kcm9wLmNvbXBvbmVudC50cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBVUE7QUFBQTtBQTJDQTtBQXJDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUF6Q0E7QUFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEyQ0E7QUFBQTtBQTNDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1059\n");

/***/ }),

/***/ 1060:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar core_1 = __webpack_require__(5);\r\nvar common_1 = __webpack_require__(63);\r\nvar material_1 = __webpack_require__(184);\r\nvar flex_layout_1 = __webpack_require__(302);\r\nvar router_1 = __webpack_require__(186);\r\nvar apple_drop_component_1 = __webpack_require__(1059);\r\nvar routes = [\r\n    { path: '', component: apple_drop_component_1.AppleDropComponent },\r\n    { path: 'apple-drop', component: apple_drop_component_1.AppleDropComponent }\r\n];\r\nvar MathCloudsModule = (function () {\r\n    function MathCloudsModule() {\r\n    }\r\n    MathCloudsModule = __decorate([\r\n        core_1.NgModule({\r\n            imports: [\r\n                common_1.CommonModule,\r\n                material_1.MaterialModule,\r\n                flex_layout_1.FlexLayoutModule,\r\n                router_1.RouterModule.forChild(routes)\r\n            ],\r\n            declarations: [\r\n                apple_drop_component_1.AppleDropComponent\r\n            ]\r\n        })\r\n    ], MathCloudsModule);\r\n    return MathCloudsModule;\r\n}());\r\nexports.default = MathCloudsModule;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA2MC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2Fzc2V0cy9hcHAvc3R1ZGVudC9nYW1lcy9hcHBsZS1kcm9wL2FwcGxlLWRyb3AubW9kdWxlLnRzP2ViMjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgTWF0ZXJpYWxNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XHJcbmltcG9ydCB7IEZsZXhMYXlvdXRNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mbGV4LWxheW91dCc7XHJcbmltcG9ydCB7IFJvdXRlck1vZHVsZSwgUm91dGVzIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcclxuaW1wb3J0IHsgQnJvd3Nlck1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xyXG5pbXBvcnQgeyBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYW5pbWF0aW9ucyc7XHJcblxyXG5pbXBvcnQgeyBBcHBsZURyb3BDb21wb25lbnQgfSBmcm9tICcuL2FwcGxlLWRyb3AuY29tcG9uZW50JztcclxuXHJcblxyXG5jb25zdCByb3V0ZXM6IFJvdXRlcyA9IFtcclxuXHR7IHBhdGg6ICcnLCBjb21wb25lbnQ6IEFwcGxlRHJvcENvbXBvbmVudCB9LFxyXG5cdHsgcGF0aDogJ2FwcGxlLWRyb3AnLCBjb21wb25lbnQ6IEFwcGxlRHJvcENvbXBvbmVudCB9XHJcbl07XHJcblxyXG5ATmdNb2R1bGUoe1xyXG5cdGltcG9ydHM6IFtcclxuXHRcdENvbW1vbk1vZHVsZSxcclxuXHRcdE1hdGVyaWFsTW9kdWxlLFxyXG5cdFx0RmxleExheW91dE1vZHVsZSxcclxuXHRcdFJvdXRlck1vZHVsZS5mb3JDaGlsZChyb3V0ZXMpXHJcblx0XSxcclxuXHRkZWNsYXJhdGlvbnM6IFtcclxuXHRcdEFwcGxlRHJvcENvbXBvbmVudFxyXG5cdF1cclxufSlcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWF0aENsb3Vkc01vZHVsZSB7fVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vYW5ndWxhci1yb3V0ZXItbG9hZGVyL3NyYyEuL2Fzc2V0cy9hcHAvc3R1ZGVudC9nYW1lcy9hcHBsZS1kcm9wL2FwcGxlLWRyb3AubW9kdWxlLnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBYUE7QUFBQTtBQUFBO0FBQUE7QUFYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1060\n");

/***/ }),

/***/ 1300:
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = \"\\r\\n<div class=\\\"background-container\\\">\\r\\n    <img class=\\\"background-image\\\" src=\\\"\" + __webpack_require__(1338) + \"\\\">\\r\\n    <canvas id=\\\"canvas\\\"></canvas>\\r\\n</div>\\r\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMwMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2Fzc2V0cy9hcHAvc3R1ZGVudC9nYW1lcy9hcHBsZS1kcm9wL2FwcGxlLWRyb3AuY29tcG9uZW50Lmh0bWw/MjkwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiXFxyXFxuPGRpdiBjbGFzcz1cXFwiYmFja2dyb3VuZC1jb250YWluZXJcXFwiPlxcclxcbiAgICA8aW1nIGNsYXNzPVxcXCJiYWNrZ3JvdW5kLWltYWdlXFxcIiBzcmM9XFxcIlwiICsgcmVxdWlyZShcIi4uLy4uLy4uL2Fzc2V0cy9nYW1lcy9hcHBsZURyb3AvYmFja2dyb3VuZC5qcGdcIikgKyBcIlxcXCI+XFxyXFxuICAgIDxjYW52YXMgaWQ9XFxcImNhbnZhc1xcXCI+PC9jYW52YXM+XFxyXFxuPC9kaXY+XFxyXFxuXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hc3NldHMvYXBwL3N0dWRlbnQvZ2FtZXMvYXBwbGUtZHJvcC9hcHBsZS1kcm9wLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxMzAwXG4vLyBtb2R1bGUgY2h1bmtzID0gOCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1300\n");

/***/ }),

/***/ 1323:
/***/ (function(module, exports) {

eval("module.exports = \".test {\\n  background-image: url('../test.jpg');\\n  width: 1000px;\\n  height: 1000px;\\n  border: 2px solid black;\\n}\\n\\n.tt {\\n  background-repeat: no-repeat;\\n  background-attachment: fixed;\\n  background-position: center;\\n  background-size: cover;\\n  background-image: url(\\\"../../../assets/games/appleDrop/background.jpg\\\");\\n}\\n\\n.featured-img-display {\\n  width: 200px;\\n  height: 500px;\\n  opacity: 1;\\n  border: 1px solid #F2F2F2;\\n  padding: 40px;\\n  padding-top: 100px;\\n  box-sizing: border-box;\\n  /*background-image: url(http://lorempixel.com/800/800/sports);\\r\\n  */\\n  background: url(test.jpg);\\n  background-size: cover;\\n  background-repeat: no-repeat;\\n}\\n\\n.background-container {\\n  width: 1000px;\\n  height: 750px;\\n  border: solid black 2px;\\n  position: relative;\\n}\\n\\n.background-image {\\n  width: 100%;\\n  height: 100%;\\n  /*margin-top:  -;\\r\\n  */\\n  position: absolute;\\n}\\n\\n#canvas {\\n  position: absolute;\\n  width: 100%;\\n  height: 100%;\\n  /*top: 0;*/\\n}\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMyMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2Fzc2V0cy9hcHAvc3R1ZGVudC9nYW1lcy9hcHBsZS1kcm9wL2FwcGxlLWRyb3AuY29tcG9uZW50LmNzcz80ZWE4Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIudGVzdCB7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJy4uL3Rlc3QuanBnJyk7XFxuICB3aWR0aDogMTAwMHB4O1xcbiAgaGVpZ2h0OiAxMDAwcHg7XFxuICBib3JkZXI6IDJweCBzb2xpZCBibGFjaztcXG59XFxuXFxuLnR0IHtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICBiYWNrZ3JvdW5kLWF0dGFjaG1lbnQ6IGZpeGVkO1xcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyO1xcbiAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwiLi4vLi4vLi4vYXNzZXRzL2dhbWVzL2FwcGxlRHJvcC9iYWNrZ3JvdW5kLmpwZ1xcXCIpO1xcbn1cXG5cXG4uZmVhdHVyZWQtaW1nLWRpc3BsYXkge1xcbiAgd2lkdGg6IDIwMHB4O1xcbiAgaGVpZ2h0OiA1MDBweDtcXG4gIG9wYWNpdHk6IDE7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjRjJGMkYyO1xcbiAgcGFkZGluZzogNDBweDtcXG4gIHBhZGRpbmctdG9wOiAxMDBweDtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAvKmJhY2tncm91bmQtaW1hZ2U6IHVybChodHRwOi8vbG9yZW1waXhlbC5jb20vODAwLzgwMC9zcG9ydHMpO1xcclxcbiAgKi9cXG4gIGJhY2tncm91bmQ6IHVybCh0ZXN0LmpwZyk7XFxuICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuXFxuLmJhY2tncm91bmQtY29udGFpbmVyIHtcXG4gIHdpZHRoOiAxMDAwcHg7XFxuICBoZWlnaHQ6IDc1MHB4O1xcbiAgYm9yZGVyOiBzb2xpZCBibGFjayAycHg7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcblxcbi5iYWNrZ3JvdW5kLWltYWdlIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgLyptYXJnaW4tdG9wOiAgLTtcXHJcXG4gICovXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcblxcbiNjYW52YXMge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICAvKnRvcDogMDsqL1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL2FwcC9zdHVkZW50L2dhbWVzL2FwcGxlLWRyb3AvYXBwbGUtZHJvcC5jb21wb25lbnQuY3NzXG4vLyBtb2R1bGUgaWQgPSAxMzIzXG4vLyBtb2R1bGUgY2h1bmtzID0gOCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1323\n");

/***/ }),

/***/ 1337:
/***/ (function(module, exports) {

eval("module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMzNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanM/YzNjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDEzMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAzIDgiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1337\n");

/***/ }),

/***/ 1338:
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"4a28ba551122f019a6c5ba95c19479f2.jpg\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMzOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2Fzc2V0cy9hcHAvYXNzZXRzL2dhbWVzL2FwcGxlRHJvcC9iYWNrZ3JvdW5kLmpwZz84YmM5Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIjRhMjhiYTU1MTEyMmYwMTlhNmM1YmE5NWMxOTQ3OWYyLmpwZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL2FwcC9hc3NldHMvZ2FtZXMvYXBwbGVEcm9wL2JhY2tncm91bmQuanBnXG4vLyBtb2R1bGUgaWQgPSAxMzM4XG4vLyBtb2R1bGUgY2h1bmtzID0gOCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1338\n");

/***/ }),

/***/ 1342:
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, {}))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM0Mi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9hbWQtb3B0aW9ucy5qcz81ZjcxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgX193ZWJwYWNrX2FtZF9vcHRpb25zX18gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDEzNDJcbi8vIG1vZHVsZSBjaHVua3MgPSA4Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1342\n");

/***/ }),

/***/ 1343:
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;var createjs = (this.createjs = (this.createjs || {}));\n/*!\n* CreateJS\n* Visit http://createjs.com/ for documentation, updates and examples.\n*\n* Copyright (c) 2010 gskinner.com, inc.\n*\n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nthis.createjs = this.createjs||{};\n\n\n//##############################################################################\n// extend.js\n//##############################################################################\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Sets up the prototype chain and constructor property for a new class.\n *\n * This should be called right after creating the class constructor.\n *\n * \tfunction MySubClass() {}\n * \tcreatejs.extend(MySubClass, MySuperClass);\n * \tMySubClass.prototype.doSomething = function() { }\n *\n * \tvar foo = new MySubClass();\n * \tconsole.log(foo instanceof MySuperClass); // true\n * \tconsole.log(foo.prototype.constructor === MySubClass); // true\n *\n * @method extend\n * @param {Function} subclass The subclass.\n * @param {Function} superclass The superclass to extend.\n * @return {Function} Returns the subclass's new prototype.\n */\ncreatejs.extend = function(subclass, superclass) {\n\t\"use strict\";\n\n\tfunction o() { this.constructor = subclass; }\n\to.prototype = superclass.prototype;\n\treturn (subclass.prototype = new o());\n};\n\n//##############################################################################\n// promote.js\n//##############################################################################\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Promotes any methods on the super class that were overridden, by creating an alias in the format `prefix_methodName`.\n * It is recommended to use the super class's name as the prefix.\n * An alias to the super class's constructor is always added in the format `prefix_constructor`.\n * This allows the subclass to call super class methods without using `function.call`, providing better performance.\n *\n * For example, if `MySubClass` extends `MySuperClass`, and both define a `draw` method, then calling `promote(MySubClass, \"MySuperClass\")`\n * would add a `MySuperClass_constructor` method to MySubClass and promote the `draw` method on `MySuperClass` to the\n * prototype of `MySubClass` as `MySuperClass_draw`.\n *\n * This should be called after the class's prototype is fully defined.\n *\n * \tfunction ClassA(name) {\n * \t\tthis.name = name;\n * \t}\n * \tClassA.prototype.greet = function() {\n * \t\treturn \"Hello \"+this.name;\n * \t}\n *\n * \tfunction ClassB(name, punctuation) {\n * \t\tthis.ClassA_constructor(name);\n * \t\tthis.punctuation = punctuation;\n * \t}\n * \tcreatejs.extend(ClassB, ClassA);\n * \tClassB.prototype.greet = function() {\n * \t\treturn this.ClassA_greet()+this.punctuation;\n * \t}\n * \tcreatejs.promote(ClassB, \"ClassA\");\n *\n * \tvar foo = new ClassB(\"World\", \"!?!\");\n * \tconsole.log(foo.greet()); // Hello World!?!\n *\n * @method promote\n * @param {Function} subclass The class to promote super class methods on.\n * @param {String} prefix The prefix to add to the promoted method names. Usually the name of the superclass.\n * @return {Function} Returns the subclass.\n */\ncreatejs.promote = function(subclass, prefix) {\n\t\"use strict\";\n\n\tvar subP = subclass.prototype, supP = (Object.getPrototypeOf&&Object.getPrototypeOf(subP))||subP.__proto__;\n\tif (supP) {\n\t\tsubP[(prefix+=\"_\") + \"constructor\"] = supP.constructor; // constructor is not always innumerable\n\t\tfor (var n in supP) {\n\t\t\tif (subP.hasOwnProperty(n) && (typeof supP[n] == \"function\")) { subP[prefix + n] = supP[n]; }\n\t\t}\n\t}\n\treturn subclass;\n};\n\n//##############################################################################\n// indexOf.js\n//##############################################################################\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Finds the first occurrence of a specified value searchElement in the passed in array, and returns the index of\n * that value.  Returns -1 if value is not found.\n *\n *      var i = createjs.indexOf(myArray, myElementToFind);\n *\n * @method indexOf\n * @param {Array} array Array to search for searchElement\n * @param searchElement Element to find in array.\n * @return {Number} The first index of searchElement in array.\n */\ncreatejs.indexOf = function (array, searchElement){\n\t\"use strict\";\n\n\tfor (var i = 0,l=array.length; i < l; i++) {\n\t\tif (searchElement === array[i]) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\n//##############################################################################\n// Event.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n// constructor:\n\t/**\n\t * Contains properties and methods shared by all events for use with\n\t * {{#crossLink \"EventDispatcher\"}}{{/crossLink}}.\n\t * \n\t * Note that Event objects are often reused, so you should never\n\t * rely on an event object's state outside of the call stack it was received in.\n\t * @class Event\n\t * @param {String} type The event type.\n\t * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.\n\t * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.\n\t * @constructor\n\t **/\n\tfunction Event(type, bubbles, cancelable) {\n\t\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * The type of event.\n\t\t * @property type\n\t\t * @type String\n\t\t **/\n\t\tthis.type = type;\n\t\n\t\t/**\n\t\t * The object that generated an event.\n\t\t * @property target\n\t\t * @type Object\n\t\t * @default null\n\t\t * @readonly\n\t\t*/\n\t\tthis.target = null;\n\t\n\t\t/**\n\t\t * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will\n\t\t * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event\n\t\t * is generated from childObj, then a listener on parentObj would receive the event with\n\t\t * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).\n\t\t * @property currentTarget\n\t\t * @type Object\n\t\t * @default null\n\t\t * @readonly\n\t\t*/\n\t\tthis.currentTarget = null;\n\t\n\t\t/**\n\t\t * For bubbling events, this indicates the current event phase:<OL>\n\t\t * \t<LI> capture phase: starting from the top parent to the target</LI>\n\t\t * \t<LI> at target phase: currently being dispatched from the target</LI>\n\t\t * \t<LI> bubbling phase: from the target to the top parent</LI>\n\t\t * </OL>\n\t\t * @property eventPhase\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @readonly\n\t\t*/\n\t\tthis.eventPhase = 0;\n\t\n\t\t/**\n\t\t * Indicates whether the event will bubble through the display list.\n\t\t * @property bubbles\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.bubbles = !!bubbles;\n\t\n\t\t/**\n\t\t * Indicates whether the default behaviour of this event can be cancelled via\n\t\t * {{#crossLink \"Event/preventDefault\"}}{{/crossLink}}. This is set via the Event constructor.\n\t\t * @property cancelable\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.cancelable = !!cancelable;\n\t\n\t\t/**\n\t\t * The epoch time at which this event was created.\n\t\t * @property timeStamp\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @readonly\n\t\t*/\n\t\tthis.timeStamp = (new Date()).getTime();\n\t\n\t\t/**\n\t\t * Indicates if {{#crossLink \"Event/preventDefault\"}}{{/crossLink}} has been called\n\t\t * on this event.\n\t\t * @property defaultPrevented\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.defaultPrevented = false;\n\t\n\t\t/**\n\t\t * Indicates if {{#crossLink \"Event/stopPropagation\"}}{{/crossLink}} or\n\t\t * {{#crossLink \"Event/stopImmediatePropagation\"}}{{/crossLink}} has been called on this event.\n\t\t * @property propagationStopped\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.propagationStopped = false;\n\t\n\t\t/**\n\t\t * Indicates if {{#crossLink \"Event/stopImmediatePropagation\"}}{{/crossLink}} has been called\n\t\t * on this event.\n\t\t * @property immediatePropagationStopped\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.immediatePropagationStopped = false;\n\t\t\n\t\t/**\n\t\t * Indicates if {{#crossLink \"Event/remove\"}}{{/crossLink}} has been called on this event.\n\t\t * @property removed\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @readonly\n\t\t*/\n\t\tthis.removed = false;\n\t}\n\tvar p = Event.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n// public methods:\n\t/**\n\t * Sets {{#crossLink \"Event/defaultPrevented\"}}{{/crossLink}} to true if the event is cancelable.\n\t * Mirrors the DOM level 2 event standard. In general, cancelable events that have `preventDefault()` called will\n\t * cancel the default behaviour associated with the event.\n\t * @method preventDefault\n\t **/\n\tp.preventDefault = function() {\n\t\tthis.defaultPrevented = this.cancelable&&true;\n\t};\n\n\t/**\n\t * Sets {{#crossLink \"Event/propagationStopped\"}}{{/crossLink}} to true.\n\t * Mirrors the DOM event standard.\n\t * @method stopPropagation\n\t **/\n\tp.stopPropagation = function() {\n\t\tthis.propagationStopped = true;\n\t};\n\n\t/**\n\t * Sets {{#crossLink \"Event/propagationStopped\"}}{{/crossLink}} and\n\t * {{#crossLink \"Event/immediatePropagationStopped\"}}{{/crossLink}} to true.\n\t * Mirrors the DOM event standard.\n\t * @method stopImmediatePropagation\n\t **/\n\tp.stopImmediatePropagation = function() {\n\t\tthis.immediatePropagationStopped = this.propagationStopped = true;\n\t};\n\t\n\t/**\n\t * Causes the active listener to be removed via removeEventListener();\n\t * \n\t * \t\tmyBtn.addEventListener(\"click\", function(evt) {\n\t * \t\t\t// do stuff...\n\t * \t\t\tevt.remove(); // removes this listener.\n\t * \t\t});\n\t * \n\t * @method remove\n\t **/\n\tp.remove = function() {\n\t\tthis.removed = true;\n\t};\n\t\n\t/**\n\t * Returns a clone of the Event instance.\n\t * @method clone\n\t * @return {Event} a clone of the Event instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Event(this.type, this.bubbles, this.cancelable);\n\t};\n\t\n\t/**\n\t * Provides a chainable shortcut method for setting a number of properties on the instance.\n\t *\n\t * @method set\n\t * @param {Object} props A generic object containing properties to copy to the instance.\n\t * @return {Event} Returns the instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t*/\n\tp.set = function(props) {\n\t\tfor (var n in props) { this[n] = props[n]; }\n\t\treturn this;\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Event (type=\"+this.type+\")]\";\n\t};\n\n\tcreatejs.Event = Event;\n}());\n\n//##############################################################################\n// EventDispatcher.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * EventDispatcher provides methods for managing queues of event listeners and dispatching events.\n\t *\n\t * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the\n\t * EventDispatcher {{#crossLink \"EventDispatcher/initialize\"}}{{/crossLink}} method.\n\t * \n\t * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the\n\t * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports\n\t * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.\n\t * \n\t * EventDispatcher also exposes a {{#crossLink \"EventDispatcher/on\"}}{{/crossLink}} method, which makes it easier\n\t * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The \n\t * {{#crossLink \"EventDispatcher/off\"}}{{/crossLink}} method is merely an alias to\n\t * {{#crossLink \"EventDispatcher/removeEventListener\"}}{{/crossLink}}.\n\t * \n\t * Another addition to the DOM Level 2 model is the {{#crossLink \"EventDispatcher/removeAllEventListeners\"}}{{/crossLink}}\n\t * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also \n\t * includes a {{#crossLink \"Event/remove\"}}{{/crossLink}} method which removes the active listener.\n\t *\n\t * <h4>Example</h4>\n\t * Add EventDispatcher capabilities to the \"MyClass\" class.\n\t *\n\t *      EventDispatcher.initialize(MyClass.prototype);\n\t *\n\t * Add an event (see {{#crossLink \"EventDispatcher/addEventListener\"}}{{/crossLink}}).\n\t *\n\t *      instance.addEventListener(\"eventName\", handlerMethod);\n\t *      function handlerMethod(event) {\n\t *          console.log(event.target + \" Was Clicked\");\n\t *      }\n\t *\n\t * <b>Maintaining proper scope</b><br />\n\t * Scope (ie. \"this\") can be be a challenge with events. Using the {{#crossLink \"EventDispatcher/on\"}}{{/crossLink}}\n\t * method to subscribe to events simplifies this.\n\t *\n\t *      instance.addEventListener(\"click\", function(event) {\n\t *          console.log(instance == this); // false, scope is ambiguous.\n\t *      });\n\t *      \n\t *      instance.on(\"click\", function(event) {\n\t *          console.log(instance == this); // true, \"on\" uses dispatcher scope by default.\n\t *      });\n\t * \n\t * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage\n\t * scope.\n\t *\n\t * <b>Browser support</b>\n\t * The event model in CreateJS can be used separately from the suite in any project, however the inheritance model\n\t * requires modern browsers (IE9+).\n\t *      \n\t *\n\t * @class EventDispatcher\n\t * @constructor\n\t **/\n\tfunction EventDispatcher() {\n\t\n\t\n\t// private properties:\n\t\t/**\n\t\t * @protected\n\t\t * @property _listeners\n\t\t * @type Object\n\t\t **/\n\t\tthis._listeners = null;\n\t\t\n\t\t/**\n\t\t * @protected\n\t\t * @property _captureListeners\n\t\t * @type Object\n\t\t **/\n\t\tthis._captureListeners = null;\n\t}\n\tvar p = EventDispatcher.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// static public methods:\n\t/**\n\t * Static initializer to mix EventDispatcher methods into a target object or prototype.\n\t * \n\t * \t\tEventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class\n\t * \t\tEventDispatcher.initialize(myObject); // add to a specific instance\n\t * \n\t * @method initialize\n\t * @static\n\t * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a\n\t * prototype.\n\t **/\n\tEventDispatcher.initialize = function(target) {\n\t\ttarget.addEventListener = p.addEventListener;\n\t\ttarget.on = p.on;\n\t\ttarget.removeEventListener = target.off =  p.removeEventListener;\n\t\ttarget.removeAllEventListeners = p.removeAllEventListeners;\n\t\ttarget.hasEventListener = p.hasEventListener;\n\t\ttarget.dispatchEvent = p.dispatchEvent;\n\t\ttarget._dispatchEvent = p._dispatchEvent;\n\t\ttarget.willTrigger = p.willTrigger;\n\t};\n\t\n\n// public methods:\n\t/**\n\t * Adds the specified event listener. Note that adding multiple listeners to the same function will result in\n\t * multiple callbacks getting fired.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      displayObject.addEventListener(\"click\", handleClick);\n\t *      function handleClick(event) {\n\t *         // Click happened.\n\t *      }\n\t *\n\t * @method addEventListener\n\t * @param {String} type The string type of the event.\n\t * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when\n\t * the event is dispatched.\n\t * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t * @return {Function | Object} Returns the listener for chaining or assignment.\n\t **/\n\tp.addEventListener = function(type, listener, useCapture) {\n\t\tvar listeners;\n\t\tif (useCapture) {\n\t\t\tlisteners = this._captureListeners = this._captureListeners||{};\n\t\t} else {\n\t\t\tlisteners = this._listeners = this._listeners||{};\n\t\t}\n\t\tvar arr = listeners[type];\n\t\tif (arr) { this.removeEventListener(type, listener, useCapture); }\n\t\tarr = listeners[type]; // remove may have deleted the array\n\t\tif (!arr) { listeners[type] = [listener];  }\n\t\telse { arr.push(listener); }\n\t\treturn listener;\n\t};\n\t\n\t/**\n\t * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener\n\t * only run once, associate arbitrary data with the listener, and remove the listener.\n\t * \n\t * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.\n\t * The wrapper function is returned for use with `removeEventListener` (or `off`).\n\t * \n\t * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener, or use\n\t * {{#crossLink \"Event/remove\"}}{{/crossLink}}. Likewise, each time you call `on` a NEW wrapper function is subscribed, so multiple calls\n\t * to `on` with the same params will create multiple listeners.\n\t * \n\t * <h4>Example</h4>\n\t * \n\t * \t\tvar listener = myBtn.on(\"click\", handleClick, null, false, {count:3});\n\t * \t\tfunction handleClick(evt, data) {\n\t * \t\t\tdata.count -= 1;\n\t * \t\t\tconsole.log(this == myBtn); // true - scope defaults to the dispatcher\n\t * \t\t\tif (data.count == 0) {\n\t * \t\t\t\talert(\"clicked 3 times!\");\n\t * \t\t\t\tmyBtn.off(\"click\", listener);\n\t * \t\t\t\t// alternately: evt.remove();\n\t * \t\t\t}\n\t * \t\t}\n\t * \n\t * @method on\n\t * @param {String} type The string type of the event.\n\t * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when\n\t * the event is dispatched.\n\t * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).\n\t * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.\n\t * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.\n\t * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.\n\t **/\n\tp.on = function(type, listener, scope, once, data, useCapture) {\n\t\tif (listener.handleEvent) {\n\t\t\tscope = scope||listener;\n\t\t\tlistener = listener.handleEvent;\n\t\t}\n\t\tscope = scope||this;\n\t\treturn this.addEventListener(type, function(evt) {\n\t\t\t\tlistener.call(scope, evt, data);\n\t\t\t\tonce&&evt.remove();\n\t\t\t}, useCapture);\n\t};\n\n\t/**\n\t * Removes the specified event listener.\n\t *\n\t * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy\n\t * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or\n\t * closure will not work.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      displayObject.removeEventListener(\"click\", handleClick);\n\t *\n\t * @method removeEventListener\n\t * @param {String} type The string type of the event.\n\t * @param {Function | Object} listener The listener function or object.\n\t * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t **/\n\tp.removeEventListener = function(type, listener, useCapture) {\n\t\tvar listeners = useCapture ? this._captureListeners : this._listeners;\n\t\tif (!listeners) { return; }\n\t\tvar arr = listeners[type];\n\t\tif (!arr) { return; }\n\t\tfor (var i=0,l=arr.length; i<l; i++) {\n\t\t\tif (arr[i] == listener) {\n\t\t\t\tif (l==1) { delete(listeners[type]); } // allows for faster checks.\n\t\t\t\telse { arr.splice(i,1); }\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\t\n\t/**\n\t * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the\n\t * .on method.\n\t * \n\t * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener. See \n\t * {{#crossLink \"EventDispatcher/on\"}}{{/crossLink}} for an example.\n\t *\n\t * @method off\n\t * @param {String} type The string type of the event.\n\t * @param {Function | Object} listener The listener function or object.\n\t * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n\t **/\n\tp.off = p.removeEventListener;\n\n\t/**\n\t * Removes all listeners for the specified type, or all listeners of all types.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      // Remove all listeners\n\t *      displayObject.removeAllEventListeners();\n\t *\n\t *      // Remove all click listeners\n\t *      displayObject.removeAllEventListeners(\"click\");\n\t *\n\t * @method removeAllEventListeners\n\t * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.\n\t **/\n\tp.removeAllEventListeners = function(type) {\n\t\tif (!type) { this._listeners = this._captureListeners = null; }\n\t\telse {\n\t\t\tif (this._listeners) { delete(this._listeners[type]); }\n\t\t\tif (this._captureListeners) { delete(this._captureListeners[type]); }\n\t\t}\n\t};\n\n\t/**\n\t * Dispatches the specified event to all listeners.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      // Use a string event\n\t *      this.dispatchEvent(\"complete\");\n\t *\n\t *      // Use an Event instance\n\t *      var event = new createjs.Event(\"progress\");\n\t *      this.dispatchEvent(event);\n\t *\n\t * @method dispatchEvent\n\t * @param {Object | String | Event} eventObj An object with a \"type\" property, or a string type.\n\t * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,\n\t * dispatchEvent will construct an Event instance if necessary with the specified type. This latter approach can\n\t * be used to avoid event object instantiation for non-bubbling events that may not have any listeners.\n\t * @param {Boolean} [bubbles] Specifies the `bubbles` value when a string was passed to eventObj.\n\t * @param {Boolean} [cancelable] Specifies the `cancelable` value when a string was passed to eventObj.\n\t * @return {Boolean} Returns false if `preventDefault()` was called on a cancelable event, true otherwise.\n\t **/\n\tp.dispatchEvent = function(eventObj, bubbles, cancelable) {\n\t\tif (typeof eventObj == \"string\") {\n\t\t\t// skip everything if there's no listeners and it doesn't bubble:\n\t\t\tvar listeners = this._listeners;\n\t\t\tif (!bubbles && (!listeners || !listeners[eventObj])) { return true; }\n\t\t\teventObj = new createjs.Event(eventObj, bubbles, cancelable);\n\t\t} else if (eventObj.target && eventObj.clone) {\n\t\t\t// redispatching an active event object, so clone it:\n\t\t\teventObj = eventObj.clone();\n\t\t}\n\t\t\n\t\t// TODO: it would be nice to eliminate this. Maybe in favour of evtObj instanceof Event? Or !!evtObj.createEvent\n\t\ttry { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events\n\n\t\tif (!eventObj.bubbles || !this.parent) {\n\t\t\tthis._dispatchEvent(eventObj, 2);\n\t\t} else {\n\t\t\tvar top=this, list=[top];\n\t\t\twhile (top.parent) { list.push(top = top.parent); }\n\t\t\tvar i, l=list.length;\n\n\t\t\t// capture & atTarget\n\t\t\tfor (i=l-1; i>=0 && !eventObj.propagationStopped; i--) {\n\t\t\t\tlist[i]._dispatchEvent(eventObj, 1+(i==0));\n\t\t\t}\n\t\t\t// bubbling\n\t\t\tfor (i=1; i<l && !eventObj.propagationStopped; i++) {\n\t\t\t\tlist[i]._dispatchEvent(eventObj, 3);\n\t\t\t}\n\t\t}\n\t\treturn !eventObj.defaultPrevented;\n\t};\n\n\t/**\n\t * Indicates whether there is at least one listener for the specified event type.\n\t * @method hasEventListener\n\t * @param {String} type The string type of the event.\n\t * @return {Boolean} Returns true if there is at least one listener for the specified event.\n\t **/\n\tp.hasEventListener = function(type) {\n\t\tvar listeners = this._listeners, captureListeners = this._captureListeners;\n\t\treturn !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));\n\t};\n\t\n\t/**\n\t * Indicates whether there is at least one listener for the specified event type on this object or any of its\n\t * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the\n\t * specified type is dispatched from this object, it will trigger at least one listener.\n\t * \n\t * This is similar to {{#crossLink \"EventDispatcher/hasEventListener\"}}{{/crossLink}}, but it searches the entire\n\t * event flow for a listener, not just this object.\n\t * @method willTrigger\n\t * @param {String} type The string type of the event.\n\t * @return {Boolean} Returns `true` if there is at least one listener for the specified event.\n\t **/\n\tp.willTrigger = function(type) {\n\t\tvar o = this;\n\t\twhile (o) {\n\t\t\tif (o.hasEventListener(type)) { return true; }\n\t\t\to = o.parent;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[EventDispatcher]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _dispatchEvent\n\t * @param {Object | String | Event} eventObj\n\t * @param {Object} eventPhase\n\t * @protected\n\t **/\n\tp._dispatchEvent = function(eventObj, eventPhase) {\n\t\tvar l, listeners = (eventPhase==1) ? this._captureListeners : this._listeners;\n\t\tif (eventObj && listeners) {\n\t\t\tvar arr = listeners[eventObj.type];\n\t\t\tif (!arr||!(l=arr.length)) { return; }\n\t\t\ttry { eventObj.currentTarget = this; } catch (e) {}\n\t\t\ttry { eventObj.eventPhase = eventPhase; } catch (e) {}\n\t\t\teventObj.removed = false;\n\t\t\t\n\t\t\tarr = arr.slice(); // to avoid issues with items being removed or added during the dispatch\n\t\t\tfor (var i=0; i<l && !eventObj.immediatePropagationStopped; i++) {\n\t\t\t\tvar o = arr[i];\n\t\t\t\tif (o.handleEvent) { o.handleEvent(eventObj); }\n\t\t\t\telse { o(eventObj); }\n\t\t\t\tif (eventObj.removed) {\n\t\t\t\t\tthis.off(eventObj.type, o, eventPhase==1);\n\t\t\t\t\teventObj.removed = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\n\tcreatejs.EventDispatcher = EventDispatcher;\n}());\n\n//##############################################################################\n// Ticker.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * The Ticker provides a centralized tick or heartbeat broadcast at a set interval. Listeners can subscribe to the tick\n\t * event to be notified when a set time interval has elapsed.\n\t *\n\t * Note that the interval that the tick event is called is a target interval, and may be broadcast at a slower interval\n\t * when under high CPU load. The Ticker class uses a static interface (ex. `Ticker.framerate = 30;`) and\n\t * can not be instantiated.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n\t *      function handleTick(event) {\n\t *          // Actions carried out each tick (aka frame)\n\t *          if (!event.paused) {\n\t *              // Actions carried out when the Ticker is not paused.\n\t *          }\n\t *      }\n\t *\n\t * @class Ticker\n\t * @uses EventDispatcher\n\t * @static\n\t **/\n\tfunction Ticker() {\n\t\tthrow \"Ticker cannot be instantiated.\";\n\t}\n\n\n// constants:\n\t/**\n\t * In this mode, Ticker uses the requestAnimationFrame API, but attempts to synch the ticks to target framerate. It\n\t * uses a simple heuristic that compares the time of the RAF return to the target time for the current frame and\n\t * dispatches the tick when the time is within a certain threshold.\n\t *\n\t * This mode has a higher variance for time between frames than {{#crossLink \"Ticker/TIMEOUT:property\"}}{{/crossLink}},\n\t * but does not require that content be time based as with {{#crossLink \"Ticker/RAF:property\"}}{{/crossLink}} while\n\t * gaining the benefits of that API (screen synch, background throttling).\n\t *\n\t * Variance is usually lowest for framerates that are a divisor of the RAF frequency. This is usually 60, so\n\t * framerates of 10, 12, 15, 20, and 30 work well.\n\t *\n\t * Falls back to {{#crossLink \"Ticker/TIMEOUT:property\"}}{{/crossLink}} if the requestAnimationFrame API is not\n\t * supported.\n\t * @property RAF_SYNCHED\n\t * @static\n\t * @type {String}\n\t * @default \"synched\"\n\t * @readonly\n\t **/\n\tTicker.RAF_SYNCHED = \"synched\";\n\n\t/**\n\t * In this mode, Ticker passes through the requestAnimationFrame heartbeat, ignoring the target framerate completely.\n\t * Because requestAnimationFrame frequency is not deterministic, any content using this mode should be time based.\n\t * You can leverage {{#crossLink \"Ticker/getTime\"}}{{/crossLink}} and the {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}}\n\t * event object's \"delta\" properties to make this easier.\n\t *\n\t * Falls back on {{#crossLink \"Ticker/TIMEOUT:property\"}}{{/crossLink}} if the requestAnimationFrame API is not\n\t * supported.\n\t * @property RAF\n\t * @static\n\t * @type {String}\n\t * @default \"raf\"\n\t * @readonly\n\t **/\n\tTicker.RAF = \"raf\";\n\n\t/**\n\t * In this mode, Ticker uses the setTimeout API. This provides predictable, adaptive frame timing, but does not\n\t * provide the benefits of requestAnimationFrame (screen synch, background throttling).\n\t * @property TIMEOUT\n\t * @static\n\t * @type {String}\n\t * @default \"timeout\"\n\t * @readonly\n\t **/\n\tTicker.TIMEOUT = \"timeout\";\n\n\n// static events:\n\t/**\n\t * Dispatched each tick. The event will be dispatched to each listener even when the Ticker has been paused using\n\t * {{#crossLink \"Ticker/setPaused\"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n\t *      function handleTick(event) {\n\t *          console.log(\"Paused:\", event.paused, event.delta);\n\t *      }\n\t *\n\t * @event tick\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {Boolean} paused Indicates whether the ticker is currently paused.\n\t * @param {Number} delta The time elapsed in ms since the last tick.\n\t * @param {Number} time The total time in ms since Ticker was initialized.\n\t * @param {Number} runTime The total time in ms that Ticker was not paused since it was initialized. For example,\n\t * \tyou could determine the amount of time that the Ticker has been paused since initialization with `time-runTime`.\n\t * @since 0.6.0\n\t */\n\n\n// public static properties:\n\t/**\n\t * Deprecated in favour of {{#crossLink \"Ticker/timingMode\"}}{{/crossLink}}, and will be removed in a future version. If true, timingMode will\n\t * use {{#crossLink \"Ticker/RAF_SYNCHED\"}}{{/crossLink}} by default.\n\t * @deprecated Deprecated in favour of {{#crossLink \"Ticker/timingMode\"}}{{/crossLink}}.\n\t * @property useRAF\n\t * @static\n\t * @type {Boolean}\n\t * @default false\n\t **/\n\tTicker.useRAF = false;\n\n\t/**\n\t * Specifies the timing api (setTimeout or requestAnimationFrame) and mode to use. See\n\t * {{#crossLink \"Ticker/TIMEOUT\"}}{{/crossLink}}, {{#crossLink \"Ticker/RAF\"}}{{/crossLink}}, and\n\t * {{#crossLink \"Ticker/RAF_SYNCHED\"}}{{/crossLink}} for mode details.\n\t * @property timingMode\n\t * @static\n\t * @type {String}\n\t * @default Ticker.TIMEOUT\n\t **/\n\tTicker.timingMode = null;\n\n\t/**\n\t * Specifies a maximum value for the delta property in the tick event object. This is useful when building time\n\t * based animations and systems to prevent issues caused by large time gaps caused by background tabs, system sleep,\n\t * alert dialogs, or other blocking routines. Double the expected frame duration is often an effective value\n\t * (ex. maxDelta=50 when running at 40fps).\n\t * \n\t * This does not impact any other values (ex. time, runTime, etc), so you may experience issues if you enable maxDelta\n\t * when using both delta and other values.\n\t * \n\t * If 0, there is no maximum.\n\t * @property maxDelta\n\t * @static\n\t * @type {number}\n\t * @default 0\n\t */\n\tTicker.maxDelta = 0;\n\t\n\t/**\n\t * When the ticker is paused, all listeners will still receive a tick event, but the <code>paused</code> property\n\t * of the event will be `true`. Also, while paused the `runTime` will not increase. See {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}},\n\t * {{#crossLink \"Ticker/getTime\"}}{{/crossLink}}, and {{#crossLink \"Ticker/getEventTime\"}}{{/crossLink}} for more\n\t * info.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n\t *      createjs.Ticker.paused = true;\n\t *      function handleTick(event) {\n\t *          console.log(event.paused,\n\t *          \tcreatejs.Ticker.getTime(false),\n\t *          \tcreatejs.Ticker.getTime(true));\n\t *      }\n\t *\n\t * @property paused\n\t * @static\n\t * @type {Boolean}\n\t * @default false\n\t **/\n\tTicker.paused = false;\n\n\n// mix-ins:\n\t// EventDispatcher methods:\n\tTicker.removeEventListener = null;\n\tTicker.removeAllEventListeners = null;\n\tTicker.dispatchEvent = null;\n\tTicker.hasEventListener = null;\n\tTicker._listeners = null;\n\tcreatejs.EventDispatcher.initialize(Ticker); // inject EventDispatcher methods.\n\tTicker._addEventListener = Ticker.addEventListener;\n\tTicker.addEventListener = function() {\n\t\t!Ticker._inited&&Ticker.init();\n\t\treturn Ticker._addEventListener.apply(Ticker, arguments);\n\t};\n\n\n// private static properties:\n\t/**\n\t * @property _inited\n\t * @static\n\t * @type {Boolean}\n\t * @protected\n\t **/\n\tTicker._inited = false;\n\n\t/**\n\t * @property _startTime\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._startTime = 0;\n\n\t/**\n\t * @property _pausedTime\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._pausedTime=0;\n\n\t/**\n\t * The number of ticks that have passed\n\t * @property _ticks\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._ticks = 0;\n\n\t/**\n\t * The number of ticks that have passed while Ticker has been paused\n\t * @property _pausedTicks\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._pausedTicks = 0;\n\n\t/**\n\t * @property _interval\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._interval = 50;\n\n\t/**\n\t * @property _lastTime\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._lastTime = 0;\n\n\t/**\n\t * @property _times\n\t * @static\n\t * @type {Array}\n\t * @protected\n\t **/\n\tTicker._times = null;\n\n\t/**\n\t * @property _tickTimes\n\t * @static\n\t * @type {Array}\n\t * @protected\n\t **/\n\tTicker._tickTimes = null;\n\n\t/**\n\t * Stores the timeout or requestAnimationFrame id.\n\t * @property _timerId\n\t * @static\n\t * @type {Number}\n\t * @protected\n\t **/\n\tTicker._timerId = null;\n\t\n\t/**\n\t * True if currently using requestAnimationFrame, false if using setTimeout. This may be different than timingMode\n\t * if that property changed and a tick hasn't fired.\n\t * @property _raf\n\t * @static\n\t * @type {Boolean}\n\t * @protected\n\t **/\n\tTicker._raf = true;\n\t\n\n// static getter / setters:\n\t/**\n\t * Use the {{#crossLink \"Ticker/interval:property\"}}{{/crossLink}} property instead.\n\t * @method setInterval\n\t * @static\n\t * @param {Number} interval\n\t * @deprecated\n\t **/\n\tTicker.setInterval = function(interval) {\n\t\tTicker._interval = interval;\n\t\tif (!Ticker._inited) { return; }\n\t\tTicker._setupTick();\n\t};\n\n\t/**\n\t * Use the {{#crossLink \"Ticker/interval:property\"}}{{/crossLink}} property instead.\n\t * @method getInterval\n\t * @static\n\t * @return {Number}\n\t * @deprecated\n\t **/\n\tTicker.getInterval = function() {\n\t\treturn Ticker._interval;\n\t};\n\n\t/**\n\t * Use the {{#crossLink \"Ticker/framerate:property\"}}{{/crossLink}} property instead.\n\t * @method setFPS\n\t * @static\n\t * @param {Number} value\n\t * @deprecated\n\t **/\n\tTicker.setFPS = function(value) {\n\t\tTicker.setInterval(1000/value);\n\t};\n\n\t/**\n\t * Use the {{#crossLink \"Ticker/framerate:property\"}}{{/crossLink}} property instead.\n\t * @method getFPS\n\t * @static\n\t * @return {Number}\n\t * @deprecated\n\t **/\n\tTicker.getFPS = function() {\n\t\treturn 1000/Ticker._interval;\n\t};\n\n\t/**\n\t * Indicates the target time (in milliseconds) between ticks. Default is 50 (20 FPS).\n\t * Note that actual time between ticks may be more than specified depending on CPU load.\n\t * This property is ignored if the ticker is using the `RAF` timing mode.\n\t * @property interval\n\t * @static\n\t * @type {Number}\n\t **/\n\t \n\t/**\n\t * Indicates the target frame rate in frames per second (FPS). Effectively just a shortcut to `interval`, where\n\t * `framerate == 1000/interval`.\n\t * @property framerate\n\t * @static\n\t * @type {Number}\n\t **/\n\ttry {\n\t\tObject.defineProperties(Ticker, {\n\t\t\tinterval: { get: Ticker.getInterval, set: Ticker.setInterval },\n\t\t\tframerate: { get: Ticker.getFPS, set: Ticker.setFPS }\n\t\t});\n\t} catch (e) { console.log(e); }\n\n\n// public static methods:\n\t/**\n\t * Starts the tick. This is called automatically when the first listener is added.\n\t * @method init\n\t * @static\n\t **/\n\tTicker.init = function() {\n\t\tif (Ticker._inited) { return; }\n\t\tTicker._inited = true;\n\t\tTicker._times = [];\n\t\tTicker._tickTimes = [];\n\t\tTicker._startTime = Ticker._getTime();\n\t\tTicker._times.push(Ticker._lastTime = 0);\n\t\tTicker.interval = Ticker._interval;\n\t};\n\t\n\t/**\n\t * Stops the Ticker and removes all listeners. Use init() to restart the Ticker.\n\t * @method reset\n\t * @static\n\t **/\n\tTicker.reset = function() {\n\t\tif (Ticker._raf) {\n\t\t\tvar f = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;\n\t\t\tf&&f(Ticker._timerId);\n\t\t} else {\n\t\t\tclearTimeout(Ticker._timerId);\n\t\t}\n\t\tTicker.removeAllEventListeners(\"tick\");\n\t\tTicker._timerId = Ticker._times = Ticker._tickTimes = null;\n\t\tTicker._startTime = Ticker._lastTime = Ticker._ticks = 0;\n\t\tTicker._inited = false;\n\t};\n\n\t/**\n\t * Returns the average time spent within a tick. This can vary significantly from the value provided by getMeasuredFPS\n\t * because it only measures the time spent within the tick execution stack. \n\t * \n\t * Example 1: With a target FPS of 20, getMeasuredFPS() returns 20fps, which indicates an average of 50ms between \n\t * the end of one tick and the end of the next. However, getMeasuredTickTime() returns 15ms. This indicates that \n\t * there may be up to 35ms of \"idle\" time between the end of one tick and the start of the next.\n\t *\n\t * Example 2: With a target FPS of 30, getFPS() returns 10fps, which indicates an average of 100ms between the end of\n\t * one tick and the end of the next. However, getMeasuredTickTime() returns 20ms. This would indicate that something\n\t * other than the tick is using ~80ms (another script, DOM rendering, etc).\n\t * @method getMeasuredTickTime\n\t * @static\n\t * @param {Number} [ticks] The number of previous ticks over which to measure the average time spent in a tick.\n\t * Defaults to the number of ticks per second. To get only the last tick's time, pass in 1.\n\t * @return {Number} The average time spent in a tick in milliseconds.\n\t **/\n\tTicker.getMeasuredTickTime = function(ticks) {\n\t\tvar ttl=0, times=Ticker._tickTimes;\n\t\tif (!times || times.length < 1) { return -1; }\n\n\t\t// by default, calculate average for the past ~1 second:\n\t\tticks = Math.min(times.length, ticks||(Ticker.getFPS()|0));\n\t\tfor (var i=0; i<ticks; i++) { ttl += times[i]; }\n\t\treturn ttl/ticks;\n\t};\n\n\t/**\n\t * Returns the actual frames / ticks per second.\n\t * @method getMeasuredFPS\n\t * @static\n\t * @param {Number} [ticks] The number of previous ticks over which to measure the actual frames / ticks per second.\n\t * Defaults to the number of ticks per second.\n\t * @return {Number} The actual frames / ticks per second. Depending on performance, this may differ\n\t * from the target frames per second.\n\t **/\n\tTicker.getMeasuredFPS = function(ticks) {\n\t\tvar times = Ticker._times;\n\t\tif (!times || times.length < 2) { return -1; }\n\n\t\t// by default, calculate fps for the past ~1 second:\n\t\tticks = Math.min(times.length-1, ticks||(Ticker.getFPS()|0));\n\t\treturn 1000/((times[0]-times[ticks])/ticks);\n\t};\n\n\t/**\n\t * Use the {{#crossLink \"Ticker/paused:property\"}}{{/crossLink}} property instead.\n\t * @method setPaused\n\t * @static\n\t * @param {Boolean} value\n\t * @deprecated\n\t **/\n\tTicker.setPaused = function(value) {\n\t\t// TODO: deprecated.\n\t\tTicker.paused = value;\n\t};\n\n\t/**\n\t * Use the {{#crossLink \"Ticker/paused:property\"}}{{/crossLink}} property instead.\n\t * @method getPaused\n\t * @static\n\t * @return {Boolean}\n\t * @deprecated\n\t **/\n\tTicker.getPaused = function() {\n\t\t// TODO: deprecated.\n\t\treturn Ticker.paused;\n\t};\n\n\t/**\n\t * Returns the number of milliseconds that have elapsed since Ticker was initialized via {{#crossLink \"Ticker/init\"}}.\n\t * Returns -1 if Ticker has not been initialized. For example, you could use\n\t * this in a time synchronized animation to determine the exact amount of time that has elapsed.\n\t * @method getTime\n\t * @static\n\t * @param {Boolean} [runTime=false] If true only time elapsed while Ticker was not paused will be returned.\n\t * If false, the value returned will be total time elapsed since the first tick event listener was added.\n\t * @return {Number} Number of milliseconds that have elapsed since Ticker was initialized or -1.\n\t **/\n\tTicker.getTime = function(runTime) {\n\t\treturn Ticker._startTime ? Ticker._getTime() - (runTime ? Ticker._pausedTime : 0) : -1;\n\t};\n\n\t/**\n\t * Similar to the {{#crossLink \"Ticker/getTime\"}}{{/crossLink}} method, but returns the time on the most recent {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}}\n\t * event object.\n\t * @method getEventTime\n\t * @static\n\t * @param runTime {Boolean} [runTime=false] If true, the runTime property will be returned instead of time.\n\t * @returns {number} The time or runTime property from the most recent tick event or -1.\n\t */\n\tTicker.getEventTime = function(runTime) {\n\t\treturn Ticker._startTime ? (Ticker._lastTime || Ticker._startTime) - (runTime ? Ticker._pausedTime : 0) : -1;\n\t};\n\t\n\t/**\n\t * Returns the number of ticks that have been broadcast by Ticker.\n\t * @method getTicks\n\t * @static\n\t * @param {Boolean} pauseable Indicates whether to include ticks that would have been broadcast\n\t * while Ticker was paused. If true only tick events broadcast while Ticker is not paused will be returned.\n\t * If false, tick events that would have been broadcast while Ticker was paused will be included in the return\n\t * value. The default value is false.\n\t * @return {Number} of ticks that have been broadcast.\n\t **/\n\tTicker.getTicks = function(pauseable) {\n\t\treturn  Ticker._ticks - (pauseable ? Ticker._pausedTicks : 0);\n\t};\n\n\n// private static methods:\n\t/**\n\t * @method _handleSynch\n\t * @static\n\t * @protected\n\t **/\n\tTicker._handleSynch = function() {\n\t\tTicker._timerId = null;\n\t\tTicker._setupTick();\n\n\t\t// run if enough time has elapsed, with a little bit of flexibility to be early:\n\t\tif (Ticker._getTime() - Ticker._lastTime >= (Ticker._interval-1)*0.97) {\n\t\t\tTicker._tick();\n\t\t}\n\t};\n\n\t/**\n\t * @method _handleRAF\n\t * @static\n\t * @protected\n\t **/\n\tTicker._handleRAF = function() {\n\t\tTicker._timerId = null;\n\t\tTicker._setupTick();\n\t\tTicker._tick();\n\t};\n\n\t/**\n\t * @method _handleTimeout\n\t * @static\n\t * @protected\n\t **/\n\tTicker._handleTimeout = function() {\n\t\tTicker._timerId = null;\n\t\tTicker._setupTick();\n\t\tTicker._tick();\n\t};\n\n\t/**\n\t * @method _setupTick\n\t * @static\n\t * @protected\n\t **/\n\tTicker._setupTick = function() {\n\t\tif (Ticker._timerId != null) { return; } // avoid duplicates\n\n\t\tvar mode = Ticker.timingMode||(Ticker.useRAF&&Ticker.RAF_SYNCHED);\n\t\tif (mode == Ticker.RAF_SYNCHED || mode == Ticker.RAF) {\n\t\t\tvar f = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;\n\t\t\tif (f) {\n\t\t\t\tTicker._timerId = f(mode == Ticker.RAF ? Ticker._handleRAF : Ticker._handleSynch);\n\t\t\t\tTicker._raf = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tTicker._raf = false;\n\t\tTicker._timerId = setTimeout(Ticker._handleTimeout, Ticker._interval);\n\t};\n\n\t/**\n\t * @method _tick\n\t * @static\n\t * @protected\n\t **/\n\tTicker._tick = function() {\n\t\tvar paused = Ticker.paused;\n\t\tvar time = Ticker._getTime();\n\t\tvar elapsedTime = time-Ticker._lastTime;\n\t\tTicker._lastTime = time;\n\t\tTicker._ticks++;\n\t\t\n\t\tif (paused) {\n\t\t\tTicker._pausedTicks++;\n\t\t\tTicker._pausedTime += elapsedTime;\n\t\t}\n\t\t\n\t\tif (Ticker.hasEventListener(\"tick\")) {\n\t\t\tvar event = new createjs.Event(\"tick\");\n\t\t\tvar maxDelta = Ticker.maxDelta;\n\t\t\tevent.delta = (maxDelta && elapsedTime > maxDelta) ? maxDelta : elapsedTime;\n\t\t\tevent.paused = paused;\n\t\t\tevent.time = time;\n\t\t\tevent.runTime = time-Ticker._pausedTime;\n\t\t\tTicker.dispatchEvent(event);\n\t\t}\n\t\t\n\t\tTicker._tickTimes.unshift(Ticker._getTime()-time);\n\t\twhile (Ticker._tickTimes.length > 100) { Ticker._tickTimes.pop(); }\n\n\t\tTicker._times.unshift(time);\n\t\twhile (Ticker._times.length > 100) { Ticker._times.pop(); }\n\t};\n\n\t/**\n\t * @method _getTime\n\t * @static\n\t * @protected\n\t **/\n\tvar now = window.performance && (performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow);\n\tTicker._getTime = function() {\n\t\treturn ((now&&now.call(performance))||(new Date().getTime())) - Ticker._startTime;\n\t};\n\n\n\tcreatejs.Ticker = Ticker;\n}());\n\n//##############################################################################\n// UID.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Global utility for generating sequential unique ID numbers. The UID class uses a static interface (ex. <code>UID.get()</code>)\n\t * and should not be instantiated.\n\t * @class UID\n\t * @static\n\t **/\n\tfunction UID() {\n\t\tthrow \"UID cannot be instantiated\";\n\t}\n\n\n// private static properties:\n\t/**\n\t * @property _nextID\n\t * @type Number\n\t * @protected\n\t **/\n\tUID._nextID = 0;\n\n\n// public static methods:\n\t/**\n\t * Returns the next unique id.\n\t * @method get\n\t * @return {Number} The next unique id\n\t * @static\n\t **/\n\tUID.get = function() {\n\t\treturn UID._nextID++;\n\t};\n\n\n\tcreatejs.UID = UID;\n}());\n\n//##############################################################################\n// MouseEvent.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Passed as the parameter to all mouse/pointer/touch related events. For a listing of mouse events and their properties,\n\t * see the {{#crossLink \"DisplayObject\"}}{{/crossLink}} and {{#crossLink \"Stage\"}}{{/crossLink}} event listings.\n\t * @class MouseEvent\n\t * @param {String} type The event type.\n\t * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.\n\t * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.\n\t * @param {Number} stageX The normalized x position relative to the stage.\n\t * @param {Number} stageY The normalized y position relative to the stage.\n\t * @param {MouseEvent} nativeEvent The native DOM event related to this mouse event.\n\t * @param {Number} pointerID The unique id for the pointer.\n\t * @param {Boolean} primary Indicates whether this is the primary pointer in a multitouch environment.\n\t * @param {Number} rawX The raw x position relative to the stage.\n\t * @param {Number} rawY The raw y position relative to the stage.\n\t * @param {DisplayObject} relatedTarget The secondary target for the event.\n\t * @extends Event\n\t * @constructor\n\t **/\n\tfunction MouseEvent(type, bubbles, cancelable, stageX, stageY, nativeEvent, pointerID, primary, rawX, rawY, relatedTarget) {\n\t\tthis.Event_constructor(type, bubbles, cancelable);\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The normalized x position on the stage. This will always be within the range 0 to stage width.\n\t\t * @property stageX\n\t\t * @type Number\n\t\t*/\n\t\tthis.stageX = stageX;\n\t\n\t\t/**\n\t\t * The normalized y position on the stage. This will always be within the range 0 to stage height.\n\t\t * @property stageY\n\t\t * @type Number\n\t\t **/\n\t\tthis.stageY = stageY;\n\t\n\t\t/**\n\t\t * The raw x position relative to the stage. Normally this will be the same as the stageX value, unless\n\t\t * stage.mouseMoveOutside is true and the pointer is outside of the stage bounds.\n\t\t * @property rawX\n\t\t * @type Number\n\t\t*/\n\t\tthis.rawX = (rawX==null)?stageX:rawX;\n\t\n\t\t/**\n\t\t * The raw y position relative to the stage. Normally this will be the same as the stageY value, unless\n\t\t * stage.mouseMoveOutside is true and the pointer is outside of the stage bounds.\n\t\t * @property rawY\n\t\t * @type Number\n\t\t*/\n\t\tthis.rawY = (rawY==null)?stageY:rawY;\n\t\n\t\t/**\n\t\t * The native MouseEvent generated by the browser. The properties and API for this\n\t\t * event may differ between browsers. This property will be null if the\n\t\t * EaselJS property was not directly generated from a native MouseEvent.\n\t\t * @property nativeEvent\n\t\t * @type HtmlMouseEvent\n\t\t * @default null\n\t\t **/\n\t\tthis.nativeEvent = nativeEvent;\n\t\n\t\t/**\n\t\t * The unique id for the pointer (touch point or cursor). This will be either -1 for the mouse, or the system\n\t\t * supplied id value.\n\t\t * @property pointerID\n\t\t * @type {Number}\n\t\t */\n\t\tthis.pointerID = pointerID;\n\t\n\t\t/**\n\t\t * Indicates whether this is the primary pointer in a multitouch environment. This will always be true for the mouse.\n\t\t * For touch pointers, the first pointer in the current stack will be considered the primary pointer.\n\t\t * @property primary\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.primary = !!primary;\n\t\t\n\t\t/**\n\t\t * The secondary target for the event, if applicable. This is used for mouseout/rollout\n\t\t * events to indicate the object that the mouse entered from, mouseover/rollover for the object the mouse exited,\n\t\t * and stagemousedown/stagemouseup events for the object that was the under the cursor, if any.\n\t\t * \n\t\t * Only valid interaction targets will be returned (ie. objects with mouse listeners or a cursor set).\n\t\t * @property relatedTarget\n\t\t * @type {DisplayObject}\n\t\t */\n\t\tthis.relatedTarget = relatedTarget;\n\t}\n\tvar p = createjs.extend(MouseEvent, createjs.Event);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\t\n\t\n// getter / setters:\n\t/**\n\t * Returns the x position of the mouse in the local coordinate system of the current target (ie. the dispatcher).\n\t * @property localX\n\t * @type {Number}\n\t * @readonly\n\t */\n\tp._get_localX = function() {\n\t\treturn this.currentTarget.globalToLocal(this.rawX, this.rawY).x;\n\t};\n\t\n\t/**\n\t * Returns the y position of the mouse in the local coordinate system of the current target (ie. the dispatcher).\n\t * @property localY\n\t * @type {Number}\n\t * @readonly\n\t */\n\tp._get_localY = function() {\n\t\treturn this.currentTarget.globalToLocal(this.rawX, this.rawY).y;\n\t};\n\t\n\t/**\n\t * Indicates whether the event was generated by a touch input (versus a mouse input).\n\t * @property isTouch\n\t * @type {Boolean}\n\t * @readonly\n\t */\n\tp._get_isTouch = function() {\n\t\treturn this.pointerID !== -1;\n\t};\n\t\n\t\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tlocalX: { get: p._get_localX },\n\t\t\tlocalY: { get: p._get_localY },\n\t\t\tisTouch: { get: p._get_isTouch }\n\t\t});\n\t} catch (e) {} // TODO: use Log\n\n\n// public methods:\n\t/**\n\t * Returns a clone of the MouseEvent instance.\n\t * @method clone\n\t * @return {MouseEvent} a clone of the MouseEvent instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new MouseEvent(this.type, this.bubbles, this.cancelable, this.stageX, this.stageY, this.nativeEvent, this.pointerID, this.primary, this.rawX, this.rawY);\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[MouseEvent (type=\"+this.type+\" stageX=\"+this.stageX+\" stageY=\"+this.stageY+\")]\";\n\t};\n\n\n\tcreatejs.MouseEvent = createjs.promote(MouseEvent, \"Event\");\n}());\n\n//##############################################################################\n// Matrix2D.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Represents an affine transformation matrix, and provides tools for constructing and concatenating matrices.\n\t *\n\t * This matrix can be visualized as:\n\t *\n\t * \t[ a  c  tx\n\t * \t  b  d  ty\n\t * \t  0  0  1  ]\n\t *\n\t * Note the locations of b and c.\n\t *\n\t * @class Matrix2D\n\t * @param {Number} [a=1] Specifies the a property for the new matrix.\n\t * @param {Number} [b=0] Specifies the b property for the new matrix.\n\t * @param {Number} [c=0] Specifies the c property for the new matrix.\n\t * @param {Number} [d=1] Specifies the d property for the new matrix.\n\t * @param {Number} [tx=0] Specifies the tx property for the new matrix.\n\t * @param {Number} [ty=0] Specifies the ty property for the new matrix.\n\t * @constructor\n\t **/\n\tfunction Matrix2D(a, b, c, d, tx, ty) {\n\t\tthis.setValues(a,b,c,d,tx,ty);\n\t\t\n\t// public properties:\n\t\t// assigned in the setValues method.\n\t\t/**\n\t\t * Position (0, 0) in a 3x3 affine transformation matrix.\n\t\t * @property a\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Position (0, 1) in a 3x3 affine transformation matrix.\n\t\t * @property b\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Position (1, 0) in a 3x3 affine transformation matrix.\n\t\t * @property c\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Position (1, 1) in a 3x3 affine transformation matrix.\n\t\t * @property d\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Position (2, 0) in a 3x3 affine transformation matrix.\n\t\t * @property tx\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Position (2, 1) in a 3x3 affine transformation matrix.\n\t\t * @property ty\n\t\t * @type Number\n\t\t **/\n\t}\n\tvar p = Matrix2D.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// constants:\n\t/**\n\t * Multiplier for converting degrees to radians. Used internally by Matrix2D.\n\t * @property DEG_TO_RAD\n\t * @static\n\t * @final\n\t * @type Number\n\t * @readonly\n\t **/\n\tMatrix2D.DEG_TO_RAD = Math.PI/180;\n\n\n// static public properties:\n\t/**\n\t * An identity matrix, representing a null transformation.\n\t * @property identity\n\t * @static\n\t * @type Matrix2D\n\t * @readonly\n\t **/\n\tMatrix2D.identity = null; // set at bottom of class definition.\n\t\n\n// public methods:\n\t/**\n\t * Sets the specified values on this instance. \n\t * @method setValues\n\t * @param {Number} [a=1] Specifies the a property for the new matrix.\n\t * @param {Number} [b=0] Specifies the b property for the new matrix.\n\t * @param {Number} [c=0] Specifies the c property for the new matrix.\n\t * @param {Number} [d=1] Specifies the d property for the new matrix.\n\t * @param {Number} [tx=0] Specifies the tx property for the new matrix.\n\t * @param {Number} [ty=0] Specifies the ty property for the new matrix.\n\t * @return {Matrix2D} This instance. Useful for chaining method calls.\n\t*/\n\tp.setValues = function(a, b, c, d, tx, ty) {\n\t\t// don't forget to update docs in the constructor if these change:\n\t\tthis.a = (a == null) ? 1 : a;\n\t\tthis.b = b || 0;\n\t\tthis.c = c || 0;\n\t\tthis.d = (d == null) ? 1 : d;\n\t\tthis.tx = tx || 0;\n\t\tthis.ty = ty || 0;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Appends the specified matrix properties to this matrix. All parameters are required.\n\t * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.\n\t * @method append\n\t * @param {Number} a\n\t * @param {Number} b\n\t * @param {Number} c\n\t * @param {Number} d\n\t * @param {Number} tx\n\t * @param {Number} ty\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.append = function(a, b, c, d, tx, ty) {\n\t\tvar a1 = this.a;\n\t\tvar b1 = this.b;\n\t\tvar c1 = this.c;\n\t\tvar d1 = this.d;\n\t\tif (a != 1 || b != 0 || c != 0 || d != 1) {\n\t\t\tthis.a  = a1*a+c1*b;\n\t\t\tthis.b  = b1*a+d1*b;\n\t\t\tthis.c  = a1*c+c1*d;\n\t\t\tthis.d  = b1*c+d1*d;\n\t\t}\n\t\tthis.tx = a1*tx+c1*ty+this.tx;\n\t\tthis.ty = b1*tx+d1*ty+this.ty;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Prepends the specified matrix properties to this matrix.\n\t * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.\n\t * All parameters are required.\n\t * @method prepend\n\t * @param {Number} a\n\t * @param {Number} b\n\t * @param {Number} c\n\t * @param {Number} d\n\t * @param {Number} tx\n\t * @param {Number} ty\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.prepend = function(a, b, c, d, tx, ty) {\n\t\tvar a1 = this.a;\n\t\tvar c1 = this.c;\n\t\tvar tx1 = this.tx;\n\n\t\tthis.a  = a*a1+c*this.b;\n\t\tthis.b  = b*a1+d*this.b;\n\t\tthis.c  = a*c1+c*this.d;\n\t\tthis.d  = b*c1+d*this.d;\n\t\tthis.tx = a*tx1+c*this.ty+tx;\n\t\tthis.ty = b*tx1+d*this.ty+ty;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Appends the specified matrix to this matrix.\n\t * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.\n\t * @method appendMatrix\n\t * @param {Matrix2D} matrix\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.appendMatrix = function(matrix) {\n\t\treturn this.append(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);\n\t};\n\n\t/**\n\t * Prepends the specified matrix to this matrix.\n\t * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.\n\t * For example, you could calculate the combined transformation for a child object using:\n\t * \n\t * \tvar o = myDisplayObject;\n\t * \tvar mtx = o.getMatrix();\n\t * \twhile (o = o.parent) {\n\t * \t\t// prepend each parent's transformation in turn:\n\t * \t\to.prependMatrix(o.getMatrix());\n\t * \t}\n\t * @method prependMatrix\n\t * @param {Matrix2D} matrix\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.prependMatrix = function(matrix) {\n\t\treturn this.prepend(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);\n\t};\n\n\t/**\n\t * Generates matrix properties from the specified display object transform properties, and appends them to this matrix.\n\t * For example, you can use this to generate a matrix representing the transformations of a display object:\n\t * \n\t * \tvar mtx = new createjs.Matrix2D();\n\t * \tmtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);\n\t * @method appendTransform\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} scaleX\n\t * @param {Number} scaleY\n\t * @param {Number} rotation\n\t * @param {Number} skewX\n\t * @param {Number} skewY\n\t * @param {Number} regX Optional.\n\t * @param {Number} regY Optional.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.appendTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {\n\t\tif (rotation%360) {\n\t\t\tvar r = rotation*Matrix2D.DEG_TO_RAD;\n\t\t\tvar cos = Math.cos(r);\n\t\t\tvar sin = Math.sin(r);\n\t\t} else {\n\t\t\tcos = 1;\n\t\t\tsin = 0;\n\t\t}\n\n\t\tif (skewX || skewY) {\n\t\t\t// TODO: can this be combined into a single append operation?\n\t\t\tskewX *= Matrix2D.DEG_TO_RAD;\n\t\t\tskewY *= Matrix2D.DEG_TO_RAD;\n\t\t\tthis.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);\n\t\t\tthis.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);\n\t\t} else {\n\t\t\tthis.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);\n\t\t}\n\t\t\n\t\tif (regX || regY) {\n\t\t\t// append the registration offset:\n\t\t\tthis.tx -= regX*this.a+regY*this.c; \n\t\t\tthis.ty -= regX*this.b+regY*this.d;\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Generates matrix properties from the specified display object transform properties, and prepends them to this matrix.\n\t * For example, you could calculate the combined transformation for a child object using:\n\t * \n\t * \tvar o = myDisplayObject;\n\t * \tvar mtx = new createjs.Matrix2D();\n\t * \tdo  {\n\t * \t\t// prepend each parent's transformation in turn:\n\t * \t\tmtx.prependTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);\n\t * \t} while (o = o.parent);\n\t * \t\n\t * \tNote that the above example would not account for {{#crossLink \"DisplayObject/transformMatrix:property\"}}{{/crossLink}}\n\t * \tvalues. See {{#crossLink \"Matrix2D/prependMatrix\"}}{{/crossLink}} for an example that does.\n\t * @method prependTransform\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} scaleX\n\t * @param {Number} scaleY\n\t * @param {Number} rotation\n\t * @param {Number} skewX\n\t * @param {Number} skewY\n\t * @param {Number} regX Optional.\n\t * @param {Number} regY Optional.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.prependTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {\n\t\tif (rotation%360) {\n\t\t\tvar r = rotation*Matrix2D.DEG_TO_RAD;\n\t\t\tvar cos = Math.cos(r);\n\t\t\tvar sin = Math.sin(r);\n\t\t} else {\n\t\t\tcos = 1;\n\t\t\tsin = 0;\n\t\t}\n\n\t\tif (regX || regY) {\n\t\t\t// prepend the registration offset:\n\t\t\tthis.tx -= regX; this.ty -= regY;\n\t\t}\n\t\tif (skewX || skewY) {\n\t\t\t// TODO: can this be combined into a single prepend operation?\n\t\t\tskewX *= Matrix2D.DEG_TO_RAD;\n\t\t\tskewY *= Matrix2D.DEG_TO_RAD;\n\t\t\tthis.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);\n\t\t\tthis.prepend(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);\n\t\t} else {\n\t\t\tthis.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Applies a clockwise rotation transformation to the matrix.\n\t * @method rotate\n\t * @param {Number} angle The angle to rotate by, in degrees. To use a value in radians, multiply it by `180/Math.PI`.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.rotate = function(angle) {\n\t\tangle = angle*Matrix2D.DEG_TO_RAD;\n\t\tvar cos = Math.cos(angle);\n\t\tvar sin = Math.sin(angle);\n\n\t\tvar a1 = this.a;\n\t\tvar b1 = this.b;\n\n\t\tthis.a = a1*cos+this.c*sin;\n\t\tthis.b = b1*cos+this.d*sin;\n\t\tthis.c = -a1*sin+this.c*cos;\n\t\tthis.d = -b1*sin+this.d*cos;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Applies a skew transformation to the matrix.\n\t * @method skew\n\t * @param {Number} skewX The amount to skew horizontally in degrees. To use a value in radians, multiply it by `180/Math.PI`.\n\t * @param {Number} skewY The amount to skew vertically in degrees.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t*/\n\tp.skew = function(skewX, skewY) {\n\t\tskewX = skewX*Matrix2D.DEG_TO_RAD;\n\t\tskewY = skewY*Matrix2D.DEG_TO_RAD;\n\t\tthis.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), 0, 0);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Applies a scale transformation to the matrix.\n\t * @method scale\n\t * @param {Number} x The amount to scale horizontally. E.G. a value of 2 will double the size in the X direction, and 0.5 will halve it.\n\t * @param {Number} y The amount to scale vertically.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.scale = function(x, y) {\n\t\tthis.a *= x;\n\t\tthis.b *= x;\n\t\tthis.c *= y;\n\t\tthis.d *= y;\n\t\t//this.tx *= x;\n\t\t//this.ty *= y;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Translates the matrix on the x and y axes.\n\t * @method translate\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.translate = function(x, y) {\n\t\tthis.tx += this.a*x + this.c*y;\n\t\tthis.ty += this.b*x + this.d*y;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Sets the properties of the matrix to those of an identity matrix (one that applies a null transformation).\n\t * @method identity\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.identity = function() {\n\t\tthis.a = this.d = 1;\n\t\tthis.b = this.c = this.tx = this.ty = 0;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Inverts the matrix, causing it to perform the opposite transformation.\n\t * @method invert\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t **/\n\tp.invert = function() {\n\t\tvar a1 = this.a;\n\t\tvar b1 = this.b;\n\t\tvar c1 = this.c;\n\t\tvar d1 = this.d;\n\t\tvar tx1 = this.tx;\n\t\tvar n = a1*d1-b1*c1;\n\n\t\tthis.a = d1/n;\n\t\tthis.b = -b1/n;\n\t\tthis.c = -c1/n;\n\t\tthis.d = a1/n;\n\t\tthis.tx = (c1*this.ty-d1*tx1)/n;\n\t\tthis.ty = -(a1*this.ty-b1*tx1)/n;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Returns true if the matrix is an identity matrix.\n\t * @method isIdentity\n\t * @return {Boolean}\n\t **/\n\tp.isIdentity = function() {\n\t\treturn this.tx === 0 && this.ty === 0 && this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1;\n\t};\n\t\n\t/**\n\t * Returns true if this matrix is equal to the specified matrix (all property values are equal).\n\t * @method equals\n\t * @param {Matrix2D} matrix The matrix to compare.\n\t * @return {Boolean}\n\t **/\n\tp.equals = function(matrix) {\n\t\treturn this.tx === matrix.tx && this.ty === matrix.ty && this.a === matrix.a && this.b === matrix.b && this.c === matrix.c && this.d === matrix.d;\n\t};\n\n\t/**\n\t * Transforms a point according to this matrix.\n\t * @method transformPoint\n\t * @param {Number} x The x component of the point to transform.\n\t * @param {Number} y The y component of the point to transform.\n\t * @param {Point | Object} [pt] An object to copy the result into. If omitted a generic object with x/y properties will be returned.\n\t * @return {Point} This matrix. Useful for chaining method calls.\n\t **/\n\tp.transformPoint = function(x, y, pt) {\n\t\tpt = pt||{};\n\t\tpt.x = x*this.a+y*this.c+this.tx;\n\t\tpt.y = x*this.b+y*this.d+this.ty;\n\t\treturn pt;\n\t};\n\n\t/**\n\t * Decomposes the matrix into transform properties (x, y, scaleX, scaleY, and rotation). Note that these values\n\t * may not match the transform properties you used to generate the matrix, though they will produce the same visual\n\t * results.\n\t * @method decompose\n\t * @param {Object} target The object to apply the transform properties to. If null, then a new object will be returned.\n\t * @return {Object} The target, or a new generic object with the transform properties applied.\n\t*/\n\tp.decompose = function(target) {\n\t\t// TODO: it would be nice to be able to solve for whether the matrix can be decomposed into only scale/rotation even when scale is negative\n\t\tif (target == null) { target = {}; }\n\t\ttarget.x = this.tx;\n\t\ttarget.y = this.ty;\n\t\ttarget.scaleX = Math.sqrt(this.a * this.a + this.b * this.b);\n\t\ttarget.scaleY = Math.sqrt(this.c * this.c + this.d * this.d);\n\n\t\tvar skewX = Math.atan2(-this.c, this.d);\n\t\tvar skewY = Math.atan2(this.b, this.a);\n\n\t\tvar delta = Math.abs(1-skewX/skewY);\n\t\tif (delta < 0.00001) { // effectively identical, can use rotation:\n\t\t\ttarget.rotation = skewY/Matrix2D.DEG_TO_RAD;\n\t\t\tif (this.a < 0 && this.d >= 0) {\n\t\t\t\ttarget.rotation += (target.rotation <= 0) ? 180 : -180;\n\t\t\t}\n\t\t\ttarget.skewX = target.skewY = 0;\n\t\t} else {\n\t\t\ttarget.skewX = skewX/Matrix2D.DEG_TO_RAD;\n\t\t\ttarget.skewY = skewY/Matrix2D.DEG_TO_RAD;\n\t\t}\n\t\treturn target;\n\t};\n\t\n\t/**\n\t * Copies all properties from the specified matrix to this matrix.\n\t * @method copy\n\t * @param {Matrix2D} matrix The matrix to copy properties from.\n\t * @return {Matrix2D} This matrix. Useful for chaining method calls.\n\t*/\n\tp.copy = function(matrix) {\n\t\treturn this.setValues(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);\n\t};\n\n\t/**\n\t * Returns a clone of the Matrix2D instance.\n\t * @method clone\n\t * @return {Matrix2D} a clone of the Matrix2D instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Matrix2D(this.a, this.b, this.c, this.d, this.tx, this.ty);\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Matrix2D (a=\"+this.a+\" b=\"+this.b+\" c=\"+this.c+\" d=\"+this.d+\" tx=\"+this.tx+\" ty=\"+this.ty+\")]\";\n\t};\n\n\t// this has to be populated after the class is defined:\n\tMatrix2D.identity = new Matrix2D();\n\n\n\tcreatejs.Matrix2D = Matrix2D;\n}());\n\n//##############################################################################\n// DisplayProps.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * Used for calculating and encapsulating display related properties.\n\t * @class DisplayProps\n\t * @param {Number} [visible=true] Visible value.\n\t * @param {Number} [alpha=1] Alpha value.\n\t * @param {Number} [shadow=null] A Shadow instance or null.\n\t * @param {Number} [compositeOperation=null] A compositeOperation value or null.\n\t * @param {Number} [matrix] A transformation matrix. Defaults to a new identity matrix.\n\t * @constructor\n\t **/\n\tfunction DisplayProps(visible, alpha, shadow, compositeOperation, matrix) {\n\t\tthis.setValues(visible, alpha, shadow, compositeOperation, matrix);\n\t\t\n\t// public properties:\n\t\t// assigned in the setValues method.\n\t\t/**\n\t\t * Property representing the alpha that will be applied to a display object.\n\t\t * @property alpha\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Property representing the shadow that will be applied to a display object.\n\t\t * @property shadow\n\t\t * @type Shadow\n\t\t **/\n\t\n\t\t/**\n\t\t * Property representing the compositeOperation that will be applied to a display object.\n\t\t * You can find a list of valid composite operations at:\n\t\t * <a href=\"https://developer.mozilla.org/en/Canvas_tutorial/Compositing\">https://developer.mozilla.org/en/Canvas_tutorial/Compositing</a>\n\t\t * @property compositeOperation\n\t\t * @type String\n\t\t **/\n\t\t\n\t\t/**\n\t\t * Property representing the value for visible that will be applied to a display object.\n\t\t * @property visible\n\t\t * @type Boolean\n\t\t **/\n\t\t\n\t\t/**\n\t\t * The transformation matrix that will be applied to a display object.\n\t\t * @property matrix\n\t\t * @type Matrix2D\n\t\t **/\n\t}\n\tvar p = DisplayProps.prototype;\n\n// initialization:\n\t/**\n\t * Reinitializes the instance with the specified values.\n\t * @method setValues\n\t * @param {Number} [visible=true] Visible value.\n\t * @param {Number} [alpha=1] Alpha value.\n\t * @param {Number} [shadow=null] A Shadow instance or null.\n\t * @param {Number} [compositeOperation=null] A compositeOperation value or null.\n\t * @param {Number} [matrix] A transformation matrix. Defaults to an identity matrix.\n\t * @return {DisplayProps} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.setValues = function (visible, alpha, shadow, compositeOperation, matrix) {\n\t\tthis.visible = visible == null ? true : !!visible;\n\t\tthis.alpha = alpha == null ? 1 : alpha;\n\t\tthis.shadow = shadow;\n\t\tthis.compositeOperation = compositeOperation;\n\t\tthis.matrix = matrix || (this.matrix&&this.matrix.identity()) || new createjs.Matrix2D();\n\t\treturn this;\n\t};\n\n// public methods:\n\t/**\n\t * Appends the specified display properties. This is generally used to apply a child's properties its parent's.\n\t * @method append\n\t * @param {Boolean} visible desired visible value\n\t * @param {Number} alpha desired alpha value\n\t * @param {Shadow} shadow desired shadow value\n\t * @param {String} compositeOperation desired composite operation value\n\t * @param {Matrix2D} [matrix] a Matrix2D instance\n\t * @return {DisplayProps} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.append = function(visible, alpha, shadow, compositeOperation, matrix) {\n\t\tthis.alpha *= alpha;\n\t\tthis.shadow = shadow || this.shadow;\n\t\tthis.compositeOperation = compositeOperation || this.compositeOperation;\n\t\tthis.visible = this.visible && visible;\n\t\tmatrix&&this.matrix.appendMatrix(matrix);\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Prepends the specified display properties. This is generally used to apply a parent's properties to a child's.\n\t * For example, to get the combined display properties that would be applied to a child, you could use:\n\t * \n\t * \tvar o = myDisplayObject;\n\t * \tvar props = new createjs.DisplayProps();\n\t * \tdo {\n\t * \t\t// prepend each parent's props in turn:\n\t * \t\tprops.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation, o.getMatrix());\n\t * \t} while (o = o.parent);\n\t * \t\n\t * @method prepend\n\t * @param {Boolean} visible desired visible value\n\t * @param {Number} alpha desired alpha value\n\t * @param {Shadow} shadow desired shadow value\n\t * @param {String} compositeOperation desired composite operation value\n\t * @param {Matrix2D} [matrix] a Matrix2D instance\n\t * @return {DisplayProps} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.prepend = function(visible, alpha, shadow, compositeOperation, matrix) {\n\t\tthis.alpha *= alpha;\n\t\tthis.shadow = this.shadow || shadow;\n\t\tthis.compositeOperation = this.compositeOperation || compositeOperation;\n\t\tthis.visible = this.visible && visible;\n\t\tmatrix&&this.matrix.prependMatrix(matrix);\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Resets this instance and its matrix to default values.\n\t * @method identity\n\t * @return {DisplayProps} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.identity = function() {\n\t\tthis.visible = true;\n\t\tthis.alpha = 1;\n\t\tthis.shadow = this.compositeOperation = null;\n\t\tthis.matrix.identity();\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Returns a clone of the DisplayProps instance. Clones the associated matrix.\n\t * @method clone\n\t * @return {DisplayProps} a clone of the DisplayProps instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new DisplayProps(this.alpha, this.shadow, this.compositeOperation, this.visible, this.matrix.clone());\n\t};\n\n// private methods:\n\n\tcreatejs.DisplayProps = DisplayProps;\n})();\n\n//##############################################################################\n// Point.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Represents a point on a 2 dimensional x / y coordinate system.\n\t *\n\t * <h4>Example</h4>\n\t * \n\t *      var point = new createjs.Point(0, 100);\n\t * \n\t * @class Point\n\t * @param {Number} [x=0] X position.\n\t * @param {Number} [y=0] Y position.\n\t * @constructor\n\t **/\n\tfunction Point(x, y) {\n\t \tthis.setValues(x, y);\n\t \t\n\t \t\n\t// public properties:\n\t\t// assigned in the setValues method.\n\t\t/**\n\t\t * X position.\n\t\t * @property x\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Y position.\n\t\t * @property y\n\t\t * @type Number\n\t\t **/\n\t}\n\tvar p = Point.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\t\n// public methods:\n\t/** \n\t * Sets the specified values on this instance.\n\t * @method setValues\n\t * @param {Number} [x=0] X position.\n\t * @param {Number} [y=0] Y position.\n\t * @return {Point} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.setValues = function(x, y) {\n\t\tthis.x = x||0;\n\t\tthis.y = y||0;\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Copies all properties from the specified point to this point.\n\t * @method copy\n\t * @param {Point} point The point to copy properties from.\n\t * @return {Point} This point. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.copy = function(point) {\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Returns a clone of the Point instance.\n\t * @method clone\n\t * @return {Point} a clone of the Point instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Point(this.x, this.y);\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Point (x=\"+this.x+\" y=\"+this.y+\")]\";\n\t};\n\t\n\t\n\tcreatejs.Point = Point;\n}());\n\n//##############################################################################\n// Rectangle.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Represents a rectangle as defined by the points (x, y) and (x+width, y+height).\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var rect = new createjs.Rectangle(0, 0, 100, 100);\n\t *\n\t * @class Rectangle\n\t * @param {Number} [x=0] X position.\n\t * @param {Number} [y=0] Y position.\n\t * @param {Number} [width=0] The width of the Rectangle.\n\t * @param {Number} [height=0] The height of the Rectangle.\n\t * @constructor\n\t **/\n\tfunction Rectangle(x, y, width, height) {\n\t\tthis.setValues(x, y, width, height);\n\t\t\n\t\t\n\t// public properties:\n\t\t// assigned in the setValues method.\n\t\t/**\n\t\t * X position.\n\t\t * @property x\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Y position.\n\t\t * @property y\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Width.\n\t\t * @property width\n\t\t * @type Number\n\t\t **/\n\t\n\t\t/**\n\t\t * Height.\n\t\t * @property height\n\t\t * @type Number\n\t\t **/\n\t}\n\tvar p = Rectangle.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// public methods:\n\t/** \n\t * Sets the specified values on this instance.\n\t * @method setValues\n\t * @param {Number} [x=0] X position.\n\t * @param {Number} [y=0] Y position.\n\t * @param {Number} [width=0] The width of the Rectangle.\n\t * @param {Number} [height=0] The height of the Rectangle.\n\t * @return {Rectangle} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.setValues = function(x, y, width, height) {\n\t\t// don't forget to update docs in the constructor if these change:\n\t\tthis.x = x||0;\n\t\tthis.y = y||0;\n\t\tthis.width = width||0;\n\t\tthis.height = height||0;\n\t\treturn this;\n\t};\n\t\n\t/** \n\t * Extends the rectangle's bounds to include the described point or rectangle.\n\t * @method extend\n\t * @param {Number} x X position of the point or rectangle.\n\t * @param {Number} y Y position of the point or rectangle.\n\t * @param {Number} [width=0] The width of the rectangle.\n\t * @param {Number} [height=0] The height of the rectangle.\n\t * @return {Rectangle} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.extend = function(x, y, width, height) {\n\t\twidth = width||0;\n\t\theight = height||0;\n\t\tif (x+width > this.x+this.width) { this.width = x+width-this.x; }\n\t\tif (y+height > this.y+this.height) { this.height = y+height-this.y; }\n\t\tif (x < this.x) { this.width += this.x-x; this.x = x; }\n\t\tif (y < this.y) { this.height += this.y-y; this.y = y; }\n\t\treturn this;\n\t};\n\t\n\t/** \n\t * Adds the specified padding to the rectangle's bounds.\n\t * @method pad\n\t * @param {Number} top\n\t * @param {Number} left\n\t * @param {Number} right\n\t * @param {Number} bottom\n\t * @return {Rectangle} This instance. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.pad = function(top, left, bottom, right) {\n\t\tthis.x -= left;\n\t\tthis.y -= top;\n\t\tthis.width += left+right;\n\t\tthis.height += top+bottom;\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Copies all properties from the specified rectangle to this rectangle.\n\t * @method copy\n\t * @param {Rectangle} rectangle The rectangle to copy properties from.\n\t * @return {Rectangle} This rectangle. Useful for chaining method calls.\n\t * @chainable\n\t*/\n\tp.copy = function(rectangle) {\n\t\treturn this.setValues(rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n\t};\n\t\n\t/** \n\t * Returns true if this rectangle fully encloses the described point or rectangle.\n\t * @method contains\n\t * @param {Number} x X position of the point or rectangle.\n\t * @param {Number} y Y position of the point or rectangle.\n\t * @param {Number} [width=0] The width of the rectangle.\n\t * @param {Number} [height=0] The height of the rectangle.\n\t * @return {Boolean} True if the described point or rectangle is contained within this rectangle.\n\t*/\n\tp.contains = function(x, y, width, height) {\n\t\twidth = width||0;\n\t\theight = height||0;\n\t\treturn (x >= this.x && x+width <= this.x+this.width && y >= this.y && y+height <= this.y+this.height);\n\t};\n\t\n\t/** \n\t * Returns a new rectangle which contains this rectangle and the specified rectangle.\n\t * @method union\n\t * @param {Rectangle} rect The rectangle to calculate a union with.\n\t * @return {Rectangle} A new rectangle describing the union.\n\t*/\n\tp.union = function(rect) {\n\t\treturn this.clone().extend(rect.x, rect.y, rect.width, rect.height);\n\t};\n\t\n\t/** \n\t * Returns a new rectangle which describes the intersection (overlap) of this rectangle and the specified rectangle,\n\t * or null if they do not intersect.\n\t * @method intersection\n\t * @param {Rectangle} rect The rectangle to calculate an intersection with.\n\t * @return {Rectangle} A new rectangle describing the intersection or null.\n\t*/\n\tp.intersection = function(rect) {\n\t\tvar x1 = rect.x, y1 = rect.y, x2 = x1+rect.width, y2 = y1+rect.height;\n\t\tif (this.x > x1) { x1 = this.x; }\n\t\tif (this.y > y1) { y1 = this.y; }\n\t\tif (this.x + this.width < x2) { x2 = this.x + this.width; }\n\t\tif (this.y + this.height < y2) { y2 = this.y + this.height; }\n\t\treturn (x2 <= x1 || y2 <= y1) ? null : new Rectangle(x1, y1, x2-x1, y2-y1);\n\t};\n\t\n\t/** \n\t * Returns true if the specified rectangle intersects (has any overlap) with this rectangle.\n\t * @method intersects\n\t * @param {Rectangle} rect The rectangle to compare.\n\t * @return {Boolean} True if the rectangles intersect.\n\t*/\n\tp.intersects = function(rect) {\n\t\treturn (rect.x <= this.x+this.width && this.x <= rect.x+rect.width && rect.y <= this.y+this.height && this.y <= rect.y + rect.height);\n\t};\n\t\n\t/** \n\t * Returns true if the width or height are equal or less than 0.\n\t * @method isEmpty\n\t * @return {Boolean} True if the rectangle is empty.\n\t*/\n\tp.isEmpty = function() {\n\t\treturn this.width <= 0 || this.height <= 0;\n\t};\n\t\n\t/**\n\t * Returns a clone of the Rectangle instance.\n\t * @method clone\n\t * @return {Rectangle} a clone of the Rectangle instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Rectangle(this.x, this.y, this.width, this.height);\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Rectangle (x=\"+this.x+\" y=\"+this.y+\" width=\"+this.width+\" height=\"+this.height+\")]\";\n\t};\n\t\n\t\n\tcreatejs.Rectangle = Rectangle;\n}());\n\n//##############################################################################\n// ButtonHelper.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * The ButtonHelper is a helper class to create interactive buttons from {{#crossLink \"MovieClip\"}}{{/crossLink}} or\n\t * {{#crossLink \"Sprite\"}}{{/crossLink}} instances. This class will intercept mouse events from an object, and\n\t * automatically call {{#crossLink \"Sprite/gotoAndStop\"}}{{/crossLink}} or {{#crossLink \"Sprite/gotoAndPlay\"}}{{/crossLink}},\n\t * to the respective animation labels, add a pointer cursor, and allows the user to define a hit state frame.\n\t *\n\t * The ButtonHelper instance does not need to be added to the stage, but a reference should be maintained to prevent\n\t * garbage collection.\n\t * \n\t * Note that over states will not work unless you call {{#crossLink \"Stage/enableMouseOver\"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var helper = new createjs.ButtonHelper(myInstance, \"out\", \"over\", \"down\", false, myInstance, \"hit\");\n\t *      myInstance.addEventListener(\"click\", handleClick);\n\t *      function handleClick(event) {\n\t *          // Click Happened.\n\t *      }\n\t *\n\t * @class ButtonHelper\n\t * @param {Sprite|MovieClip} target The instance to manage.\n\t * @param {String} [outLabel=\"out\"] The label or animation to go to when the user rolls out of the button.\n\t * @param {String} [overLabel=\"over\"] The label or animation to go to when the user rolls over the button.\n\t * @param {String} [downLabel=\"down\"] The label or animation to go to when the user presses the button.\n\t * @param {Boolean} [play=false] If the helper should call \"gotoAndPlay\" or \"gotoAndStop\" on the button when changing\n\t * states.\n\t * @param {DisplayObject} [hitArea] An optional item to use as the hit state for the button. If this is not defined,\n\t * then the button's visible states will be used instead. Note that the same instance as the \"target\" argument can be\n\t * used for the hitState.\n\t * @param {String} [hitLabel] The label or animation on the hitArea instance that defines the hitArea bounds. If this is\n\t * null, then the default state of the hitArea will be used. *\n\t * @constructor\n\t */\n\tfunction ButtonHelper(target, outLabel, overLabel, downLabel, play, hitArea, hitLabel) {\n\t\tif (!target.addEventListener) { return; }\n\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * The target for this button helper.\n\t\t * @property target\n\t\t * @type MovieClip | Sprite\n\t\t * @readonly\n\t\t **/\n\t\tthis.target = target;\n\t\n\t\t/**\n\t\t * The label name or frame number to display when the user mouses out of the target. Defaults to \"over\".\n\t\t * @property overLabel\n\t\t * @type String | Number\n\t\t **/\n\t\tthis.overLabel = overLabel == null ? \"over\" : overLabel;\n\t\n\t\t/**\n\t\t * The label name or frame number to display when the user mouses over the target. Defaults to \"out\".\n\t\t * @property outLabel\n\t\t * @type String | Number\n\t\t **/\n\t\tthis.outLabel = outLabel == null ? \"out\" : outLabel;\n\t\n\t\t/**\n\t\t * The label name or frame number to display when the user presses on the target. Defaults to \"down\".\n\t\t * @property downLabel\n\t\t * @type String | Number\n\t\t **/\n\t\tthis.downLabel = downLabel == null ? \"down\" : downLabel;\n\t\n\t\t/**\n\t\t * If true, then ButtonHelper will call gotoAndPlay, if false, it will use gotoAndStop. Default is false.\n\t\t * @property play\n\t\t * @default false\n\t\t * @type Boolean\n\t\t **/\n\t\tthis.play = play;\n\t\t\n\t\t\n\t//  private properties\n\t\t/**\n\t\t * @property _isPressed\n\t\t * @type Boolean\n\t\t * @protected\n\t\t **/\n\t\tthis._isPressed = false;\n\t\n\t\t/**\n\t\t * @property _isOver\n\t\t * @type Boolean\n\t\t * @protected\n\t\t **/\n\t\tthis._isOver = false;\n\t\n\t\t/**\n\t\t * @property _enabled\n\t\t * @type Boolean\n\t\t * @protected\n\t\t **/\n\t\tthis._enabled = false;\n\t\t\n\t// setup:\n\t\ttarget.mouseChildren = false; // prevents issues when children are removed from the display list when state changes.\n\t\tthis.enabled = true;\n\t\tthis.handleEvent({});\n\t\tif (hitArea) {\n\t\t\tif (hitLabel) {\n\t\t\t\thitArea.actionsEnabled = false;\n\t\t\t\thitArea.gotoAndStop&&hitArea.gotoAndStop(hitLabel);\n\t\t\t}\n\t\t\ttarget.hitArea = hitArea;\n\t\t}\n\t}\n\tvar p = ButtonHelper.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\t\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink \"ButtonHelper/enabled:property\"}}{{/crossLink}} property instead.\n\t * @method setEnabled\n\t * @param {Boolean} value\n\t * @deprecated\n\t **/\n\tp.setEnabled = function(value) { // TODO: deprecated.\n\t\tif (value == this._enabled) { return; }\n\t\tvar o = this.target;\n\t\tthis._enabled = value;\n\t\tif (value) {\n\t\t\to.cursor = \"pointer\";\n\t\t\to.addEventListener(\"rollover\", this);\n\t\t\to.addEventListener(\"rollout\", this);\n\t\t\to.addEventListener(\"mousedown\", this);\n\t\t\to.addEventListener(\"pressup\", this);\n\t\t\tif (o._reset) { o.__reset = o._reset; o._reset = this._reset;}\n\t\t} else {\n\t\t\to.cursor = null;\n\t\t\to.removeEventListener(\"rollover\", this);\n\t\t\to.removeEventListener(\"rollout\", this);\n\t\t\to.removeEventListener(\"mousedown\", this);\n\t\t\to.removeEventListener(\"pressup\", this);\n\t\t\tif (o.__reset) { o._reset = o.__reset; delete(o.__reset); }\n\t\t}\n\t};\n\t/**\n\t * Use the {{#crossLink \"ButtonHelper/enabled:property\"}}{{/crossLink}} property instead.\n\t * @method getEnabled\n\t * @return {Boolean}\n\t * @deprecated\n\t **/\n\tp.getEnabled = function() {\n\t\treturn this._enabled;\n\t};\n\n\t/**\n\t * Enables or disables the button functionality on the target.\n\t * @property enabled\n\t * @type {Boolean}\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tenabled: { get: p.getEnabled, set: p.setEnabled }\n\t\t});\n\t} catch (e) {} // TODO: use Log\n\n\n// public methods:\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[ButtonHelper]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method handleEvent\n\t * @param {Object} evt The mouse event to handle.\n\t * @protected\n\t **/\n\tp.handleEvent = function(evt) {\n\t\tvar label, t = this.target, type = evt.type;\n\t\tif (type == \"mousedown\") {\n\t\t\tthis._isPressed = true;\n\t\t\tlabel = this.downLabel;\n\t\t} else if (type == \"pressup\") {\n\t\t\tthis._isPressed = false;\n\t\t\tlabel = this._isOver ? this.overLabel : this.outLabel;\n\t\t} else if (type == \"rollover\") {\n\t\t\tthis._isOver = true;\n\t\t\tlabel = this._isPressed ? this.downLabel : this.overLabel;\n\t\t} else { // rollout and default\n\t\t\tthis._isOver = false;\n\t\t\tlabel = this._isPressed ? this.overLabel : this.outLabel;\n\t\t}\n\t\tif (this.play) {\n\t\t\tt.gotoAndPlay&&t.gotoAndPlay(label);\n\t\t} else {\n\t\t\tt.gotoAndStop&&t.gotoAndStop(label);\n\t\t}\n\t};\n\t\n\t/**\n\t * Injected into target. Preserves the paused state through a reset.\n\t * @method _reset\n\t * @protected\n\t **/\n\tp._reset = function() {\n\t\t// TODO: explore better ways to handle this issue. This is hacky & disrupts object signatures.\n\t\tvar p = this.paused;\n\t\tthis.__reset();\n\t\tthis.paused = p;\n\t};\n\n\n\tcreatejs.ButtonHelper = ButtonHelper;\n}());\n\n//##############################################################################\n// Shadow.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * This class encapsulates the properties required to define a shadow to apply to a {{#crossLink \"DisplayObject\"}}{{/crossLink}}\n\t * via its <code>shadow</code> property.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      myImage.shadow = new createjs.Shadow(\"#000000\", 5, 5, 10);\n\t *\n\t * @class Shadow\n\t * @constructor\n\t * @param {String} color The color of the shadow. This can be any valid CSS color value.\n\t * @param {Number} offsetX The x offset of the shadow in pixels.\n\t * @param {Number} offsetY The y offset of the shadow in pixels.\n\t * @param {Number} blur The size of the blurring effect.\n\t **/\n\tfunction Shadow(color, offsetX, offsetY, blur) {\n\t\t\n\t\t\n\t// public properties:\n\t\t/** \n\t\t * The color of the shadow. This can be any valid CSS color value.\n\t\t * @property color\n\t\t * @type String\n\t\t * @default null\n\t\t */\n\t\tthis.color = color||\"black\";\n\t\n\t\t/** The x offset of the shadow.\n\t\t * @property offsetX\n\t\t * @type Number\n\t\t * @default 0\n\t\t */\n\t\tthis.offsetX = offsetX||0;\n\t\n\t\t/** The y offset of the shadow.\n\t\t * @property offsetY\n\t\t * @type Number\n\t\t * @default 0\n\t\t */\n\t\tthis.offsetY = offsetY||0;\n\t\n\t\t/** The blur of the shadow.\n\t\t * @property blur\n\t\t * @type Number\n\t\t * @default 0\n\t\t */\n\t\tthis.blur = blur||0;\n\t}\n\tvar p = Shadow.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// static public properties:\n\t/**\n\t * An identity shadow object (all properties are set to 0).\n\t * @property identity\n\t * @type Shadow\n\t * @static\n\t * @final\n\t * @readonly\n\t **/\n\tShadow.identity = new Shadow(\"transparent\", 0, 0, 0);\n\n\n// public methods:\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Shadow]\";\n\t};\n\n\t/**\n\t * Returns a clone of this Shadow instance.\n\t * @method clone\n\t * @return {Shadow} A clone of the current Shadow instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Shadow(this.color, this.offsetX, this.offsetY, this.blur);\n\t};\n\t\n\n\tcreatejs.Shadow = Shadow;\n}());\n\n//##############################################################################\n// SpriteSheet.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Encapsulates the properties and methods associated with a sprite sheet. A sprite sheet is a series of images (usually\n\t * animation frames) combined into a larger image (or images). For example, an animation consisting of eight 100x100\n\t * images could be combined into a single 400x200 sprite sheet (4 frames across by 2 high).\n\t *\n\t * The data passed to the SpriteSheet constructor defines:\n\t * <ol>\n\t * \t<li> The source image or images to use.</li>\n\t * \t<li> The positions of individual image frames.</li>\n\t * \t<li> Sequences of frames that form named animations. Optional.</li>\n\t * \t<li> The target playback framerate. Optional.</li>\n\t * </ol>\n\t * <h3>SpriteSheet Format</h3>\n\t * SpriteSheets are an object with two required properties (`images` and `frames`), and two optional properties\n\t * (`framerate` and `animations`). This makes them easy to define in javascript code, or in JSON.\n\t *\n\t * <h4>images</h4>\n\t * An array of source images. Images can be either an HTMlimage\n\t * instance, or a uri to an image. The former is recommended to control preloading.\n\t *\n\t * \timages: [image1, \"path/to/image2.png\"],\n\t *\n\t * <h4>frames</h4>\n\t * Defines the individual frames. There are two supported formats for frame data:\n\t * When all of the frames are the same size (in a grid), use an object with `width`, `height`, `regX`, `regY`,\n\t * and `count` properties.\n\t *\n\t * <ul>\n\t *  <li>`width` & `height` are required and specify the dimensions of the frames</li>\n\t *  <li>`regX` & `regY` indicate the registration point or \"origin\" of the frames</li>\n\t *  <li>`spacing` indicate the spacing between frames</li>\n\t *  <li>`margin` specify the margin around the image(s)</li>\n\t *  <li>`count` allows you to specify the total number of frames in the spritesheet; if omitted, this will\n\t *  be calculated based on the dimensions of the source images and the frames. Frames will be assigned\n\t *  indexes based on their position in the source images (left to right, top to bottom).</li>\n\t * </ul>\n\t *\n\t *  \tframes: {width:64, height:64, count:20, regX: 32, regY:64, spacing:0, margin:0}\n\t *\n\t * If the frames are of different sizes, use an array of frame definitions. Each definition is itself an array\n\t * with 4 required and 3 optional entries, in the order:\n\t *\n\t * <ul>\n\t *  <li>The first four, `x`, `y`, `width`, and `height` are required and define the frame rectangle.</li>\n\t *  <li>The fifth, `imageIndex`, specifies the index of the source image (defaults to 0)</li>\n\t *  <li>The last two, `regX` and `regY` specify the registration point of the frame</li>\n\t * </ul>\n\t *\n\t * \tframes: [\n\t * \t\t// x, y, width, height, imageIndex*, regX*, regY*\n\t * \t\t[64, 0, 96, 64],\n\t * \t\t[0, 0, 64, 64, 1, 32, 32]\n\t * \t\t// etc.\n\t * \t]\n\t *\n\t * <h4>animations</h4>\n\t * Optional. An object defining sequences of frames to play as named animations. Each property corresponds to an\n\t * animation of the same name. Each animation must specify the frames to play, and may\n\t * also include a relative playback `speed` (ex. 2 would playback at double speed, 0.5 at half), and\n\t * the name of the `next` animation to sequence to after it completes.\n\t *\n\t * There are three formats supported for defining the frames in an animation, which can be mixed and matched as appropriate:\n\t * <ol>\n\t * \t<li>for a single frame animation, you can simply specify the frame index\n\t *\n\t * \t\tanimations: {\n\t * \t\t\tsit: 7\n\t * \t\t}\n\t *\n\t * </li>\n\t * <li>\n\t *      for an animation of consecutive frames, you can use an array with two required, and two optional entries\n\t * \t\tin the order: `start`, `end`, `next`, and `speed`. This will play the frames from start to end inclusive.\n\t *\n\t * \t\tanimations: {\n\t * \t\t\t// start, end, next*, speed*\n\t * \t\t\trun: [0, 8],\n\t * \t\t\tjump: [9, 12, \"run\", 2]\n\t * \t\t}\n\t *\n\t *  </li>\n\t *  <li>\n\t *     for non-consecutive frames, you can use an object with a `frames` property defining an array of frame\n\t *     indexes to play in order. The object can also specify `next` and `speed` properties.\n\t *\n\t * \t\tanimations: {\n\t * \t\t\twalk: {\n\t * \t\t\t\tframes: [1,2,3,3,2,1]\n\t * \t\t\t},\n\t * \t\t\tshoot: {\n\t * \t\t\t\tframes: [1,4,5,6],\n\t * \t\t\t\tnext: \"walk\",\n\t * \t\t\t\tspeed: 0.5\n\t * \t\t\t}\n\t * \t\t}\n\t *\n\t *  </li>\n\t * </ol>\n\t * <strong>Note:</strong> the `speed` property was added in EaselJS 0.7.0. Earlier versions had a `frequency`\n\t * property instead, which was the inverse of `speed`. For example, a value of \"4\" would be 1/4 normal speed in\n\t * earlier versions, but is 4x normal speed in EaselJS 0.7.0+.\n\t *\n\t * <h4>framerate</h4>\n\t * Optional. Indicates the default framerate to play this spritesheet at in frames per second. See\n\t * {{#crossLink \"SpriteSheet/framerate:property\"}}{{/crossLink}} for more information.\n\t *\n\t * \t\tframerate: 20\n\t *\n\t * Note that the Sprite framerate will only work if the stage update method is provided with the {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}}\n\t * event generated by the {{#crossLink \"Ticker\"}}{{/crossLink}}.\n\t *\n\t * \t\tcreatejs.Ticker.on(\"tick\", handleTick);\n\t * \t\tfunction handleTick(event) {\n\t *\t\t\tstage.update(event);\n\t *\t\t}\n\t *\n\t * <h3>Example</h3>\n\t * To define a simple sprite sheet, with a single image \"sprites.jpg\" arranged in a regular 50x50 grid with three\n\t * animations: \"stand\" showing the first frame, \"run\" looping frame 1-5 inclusive, and \"jump\" playing frame 6-8 and\n\t * sequencing back to run.\n\t *\n\t * \t\tvar data = {\n\t * \t\t\timages: [\"sprites.jpg\"],\n\t * \t\t\tframes: {width:50, height:50},\n\t * \t\t\tanimations: {\n\t * \t\t\t\tstand:0,\n\t * \t\t\t\trun:[1,5],\n\t * \t\t\t\tjump:[6,8,\"run\"]\n\t * \t\t\t}\n\t * \t\t};\n\t * \t\tvar spriteSheet = new createjs.SpriteSheet(data);\n\t * \t\tvar animation = new createjs.Sprite(spriteSheet, \"run\");\n\t *\n\t * <h3>Generating SpriteSheet Images</h3>\n\t * Spritesheets can be created manually by combining images in PhotoShop, and specifying the frame size or\n\t * coordinates manually, however there are a number of tools that facilitate this.\n\t * <ul>\n\t *     <li>Exporting SpriteSheets or HTML5 content from Flash Pro supports the EaselJS SpriteSheet format.</li>\n\t *     <li>The popular <a href=\"https://www.codeandweb.com/texturepacker/easeljs\" target=\"_blank\">Texture Packer</a> has\n\t *     EaselJS support.\n\t *     <li>SWF animations in Flash can be exported to SpriteSheets using <a href=\"http://createjs.com/zoe\" target=\"_blank\"></a></li>\n\t * </ul>\n\t *\n\t * <h3>Cross Origin Issues</h3>\n\t * <strong>Warning:</strong> Images loaded cross-origin will throw cross-origin security errors when interacted with\n\t * using:\n\t * <ul>\n\t *     <li>a mouse</li>\n\t *     <li>methods such as {{#crossLink \"Container/getObjectUnderPoint\"}}{{/crossLink}}</li>\n\t *     <li>Filters (see {{#crossLink \"Filter\"}}{{/crossLink}})</li>\n\t *     <li>caching (see {{#crossLink \"DisplayObject/cache\"}}{{/crossLink}})</li>\n\t * </ul>\n\t * You can get around this by setting `crossOrigin` property on your images before passing them to EaselJS, or\n\t * setting the `crossOrigin` property on PreloadJS' LoadQueue or LoadItems.\n\t *\n\t * \t\tvar image = new Image();\n\t * \t\timg.crossOrigin=\"Anonymous\";\n\t * \t\timg.src = \"http://server-with-CORS-support.com/path/to/image.jpg\";\n\t *\n\t * If you pass string paths to SpriteSheets, they will not work cross-origin. The server that stores the image must\n\t * support cross-origin requests, or this will not work. For more information, check out\n\t * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS\" target=\"_blank\">CORS overview on MDN</a>.\n\t *\n\t * @class SpriteSheet\n\t * @constructor\n\t * @param {Object} data An object describing the SpriteSheet data.\n\t * @extends EventDispatcher\n\t **/\n\tfunction SpriteSheet(data) {\n\t\tthis.EventDispatcher_constructor();\n\n\n\t\t// public properties:\n\t\t/**\n\t\t * Indicates whether all images are finished loading.\n\t\t * @property complete\n\t\t * @type Boolean\n\t\t * @readonly\n\t\t **/\n\t\tthis.complete = true;\n\n\t\t/**\n\t\t * Specifies the framerate to use by default for Sprite instances using the SpriteSheet. See the Sprite class\n\t\t * {{#crossLink \"Sprite/framerate:property\"}}{{/crossLink}} for more information.\n\t\t * @property framerate\n\t\t * @type Number\n\t\t **/\n\t\tthis.framerate = 0;\n\n\n\t\t// private properties:\n\t\t/**\n\t\t * @property _animations\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._animations = null;\n\n\t\t/**\n\t\t * @property _frames\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._frames = null;\n\n\t\t/**\n\t\t * @property _images\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._images = null;\n\n\t\t/**\n\t\t * @property _data\n\t\t * @protected\n\t\t * @type Object\n\t\t **/\n\t\tthis._data = null;\n\n\t\t/**\n\t\t * @property _loadCount\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._loadCount = 0;\n\n\t\t// only used for simple frame defs:\n\t\t/**\n\t\t * @property _frameHeight\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._frameHeight = 0;\n\n\t\t/**\n\t\t * @property _frameWidth\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._frameWidth = 0;\n\n\t\t/**\n\t\t * @property _numFrames\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._numFrames = 0;\n\n\t\t/**\n\t\t * @property _regX\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._regX = 0;\n\n\t\t/**\n\t\t * @property _regY\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._regY = 0;\n\n\t\t/**\n\t\t * @property _spacing\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._spacing = 0;\n\n\t\t/**\n\t\t * @property _margin\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._margin = 0;\n\n\t\t// setup:\n\t\tthis._parseData(data);\n\t}\n\tvar p = createjs.extend(SpriteSheet, createjs.EventDispatcher);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// events:\n\t/**\n\t * Dispatched when all images are loaded.  Note that this only fires if the images\n\t * were not fully loaded when the sprite sheet was initialized. You should check the complete property\n\t * to prior to adding a listener. Ex.\n\t *\n\t * \tvar sheet = new createjs.SpriteSheet(data);\n\t * \tif (!sheet.complete) {\n\t * \t\t// not preloaded, listen for the complete event:\n\t * \t\tsheet.addEventListener(\"complete\", handler);\n\t * \t}\n\t *\n\t * @event complete\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when getFrame is called with a valid frame index. This is primarily intended for use by {{#crossLink \"SpriteSheetBuilder\"}}{{/crossLink}}\n\t * when doing on-demand rendering.\n\t * @event getframe\n\t * @param {Number} index The frame index.\n\t * @param {Object} frame The frame object that getFrame will return.\n\t */\n\n\t/**\n\t * Dispatched when an image encounters an error. A SpriteSheet will dispatch an error event for each image that\n\t * encounters an error, and will still dispatch a {{#crossLink \"SpriteSheet/complete:event\"}}{{/crossLink}}\n\t * event once all images are finished processing, even if an error is encountered.\n\t * @event error\n\t * @param {String} src The source of the image that failed to load.\n\t * @since 0.8.2\n\t */\n\n\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink \"SpriteSheet/animations:property\"}}{{/crossLink}} property instead.\n\t * @method getAnimations\n\t * @return {Array}\n\t * @deprecated\n\t **/\n\tp.getAnimations = function() {\n\t\treturn this._animations.slice();\n\t};\n\n\t/**\n\t * Returns an array of all available animation names available on this sprite sheet as strings.\n\t * @property animations\n\t * @type {Array}\n\t * @readonly\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tanimations: { get: p.getAnimations }\n\t\t});\n\t} catch (e) {}\n\n\n// public methods:\n\t/**\n\t * Returns the total number of frames in the specified animation, or in the whole sprite\n\t * sheet if the animation param is omitted. Returns 0 if the spritesheet relies on calculated frame counts, and\n\t * the images have not been fully loaded.\n\t * @method getNumFrames\n\t * @param {String} animation The name of the animation to get a frame count for.\n\t * @return {Number} The number of frames in the animation, or in the entire sprite sheet if the animation param is omitted.\n\t */\n\tp.getNumFrames = function(animation) {\n\t\tif (animation == null) {\n\t\t\treturn this._frames ? this._frames.length : this._numFrames || 0;\n\t\t} else {\n\t\t\tvar data = this._data[animation];\n\t\t\tif (data == null) { return 0; }\n\t\t\telse { return data.frames.length; }\n\t\t}\n\t};\n\n\t/**\n\t * Returns an object defining the specified animation. The returned object contains:<UL>\n\t * \t<li>frames: an array of the frame ids in the animation</li>\n\t * \t<li>speed: the playback speed for this animation</li>\n\t * \t<li>name: the name of the animation</li>\n\t * \t<li>next: the default animation to play next. If the animation loops, the name and next property will be the\n\t * \tsame.</li>\n\t * </UL>\n\t * @method getAnimation\n\t * @param {String} name The name of the animation to get.\n\t * @return {Object} a generic object with frames, speed, name, and next properties.\n\t **/\n\tp.getAnimation = function(name) {\n\t\treturn this._data[name];\n\t};\n\n\t/**\n\t * Returns an object specifying the image and source rect of the specified frame. The returned object has:<UL>\n\t * \t<li>an image property holding a reference to the image object in which the frame is found</li>\n\t * \t<li>a rect property containing a Rectangle instance which defines the boundaries for the frame within that\n\t * \timage.</li>\n\t * \t<li> A regX and regY property corresponding to the regX/Y values for the frame.\n\t * </UL>\n\t * @method getFrame\n\t * @param {Number} frameIndex The index of the frame.\n\t * @return {Object} a generic object with image and rect properties. Returns null if the frame does not exist.\n\t **/\n\tp.getFrame = function(frameIndex) {\n\t\tvar frame;\n\t\tif (this._frames && (frame=this._frames[frameIndex])) { return frame; }\n\t\treturn null;\n\t};\n\n\t/**\n\t * Returns a {{#crossLink \"Rectangle\"}}{{/crossLink}} instance defining the bounds of the specified frame relative\n\t * to the origin. For example, a 90 x 70 frame with a regX of 50 and a regY of 40 would return:\n\t *\n\t * \t[x=-50, y=-40, width=90, height=70]\n\t *\n\t * @method getFrameBounds\n\t * @param {Number} frameIndex The index of the frame.\n\t * @param {Rectangle} [rectangle] A Rectangle instance to copy the values into. By default a new instance is created.\n\t * @return {Rectangle} A Rectangle instance. Returns null if the frame does not exist, or the image is not fully loaded.\n\t **/\n\tp.getFrameBounds = function(frameIndex, rectangle) {\n\t\tvar frame = this.getFrame(frameIndex);\n\t\treturn frame ? (rectangle||new createjs.Rectangle()).setValues(-frame.regX, -frame.regY, frame.rect.width, frame.rect.height) : null;\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[SpriteSheet]\";\n\t};\n\n\t/**\n\t * SpriteSheet cannot be cloned. A SpriteSheet can be shared by multiple Sprite instances without cloning it.\n\t * @method clone\n\t **/\n\tp.clone = function() {\n\t\tthrow(\"SpriteSheet cannot be cloned.\")\n\t};\n\n// private methods:\n\t/**\n\t * @method _parseData\n\t * @param {Object} data An object describing the SpriteSheet data.\n\t * @protected\n\t **/\n\tp._parseData = function(data) {\n\t\tvar i,l,o,a;\n\t\tif (data == null) { return; }\n\n\t\tthis.framerate = data.framerate||0;\n\n\t\t// parse images:\n\t\tif (data.images && (l=data.images.length) > 0) {\n\t\t\ta = this._images = [];\n\t\t\tfor (i=0; i<l; i++) {\n\t\t\t\tvar img = data.images[i];\n\t\t\t\tif (typeof img == \"string\") {\n\t\t\t\t\tvar src = img;\n\t\t\t\t\timg = document.createElement(\"img\");\n\t\t\t\t\timg.src = src;\n\t\t\t\t}\n\t\t\t\ta.push(img);\n\t\t\t\tif (!img.getContext && !img.naturalWidth) {\n\t\t\t\t\tthis._loadCount++;\n\t\t\t\t\tthis.complete = false;\n\t\t\t\t\t(function(o, src) { img.onload = function() { o._handleImageLoad(src); } })(this, src);\n\t\t\t\t\t(function(o, src) { img.onerror = function() { o._handleImageError(src); } })(this, src);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// parse frames:\n\t\tif (data.frames == null) { // nothing\n\t\t} else if (Array.isArray(data.frames)) {\n\t\t\tthis._frames = [];\n\t\t\ta = data.frames;\n\t\t\tfor (i=0,l=a.length;i<l;i++) {\n\t\t\t\tvar arr = a[i];\n\t\t\t\tthis._frames.push({image:this._images[arr[4]?arr[4]:0], rect:new createjs.Rectangle(arr[0],arr[1],arr[2],arr[3]), regX:arr[5]||0, regY:arr[6]||0 });\n\t\t\t}\n\t\t} else {\n\t\t\to = data.frames;\n\t\t\tthis._frameWidth = o.width;\n\t\t\tthis._frameHeight = o.height;\n\t\t\tthis._regX = o.regX||0;\n\t\t\tthis._regY = o.regY||0;\n\t\t\tthis._spacing = o.spacing||0;\n\t\t\tthis._margin = o.margin||0;\n\t\t\tthis._numFrames = o.count;\n\t\t\tif (this._loadCount == 0) { this._calculateFrames(); }\n\t\t}\n\n\t\t// parse animations:\n\t\tthis._animations = [];\n\t\tif ((o=data.animations) != null) {\n\t\t\tthis._data = {};\n\t\t\tvar name;\n\t\t\tfor (name in o) {\n\t\t\t\tvar anim = {name:name};\n\t\t\t\tvar obj = o[name];\n\t\t\t\tif (typeof obj == \"number\") { // single frame\n\t\t\t\t\ta = anim.frames = [obj];\n\t\t\t\t} else if (Array.isArray(obj)) { // simple\n\t\t\t\t\tif (obj.length == 1) { anim.frames = [obj[0]]; }\n\t\t\t\t\telse {\n\t\t\t\t\t\tanim.speed = obj[3];\n\t\t\t\t\t\tanim.next = obj[2];\n\t\t\t\t\t\ta = anim.frames = [];\n\t\t\t\t\t\tfor (i=obj[0];i<=obj[1];i++) {\n\t\t\t\t\t\t\ta.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else { // complex\n\t\t\t\t\tanim.speed = obj.speed;\n\t\t\t\t\tanim.next = obj.next;\n\t\t\t\t\tvar frames = obj.frames;\n\t\t\t\t\ta = anim.frames = (typeof frames == \"number\") ? [frames] : frames.slice(0);\n\t\t\t\t}\n\t\t\t\tif (anim.next === true || anim.next === undefined) { anim.next = name; } // loop\n\t\t\t\tif (anim.next === false || (a.length < 2 && anim.next == name)) { anim.next = null; } // stop\n\t\t\t\tif (!anim.speed) { anim.speed = 1; }\n\t\t\t\tthis._animations.push(name);\n\t\t\t\tthis._data[name] = anim;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _handleImageLoad\n\t * @protected\n\t **/\n\tp._handleImageLoad = function(src) {\n\t\tif (--this._loadCount == 0) {\n\t\t\tthis._calculateFrames();\n\t\t\tthis.complete = true;\n\t\t\tthis.dispatchEvent(\"complete\");\n\t\t}\n\t};\n\n\t/**\n\t * @method _handleImageError\n\t * @protected\n\t */\n\tp._handleImageError = function (src) {\n\t\tvar errorEvent = new createjs.Event(\"error\");\n\t\terrorEvent.src = src;\n\t\tthis.dispatchEvent(errorEvent);\n\n\t\t// Complete is still dispatched.\n\t\tif (--this._loadCount == 0) {\n\t\t\tthis.dispatchEvent(\"complete\");\n\t\t}\n\t};\n\n\t/**\n\t * @method _calculateFrames\n\t * @protected\n\t **/\n\tp._calculateFrames = function() {\n\t\tif (this._frames || this._frameWidth == 0) { return; }\n\n\t\tthis._frames = [];\n\n\t\tvar maxFrames = this._numFrames || 100000; // if we go over this, something is wrong.\n\t\tvar frameCount = 0, frameWidth = this._frameWidth, frameHeight = this._frameHeight;\n\t\tvar spacing = this._spacing, margin = this._margin;\n\t\t\n\t\timgLoop:\n\t\tfor (var i=0, imgs=this._images; i<imgs.length; i++) {\n\t\t\tvar img = imgs[i], imgW = img.width, imgH = img.height;\n\n\t\t\tvar y = margin;\n\t\t\twhile (y <= imgH-margin-frameHeight) {\n\t\t\t\tvar x = margin;\n\t\t\t\twhile (x <= imgW-margin-frameWidth) {\n\t\t\t\t\tif (frameCount >= maxFrames) { break imgLoop; }\n\t\t\t\t\tframeCount++;\n\t\t\t\t\tthis._frames.push({\n\t\t\t\t\t\t\timage: img,\n\t\t\t\t\t\t\trect: new createjs.Rectangle(x, y, frameWidth, frameHeight),\n\t\t\t\t\t\t\tregX: this._regX,\n\t\t\t\t\t\t\tregY: this._regY\n\t\t\t\t\t\t});\n\t\t\t\t\tx += frameWidth+spacing;\n\t\t\t\t}\n\t\t\t\ty += frameHeight+spacing;\n\t\t\t}\n\t\t}\n\t\tthis._numFrames = frameCount;\n\t};\n\n\n\tcreatejs.SpriteSheet = createjs.promote(SpriteSheet, \"EventDispatcher\");\n}());\n\n//##############################################################################\n// Graphics.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * The Graphics class exposes an easy to use API for generating vector drawing instructions and drawing them to a\n\t * specified context. Note that you can use Graphics without any dependency on the EaselJS framework by calling {{#crossLink \"Graphics/draw\"}}{{/crossLink}}\n\t * directly, or it can be used with the {{#crossLink \"Shape\"}}{{/crossLink}} object to draw vector graphics within the\n\t * context of an EaselJS display list.\n\t *\n\t * There are two approaches to working with Graphics object: calling methods on a Graphics instance (the \"Graphics API\"), or\n\t * instantiating Graphics command objects and adding them to the graphics queue via {{#crossLink \"Graphics/append\"}}{{/crossLink}}.\n\t * The former abstracts the latter, simplifying beginning and ending paths, fills, and strokes.\n\t *\n\t *      var g = new createjs.Graphics();\n\t *      g.setStrokeStyle(1);\n\t *      g.beginStroke(\"#000000\");\n\t *      g.beginFill(\"red\");\n\t *      g.drawCircle(0,0,30);\n\t *\n\t * All drawing methods in Graphics return the Graphics instance, so they can be chained together. For example,\n\t * the following line of code would generate the instructions to draw a rectangle with a red stroke and blue fill:\n\t *\n\t *      myGraphics.beginStroke(\"red\").beginFill(\"blue\").drawRect(20, 20, 100, 50);\n\t *\n\t * Each graphics API call generates a command object (see below). The last command to be created can be accessed via\n\t * {{#crossLink \"Graphics/command:property\"}}{{/crossLink}}:\n\t *\n\t *      var fillCommand = myGraphics.beginFill(\"red\").command;\n\t *      // ... later, update the fill style/color:\n\t *      fillCommand.style = \"blue\";\n\t *      // or change it to a bitmap fill:\n\t *      fillCommand.bitmap(myImage);\n\t *\n\t * For more direct control of rendering, you can instantiate and append command objects to the graphics queue directly. In this case, you\n\t * need to manage path creation manually, and ensure that fill/stroke is applied to a defined path:\n\t *\n\t *      // start a new path. Graphics.beginCmd is a reusable BeginPath instance:\n\t *      myGraphics.append(createjs.Graphics.beginCmd);\n\t *      // we need to define the path before applying the fill:\n\t *      var circle = new createjs.Graphics.Circle(0,0,30);\n\t *      myGraphics.append(circle);\n\t *      // fill the path we just defined:\n\t *      var fill = new createjs.Graphics.Fill(\"red\");\n\t *      myGraphics.append(fill);\n\t *\n\t * These approaches can be used together, for example to insert a custom command:\n\t *\n\t *      myGraphics.beginFill(\"red\");\n\t *      var customCommand = new CustomSpiralCommand(etc);\n\t *      myGraphics.append(customCommand);\n\t *      myGraphics.beginFill(\"blue\");\n\t *      myGraphics.drawCircle(0, 0, 30);\n\t *\n\t * See {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more info on creating custom commands.\n\t *\n\t * <h4>Tiny API</h4>\n\t * The Graphics class also includes a \"tiny API\", which is one or two-letter methods that are shortcuts for all of the\n\t * Graphics methods. These methods are great for creating compact instructions, and is used by the Toolkit for CreateJS\n\t * to generate readable code. All tiny methods are marked as protected, so you can view them by enabling protected\n\t * descriptions in the docs.\n\t *\n\t * <table>\n\t *     <tr><td><b>Tiny</b></td><td><b>Method</b></td><td><b>Tiny</b></td><td><b>Method</b></td></tr>\n\t *     <tr><td>mt</td><td>{{#crossLink \"Graphics/moveTo\"}}{{/crossLink}} </td>\n\t *     <td>lt</td> <td>{{#crossLink \"Graphics/lineTo\"}}{{/crossLink}}</td></tr>\n\t *     <tr><td>a/at</td><td>{{#crossLink \"Graphics/arc\"}}{{/crossLink}} / {{#crossLink \"Graphics/arcTo\"}}{{/crossLink}} </td>\n\t *     <td>bt</td><td>{{#crossLink \"Graphics/bezierCurveTo\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>qt</td><td>{{#crossLink \"Graphics/quadraticCurveTo\"}}{{/crossLink}} (also curveTo)</td>\n\t *     <td>r</td><td>{{#crossLink \"Graphics/rect\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>cp</td><td>{{#crossLink \"Graphics/closePath\"}}{{/crossLink}} </td>\n\t *     <td>c</td><td>{{#crossLink \"Graphics/clear\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>f</td><td>{{#crossLink \"Graphics/beginFill\"}}{{/crossLink}} </td>\n\t *     <td>lf</td><td>{{#crossLink \"Graphics/beginLinearGradientFill\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>rf</td><td>{{#crossLink \"Graphics/beginRadialGradientFill\"}}{{/crossLink}} </td>\n\t *     <td>bf</td><td>{{#crossLink \"Graphics/beginBitmapFill\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>ef</td><td>{{#crossLink \"Graphics/endFill\"}}{{/crossLink}} </td>\n\t *     <td>ss / sd</td><td>{{#crossLink \"Graphics/setStrokeStyle\"}}{{/crossLink}} / {{#crossLink \"Graphics/setStrokeDash\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>s</td><td>{{#crossLink \"Graphics/beginStroke\"}}{{/crossLink}} </td>\n\t *     <td>ls</td><td>{{#crossLink \"Graphics/beginLinearGradientStroke\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>rs</td><td>{{#crossLink \"Graphics/beginRadialGradientStroke\"}}{{/crossLink}} </td>\n\t *     <td>bs</td><td>{{#crossLink \"Graphics/beginBitmapStroke\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>es</td><td>{{#crossLink \"Graphics/endStroke\"}}{{/crossLink}} </td>\n\t *     <td>dr</td><td>{{#crossLink \"Graphics/drawRect\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>rr</td><td>{{#crossLink \"Graphics/drawRoundRect\"}}{{/crossLink}} </td>\n\t *     <td>rc</td><td>{{#crossLink \"Graphics/drawRoundRectComplex\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>dc</td><td>{{#crossLink \"Graphics/drawCircle\"}}{{/crossLink}} </td>\n\t *     <td>de</td><td>{{#crossLink \"Graphics/drawEllipse\"}}{{/crossLink}} </td></tr>\n\t *     <tr><td>dp</td><td>{{#crossLink \"Graphics/drawPolyStar\"}}{{/crossLink}} </td>\n\t *     <td>p</td><td>{{#crossLink \"Graphics/decodePath\"}}{{/crossLink}} </td></tr>\n\t * </table>\n\t *\n\t * Here is the above example, using the tiny API instead.\n\t *\n\t *      myGraphics.s(\"red\").f(\"blue\").r(20, 20, 100, 50);\n\t *\n\t * @class Graphics\n\t * @constructor\n\t **/\n\tfunction Graphics() {\n\n\n\t// public properties\n\t\t/**\n\t\t * Holds a reference to the last command that was created or appended. For example, you could retain a reference\n\t\t * to a Fill command in order to dynamically update the color later by using:\n\t\t *\n\t\t * \t\tvar myFill = myGraphics.beginFill(\"red\").command;\n\t\t * \t\t// update color later:\n\t\t * \t\tmyFill.style = \"yellow\";\n\t\t *\n\t\t * @property command\n\t\t * @type Object\n\t\t **/\n\t\tthis.command = null;\n\n\n\t// private properties\n\t\t/**\n\t\t * @property _stroke\n\t\t * @protected\n\t\t * @type {Stroke}\n\t\t **/\n\t\tthis._stroke = null;\n\n\t\t/**\n\t\t * @property _strokeStyle\n\t\t * @protected\n\t\t * @type {StrokeStyle}\n\t\t **/\n\t\tthis._strokeStyle = null;\n\t\t\n\t\t/**\n\t\t * @property _oldStrokeStyle\n\t\t * @protected\n\t\t * @type {StrokeStyle}\n\t\t **/\n\t\tthis._oldStrokeStyle = null;\n\t\t\n\t\t/**\n\t\t * @property _strokeDash\n\t\t * @protected\n\t\t * @type {StrokeDash}\n\t\t **/\n\t\tthis._strokeDash = null;\n\t\t\n\t\t/**\n\t\t * @property _oldStrokeDash\n\t\t * @protected\n\t\t * @type {StrokeDash}\n\t\t **/\n\t\tthis._oldStrokeDash = null;\n\n\t\t/**\n\t\t * @property _strokeIgnoreScale\n\t\t * @protected\n\t\t * @type Boolean\n\t\t **/\n\t\tthis._strokeIgnoreScale = false;\n\n\t\t/**\n\t\t * @property _fill\n\t\t * @protected\n\t\t * @type {Fill}\n\t\t **/\n\t\tthis._fill = null;\n\n\t\t/**\n\t\t * @property _instructions\n\t\t * @protected\n\t\t * @type {Array}\n\t\t **/\n\t\tthis._instructions = [];\n\n\t\t/**\n\t\t * Indicates the last instruction index that was committed.\n\t\t * @property _commitIndex\n\t\t * @protected\n\t\t * @type {Number}\n\t\t **/\n\t\tthis._commitIndex = 0;\n\n\t\t/**\n\t\t * Uncommitted instructions.\n\t\t * @property _activeInstructions\n\t\t * @protected\n\t\t * @type {Array}\n\t\t **/\n\t\tthis._activeInstructions = [];\n\n\t\t/**\n\t\t * This indicates that there have been changes to the activeInstruction list since the last updateInstructions call.\n\t\t * @property _dirty\n\t\t * @protected\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t **/\n\t\tthis._dirty = false;\n\n\t\t/**\n\t\t * Index to draw from if a store operation has happened.\n\t\t * @property _storeIndex\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis._storeIndex = 0;\n\n\t// setup:\n\t\tthis.clear();\n\t}\n\tvar p = Graphics.prototype;\n\tvar G = Graphics; // shortcut\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// static public methods:\n\t/**\n\t * Returns a CSS compatible color string based on the specified RGB numeric color values in the format\n\t * \"rgba(255,255,255,1.0)\", or if alpha is null then in the format \"rgb(255,255,255)\". For example,\n\t *\n\t *      createjs.Graphics.getRGB(50, 100, 150, 0.5);\n\t *      // Returns \"rgba(50,100,150,0.5)\"\n\t *\n\t * It also supports passing a single hex color value as the first param, and an optional alpha value as the second\n\t * param. For example,\n\t *\n\t *      createjs.Graphics.getRGB(0xFF00FF, 0.2);\n\t *      // Returns \"rgba(255,0,255,0.2)\"\n\t *\n\t * @method getRGB\n\t * @static\n\t * @param {Number} r The red component for the color, between 0 and 0xFF (255).\n\t * @param {Number} g The green component for the color, between 0 and 0xFF (255).\n\t * @param {Number} b The blue component for the color, between 0 and 0xFF (255).\n\t * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.\n\t * @return {String} A CSS compatible color string based on the specified RGB numeric color values in the format\n\t * \"rgba(255,255,255,1.0)\", or if alpha is null then in the format \"rgb(255,255,255)\".\n\t **/\n\tGraphics.getRGB = function(r, g, b, alpha) {\n\t\tif (r != null && b == null) {\n\t\t\talpha = g;\n\t\t\tb = r&0xFF;\n\t\t\tg = r>>8&0xFF;\n\t\t\tr = r>>16&0xFF;\n\t\t}\n\t\tif (alpha == null) {\n\t\t\treturn \"rgb(\"+r+\",\"+g+\",\"+b+\")\";\n\t\t} else {\n\t\t\treturn \"rgba(\"+r+\",\"+g+\",\"+b+\",\"+alpha+\")\";\n\t\t}\n\t};\n\n\t/**\n\t * Returns a CSS compatible color string based on the specified HSL numeric color values in the format \"hsla(360,100,100,1.0)\",\n\t * or if alpha is null then in the format \"hsl(360,100,100)\".\n\t *\n\t *      createjs.Graphics.getHSL(150, 100, 70);\n\t *      // Returns \"hsl(150,100,70)\"\n\t *\n\t * @method getHSL\n\t * @static\n\t * @param {Number} hue The hue component for the color, between 0 and 360.\n\t * @param {Number} saturation The saturation component for the color, between 0 and 100.\n\t * @param {Number} lightness The lightness component for the color, between 0 and 100.\n\t * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.\n\t * @return {String} A CSS compatible color string based on the specified HSL numeric color values in the format\n\t * \"hsla(360,100,100,1.0)\", or if alpha is null then in the format \"hsl(360,100,100)\".\n\t **/\n\tGraphics.getHSL = function(hue, saturation, lightness, alpha) {\n\t\tif (alpha == null) {\n\t\t\treturn \"hsl(\"+(hue%360)+\",\"+saturation+\"%,\"+lightness+\"%)\";\n\t\t} else {\n\t\t\treturn \"hsla(\"+(hue%360)+\",\"+saturation+\"%,\"+lightness+\"%,\"+alpha+\")\";\n\t\t}\n\t};\n\n\n// static properties:\n\t/**\n\t * A reusable instance of {{#crossLink \"Graphics/BeginPath\"}}{{/crossLink}} to avoid\n\t * unnecessary instantiation.\n\t * @property beginCmd\n\t * @type {Graphics.BeginPath}\n\t * @static\n\t **/\n\t // defined at the bottom of this file.\n\n\t/**\n\t * Map of Base64 characters to values. Used by {{#crossLink \"Graphics/decodePath\"}}{{/crossLink}}.\n\t * @property BASE_64\n\t * @static\n\t * @final\n\t * @readonly\n\t * @type {Object}\n\t **/\n\tGraphics.BASE_64 = {\"A\":0,\"B\":1,\"C\":2,\"D\":3,\"E\":4,\"F\":5,\"G\":6,\"H\":7,\"I\":8,\"J\":9,\"K\":10,\"L\":11,\"M\":12,\"N\":13,\"O\":14,\"P\":15,\"Q\":16,\"R\":17,\"S\":18,\"T\":19,\"U\":20,\"V\":21,\"W\":22,\"X\":23,\"Y\":24,\"Z\":25,\"a\":26,\"b\":27,\"c\":28,\"d\":29,\"e\":30,\"f\":31,\"g\":32,\"h\":33,\"i\":34,\"j\":35,\"k\":36,\"l\":37,\"m\":38,\"n\":39,\"o\":40,\"p\":41,\"q\":42,\"r\":43,\"s\":44,\"t\":45,\"u\":46,\"v\":47,\"w\":48,\"x\":49,\"y\":50,\"z\":51,\"0\":52,\"1\":53,\"2\":54,\"3\":55,\"4\":56,\"5\":57,\"6\":58,\"7\":59,\"8\":60,\"9\":61,\"+\":62,\"/\":63};\n\n\t/**\n\t * Maps numeric values for the caps parameter of {{#crossLink \"Graphics/setStrokeStyle\"}}{{/crossLink}} to\n\t * corresponding string values. This is primarily for use with the tiny API. The mappings are as follows: 0 to\n\t * \"butt\", 1 to \"round\", and 2 to \"square\".\n\t * For example, to set the line caps to \"square\":\n\t *\n\t *      myGraphics.ss(16, 2);\n\t *\n\t * @property STROKE_CAPS_MAP\n\t * @static\n\t * @final\n\t * @readonly\n\t * @type {Array}\n\t **/\n\tGraphics.STROKE_CAPS_MAP = [\"butt\", \"round\", \"square\"];\n\n\t/**\n\t * Maps numeric values for the joints parameter of {{#crossLink \"Graphics/setStrokeStyle\"}}{{/crossLink}} to\n\t * corresponding string values. This is primarily for use with the tiny API. The mappings are as follows: 0 to\n\t * \"miter\", 1 to \"round\", and 2 to \"bevel\".\n\t * For example, to set the line joints to \"bevel\":\n\t *\n\t *      myGraphics.ss(16, 0, 2);\n\t *\n\t * @property STROKE_JOINTS_MAP\n\t * @static\n\t * @final\n\t * @readonly\n\t * @type {Array}\n\t **/\n\tGraphics.STROKE_JOINTS_MAP = [\"miter\", \"round\", \"bevel\"];\n\n\t/**\n\t * @property _ctx\n\t * @static\n\t * @protected\n\t * @type {CanvasRenderingContext2D}\n\t **/\n\tvar canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement(\"canvas\"));\n\tif (canvas.getContext) {\n\t\tGraphics._ctx = canvas.getContext(\"2d\");\n\t\tcanvas.width = canvas.height = 1;\n\t}\n\n\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink \"Graphics/instructions:property\"}}{{/crossLink}} property instead.\n\t * @method getInstructions\n\t * @return {Array}\n\t * @deprecated\n\t **/\n\tp.getInstructions = function() {\n\t\tthis._updateInstructions();\n\t\treturn this._instructions;\n\t};\n\n\t/**\n\t * Returns the graphics instructions array. Each entry is a graphics command object (ex. Graphics.Fill, Graphics.Rect)\n\t * Modifying the returned array directly is not recommended, and is likely to result in unexpected behaviour.\n\t *\n\t * This property is mainly intended for introspection of the instructions (ex. for graphics export).\n\t * @property instructions\n\t * @type {Array}\n\t * @readonly\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tinstructions: { get: p.getInstructions }\n\t\t});\n\t} catch (e) {}\n\n\n// public methods:\n\t/**\n\t * Returns true if this Graphics instance has no drawing commands.\n\t * @method isEmpty\n\t * @return {Boolean} Returns true if this Graphics instance has no drawing commands.\n\t **/\n\tp.isEmpty = function() {\n\t\treturn !(this._instructions.length || this._activeInstructions.length);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Object} data Optional data that is passed to graphics command exec methods. When called from a Shape instance, the shape passes itself as the data parameter. This can be used by custom graphic commands to insert contextual data.\n\t **/\n\tp.draw = function(ctx, data) {\n\t\tthis._updateInstructions();\n\t\tvar instr = this._instructions;\n\t\tfor (var i=this._storeIndex, l=instr.length; i<l; i++) {\n\t\t\tinstr[i].exec(ctx, data);\n\t\t}\n\t};\n\n\t/**\n\t * Draws only the path described for this Graphics instance, skipping any non-path instructions, including fill and\n\t * stroke descriptions. Used for <code>DisplayObject.mask</code> to draw the clipping path, for example.\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method drawAsPath\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t **/\n\tp.drawAsPath = function(ctx) {\n\t\tthis._updateInstructions();\n\t\tvar instr, instrs = this._instructions;\n\t\tfor (var i=this._storeIndex, l=instrs.length; i<l; i++) {\n\t\t\t// the first command is always a beginPath command.\n\t\t\tif ((instr = instrs[i]).path !== false) { instr.exec(ctx); }\n\t\t}\n\t};\n\n\n// public methods that map directly to context 2D calls:\n\t/**\n\t * Moves the drawing point to the specified position. A tiny API method \"mt\" also exists.\n\t * @method moveTo\n\t * @param {Number} x The x coordinate the drawing point should move to.\n\t * @param {Number} y The y coordinate the drawing point should move to.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls).\n\t * @chainable\n\t **/\n\tp.moveTo = function(x, y) {\n\t\treturn this.append(new G.MoveTo(x,y), true);\n\t};\n\n\t/**\n\t * Draws a line from the current drawing point to the specified position, which become the new current drawing\n\t * point. Note that you *must* call {{#crossLink \"Graphics/moveTo\"}}{{/crossLink}} before the first `lineTo()`.\n\t * A tiny API method \"lt\" also exists.\n\t *\n\t * For detailed information, read the\n\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#complex-shapes-(paths)\">\n\t * whatwg spec</a>.\n\t * @method lineTo\n\t * @param {Number} x The x coordinate the drawing point should draw to.\n\t * @param {Number} y The y coordinate the drawing point should draw to.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.lineTo = function(x, y) {\n\t\treturn this.append(new G.LineTo(x,y));\n\t};\n\n\t/**\n\t * Draws an arc with the specified control points and radius.  For detailed information, read the\n\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arcto\">\n\t * whatwg spec</a>. A tiny API method \"at\" also exists.\n\t * @method arcTo\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @param {Number} x2\n\t * @param {Number} y2\n\t * @param {Number} radius\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.arcTo = function(x1, y1, x2, y2, radius) {\n\t\treturn this.append(new G.ArcTo(x1, y1, x2, y2, radius));\n\t};\n\n\t/**\n\t * Draws an arc defined by the radius, startAngle and endAngle arguments, centered at the position (x, y). For\n\t * example, to draw a full circle with a radius of 20 centered at (100, 100):\n\t *\n\t *      arc(100, 100, 20, 0, Math.PI*2);\n\t *\n\t * For detailed information, read the\n\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arc\">whatwg spec</a>.\n\t * A tiny API method \"a\" also exists.\n\t * @method arc\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} radius\n\t * @param {Number} startAngle Measured in radians.\n\t * @param {Number} endAngle Measured in radians.\n\t * @param {Boolean} anticlockwise\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {\n\t\treturn this.append(new G.Arc(x, y, radius, startAngle, endAngle, anticlockwise));\n\t};\n\n\t/**\n\t * Draws a quadratic curve from the current drawing point to (x, y) using the control point (cpx, cpy). For detailed\n\t * information, read the <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto\">\n\t * whatwg spec</a>. A tiny API method \"qt\" also exists.\n\t * @method quadraticCurveTo\n\t * @param {Number} cpx\n\t * @param {Number} cpy\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.quadraticCurveTo = function(cpx, cpy, x, y) {\n\t\treturn this.append(new G.QuadraticCurveTo(cpx, cpy, x, y));\n\t};\n\n\t/**\n\t * Draws a bezier curve from the current drawing point to (x, y) using the control points (cp1x, cp1y) and (cp2x,\n\t * cp2y). For detailed information, read the\n\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-beziercurveto\">\n\t * whatwg spec</a>. A tiny API method \"bt\" also exists.\n\t * @method bezierCurveTo\n\t * @param {Number} cp1x\n\t * @param {Number} cp1y\n\t * @param {Number} cp2x\n\t * @param {Number} cp2y\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {\n\t\treturn this.append(new G.BezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y));\n\t};\n\n\t/**\n\t * Draws a rectangle at (x, y) with the specified width and height using the current fill and/or stroke.\n\t * For detailed information, read the\n\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-rect\">\n\t * whatwg spec</a>. A tiny API method \"r\" also exists.\n\t * @method rect\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w Width of the rectangle\n\t * @param {Number} h Height of the rectangle\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.rect = function(x, y, w, h) {\n\t\treturn this.append(new G.Rect(x, y, w, h));\n\t};\n\n\t/**\n\t * Closes the current path, effectively drawing a line from the current drawing point to the first drawing point specified\n\t * since the fill or stroke was last set. A tiny API method \"cp\" also exists.\n\t * @method closePath\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.closePath = function() {\n\t\treturn this._activeInstructions.length ? this.append(new G.ClosePath()) : this;\n\t};\n\n\n// public methods that roughly map to Flash graphics APIs:\n\t/**\n\t * Clears all drawing instructions, effectively resetting this Graphics instance. Any line and fill styles will need\n\t * to be redefined to draw shapes following a clear call. A tiny API method \"c\" also exists.\n\t * @method clear\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.clear = function() {\n\t\tthis._instructions.length = this._activeInstructions.length = this._commitIndex = 0;\n\t\tthis._strokeStyle = this._oldStrokeStyle = this._stroke = this._fill = this._strokeDash = this._oldStrokeDash = null;\n\t\tthis._dirty = this._strokeIgnoreScale = false;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Begins a fill with the specified color. This ends the current sub-path. A tiny API method \"f\" also exists.\n\t * @method beginFill\n\t * @param {String} color A CSS compatible color value (ex. \"red\", \"#FF0000\", or \"rgba(255,0,0,0.5)\"). Setting to\n\t * null will result in no fill.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginFill = function(color) {\n\t\treturn this._setFill(color ? new G.Fill(color) : null);\n\t};\n\n\t/**\n\t * Begins a linear gradient fill defined by the line (x0, y0) to (x1, y1). This ends the current sub-path. For\n\t * example, the following code defines a black to white vertical gradient ranging from 20px to 120px, and draws a\n\t * square to display it:\n\t *\n\t *      myGraphics.beginLinearGradientFill([\"#000\",\"#FFF\"], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);\n\t *\n\t * A tiny API method \"lf\" also exists.\n\t * @method beginLinearGradientFill\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define a gradient\n\t * drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw\n\t * the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginLinearGradientFill = function(colors, ratios, x0, y0, x1, y1) {\n\t\treturn this._setFill(new G.Fill().linearGradient(colors, ratios, x0, y0, x1, y1));\n\t};\n\n\t/**\n\t * Begins a radial gradient fill. This ends the current sub-path. For example, the following code defines a red to\n\t * blue radial gradient centered at (100, 100), with a radius of 50, and draws a circle to display it:\n\t *\n\t *      myGraphics.beginRadialGradientFill([\"#F00\",\"#00F\"], [0, 1], 100, 100, 0, 100, 100, 50).drawCircle(100, 100, 50);\n\t *\n\t * A tiny API method \"rf\" also exists.\n\t * @method beginRadialGradientFill\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} y0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} r0 Radius of the inner circle that defines the gradient.\n\t * @param {Number} x1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} y1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} r1 Radius of the outer circle that defines the gradient.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginRadialGradientFill = function(colors, ratios, x0, y0, r0, x1, y1, r1) {\n\t\treturn this._setFill(new G.Fill().radialGradient(colors, ratios, x0, y0, r0, x1, y1, r1));\n\t};\n\n\t/**\n\t * Begins a pattern fill using the specified image. This ends the current sub-path. A tiny API method \"bf\" also\n\t * exists.\n\t * @method beginBitmapFill\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use\n\t * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.\n\t * @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of \"repeat\",\n\t * \"repeat-x\", \"repeat-y\", or \"no-repeat\". Defaults to \"repeat\". Note that Firefox does not support \"repeat-x\" or\n\t * \"repeat-y\" (latest tests were in FF 20.0), and will default to \"repeat\".\n\t * @param {Matrix2D} matrix Optional. Specifies a transformation matrix for the bitmap fill. This transformation\n\t * will be applied relative to the parent transform.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginBitmapFill = function(image, repetition, matrix) {\n\t\treturn this._setFill(new G.Fill(null,matrix).bitmap(image, repetition));\n\t};\n\n\t/**\n\t * Ends the current sub-path, and begins a new one with no fill. Functionally identical to <code>beginFill(null)</code>.\n\t * A tiny API method \"ef\" also exists.\n\t * @method endFill\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.endFill = function() {\n\t\treturn this.beginFill();\n\t};\n\n\t/**\n\t * Sets the stroke style. Like all drawing methods, this can be chained, so you can define\n\t * the stroke style and color in a single line of code like so:\n\t *\n\t * \tmyGraphics.setStrokeStyle(8,\"round\").beginStroke(\"#F00\");\n\t *\n\t * A tiny API method \"ss\" also exists.\n\t * @method setStrokeStyle\n\t * @param {Number} thickness The width of the stroke.\n\t * @param {String | Number} [caps=0] Indicates the type of caps to use at the end of lines. One of butt,\n\t * round, or square. Defaults to \"butt\". Also accepts the values 0 (butt), 1 (round), and 2 (square) for use with\n\t * the tiny API.\n\t * @param {String | Number} [joints=0] Specifies the type of joints that should be used where two lines meet.\n\t * One of bevel, round, or miter. Defaults to \"miter\". Also accepts the values 0 (miter), 1 (round), and 2 (bevel)\n\t * for use with the tiny API.\n\t * @param {Number} [miterLimit=10] If joints is set to \"miter\", then you can specify a miter limit ratio which\n\t * controls at what point a mitered joint will be clipped.\n\t * @param {Boolean} [ignoreScale=false] If true, the stroke will be drawn at the specified thickness regardless\n\t * of active transformations.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.setStrokeStyle = function(thickness, caps, joints, miterLimit, ignoreScale) {\n\t\tthis._updateInstructions(true);\n\t\tthis._strokeStyle = this.command = new G.StrokeStyle(thickness, caps, joints, miterLimit, ignoreScale);\n\n\t\t// ignoreScale lives on Stroke, not StrokeStyle, so we do a little trickery:\n\t\tif (this._stroke) { this._stroke.ignoreScale = ignoreScale; }\n\t\tthis._strokeIgnoreScale = ignoreScale;\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Sets or clears the stroke dash pattern.\n\t *\n\t * \tmyGraphics.setStrokeDash([20, 10], 0);\n\t *\n\t * A tiny API method `sd` also exists.\n\t * @method setStrokeDash\n\t * @param {Array} [segments] An array specifying the dash pattern, alternating between line and gap.\n\t * For example, `[20,10]` would create a pattern of 20 pixel lines with 10 pixel gaps between them.\n\t * Passing null or an empty array will clear the existing stroke dash.\n\t * @param {Number} [offset=0] The offset of the dash pattern. For example, you could increment this value to create a \"marching ants\" effect.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.setStrokeDash = function(segments, offset) {\n\t\tthis._updateInstructions(true);\n\t\tthis._strokeDash = this.command = new G.StrokeDash(segments, offset);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Begins a stroke with the specified color. This ends the current sub-path. A tiny API method \"s\" also exists.\n\t * @method beginStroke\n\t * @param {String} color A CSS compatible color value (ex. \"#FF0000\", \"red\", or \"rgba(255,0,0,0.5)\"). Setting to\n\t * null will result in no stroke.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginStroke = function(color) {\n\t\treturn this._setStroke(color ? new G.Stroke(color) : null);\n\t};\n\n\t/**\n\t * Begins a linear gradient stroke defined by the line (x0, y0) to (x1, y1). This ends the current sub-path. For\n\t * example, the following code defines a black to white vertical gradient ranging from 20px to 120px, and draws a\n\t * square to display it:\n\t *\n\t *      myGraphics.setStrokeStyle(10).\n\t *          beginLinearGradientStroke([\"#000\",\"#FFF\"], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);\n\t *\n\t * A tiny API method \"ls\" also exists.\n\t * @method beginLinearGradientStroke\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginLinearGradientStroke = function(colors, ratios, x0, y0, x1, y1) {\n\t\treturn this._setStroke(new G.Stroke().linearGradient(colors, ratios, x0, y0, x1, y1));\n\t};\n\n\t/**\n\t * Begins a radial gradient stroke. This ends the current sub-path. For example, the following code defines a red to\n\t * blue radial gradient centered at (100, 100), with a radius of 50, and draws a rectangle to display it:\n\t *\n\t *      myGraphics.setStrokeStyle(10)\n\t *          .beginRadialGradientStroke([\"#F00\",\"#00F\"], [0, 1], 100, 100, 0, 100, 100, 50)\n\t *          .drawRect(50, 90, 150, 110);\n\t *\n\t * A tiny API method \"rs\" also exists.\n\t * @method beginRadialGradientStroke\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%, then draw the second color\n\t * to 100%.\n\t * @param {Number} x0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} y0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} r0 Radius of the inner circle that defines the gradient.\n\t * @param {Number} x1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} y1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} r1 Radius of the outer circle that defines the gradient.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginRadialGradientStroke = function(colors, ratios, x0, y0, r0, x1, y1, r1) {\n\t\treturn this._setStroke(new G.Stroke().radialGradient(colors, ratios, x0, y0, r0, x1, y1, r1));\n\t};\n\n\t/**\n\t * Begins a pattern fill using the specified image. This ends the current sub-path. Note that unlike bitmap fills,\n\t * strokes do not currently support a matrix parameter due to limitations in the canvas API. A tiny API method \"bs\"\n\t * also exists.\n\t * @method beginBitmapStroke\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use\n\t * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.\n\t * @param {String} [repetition=repeat] Optional. Indicates whether to repeat the image in the fill area. One of\n\t * \"repeat\", \"repeat-x\", \"repeat-y\", or \"no-repeat\". Defaults to \"repeat\".\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.beginBitmapStroke = function(image, repetition) {\n\t\t// NOTE: matrix is not supported for stroke because transforms on strokes also affect the drawn stroke width.\n\t\treturn this._setStroke(new G.Stroke().bitmap(image, repetition));\n\t};\n\n\t/**\n\t * Ends the current sub-path, and begins a new one with no stroke. Functionally identical to <code>beginStroke(null)</code>.\n\t * A tiny API method \"es\" also exists.\n\t * @method endStroke\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.endStroke = function() {\n\t\treturn this.beginStroke();\n\t};\n\n\t/**\n\t * Maps the familiar ActionScript <code>curveTo()</code> method to the functionally similar {{#crossLink \"Graphics/quadraticCurveTo\"}}{{/crossLink}}\n\t * method.\n\t * @method quadraticCurveTo\n\t * @param {Number} cpx\n\t * @param {Number} cpy\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.curveTo = p.quadraticCurveTo;\n\n\t/**\n\t *\n\t * Maps the familiar ActionScript <code>drawRect()</code> method to the functionally similar {{#crossLink \"Graphics/rect\"}}{{/crossLink}}\n\t * method.\n\t * @method drawRect\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w Width of the rectangle\n\t * @param {Number} h Height of the rectangle\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawRect = p.rect;\n\n\t/**\n\t * Draws a rounded rectangle with all corners with the specified radius.\n\t * @method drawRoundRect\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w\n\t * @param {Number} h\n\t * @param {Number} radius Corner radius.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawRoundRect = function(x, y, w, h, radius) {\n\t\treturn this.drawRoundRectComplex(x, y, w, h, radius, radius, radius, radius);\n\t};\n\n\t/**\n\t * Draws a rounded rectangle with different corner radii. Supports positive and negative corner radii. A tiny API\n\t * method \"rc\" also exists.\n\t * @method drawRoundRectComplex\n\t * @param {Number} x The horizontal coordinate to draw the round rect.\n\t * @param {Number} y The vertical coordinate to draw the round rect.\n\t * @param {Number} w The width of the round rect.\n\t * @param {Number} h The height of the round rect.\n\t * @param {Number} radiusTL Top left corner radius.\n\t * @param {Number} radiusTR Top right corner radius.\n\t * @param {Number} radiusBR Bottom right corner radius.\n\t * @param {Number} radiusBL Bottom left corner radius.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawRoundRectComplex = function(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {\n\t\treturn this.append(new G.RoundRect(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL));\n\t};\n\n\t/**\n\t * Draws a circle with the specified radius at (x, y).\n\t *\n\t *      var g = new createjs.Graphics();\n\t *\t    g.setStrokeStyle(1);\n\t *\t    g.beginStroke(createjs.Graphics.getRGB(0,0,0));\n\t *\t    g.beginFill(createjs.Graphics.getRGB(255,0,0));\n\t *\t    g.drawCircle(0,0,3);\n\t *\n\t *\t    var s = new createjs.Shape(g);\n\t *\t\ts.x = 100;\n\t *\t\ts.y = 100;\n\t *\n\t *\t    stage.addChild(s);\n\t *\t    stage.update();\n\t *\n\t * A tiny API method \"dc\" also exists.\n\t * @method drawCircle\n\t * @param {Number} x x coordinate center point of circle.\n\t * @param {Number} y y coordinate center point of circle.\n\t * @param {Number} radius Radius of circle.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawCircle = function(x, y, radius) {\n\t\treturn this.append(new G.Circle(x, y, radius));\n\t};\n\n\t/**\n\t * Draws an ellipse (oval) with a specified width (w) and height (h). Similar to {{#crossLink \"Graphics/drawCircle\"}}{{/crossLink}},\n\t * except the width and height can be different. A tiny API method \"de\" also exists.\n\t * @method drawEllipse\n\t * @param {Number} x The left coordinate point of the ellipse. Note that this is different from {{#crossLink \"Graphics/drawCircle\"}}{{/crossLink}}\n\t * which draws from center.\n\t * @param {Number} y The top coordinate point of the ellipse. Note that this is different from {{#crossLink \"Graphics/drawCircle\"}}{{/crossLink}}\n\t * which draws from the center.\n\t * @param {Number} w The height (horizontal diameter) of the ellipse. The horizontal radius will be half of this\n\t * number.\n\t * @param {Number} h The width (vertical diameter) of the ellipse. The vertical radius will be half of this number.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawEllipse = function(x, y, w, h) {\n\t\treturn this.append(new G.Ellipse(x, y, w, h));\n\t};\n\n\t/**\n\t * Draws a star if pointSize is greater than 0, or a regular polygon if pointSize is 0 with the specified number of\n\t * points. For example, the following code will draw a familiar 5 pointed star shape centered at 100, 100 and with a\n\t * radius of 50:\n\t *\n\t *      myGraphics.beginFill(\"#FF0\").drawPolyStar(100, 100, 50, 5, 0.6, -90);\n\t *      // Note: -90 makes the first point vertical\n\t *\n\t * A tiny API method \"dp\" also exists.\n\t *\n\t * @method drawPolyStar\n\t * @param {Number} x Position of the center of the shape.\n\t * @param {Number} y Position of the center of the shape.\n\t * @param {Number} radius The outer radius of the shape.\n\t * @param {Number} sides The number of points on the star or sides on the polygon.\n\t * @param {Number} pointSize The depth or \"pointy-ness\" of the star points. A pointSize of 0 will draw a regular\n\t * polygon (no points), a pointSize of 1 will draw nothing because the points are infinitely pointy.\n\t * @param {Number} angle The angle of the first point / corner. For example a value of 0 will draw the first point\n\t * directly to the right of the center.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.drawPolyStar = function(x, y, radius, sides, pointSize, angle) {\n\t\treturn this.append(new G.PolyStar(x, y, radius, sides, pointSize, angle));\n\t};\n\n\t// TODO: deprecated.\n\t/**\n\t * Removed in favour of using custom command objects with {{#crossLink \"Graphics/append\"}}{{/crossLink}}.\n\t * @method inject\n\t * @deprecated\n\t **/\n\n\t/**\n\t * Appends a graphics command object to the graphics queue. Command objects expose an \"exec\" method\n\t * that accepts two parameters: the Context2D to operate on, and an arbitrary data object passed into\n\t * {{#crossLink \"Graphics/draw\"}}{{/crossLink}}. The latter will usually be the Shape instance that called draw.\n\t *\n\t * This method is used internally by Graphics methods, such as drawCircle, but can also be used directly to insert\n\t * built-in or custom graphics commands. For example:\n\t *\n\t * \t\t// attach data to our shape, so we can access it during the draw:\n\t * \t\tmyShape.color = \"red\";\n\t *\n\t * \t\t// append a Circle command object:\n\t * \t\tmyShape.graphics.append(new createjs.Graphics.Circle(50, 50, 30));\n\t *\n\t * \t\t// append a custom command object with an exec method that sets the fill style\n\t * \t\t// based on the shape's data, and then fills the circle.\n\t * \t\tmyShape.graphics.append({exec:function(ctx, shape) {\n\t * \t\t\tctx.fillStyle = shape.color;\n\t * \t\t\tctx.fill();\n\t * \t\t}});\n\t *\n\t * @method append\n\t * @param {Object} command A graphics command object exposing an \"exec\" method.\n\t * @param {boolean} clean The clean param is primarily for internal use. A value of true indicates that a command does not generate a path that should be stroked or filled.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.append = function(command, clean) {\n\t\tthis._activeInstructions.push(command);\n\t\tthis.command = command;\n\t\tif (!clean) { this._dirty = true; }\n\t\treturn this;\n\t};\n\n\t/**\n\t * Decodes a compact encoded path string into a series of draw instructions.\n\t * This format is not intended to be human readable, and is meant for use by authoring tools.\n\t * The format uses a base64 character set, with each character representing 6 bits, to define a series of draw\n\t * commands.\n\t *\n\t * Each command is comprised of a single \"header\" character followed by a variable number of alternating x and y\n\t * position values. Reading the header bits from left to right (most to least significant): bits 1 to 3 specify the\n\t * type of operation (0-moveTo, 1-lineTo, 2-quadraticCurveTo, 3-bezierCurveTo, 4-closePath, 5-7 unused). Bit 4\n\t * indicates whether position values use 12 bits (2 characters) or 18 bits (3 characters), with a one indicating the\n\t * latter. Bits 5 and 6 are currently unused.\n\t *\n\t * Following the header is a series of 0 (closePath), 2 (moveTo, lineTo), 4 (quadraticCurveTo), or 6 (bezierCurveTo)\n\t * parameters. These parameters are alternating x/y positions represented by 2 or 3 characters (as indicated by the\n\t * 4th bit in the command char). These characters consist of a 1 bit sign (1 is negative, 0 is positive), followed\n\t * by an 11 (2 char) or 17 (3 char) bit integer value. All position values are in tenths of a pixel. Except in the\n\t * case of move operations which are absolute, this value is a delta from the previous x or y position (as\n\t * appropriate).\n\t *\n\t * For example, the string \"A3cAAMAu4AAA\" represents a line starting at -150,0 and ending at 150,0.\n\t * <br />A - bits 000000. First 3 bits (000) indicate a moveTo operation. 4th bit (0) indicates 2 chars per\n\t * parameter.\n\t * <br />n0 - 110111011100. Absolute x position of -150.0px. First bit indicates a negative value, remaining bits\n\t * indicate 1500 tenths of a pixel.\n\t * <br />AA - 000000000000. Absolute y position of 0.\n\t * <br />I - 001100. First 3 bits (001) indicate a lineTo operation. 4th bit (1) indicates 3 chars per parameter.\n\t * <br />Au4 - 000000101110111000. An x delta of 300.0px, which is added to the previous x value of -150.0px to\n\t * provide an absolute position of +150.0px.\n\t * <br />AAA - 000000000000000000. A y delta value of 0.\n\t *\n\t * A tiny API method \"p\" also exists.\n\t * @method decodePath\n\t * @param {String} str The path string to decode.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.decodePath = function(str) {\n\t\tvar instructions = [this.moveTo, this.lineTo, this.quadraticCurveTo, this.bezierCurveTo, this.closePath];\n\t\tvar paramCount = [2, 2, 4, 6, 0];\n\t\tvar i=0, l=str.length;\n\t\tvar params = [];\n\t\tvar x=0, y=0;\n\t\tvar base64 = Graphics.BASE_64;\n\n\t\twhile (i<l) {\n\t\t\tvar c = str.charAt(i);\n\t\t\tvar n = base64[c];\n\t\t\tvar fi = n>>3; // highest order bits 1-3 code for operation.\n\t\t\tvar f = instructions[fi];\n\t\t\t// check that we have a valid instruction & that the unused bits are empty:\n\t\t\tif (!f || (n&3)) { throw(\"bad path data (@\"+i+\"): \"+c); }\n\t\t\tvar pl = paramCount[fi];\n\t\t\tif (!fi) { x=y=0; } // move operations reset the position.\n\t\t\tparams.length = 0;\n\t\t\ti++;\n\t\t\tvar charCount = (n>>2&1)+2;  // 4th header bit indicates number size for this operation.\n\t\t\tfor (var p=0; p<pl; p++) {\n\t\t\t\tvar num = base64[str.charAt(i)];\n\t\t\t\tvar sign = (num>>5) ? -1 : 1;\n\t\t\t\tnum = ((num&31)<<6)|(base64[str.charAt(i+1)]);\n\t\t\t\tif (charCount == 3) { num = (num<<6)|(base64[str.charAt(i+2)]); }\n\t\t\t\tnum = sign*num/10;\n\t\t\t\tif (p%2) { x = (num += x); }\n\t\t\t\telse { y = (num += y); }\n\t\t\t\tparams[p] = num;\n\t\t\t\ti += charCount;\n\t\t\t}\n\t\t\tf.apply(this,params);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Stores all graphics commands so they won't be executed in future draws. Calling store() a second time adds to\n\t * the existing store. This also affects `drawAsPath()`.\n\t *\n\t * This is useful in cases where you are creating vector graphics in an iterative manner (ex. generative art), so\n\t * that only new graphics need to be drawn (which can provide huge performance benefits), but you wish to retain all\n\t * of the vector instructions for later use (ex. scaling, modifying, or exporting).\n\t *\n\t * Note that calling store() will force the active path (if any) to be ended in a manner similar to changing\n\t * the fill or stroke.\n\t *\n\t * For example, consider a application where the user draws lines with the mouse. As each line segment (or collection of\n\t * segments) are added to a Shape, it can be rasterized using {{#crossLink \"DisplayObject/updateCache\"}}{{/crossLink}},\n\t * and then stored, so that it can be redrawn at a different scale when the application is resized, or exported to SVG.\n\t *\n\t * \t// set up cache:\n\t * \tmyShape.cache(0,0,500,500,scale);\n\t *\n\t * \t// when the user drags, draw a new line:\n\t * \tmyShape.graphics.moveTo(oldX,oldY).lineTo(newX,newY);\n\t * \t// then draw it into the existing cache:\n\t * \tmyShape.updateCache(\"source-over\");\n\t * \t// store the new line, so it isn't redrawn next time:\n\t * \tmyShape.store();\n\t *\n\t * \t// then, when the window resizes, we can re-render at a different scale:\n\t * \t// first, unstore all our lines:\n\t * \tmyShape.unstore();\n\t * \t// then cache using the new scale:\n\t * \tmyShape.cache(0,0,500,500,newScale);\n\t * \t// finally, store the existing commands again:\n\t * \tmyShape.store();\n\t *\n\t * @method store\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.store = function() {\n\t\tthis._updateInstructions(true);\n\t\tthis._storeIndex = this._instructions.length;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Unstores any graphics commands that were previously stored using {{#crossLink \"Graphics/store\"}}{{/crossLink}}\n\t * so that they will be executed in subsequent draw calls.\n\t *\n\t * @method unstore\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.unstore = function() {\n\t\tthis._storeIndex = 0;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Returns a clone of this Graphics instance. Note that the individual command objects are not cloned.\n\t * @method clone\n\t * @return {Graphics} A clone of the current Graphics instance.\n\t **/\n\tp.clone = function() {\n\t\tvar o = new Graphics();\n\t\to.command = this.command;\n\t\to._stroke = this._stroke;\n\t\to._strokeStyle = this._strokeStyle;\n\t\to._strokeDash = this._strokeDash;\n\t\to._strokeIgnoreScale = this._strokeIgnoreScale;\n\t\to._fill = this._fill;\n\t\to._instructions = this._instructions.slice();\n\t\to._commitIndex = this._commitIndex;\n\t\to._activeInstructions = this._activeInstructions.slice();\n\t\to._dirty = this._dirty;\n\t\to._storeIndex = this._storeIndex;\n\t\treturn o;\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Graphics]\";\n\t};\n\n\n// tiny API:\n\t/**\n\t * Shortcut to moveTo.\n\t * @method mt\n\t * @param {Number} x The x coordinate the drawing point should move to.\n\t * @param {Number} y The y coordinate the drawing point should move to.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls).\n\t * @chainable\n\t * @protected\n\t **/\n\tp.mt = p.moveTo;\n\n\t/**\n\t * Shortcut to lineTo.\n\t * @method lt\n\t * @param {Number} x The x coordinate the drawing point should draw to.\n\t * @param {Number} y The y coordinate the drawing point should draw to.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.lt = p.lineTo;\n\n\t/**\n\t * Shortcut to arcTo.\n\t * @method at\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @param {Number} x2\n\t * @param {Number} y2\n\t * @param {Number} radius\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.at = p.arcTo;\n\n\t/**\n\t * Shortcut to bezierCurveTo.\n\t * @method bt\n\t * @param {Number} cp1x\n\t * @param {Number} cp1y\n\t * @param {Number} cp2x\n\t * @param {Number} cp2y\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.bt = p.bezierCurveTo;\n\n\t/**\n\t * Shortcut to quadraticCurveTo / curveTo.\n\t * @method qt\n\t * @param {Number} cpx\n\t * @param {Number} cpy\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @protected\n\t * @chainable\n\t **/\n\tp.qt = p.quadraticCurveTo;\n\n\t/**\n\t * Shortcut to arc.\n\t * @method a\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} radius\n\t * @param {Number} startAngle Measured in radians.\n\t * @param {Number} endAngle Measured in radians.\n\t * @param {Boolean} anticlockwise\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @protected\n\t * @chainable\n\t **/\n\tp.a = p.arc;\n\n\t/**\n\t * Shortcut to rect.\n\t * @method r\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w Width of the rectangle\n\t * @param {Number} h Height of the rectangle\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.r = p.rect;\n\n\t/**\n\t * Shortcut to closePath.\n\t * @method cp\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.cp = p.closePath;\n\n\t/**\n\t * Shortcut to clear.\n\t * @method c\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.c = p.clear;\n\n\t/**\n\t * Shortcut to beginFill.\n\t * @method f\n\t * @param {String} color A CSS compatible color value (ex. \"red\", \"#FF0000\", or \"rgba(255,0,0,0.5)\"). Setting to\n\t * null will result in no fill.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.f = p.beginFill;\n\n\t/**\n\t * Shortcut to beginLinearGradientFill.\n\t * @method lf\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define a gradient\n\t * drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw\n\t * the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.lf = p.beginLinearGradientFill;\n\n\t/**\n\t * Shortcut to beginRadialGradientFill.\n\t * @method rf\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} y0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} r0 Radius of the inner circle that defines the gradient.\n\t * @param {Number} x1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} y1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} r1 Radius of the outer circle that defines the gradient.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.rf = p.beginRadialGradientFill;\n\n\t/**\n\t * Shortcut to beginBitmapFill.\n\t * @method bf\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use\n\t * as the pattern.\n\t * @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of \"repeat\",\n\t * \"repeat-x\", \"repeat-y\", or \"no-repeat\". Defaults to \"repeat\". Note that Firefox does not support \"repeat-x\" or\n\t * \"repeat-y\" (latest tests were in FF 20.0), and will default to \"repeat\".\n\t * @param {Matrix2D} matrix Optional. Specifies a transformation matrix for the bitmap fill. This transformation\n\t * will be applied relative to the parent transform.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.bf = p.beginBitmapFill;\n\n\t/**\n\t * Shortcut to endFill.\n\t * @method ef\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.ef = p.endFill;\n\n\t/**\n\t * Shortcut to setStrokeStyle.\n\t * @method ss\n\t * @param {Number} thickness The width of the stroke.\n\t * @param {String | Number} [caps=0] Indicates the type of caps to use at the end of lines. One of butt,\n\t * round, or square. Defaults to \"butt\". Also accepts the values 0 (butt), 1 (round), and 2 (square) for use with\n\t * the tiny API.\n\t * @param {String | Number} [joints=0] Specifies the type of joints that should be used where two lines meet.\n\t * One of bevel, round, or miter. Defaults to \"miter\". Also accepts the values 0 (miter), 1 (round), and 2 (bevel)\n\t * for use with the tiny API.\n\t * @param {Number} [miterLimit=10] If joints is set to \"miter\", then you can specify a miter limit ratio which\n\t * controls at what point a mitered joint will be clipped.\n\t * @param {Boolean} [ignoreScale=false] If true, the stroke will be drawn at the specified thickness regardless\n\t * of active transformations.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.ss = p.setStrokeStyle;\n\t\n\t/**\n\t * Shortcut to setStrokeDash.\n\t * @method sd\n\t * @param {Array} [segments] An array specifying the dash pattern, alternating between line and gap.\n\t * For example, [20,10] would create a pattern of 20 pixel lines with 10 pixel gaps between them.\n\t * Passing null or an empty array will clear any existing dash.\n\t * @param {Number} [offset=0] The offset of the dash pattern. For example, you could increment this value to create a \"marching ants\" effect.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.sd = p.setStrokeDash;\n\n\t/**\n\t * Shortcut to beginStroke.\n\t * @method s\n\t * @param {String} color A CSS compatible color value (ex. \"#FF0000\", \"red\", or \"rgba(255,0,0,0.5)\"). Setting to\n\t * null will result in no stroke.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.s = p.beginStroke;\n\n\t/**\n\t * Shortcut to beginLinearGradientStroke.\n\t * @method ls\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.\n\t * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.\n\t * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.ls = p.beginLinearGradientStroke;\n\n\t/**\n\t * Shortcut to beginRadialGradientStroke.\n\t * @method rs\n\t * @param {Array} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define\n\t * a gradient drawing from red to blue.\n\t * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,\n\t * 0.9] would draw the first color to 10% then interpolating to the second color at 90%, then draw the second color\n\t * to 100%.\n\t * @param {Number} x0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} y0 Center position of the inner circle that defines the gradient.\n\t * @param {Number} r0 Radius of the inner circle that defines the gradient.\n\t * @param {Number} x1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} y1 Center position of the outer circle that defines the gradient.\n\t * @param {Number} r1 Radius of the outer circle that defines the gradient.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.rs = p.beginRadialGradientStroke;\n\n\t/**\n\t * Shortcut to beginBitmapStroke.\n\t * @method bs\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use\n\t * as the pattern.\n\t * @param {String} [repetition=repeat] Optional. Indicates whether to repeat the image in the fill area. One of\n\t * \"repeat\", \"repeat-x\", \"repeat-y\", or \"no-repeat\". Defaults to \"repeat\".\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.bs = p.beginBitmapStroke;\n\n\t/**\n\t * Shortcut to endStroke.\n\t * @method es\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.es = p.endStroke;\n\n\t/**\n\t * Shortcut to drawRect.\n\t * @method dr\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w Width of the rectangle\n\t * @param {Number} h Height of the rectangle\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.dr = p.drawRect;\n\n\t/**\n\t * Shortcut to drawRoundRect.\n\t * @method rr\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w\n\t * @param {Number} h\n\t * @param {Number} radius Corner radius.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.rr = p.drawRoundRect;\n\n\t/**\n\t * Shortcut to drawRoundRectComplex.\n\t * @method rc\n\t * @param {Number} x The horizontal coordinate to draw the round rect.\n\t * @param {Number} y The vertical coordinate to draw the round rect.\n\t * @param {Number} w The width of the round rect.\n\t * @param {Number} h The height of the round rect.\n\t * @param {Number} radiusTL Top left corner radius.\n\t * @param {Number} radiusTR Top right corner radius.\n\t * @param {Number} radiusBR Bottom right corner radius.\n\t * @param {Number} radiusBL Bottom left corner radius.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.rc = p.drawRoundRectComplex;\n\n\t/**\n\t * Shortcut to drawCircle.\n\t * @method dc\n\t * @param {Number} x x coordinate center point of circle.\n\t * @param {Number} y y coordinate center point of circle.\n\t * @param {Number} radius Radius of circle.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.dc = p.drawCircle;\n\n\t/**\n\t * Shortcut to drawEllipse.\n\t * @method de\n\t * @param {Number} x The left coordinate point of the ellipse. Note that this is different from {{#crossLink \"Graphics/drawCircle\"}}{{/crossLink}}\n\t * which draws from center.\n\t * @param {Number} y The top coordinate point of the ellipse. Note that this is different from {{#crossLink \"Graphics/drawCircle\"}}{{/crossLink}}\n\t * which draws from the center.\n\t * @param {Number} w The height (horizontal diameter) of the ellipse. The horizontal radius will be half of this\n\t * number.\n\t * @param {Number} h The width (vertical diameter) of the ellipse. The vertical radius will be half of this number.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.de = p.drawEllipse;\n\n\t/**\n\t * Shortcut to drawPolyStar.\n\t * @method dp\n\t * @param {Number} x Position of the center of the shape.\n\t * @param {Number} y Position of the center of the shape.\n\t * @param {Number} radius The outer radius of the shape.\n\t * @param {Number} sides The number of points on the star or sides on the polygon.\n\t * @param {Number} pointSize The depth or \"pointy-ness\" of the star points. A pointSize of 0 will draw a regular\n\t * polygon (no points), a pointSize of 1 will draw nothing because the points are infinitely pointy.\n\t * @param {Number} angle The angle of the first point / corner. For example a value of 0 will draw the first point\n\t * directly to the right of the center.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.dp = p.drawPolyStar;\n\n\t/**\n\t * Shortcut to decodePath.\n\t * @method p\n\t * @param {String} str The path string to decode.\n\t * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t * @protected\n\t **/\n\tp.p = p.decodePath;\n\n\n// private methods:\n\t/**\n\t * @method _updateInstructions\n\t * @param commit\n\t * @protected\n\t **/\n\tp._updateInstructions = function(commit) {\n\t\tvar instr = this._instructions, active = this._activeInstructions, commitIndex = this._commitIndex;\n\n\t\tif (this._dirty && active.length) {\n\t\t\tinstr.length = commitIndex; // remove old, uncommitted commands\n\t\t\tinstr.push(Graphics.beginCmd);\n\n\t\t\tvar l = active.length, ll = instr.length;\n\t\t\tinstr.length = ll+l;\n\t\t\tfor (var i=0; i<l; i++) { instr[i+ll] = active[i]; }\n\n\t\t\tif (this._fill) { instr.push(this._fill); }\n\t\t\tif (this._stroke) {\n\t\t\t\t// doesn't need to be re-applied if it hasn't changed.\n\t\t\t\tif (this._strokeDash !== this._oldStrokeDash) {\n\t\t\t\t\tthis._oldStrokeDash = this._strokeDash;\n\t\t\t\t\tinstr.push(this._strokeDash);\n\t\t\t\t}\n\t\t\t\tif (this._strokeStyle !== this._oldStrokeStyle) {\n\t\t\t\t\tthis._oldStrokeStyle = this._strokeStyle;\n\t\t\t\t\tinstr.push(this._strokeStyle);\n\t\t\t\t}\n\t\t\t\tinstr.push(this._stroke);\n\t\t\t}\n\n\t\t\tthis._dirty = false;\n\t\t}\n\n\t\tif (commit) {\n\t\t\tactive.length = 0;\n\t\t\tthis._commitIndex = instr.length;\n\t\t}\n\t};\n\n\t/**\n\t * @method _setFill\n\t * @param fill\n\t * @protected\n\t **/\n\tp._setFill = function(fill) {\n\t\tthis._updateInstructions(true);\n\t\tthis.command = this._fill = fill;\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method _setStroke\n\t * @param stroke\n\t * @protected\n\t **/\n\tp._setStroke = function(stroke) {\n\t\tthis._updateInstructions(true);\n\t\tif (this.command = this._stroke = stroke) {\n\t\t\tstroke.ignoreScale = this._strokeIgnoreScale;\n\t\t}\n\t\treturn this;\n\t};\n\n// Command Objects:\n\t/**\n\t * @namespace Graphics\n\t */\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/lineTo\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information. See {{#crossLink \"Graphics\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class LineTo\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.LineTo = function(x, y) {\n\t\tthis.x = x; this.y = y;\n\t}).prototype.exec = function(ctx) { ctx.lineTo(this.x,this.y); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/moveTo\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class MoveTo\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx\n\t */\n\t(G.MoveTo = function(x, y) {\n\t\tthis.x = x; this.y = y;\n\t}).prototype.exec = function(ctx) { ctx.moveTo(this.x, this.y); };\n\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/arcTo\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class ArcTo\n\t * @constructor\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @param {Number} x2\n\t * @param {Number} y2\n\t * @param {Number} radius\n\t **/\n\t/**\n\t * @property x1\n\t * @type Number\n\t */\n\t/**\n\t * @property y1\n\t * @type Number\n\t */\n\t/**\n\t * @property x2\n\t * @type Number\n\t */\n\t/**\n\t * @property y2\n\t * @type Number\n\t */\n\t/**\n\t * @property radius\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.ArcTo = function(x1, y1, x2, y2, radius) {\n\t\tthis.x1 = x1; this.y1 = y1;\n\t\tthis.x2 = x2; this.y2 = y2;\n\t\tthis.radius = radius;\n\t}).prototype.exec = function(ctx) { ctx.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/arc\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class Arc\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} radius\n\t * @param {Number} startAngle\n\t * @param {Number} endAngle\n\t * @param {Number} anticlockwise\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property radius\n\t * @type Number\n\t */\n\t/**\n\t * @property startAngle\n\t * @type Number\n\t */\n\t/**\n\t * @property endAngle\n\t * @type Number\n\t */\n\t/**\n\t * @property anticlockwise\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.Arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.radius = radius;\n\t\tthis.startAngle = startAngle; this.endAngle = endAngle;\n\t\tthis.anticlockwise = !!anticlockwise;\n\t}).prototype.exec = function(ctx) { ctx.arc(this.x, this.y, this.radius, this.startAngle, this.endAngle, this.anticlockwise); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/quadraticCurveTo\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class QuadraticCurveTo\n\t * @constructor\n\t * @param {Number} cpx\n\t * @param {Number} cpy\n\t * @param {Number} x\n\t * @param {Number} y\n\t **/\n\t/**\n\t * @property cpx\n\t * @type Number\n\t */\n\t/**\n\t * @property cpy\n\t * @type Number\n\t */\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.QuadraticCurveTo = function(cpx, cpy, x, y) {\n\t\tthis.cpx = cpx; this.cpy = cpy;\n\t\tthis.x = x; this.y = y;\n\t}).prototype.exec = function(ctx) { ctx.quadraticCurveTo(this.cpx, this.cpy, this.x, this.y); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/bezierCurveTo\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class BezierCurveTo\n\t * @constructor\n\t * @param {Number} cp1x\n\t * @param {Number} cp1y\n\t * @param {Number} cp2x\n\t * @param {Number} cp2y\n\t * @param {Number} x\n\t * @param {Number} y\n\t **/\n\t/**\n\t * @property cp1x\n\t * @type Number\n\t */\n\t/**\n\t * @property cp1y\n\t * @type Number\n\t */\n\t/**\n\t * @property cp2x\n\t * @type Number\n\t */\n\t/**\n\t * @property cp2y\n\t * @type Number\n\t */\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.BezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {\n\t\tthis.cp1x = cp1x; this.cp1y = cp1y;\n\t\tthis.cp2x = cp2x; this.cp2y = cp2y;\n\t\tthis.x = x; this.y = y;\n\t}).prototype.exec = function(ctx) { ctx.bezierCurveTo(this.cp1x, this.cp1y, this.cp2x, this.cp2y, this.x, this.y); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/rect\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class Rect\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w\n\t * @param {Number} h\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property w\n\t * @type Number\n\t */\n\t/**\n\t * @property h\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.Rect = function(x, y, w, h) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.w = w; this.h = h;\n\t}).prototype.exec = function(ctx) { ctx.rect(this.x, this.y, this.w, this.h); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/closePath\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class ClosePath\n\t * @constructor\n\t **/\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.ClosePath = function() {\n\t}).prototype.exec = function(ctx) { ctx.closePath(); };\n\n\t/**\n\t * Graphics command object to begin a new path. See {{#crossLink \"Graphics\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class BeginPath\n\t * @constructor\n\t **/\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.BeginPath = function() {\n\t}).prototype.exec = function(ctx) { ctx.beginPath(); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/beginFill\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class Fill\n\t * @constructor\n\t * @param {Object} style A valid Context2D fillStyle.\n\t * @param {Matrix2D} matrix\n\t **/\n\t/**\n\t * A valid Context2D fillStyle.\n\t * @property style\n\t * @type Object\n\t */\n\t/**\n\t * @property matrix\n\t * @type Matrix2D\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\tp = (G.Fill = function(style, matrix) {\n\t\tthis.style = style;\n\t\tthis.matrix = matrix;\n\t}).prototype;\n\tp.exec = function(ctx) {\n\t\tif (!this.style) { return; }\n\t\tctx.fillStyle = this.style;\n\t\tvar mtx = this.matrix;\n\t\tif (mtx) { ctx.save(); ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty); }\n\t\tctx.fill();\n\t\tif (mtx) { ctx.restore(); }\n\t};\n\t/**\n\t * Creates a linear gradient style and assigns it to {{#crossLink \"Fill/style:property\"}}{{/crossLink}}.\n\t * See {{#crossLink \"Graphics/beginLinearGradientFill\"}}{{/crossLink}} for more information.\n\t * @method linearGradient\n\t * @param {Array} colors\n\t *\n\t * @param {Array} ratios\n\t * @param {Number} x0\n\t * @param {Number} y0\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @return {Fill} Returns this Fill object for chaining or assignment.\n\t */\n\tp.linearGradient = function(colors, ratios, x0, y0, x1, y1) {\n\t\tvar o = this.style =  Graphics._ctx.createLinearGradient(x0, y0, x1, y1);\n\t\tfor (var i=0, l=colors.length; i<l; i++) { o.addColorStop(ratios[i], colors[i]); }\n\t\to.props = {colors:colors, ratios:ratios, x0:x0, y0:y0, x1:x1, y1:y1, type:\"linear\"};\n\t\treturn this;\n\t};\n\t/**\n\t * Creates a radial gradient style and assigns it to {{#crossLink \"Fill/style:property\"}}{{/crossLink}}.\n\t * See {{#crossLink \"Graphics/beginRadialGradientFill\"}}{{/crossLink}} for more information.\n\t * @method radialGradient\n\t * @param {Array} colors\n\t * @param {Array} ratios\n\t * @param {Number} x0\n\t * @param {Number} y0\n\t * @param {Number} r0\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @param {Number} r1\n\t * @return {Fill} Returns this Fill object for chaining or assignment.\n\t */\n\tp.radialGradient = function(colors, ratios, x0, y0, r0, x1, y1, r1) {\n\t\tvar o = this.style =  Graphics._ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);\n\t\tfor (var i=0, l=colors.length; i<l; i++) { o.addColorStop(ratios[i], colors[i]); }\n\t\to.props = {colors:colors, ratios:ratios, x0:x0, y0:y0, r0:r0, x1:x1, y1:y1, r1:r1, type:\"radial\"};\n\t\treturn this;\n\t};\n\t/**\n\t * Creates a bitmap fill style and assigns it to the {{#crossLink \"Fill/style:property\"}}{{/crossLink}}.\n\t * See {{#crossLink \"Graphics/beginBitmapFill\"}}{{/crossLink}} for more information.\n\t * @method bitmap\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image  Must be loaded prior to creating a bitmap fill, or the fill will be empty.\n\t * @param {String} [repetition] One of: repeat, repeat-x, repeat-y, or no-repeat.\n\t * @return {Fill} Returns this Fill object for chaining or assignment.\n\t */\n\tp.bitmap = function(image, repetition) {\n\t\tif (image.naturalWidth || image.getContext || image.readyState >= 2) {\n\t\t\tvar o = this.style = Graphics._ctx.createPattern(image, repetition || \"\");\n\t\t\to.props = {image: image, repetition: repetition, type: \"bitmap\"};\n\t\t}\n\t\treturn this;\n\t};\n\tp.path = false;\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/beginStroke\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class Stroke\n\t * @constructor\n\t * @param {Object} style A valid Context2D fillStyle.\n\t * @param {Boolean} ignoreScale\n\t **/\n\t/**\n\t * A valid Context2D strokeStyle.\n\t * @property style\n\t * @type Object\n\t */\n\t/**\n\t * @property ignoreScale\n\t * @type Boolean\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\tp = (G.Stroke = function(style, ignoreScale) {\n\t\tthis.style = style;\n\t\tthis.ignoreScale = ignoreScale;\n\t}).prototype;\n\tp.exec = function(ctx) {\n\t\tif (!this.style) { return; }\n\t\tctx.strokeStyle = this.style;\n\t\tif (this.ignoreScale) { ctx.save(); ctx.setTransform(1,0,0,1,0,0); }\n\t\tctx.stroke();\n\t\tif (this.ignoreScale) { ctx.restore(); }\n\t};\n\t/**\n\t * Creates a linear gradient style and assigns it to {{#crossLink \"Stroke/style:property\"}}{{/crossLink}}.\n\t * See {{#crossLink \"Graphics/beginLinearGradientStroke\"}}{{/crossLink}} for more information.\n\t * @method linearGradient\n\t * @param {Array} colors\n\t * @param {Array} ratios\n\t * @param {Number} x0\n\t * @param {Number} y0\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @return {Fill} Returns this Stroke object for chaining or assignment.\n\t */\n\tp.linearGradient = G.Fill.prototype.linearGradient;\n\t/**\n\t * Creates a radial gradient style and assigns it to {{#crossLink \"Stroke/style:property\"}}{{/crossLink}}.\n\t * See {{#crossLink \"Graphics/beginRadialGradientStroke\"}}{{/crossLink}} for more information.\n\t * @method radialGradient\n\t * @param {Array} colors\n\t * @param {Array} ratios\n\t * @param {Number} x0\n\t * @param {Number} y0\n\t * @param {Number} r0\n\t * @param {Number} x1\n\t * @param {Number} y1\n\t * @param {Number} r1\n\t * @return {Fill} Returns this Stroke object for chaining or assignment.\n\t */\n\tp.radialGradient = G.Fill.prototype.radialGradient;\n\t/**\n\t * Creates a bitmap fill style and assigns it to {{#crossLink \"Stroke/style:property\"}}{{/crossLink}}.\n\t * See {{#crossLink \"Graphics/beginBitmapStroke\"}}{{/crossLink}} for more information.\n\t * @method bitmap\n\t * @param {HTMLImageElement} image\n\t * @param {String} [repetition] One of: repeat, repeat-x, repeat-y, or no-repeat.\n\t * @return {Fill} Returns this Stroke object for chaining or assignment.\n\t */\n\tp.bitmap = G.Fill.prototype.bitmap;\n\tp.path = false;\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/setStrokeStyle\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class StrokeStyle\n\t * @constructor\n\t * @param {Number} width\n\t * @param {String} [caps=butt]\n\t * @param {String} [joints=miter]\n\t * @param {Number} [miterLimit=10]\n\t * @param {Boolean} [ignoreScale=false]\n\t **/\n\t/**\n\t * @property width\n\t * @type Number\n\t */\n\t/**\n\t * One of: butt, round, square\n\t * @property caps\n\t * @type String\n\t */\n\t/**\n\t * One of: round, bevel, miter\n\t * @property joints\n\t * @type String\n\t */\n\t/**\n\t * @property miterLimit\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\tp = (G.StrokeStyle = function(width, caps, joints, miterLimit, ignoreScale) {\n\t\tthis.width = width;\n\t\tthis.caps = caps;\n\t\tthis.joints = joints;\n\t\tthis.miterLimit = miterLimit;\n\t\tthis.ignoreScale = ignoreScale;\n\t}).prototype;\n\tp.exec = function(ctx) {\n\t\tctx.lineWidth = (this.width == null ? \"1\" : this.width);\n\t\tctx.lineCap = (this.caps == null ? \"butt\" : (isNaN(this.caps) ? this.caps : Graphics.STROKE_CAPS_MAP[this.caps]));\n\t\tctx.lineJoin = (this.joints == null ? \"miter\" : (isNaN(this.joints) ? this.joints : Graphics.STROKE_JOINTS_MAP[this.joints]));\n\t\tctx.miterLimit = (this.miterLimit == null ? \"10\" : this.miterLimit);\n\t\tctx.ignoreScale = (this.ignoreScale == null ? false : this.ignoreScale);\n\t};\n\tp.path = false;\n\t\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/setStrokeDash\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class StrokeDash\n\t * @constructor\n\t * @param {Array} [segments]\n\t * @param {Number} [offset=0]\n\t **/\n\t/**\n\t * @property segments\n\t * @type Array\n\t */\n\t/**\n\t * @property offset\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.StrokeDash = function(segments, offset) {\n\t\tthis.segments = segments;\n\t\tthis.offset = offset||0;\n\t}).prototype.exec = function(ctx) {\n\t\tif (ctx.setLineDash) { // feature detection.\n\t\t\tctx.setLineDash(this.segments|| G.StrokeDash.EMPTY_SEGMENTS); // instead of [] to reduce churn.\n\t\t\tctx.lineDashOffset = this.offset||0;\n\t\t}\n\t};\n\t/**\n\t * The default value for segments (ie. no dash).\n\t * @property EMPTY_SEGMENTS\n\t * @static\n\t * @final\n\t * @readonly\n\t * @protected\n\t * @type {Array}\n\t **/\n\tG.StrokeDash.EMPTY_SEGMENTS = [];\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/drawRoundRectComplex\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class RoundRect\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w\n\t * @param {Number} h\n\t * @param {Number} radiusTL\n\t * @param {Number} radiusTR\n\t * @param {Number} radiusBR\n\t * @param {Number} radiusBL\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property w\n\t * @type Number\n\t */\n\t/**\n\t * @property h\n\t * @type Number\n\t */\n\t/**\n\t * @property radiusTL\n\t * @type Number\n\t */\n\t/**\n\t * @property radiusTR\n\t * @type Number\n\t */\n\t/**\n\t * @property radiusBR\n\t * @type Number\n\t */\n\t/**\n\t * @property radiusBL\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.RoundRect = function(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.w = w; this.h = h;\n\t\tthis.radiusTL = radiusTL; this.radiusTR = radiusTR;\n\t\tthis.radiusBR = radiusBR; this.radiusBL = radiusBL;\n\t}).prototype.exec = function(ctx) {\n\t\tvar max = (w<h?w:h)/2;\n\t\tvar mTL=0, mTR=0, mBR=0, mBL=0;\n\t\tvar x = this.x, y = this.y, w = this.w, h = this.h;\n\t\tvar rTL = this.radiusTL, rTR = this.radiusTR, rBR = this.radiusBR, rBL = this.radiusBL;\n\n\t\tif (rTL < 0) { rTL *= (mTL=-1); }\n\t\tif (rTL > max) { rTL = max; }\n\t\tif (rTR < 0) { rTR *= (mTR=-1); }\n\t\tif (rTR > max) { rTR = max; }\n\t\tif (rBR < 0) { rBR *= (mBR=-1); }\n\t\tif (rBR > max) { rBR = max; }\n\t\tif (rBL < 0) { rBL *= (mBL=-1); }\n\t\tif (rBL > max) { rBL = max; }\n\n\t\tctx.moveTo(x+w-rTR, y);\n\t\tctx.arcTo(x+w+rTR*mTR, y-rTR*mTR, x+w, y+rTR, rTR);\n\t\tctx.lineTo(x+w, y+h-rBR);\n\t\tctx.arcTo(x+w+rBR*mBR, y+h+rBR*mBR, x+w-rBR, y+h, rBR);\n\t\tctx.lineTo(x+rBL, y+h);\n\t\tctx.arcTo(x-rBL*mBL, y+h+rBL*mBL, x, y+h-rBL, rBL);\n\t\tctx.lineTo(x, y+rTL);\n\t\tctx.arcTo(x-rTL*mTL, y-rTL*mTL, x+rTL, y, rTL);\n\t\tctx.closePath();\n\t};\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/drawCircle\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class Circle\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} radius\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property radius\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.Circle = function(x, y, radius) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.radius = radius;\n\t}).prototype.exec = function(ctx) { ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); };\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/drawEllipse\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class Ellipse\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} w\n\t * @param {Number} h\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property w\n\t * @type Number\n\t */\n\t/**\n\t * @property h\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.Ellipse = function(x, y, w, h) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.w = w; this.h = h;\n\t}).prototype.exec = function(ctx) {\n\t\tvar x = this.x, y = this.y;\n\t\tvar w = this.w, h = this.h;\n\n\t\tvar k = 0.5522848;\n\t\tvar ox = (w / 2) * k;\n\t\tvar oy = (h / 2) * k;\n\t\tvar xe = x + w;\n\t\tvar ye = y + h;\n\t\tvar xm = x + w / 2;\n\t\tvar ym = y + h / 2;\n\n\t\tctx.moveTo(x, ym);\n\t\tctx.bezierCurveTo(x, ym-oy, xm-ox, y, xm, y);\n\t\tctx.bezierCurveTo(xm+ox, y, xe, ym-oy, xe, ym);\n\t\tctx.bezierCurveTo(xe, ym+oy, xm+ox, ye, xm, ye);\n\t\tctx.bezierCurveTo(xm-ox, ye, x, ym+oy, x, ym);\n\t};\n\n\t/**\n\t * Graphics command object. See {{#crossLink \"Graphics/drawPolyStar\"}}{{/crossLink}} and {{#crossLink \"Graphics/append\"}}{{/crossLink}} for more information.\n\t * @class PolyStar\n\t * @constructor\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} radius\n\t * @param {Number} sides\n\t * @param {Number} pointSize\n\t * @param {Number} angle\n\t **/\n\t/**\n\t * @property x\n\t * @type Number\n\t */\n\t/**\n\t * @property y\n\t * @type Number\n\t */\n\t/**\n\t * @property radius\n\t * @type Number\n\t */\n\t/**\n\t * @property sides\n\t * @type Number\n\t */\n\t/**\n\t * @property pointSize\n\t * @type Number\n\t */\n\t/**\n\t * @property angle\n\t * @type Number\n\t */\n\t/**\n\t * Execute the Graphics command in the provided Canvas context.\n\t * @method exec\n\t * @param {CanvasRenderingContext2D} ctx The canvas rendering context\n\t */\n\t(G.PolyStar = function(x, y, radius, sides, pointSize, angle) {\n\t\tthis.x = x; this.y = y;\n\t\tthis.radius = radius;\n\t\tthis.sides = sides;\n\t\tthis.pointSize = pointSize;\n\t\tthis.angle = angle;\n\t}).prototype.exec = function(ctx) {\n\t\tvar x = this.x, y = this.y;\n\t\tvar radius = this.radius;\n\t\tvar angle = (this.angle||0)/180*Math.PI;\n\t\tvar sides = this.sides;\n\t\tvar ps = 1-(this.pointSize||0);\n\t\tvar a = Math.PI/sides;\n\n\t\tctx.moveTo(x+Math.cos(angle)*radius, y+Math.sin(angle)*radius);\n\t\tfor (var i=0; i<sides; i++) {\n\t\t\tangle += a;\n\t\t\tif (ps != 1) {\n\t\t\t\tctx.lineTo(x+Math.cos(angle)*radius*ps, y+Math.sin(angle)*radius*ps);\n\t\t\t}\n\t\t\tangle += a;\n\t\t\tctx.lineTo(x+Math.cos(angle)*radius, y+Math.sin(angle)*radius);\n\t\t}\n\t\tctx.closePath();\n\t};\n\n\t// docced above.\n\tGraphics.beginCmd = new G.BeginPath(); // so we don't have to instantiate multiple instances.\n\n\n\tcreatejs.Graphics = Graphics;\n}());\n\n//##############################################################################\n// DisplayObject.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * DisplayObject is an abstract class that should not be constructed directly. Instead construct subclasses such as\n\t * {{#crossLink \"Container\"}}{{/crossLink}}, {{#crossLink \"Bitmap\"}}{{/crossLink}}, and {{#crossLink \"Shape\"}}{{/crossLink}}.\n\t * DisplayObject is the base class for all display classes in the EaselJS library. It defines the core properties and\n\t * methods that are shared between all display objects, such as transformation properties (x, y, scaleX, scaleY, etc),\n\t * caching, and mouse handlers.\n\t * @class DisplayObject\n\t * @extends EventDispatcher\n\t * @constructor\n\t **/\n\tfunction DisplayObject() {\n\t\tthis.EventDispatcher_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The alpha (transparency) for this display object. 0 is fully transparent, 1 is fully opaque.\n\t\t * @property alpha\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t **/\n\t\tthis.alpha = 1;\n\t\n\t\t/**\n\t\t * If a cache is active, this returns the canvas that holds the cached version of this display object. See {{#crossLink \"cache\"}}{{/crossLink}}\n\t\t * for more information.\n\t\t * @property cacheCanvas\n\t\t * @type {HTMLCanvasElement | Object}\n\t\t * @default null\n\t\t * @readonly\n\t\t **/\n\t\tthis.cacheCanvas = null;\n\t\n\t\t/**\n\t\t * Returns an ID number that uniquely identifies the current cache for this display object. This can be used to\n\t\t * determine if the cache has changed since a previous check.\n\t\t * @property cacheID\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.cacheID = 0;\n\t\n\t\t/**\n\t\t * Unique ID for this display object. Makes display objects easier for some uses.\n\t\t * @property id\n\t\t * @type {Number}\n\t\t * @default -1\n\t\t **/\n\t\tthis.id = createjs.UID.get();\n\t\n\t\t/**\n\t\t * Indicates whether to include this object when running mouse interactions. Setting this to `false` for children\n\t\t * of a {{#crossLink \"Container\"}}{{/crossLink}} will cause events on the Container to not fire when that child is\n\t\t * clicked. Setting this property to `false` does not prevent the {{#crossLink \"Container/getObjectsUnderPoint\"}}{{/crossLink}}\n\t\t * method from returning the child.\n\t\t *\n\t\t * <strong>Note:</strong> In EaselJS 0.7.0, the mouseEnabled property will not work properly with nested Containers. Please\n\t\t * check out the latest NEXT version in <a href=\"https://github.com/CreateJS/EaselJS/tree/master/lib\">GitHub</a> for an updated version with this issue resolved. The fix will be\n\t\t * provided in the next release of EaselJS.\n\t\t * @property mouseEnabled\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t **/\n\t\tthis.mouseEnabled = true;\n\t\t\n\t\t/**\n\t\t * If false, the tick will not run on this display object (or its children). This can provide some performance benefits.\n\t\t * In addition to preventing the \"tick\" event from being dispatched, it will also prevent tick related updates\n\t\t * on some display objects (ex. Sprite & MovieClip frame advancing, DOMElement visibility handling).\n\t\t * @property tickEnabled\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.tickEnabled = true;\n\t\n\t\t/**\n\t\t * An optional name for this display object. Included in {{#crossLink \"DisplayObject/toString\"}}{{/crossLink}} . Useful for\n\t\t * debugging.\n\t\t * @property name\n\t\t * @type {String}\n\t\t * @default null\n\t\t **/\n\t\tthis.name = null;\n\t\n\t\t/**\n\t\t * A reference to the {{#crossLink \"Container\"}}{{/crossLink}} or {{#crossLink \"Stage\"}}{{/crossLink}} object that\n\t\t * contains this display object, or null if it has not been added\n\t\t * to one.\n\t\t * @property parent\n\t\t * @final\n\t\t * @type {Container}\n\t\t * @default null\n\t\t * @readonly\n\t\t **/\n\t\tthis.parent = null;\n\t\n\t\t/**\n\t\t * The left offset for this display object's registration point. For example, to make a 100x100px Bitmap rotate\n\t\t * around its center, you would set regX and {{#crossLink \"DisplayObject/regY:property\"}}{{/crossLink}} to 50.\n\t\t * @property regX\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.regX = 0;\n\t\n\t\t/**\n\t\t * The y offset for this display object's registration point. For example, to make a 100x100px Bitmap rotate around\n\t\t * its center, you would set {{#crossLink \"DisplayObject/regX:property\"}}{{/crossLink}} and regY to 50.\n\t\t * @property regY\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.regY = 0;\n\t\n\t\t/**\n\t\t * The rotation in degrees for this display object.\n\t\t * @property rotation\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.rotation = 0;\n\t\n\t\t/**\n\t\t * The factor to stretch this display object horizontally. For example, setting scaleX to 2 will stretch the display\n\t\t * object to twice its nominal width. To horizontally flip an object, set the scale to a negative number.\n\t\t * @property scaleX\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t **/\n\t\tthis.scaleX = 1;\n\t\n\t\t/**\n\t\t * The factor to stretch this display object vertically. For example, setting scaleY to 0.5 will stretch the display\n\t\t * object to half its nominal height. To vertically flip an object, set the scale to a negative number.\n\t\t * @property scaleY\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t **/\n\t\tthis.scaleY = 1;\n\t\n\t\t/**\n\t\t * The factor to skew this display object horizontally.\n\t\t * @property skewX\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.skewX = 0;\n\t\n\t\t/**\n\t\t * The factor to skew this display object vertically.\n\t\t * @property skewY\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.skewY = 0;\n\t\n\t\t/**\n\t\t * A shadow object that defines the shadow to render on this display object. Set to `null` to remove a shadow. If\n\t\t * null, this property is inherited from the parent container.\n\t\t * @property shadow\n\t\t * @type {Shadow}\n\t\t * @default null\n\t\t **/\n\t\tthis.shadow = null;\n\t\n\t\t/**\n\t\t * Indicates whether this display object should be rendered to the canvas and included when running the Stage\n\t\t * {{#crossLink \"Stage/getObjectsUnderPoint\"}}{{/crossLink}} method.\n\t\t * @property visible\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t **/\n\t\tthis.visible = true;\n\t\n\t\t/**\n\t\t * The x (horizontal) position of the display object, relative to its parent.\n\t\t * @property x\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.x = 0;\n\t\n\t\t/** The y (vertical) position of the display object, relative to its parent.\n\t\t * @property y\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.y = 0;\n\t\t\n\t\t/**\n\t\t * If set, defines the transformation for this display object, overriding all other transformation properties\n\t\t * (x, y, rotation, scale, skew).\n\t\t * @property transformMatrix\n\t\t * @type {Matrix2D}\n\t\t * @default null\n\t\t **/\n\t\tthis.transformMatrix = null;\n\t\t\n\t\t/**\n\t\t * The composite operation indicates how the pixels of this display object will be composited with the elements\n\t\t * behind it. If `null`, this property is inherited from the parent container. For more information, read the\n\t\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#compositing\">\n\t\t * whatwg spec on compositing</a>.\n\t\t * @property compositeOperation\n\t\t * @type {String}\n\t\t * @default null\n\t\t **/\n\t\tthis.compositeOperation = null;\n\t\n\t\t/**\n\t\t * Indicates whether the display object should be drawn to a whole pixel when\n\t\t * {{#crossLink \"Stage/snapToPixelEnabled\"}}{{/crossLink}} is true. To enable/disable snapping on whole\n\t\t * categories of display objects, set this value on the prototype (Ex. Text.prototype.snapToPixel = true).\n\t\t * @property snapToPixel\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t **/\n\t\tthis.snapToPixel = true;\n\t\n\t\t/**\n\t\t * An array of Filter objects to apply to this display object. Filters are only applied / updated when {{#crossLink \"cache\"}}{{/crossLink}}\n\t\t * or {{#crossLink \"updateCache\"}}{{/crossLink}} is called on the display object, and only apply to the area that is\n\t\t * cached.\n\t\t * @property filters\n\t\t * @type {Array}\n\t\t * @default null\n\t\t **/\n\t\tthis.filters = null;\n\t\t\n\t\t/**\n\t\t * A Shape instance that defines a vector mask (clipping path) for this display object.  The shape's transformation\n\t\t * will be applied relative to the display object's parent coordinates (as if it were a child of the parent).\n\t\t * @property mask\n\t\t * @type {Shape}\n\t\t * @default null\n\t\t */\n\t\tthis.mask = null;\n\t\t\n\t\t/**\n\t\t * A display object that will be tested when checking mouse interactions or testing {{#crossLink \"Container/getObjectsUnderPoint\"}}{{/crossLink}}.\n\t\t * The hit area will have its transformation applied relative to this display object's coordinate space (as though\n\t\t * the hit test object were a child of this display object and relative to its regX/Y). The hitArea will be tested\n\t\t * using only its own `alpha` value regardless of the alpha value on the target display object, or the target's\n\t\t * ancestors (parents).\n\t\t * \n\t\t * If set on a {{#crossLink \"Container\"}}{{/crossLink}}, children of the Container will not receive mouse events.\n\t\t * This is similar to setting {{#crossLink \"mouseChildren\"}}{{/crossLink}} to false.\n\t\t *\n\t\t * Note that hitArea is NOT currently used by the `hitTest()` method, nor is it supported for {{#crossLink \"Stage\"}}{{/crossLink}}.\n\t\t * @property hitArea\n\t\t * @type {DisplayObject}\n\t\t * @default null\n\t\t */\n\t\tthis.hitArea = null;\n\t\t\n\t\t/**\n\t\t * A CSS cursor (ex. \"pointer\", \"help\", \"text\", etc) that will be displayed when the user hovers over this display\n\t\t * object. You must enable mouseover events using the {{#crossLink \"Stage/enableMouseOver\"}}{{/crossLink}} method to\n\t\t * use this property. Setting a non-null cursor on a Container will override the cursor set on its descendants.\n\t\t * @property cursor\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.cursor = null;\n\t\n\t\n\t// private properties:\n\t\t/**\n\t\t * @property _cacheOffsetX\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis._cacheOffsetX = 0;\n\t\n\t\t/**\n\t\t * @property _cacheOffsetY\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis._cacheOffsetY = 0;\n\t\t\n\t\t/**\n\t\t * @property _filterOffsetX\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis._filterOffsetX = 0;\n\t\t\n\t\t/**\n\t\t * @property _filterOffsetY\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis._filterOffsetY = 0;\n\t\t\n\t\t/**\n\t\t * @property _cacheScale\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t **/\n\t\tthis._cacheScale = 1;\n\t\n\t\t/**\n\t\t* @property _cacheDataURLID\n\t\t* @protected\n\t\t* @type {Number}\n\t\t* @default 0\n\t\t*/\n\t\tthis._cacheDataURLID = 0;\n\t\t\n\t\t/**\n\t\t* @property _cacheDataURL\n\t\t* @protected\n\t\t* @type {String}\n\t\t* @default null\n\t\t*/\n\t\tthis._cacheDataURL = null;\n\t\n\t\t/**\n\t\t * @property _props\n\t\t * @protected\n\t\t * @type {DisplayObject}\n\t\t * @default null\n\t\t **/\n\t\tthis._props = new createjs.DisplayProps();\n\t\n\t\t/**\n\t\t * @property _rectangle\n\t\t * @protected\n\t\t * @type {Rectangle}\n\t\t * @default null\n\t\t **/\n\t\tthis._rectangle = new createjs.Rectangle();\n\t\n\t\t/**\n\t\t * @property _bounds\n\t\t * @protected\n\t\t * @type {Rectangle}\n\t\t * @default null\n\t\t **/\n\t\tthis._bounds = null;\n\t}\n\tvar p = createjs.extend(DisplayObject, createjs.EventDispatcher);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\t\n// static properties:\n\t/**\n\t * Listing of mouse event names. Used in _hasMouseEventListener.\n\t * @property _MOUSE_EVENTS\n\t * @protected\n\t * @static\n\t * @type {Array}\n\t **/\n\tDisplayObject._MOUSE_EVENTS = [\"click\",\"dblclick\",\"mousedown\",\"mouseout\",\"mouseover\",\"pressmove\",\"pressup\",\"rollout\",\"rollover\"];\n\n\t/**\n\t * Suppresses errors generated when using features like hitTest, mouse events, and {{#crossLink \"getObjectsUnderPoint\"}}{{/crossLink}}\n\t * with cross domain content.\n\t * @property suppressCrossDomainErrors\n\t * @static\n\t * @type {Boolean}\n\t * @default false\n\t **/\n\tDisplayObject.suppressCrossDomainErrors = false;\n\t\n\t/**\n\t * @property _snapToPixelEnabled\n\t * @protected\n\t * @static\n\t * @type {Boolean}\n\t * @default false\n\t **/\n\tDisplayObject._snapToPixelEnabled = false; // stage.snapToPixelEnabled is temporarily copied here during a draw to provide global access.\n\n\t/**\n\t * @property _hitTestCanvas\n\t * @type {HTMLCanvasElement | Object}\n\t * @static\n\t * @protected\n\t **/\n\t/**\n\t * @property _hitTestContext\n\t * @type {CanvasRenderingContext2D}\n\t * @static\n\t * @protected\n\t **/\n\tvar canvas = createjs.createCanvas?createjs.createCanvas():document.createElement(\"canvas\"); // prevent errors on load in browsers without canvas.\n\tif (canvas.getContext) {\n\t\tDisplayObject._hitTestCanvas = canvas;\n\t\tDisplayObject._hitTestContext = canvas.getContext(\"2d\");\n\t\tcanvas.width = canvas.height = 1;\n\t}\n\n\t/**\n\t * @property _nextCacheID\n\t * @type {Number}\n\t * @static\n\t * @protected\n\t **/\n\tDisplayObject._nextCacheID = 1;\n\n\n// events:\n\t/**\n\t * Dispatched when the user presses their left mouse button over the display object. See the \n\t * {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event mousedown\n\t * @since 0.6.0\n\t */\n\t \n\t/**\n\t * Dispatched when the user presses their left mouse button and then releases it while over the display object.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event click\n\t * @since 0.6.0\n\t */\n\t \n\t/**\n\t * Dispatched when the user double clicks their left mouse button over this display object.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event dblclick\n\t * @since 0.6.0\n\t */\n\t \n\t/**\n\t * Dispatched when the user's mouse enters this display object. This event must be enabled using \n\t * {{#crossLink \"Stage/enableMouseOver\"}}{{/crossLink}}. See also {{#crossLink \"DisplayObject/rollover:event\"}}{{/crossLink}}.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event mouseover\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when the user's mouse leaves this display object. This event must be enabled using \n\t * {{#crossLink \"Stage/enableMouseOver\"}}{{/crossLink}}. See also {{#crossLink \"DisplayObject/rollout:event\"}}{{/crossLink}}.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event mouseout\n\t * @since 0.6.0\n\t */\n\t \n\t/**\n\t * This event is similar to {{#crossLink \"DisplayObject/mouseover:event\"}}{{/crossLink}}, with the following\n\t * differences: it does not bubble, and it considers {{#crossLink \"Container\"}}{{/crossLink}} instances as an\n\t * aggregate of their content.\n\t * \n\t * For example, myContainer contains two overlapping children: shapeA and shapeB. The user moves their mouse over\n\t * shapeA and then directly on to shapeB. With a listener for {{#crossLink \"mouseover:event\"}}{{/crossLink}} on\n\t * myContainer, two events would be received, each targeting a child element:<OL>\n\t * <LI>when the mouse enters shapeA (target=shapeA)</LI>\n\t * <LI>when the mouse enters shapeB (target=shapeB)</LI>\n\t * </OL>\n\t * However, with a listener for \"rollover\" instead, only a single event is received when the mouse first enters\n\t * the aggregate myContainer content (target=myContainer).\n\t * \n\t * This event must be enabled using {{#crossLink \"Stage/enableMouseOver\"}}{{/crossLink}}.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event rollover\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * This event is similar to {{#crossLink \"DisplayObject/mouseout:event\"}}{{/crossLink}}, with the following\n\t * differences: it does not bubble, and it considers {{#crossLink \"Container\"}}{{/crossLink}} instances as an\n\t * aggregate of their content.\n\t * \n\t * For example, myContainer contains two overlapping children: shapeA and shapeB. The user moves their mouse over\n\t * shapeA, then directly on to shapeB, then off both. With a listener for {{#crossLink \"mouseout:event\"}}{{/crossLink}}\n\t * on myContainer, two events would be received, each targeting a child element:<OL>\n\t * <LI>when the mouse leaves shapeA (target=shapeA)</LI>\n\t * <LI>when the mouse leaves shapeB (target=shapeB)</LI>\n\t * </OL>\n\t * However, with a listener for \"rollout\" instead, only a single event is received when the mouse leaves\n\t * the aggregate myContainer content (target=myContainer).\n\t * \n\t * This event must be enabled using {{#crossLink \"Stage/enableMouseOver\"}}{{/crossLink}}.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event rollout\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * After a {{#crossLink \"DisplayObject/mousedown:event\"}}{{/crossLink}} occurs on a display object, a pressmove\n\t * event will be generated on that object whenever the mouse moves until the mouse press is released. This can be\n\t * useful for dragging and similar operations.\n\t * @event pressmove\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * After a {{#crossLink \"DisplayObject/mousedown:event\"}}{{/crossLink}} occurs on a display object, a pressup event\n\t * will be generated on that object when that mouse press is released. This can be useful for dragging and similar\n\t * operations.\n\t * @event pressup\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * Dispatched when the display object is added to a parent container.\n\t * @event added\n\t */\n\t \n\t/**\n\t * Dispatched when the display object is removed from its parent container.\n\t * @event removed\n\t */\n\t \n\t/**\n\t * Dispatched on each display object on a stage whenever the stage updates. This occurs immediately before the\n\t * rendering (draw) pass. When {{#crossLink \"Stage/update\"}}{{/crossLink}} is called, first all display objects on\n\t * the stage dispatch the tick event, then all of the display objects are drawn to stage. Children will have their\n\t * {{#crossLink \"tick:event\"}}{{/crossLink}} event dispatched in order of their depth prior to the event being\n\t * dispatched on their parent.\n\t * @event tick\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {Array} params An array containing any arguments that were passed to the Stage.update() method. For\n\t *      example if you called stage.update(\"hello\"), then the params would be [\"hello\"].\n\t * @since 0.6.0\n\t */\n\t\n\t\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink \"DisplayObject/stage:property\"}}{{/crossLink}} property instead.\n\t * @method getStage\n\t * @return {Stage}\n\t * @deprecated\n\t **/\n\tp.getStage = function() {\n\t\t// uses dynamic access to avoid circular dependencies;\n\t\tvar o = this, _Stage = createjs[\"Stage\"];\n\t\twhile (o.parent) { o = o.parent; }\n\t\tif (o instanceof _Stage) { return o; }\n\t\treturn null;\n\t};\n\n\t/**\n\t * Returns the Stage instance that this display object will be rendered on, or null if it has not been added to one.\n\t * @property stage\n\t * @type {Stage}\n\t * @readonly\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tstage: { get: p.getStage }\n\t\t});\n\t} catch (e) {}\n\n\n// public methods:\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns <code>true</code> if the draw was handled (useful for overriding functionality).\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,\n\t * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).\n\t * @return {Boolean}\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tvar cacheCanvas = this.cacheCanvas;\n\t\tif (ignoreCache || !cacheCanvas) { return false; }\n\t\tvar scale = this._cacheScale;\n\t\tctx.drawImage(cacheCanvas, this._cacheOffsetX+this._filterOffsetX, this._cacheOffsetY+this._filterOffsetY, cacheCanvas.width/scale, cacheCanvas.height/scale);\n\t\treturn true;\n\t};\n\t\n\t/**\n\t * Applies this display object's transformation, alpha, globalCompositeOperation, clipping path (mask), and shadow\n\t * to the specified context. This is typically called prior to {{#crossLink \"DisplayObject/draw\"}}{{/crossLink}}.\n\t * @method updateContext\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D to update.\n\t **/\n\tp.updateContext = function(ctx) {\n\t\tvar o=this, mask=o.mask, mtx= o._props.matrix;\n\t\t\n\t\tif (mask && mask.graphics && !mask.graphics.isEmpty()) {\n\t\t\tmask.getMatrix(mtx);\n\t\t\tctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\n\t\t\t\n\t\t\tmask.graphics.drawAsPath(ctx);\n\t\t\tctx.clip();\n\t\t\t\n\t\t\tmtx.invert();\n\t\t\tctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\n\t\t}\n\t\t\n\t\tthis.getMatrix(mtx);\n\t\tvar tx = mtx.tx, ty = mtx.ty;\n\t\tif (DisplayObject._snapToPixelEnabled && o.snapToPixel) {\n\t\t\ttx = tx + (tx < 0 ? -0.5 : 0.5) | 0;\n\t\t\tty = ty + (ty < 0 ? -0.5 : 0.5) | 0;\n\t\t}\n\t\tctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, tx, ty);\n\t\tctx.globalAlpha *= o.alpha;\n\t\tif (o.compositeOperation) { ctx.globalCompositeOperation = o.compositeOperation; }\n\t\tif (o.shadow) { this._applyShadow(ctx, o.shadow); }\n\t};\n\n\t/**\n\t * Draws the display object into a new canvas, which is then used for subsequent draws. For complex content\n\t * that does not change frequently (ex. a Container with many children that do not move, or a complex vector Shape),\n\t * this can provide for much faster rendering because the content does not need to be re-rendered each tick. The\n\t * cached display object can be moved, rotated, faded, etc freely, however if its content changes, you must\n\t * manually update the cache by calling <code>updateCache()</code> or <code>cache()</code> again. You must specify\n\t * the cache area via the x, y, w, and h parameters. This defines the rectangle that will be rendered and cached\n\t * using this display object's coordinates.\n\t *\n\t * <h4>Example</h4>\n\t * For example if you defined a Shape that drew a circle at 0, 0 with a radius of 25:\n\t *\n\t *      var shape = new createjs.Shape();\n\t *      shape.graphics.beginFill(\"#ff0000\").drawCircle(0, 0, 25);\n\t *      myShape.cache(-25, -25, 50, 50);\n\t *\n\t * Note that filters need to be defined <em>before</em> the cache is applied. Check out the {{#crossLink \"Filter\"}}{{/crossLink}}\n\t * class for more information. Some filters (ex. BlurFilter) will not work as expected in conjunction with the scale param.\n\t * \n\t * Usually, the resulting cacheCanvas will have the dimensions width*scale by height*scale, however some filters (ex. BlurFilter)\n\t * will add padding to the canvas dimensions.\n\t *\n\t * @method cache\n\t * @param {Number} x The x coordinate origin for the cache region.\n\t * @param {Number} y The y coordinate origin for the cache region.\n\t * @param {Number} width The width of the cache region.\n\t * @param {Number} height The height of the cache region.\n\t * @param {Number} [scale=1] The scale at which the cache will be created. For example, if you cache a vector shape using\n\t * \tmyShape.cache(0,0,100,100,2) then the resulting cacheCanvas will be 200x200 px. This lets you scale and rotate\n\t * \tcached elements with greater fidelity. Default is 1.\n\t **/\n\tp.cache = function(x, y, width, height, scale) {\n\t\t// draw to canvas.\n\t\tscale = scale||1;\n\t\tif (!this.cacheCanvas) { this.cacheCanvas = createjs.createCanvas?createjs.createCanvas():document.createElement(\"canvas\"); }\n\t\tthis._cacheWidth = width;\n\t\tthis._cacheHeight = height;\n\t\tthis._cacheOffsetX = x;\n\t\tthis._cacheOffsetY = y;\n\t\tthis._cacheScale = scale;\n\t\tthis.updateCache();\n\t};\n\n\t/**\n\t * Redraws the display object to its cache. Calling updateCache without an active cache will throw an error.\n\t * If compositeOperation is null the current cache will be cleared prior to drawing. Otherwise the display object\n\t * will be drawn over the existing cache using the specified compositeOperation.\n\t *\n\t * <h4>Example</h4>\n\t * Clear the current graphics of a cached shape, draw some new instructions, and then update the cache. The new line\n\t * will be drawn on top of the old one.\n\t *\n\t *      // Not shown: Creating the shape, and caching it.\n\t *      shapeInstance.clear();\n\t *      shapeInstance.setStrokeStyle(3).beginStroke(\"#ff0000\").moveTo(100, 100).lineTo(200,200);\n\t *      shapeInstance.updateCache();\n\t *\n\t * @method updateCache\n\t * @param {String} compositeOperation The compositeOperation to use, or null to clear the cache and redraw it.\n\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#compositing\">\n\t * whatwg spec on compositing</a>.\n\t **/\n\tp.updateCache = function(compositeOperation) {\n\t\tvar cacheCanvas = this.cacheCanvas;\n\t\tif (!cacheCanvas) { throw \"cache() must be called before updateCache()\"; }\n\t\tvar scale = this._cacheScale, offX = this._cacheOffsetX*scale, offY = this._cacheOffsetY*scale;\n\t\tvar w = this._cacheWidth, h = this._cacheHeight, ctx = cacheCanvas.getContext(\"2d\");\n\t\t\n\t\tvar fBounds = this._getFilterBounds();\n\t\toffX += (this._filterOffsetX = fBounds.x);\n\t\toffY += (this._filterOffsetY = fBounds.y);\n\t\t\n\t\tw = Math.ceil(w*scale) + fBounds.width;\n\t\th = Math.ceil(h*scale) + fBounds.height;\n\t\tif (w != cacheCanvas.width || h != cacheCanvas.height) {\n\t\t\t// TODO: it would be nice to preserve the content if there is a compositeOperation.\n\t\t\tcacheCanvas.width = w;\n\t\t\tcacheCanvas.height = h;\n\t\t} else if (!compositeOperation) {\n\t\t\tctx.clearRect(0, 0, w+1, h+1);\n\t\t}\n\t\t\n\t\tctx.save();\n\t\tctx.globalCompositeOperation = compositeOperation;\n\t\tctx.setTransform(scale, 0, 0, scale, -offX, -offY);\n\t\tthis.draw(ctx, true);\n\t\t// TODO: filters and cache scale don't play well together at present.\n\t\tthis._applyFilters();\n\t\tctx.restore();\n\t\tthis.cacheID = DisplayObject._nextCacheID++;\n\t};\n\n\t/**\n\t * Clears the current cache. See {{#crossLink \"DisplayObject/cache\"}}{{/crossLink}} for more information.\n\t * @method uncache\n\t **/\n\tp.uncache = function() {\n\t\tthis._cacheDataURL = this.cacheCanvas = null;\n\t\tthis.cacheID = this._cacheOffsetX = this._cacheOffsetY = this._filterOffsetX = this._filterOffsetY = 0;\n\t\tthis._cacheScale = 1;\n\t};\n\t\n\t/**\n\t * Returns a data URL for the cache, or null if this display object is not cached.\n\t * Uses cacheID to ensure a new data URL is not generated if the cache has not changed.\n\t * @method getCacheDataURL\n\t * @return {String} The image data url for the cache.\n\t **/\n\tp.getCacheDataURL = function() {\n\t\tif (!this.cacheCanvas) { return null; }\n\t\tif (this.cacheID != this._cacheDataURLID) { this._cacheDataURL = this.cacheCanvas.toDataURL(); }\n\t\treturn this._cacheDataURL;\n\t};\n\n\t/**\n\t * Transforms the specified x and y position from the coordinate space of the display object\n\t * to the global (stage) coordinate space. For example, this could be used to position an HTML label\n\t * over a specific point on a nested display object. Returns a Point instance with x and y properties\n\t * correlating to the transformed coordinates on the stage.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      displayObject.x = 300;\n\t *      displayObject.y = 200;\n\t *      stage.addChild(displayObject);\n\t *      var point = displayObject.localToGlobal(100, 100);\n\t *      // Results in x=400, y=300\n\t *\n\t * @method localToGlobal\n\t * @param {Number} x The x position in the source display object to transform.\n\t * @param {Number} y The y position in the source display object to transform.\n\t * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. \n\t * @return {Point} A Point instance with x and y properties correlating to the transformed coordinates\n\t * on the stage.\n\t **/\n\tp.localToGlobal = function(x, y, pt) {\n\t\treturn this.getConcatenatedMatrix(this._props.matrix).transformPoint(x,y, pt||new createjs.Point());\n\t};\n\n\t/**\n\t * Transforms the specified x and y position from the global (stage) coordinate space to the\n\t * coordinate space of the display object. For example, this could be used to determine\n\t * the current mouse position within the display object. Returns a Point instance with x and y properties\n\t * correlating to the transformed position in the display object's coordinate space.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      displayObject.x = 300;\n\t *      displayObject.y = 200;\n\t *      stage.addChild(displayObject);\n\t *      var point = displayObject.globalToLocal(100, 100);\n\t *      // Results in x=-200, y=-100\n\t *\n\t * @method globalToLocal\n\t * @param {Number} x The x position on the stage to transform.\n\t * @param {Number} y The y position on the stage to transform.\n\t * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. \n\t * @return {Point} A Point instance with x and y properties correlating to the transformed position in the\n\t * display object's coordinate space.\n\t **/\n\tp.globalToLocal = function(x, y, pt) {\n\t\treturn this.getConcatenatedMatrix(this._props.matrix).invert().transformPoint(x,y, pt||new createjs.Point());\n\t};\n\n\t/**\n\t * Transforms the specified x and y position from the coordinate space of this display object to the coordinate\n\t * space of the target display object. Returns a Point instance with x and y properties correlating to the\n\t * transformed position in the target's coordinate space. Effectively the same as using the following code with\n\t * {{#crossLink \"DisplayObject/localToGlobal\"}}{{/crossLink}} and {{#crossLink \"DisplayObject/globalToLocal\"}}{{/crossLink}}.\n\t *\n\t *      var pt = this.localToGlobal(x, y);\n\t *      pt = target.globalToLocal(pt.x, pt.y);\n\t *\n\t * @method localToLocal\n\t * @param {Number} x The x position in the source display object to transform.\n\t * @param {Number} y The y position on the source display object to transform.\n\t * @param {DisplayObject} target The target display object to which the coordinates will be transformed.\n\t * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. \n\t * @return {Point} Returns a Point instance with x and y properties correlating to the transformed position\n\t * in the target's coordinate space.\n\t **/\n\tp.localToLocal = function(x, y, target, pt) {\n\t\tpt = this.localToGlobal(x, y, pt);\n\t\treturn target.globalToLocal(pt.x, pt.y, pt);\n\t};\n\n\t/**\n\t * Shortcut method to quickly set the transform properties on the display object. All parameters are optional.\n\t * Omitted parameters will have the default value set.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      displayObject.setTransform(100, 100, 2, 2);\n\t *\n\t * @method setTransform\n\t * @param {Number} [x=0] The horizontal translation (x position) in pixels\n\t * @param {Number} [y=0] The vertical translation (y position) in pixels\n\t * @param {Number} [scaleX=1] The horizontal scale, as a percentage of 1\n\t * @param {Number} [scaleY=1] the vertical scale, as a percentage of 1\n\t * @param {Number} [rotation=0] The rotation, in degrees\n\t * @param {Number} [skewX=0] The horizontal skew factor\n\t * @param {Number} [skewY=0] The vertical skew factor\n\t * @param {Number} [regX=0] The horizontal registration point in pixels\n\t * @param {Number} [regY=0] The vertical registration point in pixels\n\t * @return {DisplayObject} Returns this instance. Useful for chaining commands.\n\t * @chainable\n\t*/\n\tp.setTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\tthis.scaleX = scaleX == null ? 1 : scaleX;\n\t\tthis.scaleY = scaleY == null ? 1 : scaleY;\n\t\tthis.rotation = rotation || 0;\n\t\tthis.skewX = skewX || 0;\n\t\tthis.skewY = skewY || 0;\n\t\tthis.regX = regX || 0;\n\t\tthis.regY = regY || 0;\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Returns a matrix based on this object's current transform.\n\t * @method getMatrix\n\t * @param {Matrix2D} matrix Optional. A Matrix2D object to populate with the calculated values. If null, a new\n\t * Matrix object is returned.\n\t * @return {Matrix2D} A matrix representing this display object's transform.\n\t **/\n\tp.getMatrix = function(matrix) {\n\t\tvar o = this, mtx = matrix&&matrix.identity() || new createjs.Matrix2D();\n\t\treturn o.transformMatrix ?  mtx.copy(o.transformMatrix) : mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);\n\t};\n\t\n\t/**\n\t * Generates a Matrix2D object representing the combined transform of the display object and all of its\n\t * parent Containers up to the highest level ancestor (usually the {{#crossLink \"Stage\"}}{{/crossLink}}). This can\n\t * be used to transform positions between coordinate spaces, such as with {{#crossLink \"DisplayObject/localToGlobal\"}}{{/crossLink}}\n\t * and {{#crossLink \"DisplayObject/globalToLocal\"}}{{/crossLink}}.\n\t * @method getConcatenatedMatrix\n\t * @param {Matrix2D} [matrix] A {{#crossLink \"Matrix2D\"}}{{/crossLink}} object to populate with the calculated values.\n\t * If null, a new Matrix2D object is returned.\n\t * @return {Matrix2D} The combined matrix.\n\t **/\n\tp.getConcatenatedMatrix = function(matrix) {\n\t\tvar o = this, mtx = this.getMatrix(matrix);\n\t\twhile (o = o.parent) {\n\t\t\tmtx.prependMatrix(o.getMatrix(o._props.matrix));\n\t\t}\n\t\treturn mtx;\n\t};\n\t\n\t/**\n\t * Generates a DisplayProps object representing the combined display properties of the  object and all of its\n\t * parent Containers up to the highest level ancestor (usually the {{#crossLink \"Stage\"}}{{/crossLink}}).\n\t * @method getConcatenatedDisplayProps\n\t * @param {DisplayProps} [props] A {{#crossLink \"DisplayProps\"}}{{/crossLink}} object to populate with the calculated values.\n\t * If null, a new DisplayProps object is returned.\n\t * @return {DisplayProps} The combined display properties.\n\t **/\n\tp.getConcatenatedDisplayProps = function(props) {\n\t\tprops = props ? props.identity() : new createjs.DisplayProps();\n\t\tvar o = this, mtx = o.getMatrix(props.matrix); \n\t\tdo {\n\t\t\tprops.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation);\n\t\t\t\n\t\t\t// we do this to avoid problems with the matrix being used for both operations when o._props.matrix is passed in as the props param.\n\t\t\t// this could be simplified (ie. just done as part of the prepend above) if we switched to using a pool.\n\t\t\tif (o != this) { mtx.prependMatrix(o.getMatrix(o._props.matrix)); }\n\t\t} while (o = o.parent);\n\t\treturn props;\n\t};\n\n\t/**\n\t * Tests whether the display object intersects the specified point in <em>local</em> coordinates (ie. draws a pixel\n\t * with alpha > 0 at the specified position). This ignores the alpha, shadow, hitArea, mask, and compositeOperation\n\t * of the display object.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \t\tvar myShape = new createjs.Shape();\n\t * \t\tmyShape.graphics.beginFill(\"red\").drawRect(100, 100, 20, 50);\n\t *\n\t * \t\tconsole.log(myShape.hitTest(10,10); // false\n\t * \t\tconsole.log(myShape.hitTest(110, 25); // true\n\t *\n\t * Note that to use Stage coordinates (such as {{#crossLink \"Stage/mouseX:property\"}}{{/crossLink}}), they must\n\t * first be converted to local coordinates:\n\t *\n\t *      stage.addEventListener(\"stagemousedown\", handleMouseDown);\n\t *      function handleMouseDown(event) {\n\t *      \tvar p = myShape.globalToLocal(stage.mouseX, stage.mouseY);\n\t *          var hit = myShape.hitTest(p.x, p.y);\n\t *      }\n\t *\n\t * Shape-to-shape collision is not currently supported by EaselJS.\n\t *\n\t * @method hitTest\n\t * @param {Number} x The x position to check in the display object's local coordinates.\n\t * @param {Number} y The y position to check in the display object's local coordinates.\n\t * @return {Boolean} A Boolean indicating whether a visible portion of the DisplayObject intersect the specified\n\t * local Point.\n\t*/\n\tp.hitTest = function(x, y) {\n\t\tvar ctx = DisplayObject._hitTestContext;\n\t\tctx.setTransform(1, 0, 0, 1, -x, -y);\n\t\tthis.draw(ctx);\n\n\t\tvar hit = this._testHit(ctx);\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\tctx.clearRect(0, 0, 2, 2);\n\t\treturn hit;\n\t};\n\t\n\t/**\n\t * Provides a chainable shortcut method for setting a number of properties on the instance.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var myGraphics = new createjs.Graphics().beginFill(\"#ff0000\").drawCircle(0, 0, 25);\n\t *      var shape = stage.addChild(new createjs.Shape()).set({graphics:myGraphics, x:100, y:100, alpha:0.5});\n\t *\n\t * @method set\n\t * @param {Object} props A generic object containing properties to copy to the DisplayObject instance.\n\t * @return {DisplayObject} Returns the instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t*/\n\tp.set = function(props) {\n\t\tfor (var n in props) { this[n] = props[n]; }\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Returns a rectangle representing this object's bounds in its local coordinate system (ie. with no transformation).\n\t * Objects that have been cached will return the bounds of the cache.\n\t * \n\t * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use \n\t * {{#crossLink \"DisplayObject/setBounds\"}}{{/crossLink}} so that they are included when calculating Container\n\t * bounds.\n\t * \n\t * <table>\n\t * \t<tr><td><b>All</b></td><td>\n\t * \t\tAll display objects support setting bounds manually using setBounds(). Likewise, display objects that\n\t * \t\thave been cached using cache() will return the bounds of their cache. Manual and cache bounds will override\n\t * \t\tthe automatic calculations listed below.\n\t * \t</td></tr>\n\t * \t<tr><td><b>Bitmap</b></td><td>\n\t * \t\tReturns the width and height of the sourceRect (if specified) or image, extending from (x=0,y=0).\n\t * \t</td></tr>\n\t * \t<tr><td><b>Sprite</b></td><td>\n\t * \t\tReturns the bounds of the current frame. May have non-zero x/y if a frame registration point was specified\n\t * \t\tin the spritesheet data. See also {{#crossLink \"SpriteSheet/getFrameBounds\"}}{{/crossLink}}\n\t * \t</td></tr>\n\t * \t<tr><td><b>Container</b></td><td>\n\t * \t\tReturns the aggregate (combined) bounds of all children that return a non-null value from getBounds().\n\t * \t</td></tr>\n\t * \t<tr><td><b>Shape</b></td><td>\n\t * \t\tDoes not currently support automatic bounds calculations. Use setBounds() to manually define bounds.\n\t * \t</td></tr>\n\t * \t<tr><td><b>Text</b></td><td>\n\t * \t\tReturns approximate bounds. Horizontal values (x/width) are quite accurate, but vertical values (y/height) are\n\t * \t\tnot, especially when using textBaseline values other than \"top\".\n\t * \t</td></tr>\n\t * \t<tr><td><b>BitmapText</b></td><td>\n\t * \t\tReturns approximate bounds. Values will be more accurate if spritesheet frame registration points are close\n\t * \t\tto (x=0,y=0).\n\t * \t</td></tr>\n\t* </table>\n\t * \n\t * Bounds can be expensive to calculate for some objects (ex. text, or containers with many children), and\n\t * are recalculated each time you call getBounds(). You can prevent recalculation on static objects by setting the\n\t * bounds explicitly:\n\t * \n\t * \tvar bounds = obj.getBounds();\n\t * \tobj.setBounds(bounds.x, bounds.y, bounds.width, bounds.height);\n\t * \t// getBounds will now use the set values, instead of recalculating\n\t * \n\t * To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its\n\t * values if you need to retain it.\n\t * \n\t * \tvar myBounds = obj.getBounds().clone();\n\t * \t// OR:\n\t * \tmyRect.copy(obj.getBounds());\n\t * \n\t * @method getBounds\n\t * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this\n\t * object.\n\t **/\n\tp.getBounds = function() {\n\t\tif (this._bounds) { return this._rectangle.copy(this._bounds); }\n\t\tvar cacheCanvas = this.cacheCanvas;\n\t\tif (cacheCanvas) {\n\t\t\tvar scale = this._cacheScale;\n\t\t\treturn this._rectangle.setValues(this._cacheOffsetX, this._cacheOffsetY, cacheCanvas.width/scale, cacheCanvas.height/scale);\n\t\t}\n\t\treturn null;\n\t};\n\t\n\t/**\n\t * Returns a rectangle representing this object's bounds in its parent's coordinate system (ie. with transformations applied).\n\t * Objects that have been cached will return the transformed bounds of the cache.\n\t * \n\t * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use \n\t * {{#crossLink \"DisplayObject/setBounds\"}}{{/crossLink}} so that they are included when calculating Container\n\t * bounds.\n\t * \n\t * To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its\n\t * values if you need to retain it.\n\t * \n\t * Container instances calculate aggregate bounds for all children that return bounds via getBounds.\n\t * @method getTransformedBounds\n\t * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this object.\n\t **/\n\tp.getTransformedBounds = function() {\n\t\treturn this._getBounds();\n\t};\n\t\n\t/**\n\t * Allows you to manually specify the bounds of an object that either cannot calculate their own bounds (ex. Shape &\n\t * Text) for future reference, or so the object can be included in Container bounds. Manually set bounds will always\n\t * override calculated bounds.\n\t * \n\t * The bounds should be specified in the object's local (untransformed) coordinates. For example, a Shape instance\n\t * with a 25px radius circle centered at 0,0 would have bounds of (-25, -25, 50, 50).\n\t * @method setBounds\n\t * @param {Number} x The x origin of the bounds. Pass null to remove the manual bounds.\n\t * @param {Number} y The y origin of the bounds.\n\t * @param {Number} width The width of the bounds.\n\t * @param {Number} height The height of the bounds.\n\t **/\n\tp.setBounds = function(x, y, width, height) {\n\t\tif (x == null) { this._bounds = x; }\n\t\tthis._bounds = (this._bounds || new createjs.Rectangle()).setValues(x, y, width, height);\n\t};\n\n\t/**\n\t * Returns a clone of this DisplayObject. Some properties that are specific to this instance's current context are\n\t * reverted to their defaults (for example .parent). Caches are not maintained across clones, and some elements\n\t * are copied by reference (masks, individual filter instances, hit area)\n\t * @method clone\n\t * @return {DisplayObject} A clone of the current DisplayObject instance.\n\t **/\n\tp.clone = function() {\n\t\treturn this._cloneProps(new DisplayObject());\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[DisplayObject (name=\"+  this.name +\")]\";\n\t};\n\n\n// private methods:\n\t// separated so it can be used more easily in subclasses:\n\t/**\n\t * @method _cloneProps\n\t * @param {DisplayObject} o The DisplayObject instance which will have properties from the current DisplayObject\n\t * instance copied into.\n\t * @return {DisplayObject} o\n\t * @protected\n\t **/\n\tp._cloneProps = function(o) {\n\t\to.alpha = this.alpha;\n\t\to.mouseEnabled = this.mouseEnabled;\n\t\to.tickEnabled = this.tickEnabled;\n\t\to.name = this.name;\n\t\to.regX = this.regX;\n\t\to.regY = this.regY;\n\t\to.rotation = this.rotation;\n\t\to.scaleX = this.scaleX;\n\t\to.scaleY = this.scaleY;\n\t\to.shadow = this.shadow;\n\t\to.skewX = this.skewX;\n\t\to.skewY = this.skewY;\n\t\to.visible = this.visible;\n\t\to.x  = this.x;\n\t\to.y = this.y;\n\t\to.compositeOperation = this.compositeOperation;\n\t\to.snapToPixel = this.snapToPixel;\n\t\to.filters = this.filters==null?null:this.filters.slice(0);\n\t\to.mask = this.mask;\n\t\to.hitArea = this.hitArea;\n\t\to.cursor = this.cursor;\n\t\to._bounds = this._bounds;\n\t\treturn o;\n\t};\n\n\t/**\n\t * @method _applyShadow\n\t * @protected\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {Shadow} shadow\n\t **/\n\tp._applyShadow = function(ctx, shadow) {\n\t\tshadow = shadow || Shadow.identity;\n\t\tctx.shadowColor = shadow.color;\n\t\tctx.shadowOffsetX = shadow.offsetX;\n\t\tctx.shadowOffsetY = shadow.offsetY;\n\t\tctx.shadowBlur = shadow.blur;\n\t};\n\t\n\t\n\t/**\n\t * @method _tick\n\t * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.\n\t * @protected\n\t **/\n\tp._tick = function(evtObj) {\n\t\t// because tick can be really performance sensitive, check for listeners before calling dispatchEvent.\n\t\tvar ls = this._listeners;\n\t\tif (ls && ls[\"tick\"]) {\n\t\t\t// reset & reuse the event object to avoid construction / GC costs:\n\t\t\tevtObj.target = null;\n\t\t\tevtObj.propagationStopped = evtObj.immediatePropagationStopped = false;\n\t\t\tthis.dispatchEvent(evtObj);\n\t\t}\n\t};\n\n\t/**\n\t * @method _testHit\n\t * @protected\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @return {Boolean}\n\t **/\n\tp._testHit = function(ctx) {\n\t\ttry {\n\t\t\tvar hit = ctx.getImageData(0, 0, 1, 1).data[3] > 1;\n\t\t} catch (e) {\n\t\t\tif (!DisplayObject.suppressCrossDomainErrors) {\n\t\t\t\tthrow \"An error has occurred. This is most likely due to security restrictions on reading canvas pixel data with local or cross-domain images.\";\n\t\t\t}\n\t\t}\n\t\treturn hit;\n\t};\n\n\t/**\n\t * @method _applyFilters\n\t * @protected\n\t **/\n\tp._applyFilters = function() {\n\t\tif (!this.filters || this.filters.length == 0 || !this.cacheCanvas) { return; }\n\t\tvar l = this.filters.length;\n\t\tvar ctx = this.cacheCanvas.getContext(\"2d\");\n\t\tvar w = this.cacheCanvas.width;\n\t\tvar h = this.cacheCanvas.height;\n\t\tfor (var i=0; i<l; i++) {\n\t\t\tthis.filters[i].applyFilter(ctx, 0, 0, w, h);\n\t\t}\n\t};\n\t\n\t/**\n\t * @method _getFilterBounds\n\t * @return {Rectangle}\n\t * @protected\n\t **/\n\tp._getFilterBounds = function(rect) {\n\t\tvar l, filters = this.filters, bounds = this._rectangle.setValues(0,0,0,0);\n\t\tif (!filters || !(l=filters.length)) { return bounds; }\n\t\t\n\t\tfor (var i=0; i<l; i++) {\n\t\t\tvar f = this.filters[i];\n\t\t\tf.getBounds&&f.getBounds(bounds);\n\t\t}\n\t\treturn bounds;\n\t};\n\t\n\t/**\n\t * @method _getBounds\n\t * @param {Matrix2D} matrix\n\t * @param {Boolean} ignoreTransform If true, does not apply this object's transform.\n\t * @return {Rectangle}\n\t * @protected\n\t **/\n\tp._getBounds = function(matrix, ignoreTransform){\n\t\treturn this._transformBounds(this.getBounds(), matrix, ignoreTransform);\n\t};\n\t\n\t/**\n\t * @method _transformBounds\n\t * @param {Rectangle} bounds\n\t * @param {Matrix2D} matrix\n\t * @param {Boolean} ignoreTransform\n\t * @return {Rectangle}\n\t * @protected\n\t **/\n\tp._transformBounds = function(bounds, matrix, ignoreTransform) {\n\t\tif (!bounds) { return bounds; }\n\t\tvar x = bounds.x, y = bounds.y, width = bounds.width, height = bounds.height, mtx = this._props.matrix;\n\t\tmtx = ignoreTransform ? mtx.identity() : this.getMatrix(mtx);\n\t\t\n\t\tif (x || y) { mtx.appendTransform(0,0,1,1,0,0,0,-x,-y); } // TODO: simplify this.\n\t\tif (matrix) { mtx.prependMatrix(matrix); }\n\t\t\n\t\tvar x_a = width*mtx.a, x_b = width*mtx.b;\n\t\tvar y_c = height*mtx.c, y_d = height*mtx.d;\n\t\tvar tx = mtx.tx, ty = mtx.ty;\n\t\t\n\t\tvar minX = tx, maxX = tx, minY = ty, maxY = ty;\n\n\t\tif ((x = x_a + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }\n\t\tif ((x = x_a + y_c + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }\n\t\tif ((x = y_c + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }\n\t\t\n\t\tif ((y = x_b + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }\n\t\tif ((y = x_b + y_d + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }\n\t\tif ((y = y_d + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }\n\t\t\n\t\treturn bounds.setValues(minX, minY, maxX-minX, maxY-minY);\n\t};\n\t\n\t/**\n\t * Indicates whether the display object has any mouse event listeners or a cursor.\n\t * @method _isMouseOpaque\n\t * @return {Boolean}\n\t * @protected\n\t **/\n\tp._hasMouseEventListener = function() {\n\t\tvar evts = DisplayObject._MOUSE_EVENTS;\n\t\tfor (var i= 0, l=evts.length; i<l; i++) {\n\t\t\tif (this.hasEventListener(evts[i])) { return true; }\n\t\t}\n\t\treturn !!this.cursor;\n\t};\n\n\tcreatejs.DisplayObject = createjs.promote(DisplayObject, \"EventDispatcher\");\n}());\n\n//##############################################################################\n// Container.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\t\n\n// constructor:\n/**\n * A Container is a nestable display list that allows you to work with compound display elements. For  example you could\n * group arm, leg, torso and head {{#crossLink \"Bitmap\"}}{{/crossLink}} instances together into a Person Container, and\n * transform them as a group, while still being able to move the individual parts relative to each other. Children of\n * containers have their <code>transform</code> and <code>alpha</code> properties concatenated with their parent\n * Container.\n *\n * For example, a {{#crossLink \"Shape\"}}{{/crossLink}} with x=100 and alpha=0.5, placed in a Container with <code>x=50</code>\n * and <code>alpha=0.7</code> will be rendered to the canvas at <code>x=150</code> and <code>alpha=0.35</code>.\n * Containers have some overhead, so you generally shouldn't create a Container to hold a single child.\n *\n * <h4>Example</h4>\n *\n *      var container = new createjs.Container();\n *      container.addChild(bitmapInstance, shapeInstance);\n *      container.x = 100;\n *\n * @class Container\n * @extends DisplayObject\n * @constructor\n **/\n\tfunction Container() {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The array of children in the display list. You should usually use the child management methods such as\n\t\t * {{#crossLink \"Container/addChild\"}}{{/crossLink}}, {{#crossLink \"Container/removeChild\"}}{{/crossLink}},\n\t\t * {{#crossLink \"Container/swapChildren\"}}{{/crossLink}}, etc, rather than accessing this directly, but it is\n\t\t * included for advanced uses.\n\t\t * @property children\n\t\t * @type Array\n\t\t * @default null\n\t\t **/\n\t\tthis.children = [];\n\t\t\n\t\t/**\n\t\t * Indicates whether the children of this container are independently enabled for mouse/pointer interaction.\n\t\t * If false, the children will be aggregated under the container - for example, a click on a child shape would\n\t\t * trigger a click event on the container.\n\t\t * @property mouseChildren\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.mouseChildren = true;\n\t\t\n\t\t/**\n\t\t * If false, the tick will not be propagated to children of this Container. This can provide some performance benefits.\n\t\t * In addition to preventing the \"tick\" event from being dispatched, it will also prevent tick related updates\n\t\t * on some display objects (ex. Sprite & MovieClip frame advancing, DOMElement visibility handling).\n\t\t * @property tickChildren\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.tickChildren = true;\n\t}\n\tvar p = createjs.extend(Container, createjs.DisplayObject);\n\t\n\t\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink \"Container/numChildren:property\"}}{{/crossLink}} property instead.\n\t * @method getNumChildren\n\t * @return {Number}\n\t * @deprecated\n\t **/\n\tp.getNumChildren = function() {\n\t\treturn this.children.length;\n\t};\n\n\t/**\n\t * Returns the number of children in the container.\n\t * @property numChildren\n\t * @type {Number}\n\t * @readonly\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tnumChildren: { get: p.getNumChildren }\n\t\t});\n\t} catch (e) {}\n\t\n\n// public methods:\n\t/**\n\t * Constructor alias for backwards compatibility. This method will be removed in future versions.\n\t * Subclasses should be updated to use {{#crossLink \"Utility Methods/extends\"}}{{/crossLink}}.\n\t * @method initialize\n\t * @deprecated in favour of `createjs.promote()`\n\t **/\n\tp.initialize = Container; // TODO: deprecated.\n\t\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar hasContent = this.cacheCanvas || this.children.length;\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\t\t\n\t\t// this ensures we don't have issues with display list changes that occur during a draw:\n\t\tvar list = this.children.slice();\n\t\tfor (var i=0,l=list.length; i<l; i++) {\n\t\t\tvar child = list[i];\n\t\t\tif (!child.isVisible()) { continue; }\n\t\t\t\n\t\t\t// draw the child:\n\t\t\tctx.save();\n\t\t\tchild.updateContext(ctx);\n\t\t\tchild.draw(ctx);\n\t\t\tctx.restore();\n\t\t}\n\t\treturn true;\n\t};\n\t\n\t/**\n\t * Adds a child to the top of the display list.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \t\tcontainer.addChild(bitmapInstance);\n\t *\n\t * You can also add multiple children at once:\n\t *\n\t * \t\tcontainer.addChild(bitmapInstance, shapeInstance, textInstance);\n\t *\n\t * @method addChild\n\t * @param {DisplayObject} child The display object to add.\n\t * @return {DisplayObject} The child that was added, or the last child if multiple children were added.\n\t **/\n\tp.addChild = function(child) {\n\t\tif (child == null) { return child; }\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tfor (var i=0; i<l; i++) { this.addChild(arguments[i]); }\n\t\t\treturn arguments[l-1];\n\t\t}\n\t\tif (child.parent) { child.parent.removeChild(child); }\n\t\tchild.parent = this;\n\t\tthis.children.push(child);\n\t\tchild.dispatchEvent(\"added\");\n\t\treturn child;\n\t};\n\n\t/**\n\t * Adds a child to the display list at the specified index, bumping children at equal or greater indexes up one, and\n\t * setting its parent to this Container.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      addChildAt(child1, index);\n\t *\n\t * You can also add multiple children, such as:\n\t *\n\t *      addChildAt(child1, child2, ..., index);\n\t *\n\t * The index must be between 0 and numChildren. For example, to add myShape under otherShape in the display list,\n\t * you could use:\n\t *\n\t *      container.addChildAt(myShape, container.getChildIndex(otherShape));\n\t *\n\t * This would also bump otherShape's index up by one. Fails silently if the index is out of range.\n\t *\n\t * @method addChildAt\n\t * @param {DisplayObject} child The display object to add.\n\t * @param {Number} index The index to add the child at.\n\t * @return {DisplayObject} Returns the last child that was added, or the last child if multiple children were added.\n\t **/\n\tp.addChildAt = function(child, index) {\n\t\tvar l = arguments.length;\n\t\tvar indx = arguments[l-1]; // can't use the same name as the index param or it replaces arguments[1]\n\t\tif (indx < 0 || indx > this.children.length) { return arguments[l-2]; }\n\t\tif (l > 2) {\n\t\t\tfor (var i=0; i<l-1; i++) { this.addChildAt(arguments[i], indx+i); }\n\t\t\treturn arguments[l-2];\n\t\t}\n\t\tif (child.parent) { child.parent.removeChild(child); }\n\t\tchild.parent = this;\n\t\tthis.children.splice(index, 0, child);\n\t\tchild.dispatchEvent(\"added\");\n\t\treturn child;\n\t};\n\n\t/**\n\t * Removes the specified child from the display list. Note that it is faster to use removeChildAt() if the index is\n\t * already known.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      container.removeChild(child);\n\t *\n\t * You can also remove multiple children:\n\t *\n\t *      removeChild(child1, child2, ...);\n\t *\n\t * Returns true if the child (or children) was removed, or false if it was not in the display list.\n\t * @method removeChild\n\t * @param {DisplayObject} child The child to remove.\n\t * @return {Boolean} true if the child (or children) was removed, or false if it was not in the display list.\n\t **/\n\tp.removeChild = function(child) {\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tvar good = true;\n\t\t\tfor (var i=0; i<l; i++) { good = good && this.removeChild(arguments[i]); }\n\t\t\treturn good;\n\t\t}\n\t\treturn this.removeChildAt(createjs.indexOf(this.children, child));\n\t};\n\n\t/**\n\t * Removes the child at the specified index from the display list, and sets its parent to null.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      container.removeChildAt(2);\n\t *\n\t * You can also remove multiple children:\n\t *\n\t *      container.removeChild(2, 7, ...)\n\t *\n\t * Returns true if the child (or children) was removed, or false if any index was out of range.\n\t * @method removeChildAt\n\t * @param {Number} index The index of the child to remove.\n\t * @return {Boolean} true if the child (or children) was removed, or false if any index was out of range.\n\t **/\n\tp.removeChildAt = function(index) {\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tvar a = [];\n\t\t\tfor (var i=0; i<l; i++) { a[i] = arguments[i]; }\n\t\t\ta.sort(function(a, b) { return b-a; });\n\t\t\tvar good = true;\n\t\t\tfor (var i=0; i<l; i++) { good = good && this.removeChildAt(a[i]); }\n\t\t\treturn good;\n\t\t}\n\t\tif (index < 0 || index > this.children.length-1) { return false; }\n\t\tvar child = this.children[index];\n\t\tif (child) { child.parent = null; }\n\t\tthis.children.splice(index, 1);\n\t\tchild.dispatchEvent(\"removed\");\n\t\treturn true;\n\t};\n\n\t/**\n\t * Removes all children from the display list.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \tcontainer.removeAllChildren();\n\t *\n\t * @method removeAllChildren\n\t **/\n\tp.removeAllChildren = function() {\n\t\tvar kids = this.children;\n\t\twhile (kids.length) { this.removeChildAt(0); }\n\t};\n\n\t/**\n\t * Returns the child at the specified index.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      container.getChildAt(2);\n\t *\n\t * @method getChildAt\n\t * @param {Number} index The index of the child to return.\n\t * @return {DisplayObject} The child at the specified index. Returns null if there is no child at the index.\n\t **/\n\tp.getChildAt = function(index) {\n\t\treturn this.children[index];\n\t};\n\t\n\t/**\n\t * Returns the child with the specified name.\n\t * @method getChildByName\n\t * @param {String} name The name of the child to return.\n\t * @return {DisplayObject} The child with the specified name.\n\t **/\n\tp.getChildByName = function(name) {\n\t\tvar kids = this.children;\n\t\tfor (var i=0,l=kids.length;i<l;i++) {\n\t\t\tif(kids[i].name == name) { return kids[i]; }\n\t\t}\n\t\treturn null;\n\t};\n\n\t/**\n\t * Performs an array sort operation on the child list.\n\t *\n\t * <h4>Example: Display children with a higher y in front.</h4>\n\t * \n\t *      var sortFunction = function(obj1, obj2, options) {\n\t *          if (obj1.y > obj2.y) { return 1; }\n\t *          if (obj1.y < obj2.y) { return -1; }\n\t *          return 0;\n\t *      }\n\t *      container.sortChildren(sortFunction);\n\t *\n\t * @method sortChildren\n\t * @param {Function} sortFunction the function to use to sort the child list. See JavaScript's <code>Array.sort</code>\n\t * documentation for details.\n\t **/\n\tp.sortChildren = function(sortFunction) {\n\t\tthis.children.sort(sortFunction);\n\t};\n\n\t/**\n\t * Returns the index of the specified child in the display list, or -1 if it is not in the display list.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var index = container.getChildIndex(child);\n\t *\n\t * @method getChildIndex\n\t * @param {DisplayObject} child The child to return the index of.\n\t * @return {Number} The index of the specified child. -1 if the child is not found.\n\t **/\n\tp.getChildIndex = function(child) {\n\t\treturn createjs.indexOf(this.children, child);\n\t};\n\t\n\t/**\n\t * Swaps the children at the specified indexes. Fails silently if either index is out of range.\n\t * @method swapChildrenAt\n\t * @param {Number} index1\n\t * @param {Number} index2\n\t **/\n\tp.swapChildrenAt = function(index1, index2) {\n\t\tvar kids = this.children;\n\t\tvar o1 = kids[index1];\n\t\tvar o2 = kids[index2];\n\t\tif (!o1 || !o2) { return; }\n\t\tkids[index1] = o2;\n\t\tkids[index2] = o1;\n\t};\n\t\n\t/**\n\t * Swaps the specified children's depth in the display list. Fails silently if either child is not a child of this\n\t * Container.\n\t * @method swapChildren\n\t * @param {DisplayObject} child1\n\t * @param {DisplayObject} child2\n\t **/\n\tp.swapChildren = function(child1, child2) {\n\t\tvar kids = this.children;\n\t\tvar index1,index2;\n\t\tfor (var i=0,l=kids.length;i<l;i++) {\n\t\t\tif (kids[i] == child1) { index1 = i; }\n\t\t\tif (kids[i] == child2) { index2 = i; }\n\t\t\tif (index1 != null && index2 != null) { break; }\n\t\t}\n\t\tif (i==l) { return; } // TODO: throw error?\n\t\tkids[index1] = child2;\n\t\tkids[index2] = child1;\n\t};\n\t\n\t/**\n\t * Changes the depth of the specified child. Fails silently if the child is not a child of this container, or the index is out of range.\n\t * @param {DisplayObject} child\n\t * @param {Number} index  \n\t * @method setChildIndex\n\t **/\n\tp.setChildIndex = function(child, index) {\n\t\tvar kids = this.children, l=kids.length;\n\t\tif (child.parent != this || index < 0 || index >= l) { return; }\n\t\tfor (var i=0;i<l;i++) {\n\t\t\tif (kids[i] == child) { break; }\n\t\t}\n\t\tif (i==l || i == index) { return; }\n\t\tkids.splice(i,1);\n\t\tkids.splice(index,0,child);\n\t};\n\n\t/**\n\t * Returns true if the specified display object either is this container or is a descendent (child, grandchild, etc)\n\t * of this container.\n\t * @method contains\n\t * @param {DisplayObject} child The DisplayObject to be checked.\n\t * @return {Boolean} true if the specified display object either is this container or is a descendent.\n\t **/\n\tp.contains = function(child) {\n\t\twhile (child) {\n\t\t\tif (child == this) { return true; }\n\t\t\tchild = child.parent;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Tests whether the display object intersects the specified local point (ie. draws a pixel with alpha > 0 at the\n\t * specified position). This ignores the alpha, shadow and compositeOperation of the display object, and all\n\t * transform properties including regX/Y.\n\t * @method hitTest\n\t * @param {Number} x The x position to check in the display object's local coordinates.\n\t * @param {Number} y The y position to check in the display object's local coordinates.\n\t * @return {Boolean} A Boolean indicating whether there is a visible section of a DisplayObject that overlaps the specified\n\t * coordinates.\n\t **/\n\tp.hitTest = function(x, y) {\n\t\t// TODO: optimize to use the fast cache check where possible.\n\t\treturn (this.getObjectUnderPoint(x, y) != null);\n\t};\n\n\t/**\n\t * Returns an array of all display objects under the specified coordinates that are in this container's display\n\t * list. This routine ignores any display objects with {{#crossLink \"DisplayObject/mouseEnabled:property\"}}{{/crossLink}}\n\t * set to `false`. The array will be sorted in order of visual depth, with the top-most display object at index 0.\n\t * This uses shape based hit detection, and can be an expensive operation to run, so it is best to use it carefully.\n\t * For example, if testing for objects under the mouse, test on tick (instead of on {{#crossLink \"DisplayObject/mousemove:event\"}}{{/crossLink}}),\n\t * and only if the mouse's position has changed.\n\t * \n\t * <ul>\n\t *     <li>By default (mode=0) this method evaluates all display objects.</li>\n\t *     <li>By setting the `mode` parameter to `1`, the {{#crossLink \"DisplayObject/mouseEnabled:property\"}}{{/crossLink}}\n\t * \t\tand {{#crossLink \"mouseChildren:property\"}}{{/crossLink}} properties will be respected.</li>\n\t * \t   <li>Setting the `mode` to `2` additionally excludes display objects that do not have active mouse event\n\t * \t   \tlisteners or a {{#crossLink \"DisplayObject:cursor:property\"}}{{/crossLink}} property. That is, only objects\n\t * \t   \tthat would normally intercept mouse interaction will be included. This can significantly improve performance\n\t * \t   \tin some cases by reducing the number of display objects that need to be tested.</li>\n\t * </li>\n\t * \n\t * This method accounts for both {{#crossLink \"DisplayObject/hitArea:property\"}}{{/crossLink}} and {{#crossLink \"DisplayObject/mask:property\"}}{{/crossLink}}.\n\t * @method getObjectsUnderPoint\n\t * @param {Number} x The x position in the container to test.\n\t * @param {Number} y The y position in the container to test.\n\t * @param {Number} [mode=0] The mode to use to determine which display objects to include. 0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.\n\t * @return {Array} An Array of DisplayObjects under the specified coordinates.\n\t **/\n\tp.getObjectsUnderPoint = function(x, y, mode) {\n\t\tvar arr = [];\n\t\tvar pt = this.localToGlobal(x, y);\n\t\tthis._getObjectsUnderPoint(pt.x, pt.y, arr, mode>0, mode==1);\n\t\treturn arr;\n\t};\n\n\t/**\n\t * Similar to {{#crossLink \"Container/getObjectsUnderPoint\"}}{{/crossLink}}, but returns only the top-most display\n\t * object. This runs significantly faster than <code>getObjectsUnderPoint()</code>, but is still potentially an expensive\n\t * operation. See {{#crossLink \"Container/getObjectsUnderPoint\"}}{{/crossLink}} for more information.\n\t * @method getObjectUnderPoint\n\t * @param {Number} x The x position in the container to test.\n\t * @param {Number} y The y position in the container to test.\n\t * @param {Number} mode The mode to use to determine which display objects to include.  0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.\n\t * @return {DisplayObject} The top-most display object under the specified coordinates.\n\t **/\n\tp.getObjectUnderPoint = function(x, y, mode) {\n\t\tvar pt = this.localToGlobal(x, y);\n\t\treturn this._getObjectsUnderPoint(pt.x, pt.y, null, mode>0, mode==1);\n\t};\n\t\n\t/**\n\t * Docced in superclass.\n\t */\n\tp.getBounds = function() {\n\t\treturn this._getBounds(null, true);\n\t};\n\t\n\t\n\t/**\n\t * Docced in superclass.\n\t */\n\tp.getTransformedBounds = function() {\n\t\treturn this._getBounds();\n\t};\n\n\t/**\n\t * Returns a clone of this Container. Some properties that are specific to this instance's current context are\n\t * reverted to their defaults (for example .parent).\n\t * @method clone\n\t * @param {Boolean} [recursive=false] If true, all of the descendants of this container will be cloned recursively. If false, the\n\t * properties of the container will be cloned, but the new instance will not have any children.\n\t * @return {Container} A clone of the current Container instance.\n\t **/\n\tp.clone = function(recursive) {\n\t\tvar o = this._cloneProps(new Container());\n\t\tif (recursive) { this._cloneChildren(o); }\n\t\treturn o;\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Container (name=\"+  this.name +\")]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _tick\n\t * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.\n\t * @protected\n\t **/\n\tp._tick = function(evtObj) {\n\t\tif (this.tickChildren) {\n\t\t\tfor (var i=this.children.length-1; i>=0; i--) {\n\t\t\t\tvar child = this.children[i];\n\t\t\t\tif (child.tickEnabled && child._tick) { child._tick(evtObj); }\n\t\t\t}\n\t\t}\n\t\tthis.DisplayObject__tick(evtObj);\n\t};\n\t\n\t/**\n\t * Recursively clones all children of this container, and adds them to the target container.\n\t * @method cloneChildren\n\t * @protected\n\t * @param {Container} o The target container.\n\t **/\n\tp._cloneChildren = function(o) {\n\t\tif (o.children.length) { o.removeAllChildren(); }\n\t\tvar arr = o.children;\n\t\tfor (var i=0, l=this.children.length; i<l; i++) {\n\t\t\tvar clone = this.children[i].clone(true);\n\t\t\tclone.parent = o;\n\t\t\tarr.push(clone);\n\t\t}\n\t};\n\n\t/**\n\t * @method _getObjectsUnderPoint\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Array} arr\n\t * @param {Boolean} mouse If true, it will respect mouse interaction properties like mouseEnabled, mouseChildren, and active listeners.\n\t * @param {Boolean} activeListener If true, there is an active mouse event listener on a parent object.\n\t * @param {Number} currentDepth Indicates the current depth of the search.\n\t * @return {DisplayObject}\n\t * @protected\n\t **/\n\tp._getObjectsUnderPoint = function(x, y, arr, mouse, activeListener, currentDepth) {\n\t\tcurrentDepth = currentDepth || 0;\n\t\tif (!currentDepth && !this._testMask(this, x, y)) { return null; }\n\t\tvar mtx, ctx = createjs.DisplayObject._hitTestContext;\n\t\tactiveListener = activeListener || (mouse&&this._hasMouseEventListener());\n\n\t\t// draw children one at a time, and check if we get a hit:\n\t\tvar children = this.children, l = children.length;\n\t\tfor (var i=l-1; i>=0; i--) {\n\t\t\tvar child = children[i];\n\t\t\tvar hitArea = child.hitArea;\n\t\t\tif (!child.visible || (!hitArea && !child.isVisible()) || (mouse && !child.mouseEnabled)) { continue; }\n\t\t\tif (!hitArea && !this._testMask(child, x, y)) { continue; }\n\t\t\t\n\t\t\t// if a child container has a hitArea then we only need to check its hitArea, so we can treat it as a normal DO:\n\t\t\tif (!hitArea && child instanceof Container) {\n\t\t\t\tvar result = child._getObjectsUnderPoint(x, y, arr, mouse, activeListener, currentDepth+1);\n\t\t\t\tif (!arr && result) { return (mouse && !this.mouseChildren) ? this : result; }\n\t\t\t} else {\n\t\t\t\tif (mouse && !activeListener && !child._hasMouseEventListener()) { continue; }\n\t\t\t\t\n\t\t\t\t// TODO: can we pass displayProps forward, to avoid having to calculate this backwards every time? It's kind of a mixed bag. When we're only hunting for DOs with event listeners, it may not make sense.\n\t\t\t\tvar props = child.getConcatenatedDisplayProps(child._props);\n\t\t\t\tmtx = props.matrix;\n\t\t\t\t\n\t\t\t\tif (hitArea) {\n\t\t\t\t\tmtx.appendMatrix(hitArea.getMatrix(hitArea._props.matrix));\n\t\t\t\t\tprops.alpha = hitArea.alpha;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tctx.globalAlpha = props.alpha;\n\t\t\t\tctx.setTransform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx-x, mtx.ty-y);\n\t\t\t\t(hitArea||child).draw(ctx);\n\t\t\t\tif (!this._testHit(ctx)) { continue; }\n\t\t\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\t\t\tctx.clearRect(0, 0, 2, 2);\n\t\t\t\tif (arr) { arr.push(child); }\n\t\t\t\telse { return (mouse && !this.mouseChildren) ? this : child; }\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\t\n\t/**\n\t * @method _testMask\n\t * @param {DisplayObject} target\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Boolean} Indicates whether the x/y is within the masked region.\n\t * @protected\n\t **/\n\tp._testMask = function(target, x, y) {\n\t\tvar mask = target.mask;\n\t\tif (!mask || !mask.graphics || mask.graphics.isEmpty()) { return true; }\n\t\t\n\t\tvar mtx = this._props.matrix, parent = target.parent;\n\t\tmtx = parent ? parent.getConcatenatedMatrix(mtx) : mtx.identity();\n\t\tmtx = mask.getMatrix(mask._props.matrix).prependMatrix(mtx);\n\t\t\n\t\tvar ctx = createjs.DisplayObject._hitTestContext;\n\t\tctx.setTransform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx-x, mtx.ty-y);\n\t\t\n\t\t// draw the mask as a solid fill:\n\t\tmask.graphics.drawAsPath(ctx);\n\t\tctx.fillStyle = \"#000\";\n\t\tctx.fill();\n\t\t\n\t\tif (!this._testHit(ctx)) { return false; }\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\tctx.clearRect(0, 0, 2, 2);\n\t\t\n\t\treturn true;\n\t};\n\t\n\t/**\n\t * @method _getBounds\n\t * @param {Matrix2D} matrix\n\t * @param {Boolean} ignoreTransform If true, does not apply this object's transform.\n\t * @return {Rectangle}\n\t * @protected\n\t **/\n\tp._getBounds = function(matrix, ignoreTransform) {\n\t\tvar bounds = this.DisplayObject_getBounds();\n\t\tif (bounds) { return this._transformBounds(bounds, matrix, ignoreTransform); }\n\t\t\n\t\tvar mtx = this._props.matrix;\n\t\tmtx = ignoreTransform ? mtx.identity() : this.getMatrix(mtx);\n\t\tif (matrix) { mtx.prependMatrix(matrix); }\n\t\t\n\t\tvar l = this.children.length, rect=null;\n\t\tfor (var i=0; i<l; i++) {\n\t\t\tvar child = this.children[i];\n\t\t\tif (!child.visible || !(bounds = child._getBounds(mtx))) { continue; }\n\t\t\tif (rect) { rect.extend(bounds.x, bounds.y, bounds.width, bounds.height); }\n\t\t\telse { rect = bounds.clone(); }\n\t\t}\n\t\treturn rect;\n\t};\n\n\n\tcreatejs.Container = createjs.promote(Container, \"DisplayObject\");\n}());\n\n//##############################################################################\n// Stage.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * A stage is the root level {{#crossLink \"Container\"}}{{/crossLink}} for a display list. Each time its {{#crossLink \"Stage/tick\"}}{{/crossLink}}\n\t * method is called, it will render its display list to its target canvas.\n\t *\n\t * <h4>Example</h4>\n\t * This example creates a stage, adds a child to it, then uses {{#crossLink \"Ticker\"}}{{/crossLink}} to update the child\n\t * and redraw the stage using {{#crossLink \"Stage/update\"}}{{/crossLink}}.\n\t *\n\t *      var stage = new createjs.Stage(\"canvasElementId\");\n\t *      var image = new createjs.Bitmap(\"imagePath.png\");\n\t *      stage.addChild(image);\n\t *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n\t *      function handleTick(event) {\n\t *          image.x += 10;\n\t *          stage.update();\n\t *      }\n\t *\n\t * @class Stage\n\t * @extends Container\n\t * @constructor\n\t * @param {HTMLCanvasElement | String | Object} canvas A canvas object that the Stage will render to, or the string id\n\t * of a canvas object in the current document.\n\t **/\n\tfunction Stage(canvas) {\n\t\tthis.Container_constructor();\n\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * Indicates whether the stage should automatically clear the canvas before each render. You can set this to <code>false</code>\n\t\t * to manually control clearing (for generative art, or when pointing multiple stages at the same canvas for\n\t\t * example).\n\t\t *\n\t\t * <h4>Example</h4>\n\t\t *\n\t\t *      var stage = new createjs.Stage(\"canvasId\");\n\t\t *      stage.autoClear = false;\n\t\t *\n\t\t * @property autoClear\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.autoClear = true;\n\t\n\t\t/**\n\t\t * The canvas the stage will render to. Multiple stages can share a single canvas, but you must disable autoClear for all but the\n\t\t * first stage that will be ticked (or they will clear each other's render).\n\t\t *\n\t\t * When changing the canvas property you must disable the events on the old canvas, and enable events on the\n\t\t * new canvas or mouse events will not work as expected. For example:\n\t\t *\n\t\t *      myStage.enableDOMEvents(false);\n\t\t *      myStage.canvas = anotherCanvas;\n\t\t *      myStage.enableDOMEvents(true);\n\t\t *\n\t\t * @property canvas\n\t\t * @type HTMLCanvasElement | Object\n\t\t **/\n\t\tthis.canvas = (typeof canvas == \"string\") ? document.getElementById(canvas) : canvas;\n\t\n\t\t/**\n\t\t * The current mouse X position on the canvas. If the mouse leaves the canvas, this will indicate the most recent\n\t\t * position over the canvas, and mouseInBounds will be set to false.\n\t\t * @property mouseX\n\t\t * @type Number\n\t\t * @readonly\n\t\t **/\n\t\tthis.mouseX = 0;\n\t\n\t\t/**\n\t\t * The current mouse Y position on the canvas. If the mouse leaves the canvas, this will indicate the most recent\n\t\t * position over the canvas, and mouseInBounds will be set to false.\n\t\t * @property mouseY\n\t\t * @type Number\n\t\t * @readonly\n\t\t **/\n\t\tthis.mouseY = 0;\n\t\n\t\t/**\n\t\t * Specifies the area of the stage to affect when calling update. This can be use to selectively\n\t\t * re-draw specific regions of the canvas. If null, the whole canvas area is drawn.\n\t\t * @property drawRect\n\t\t * @type {Rectangle}\n\t\t */\n\t\tthis.drawRect = null;\n\t\n\t\t/**\n\t\t * Indicates whether display objects should be rendered on whole pixels. You can set the\n\t\t * {{#crossLink \"DisplayObject/snapToPixel\"}}{{/crossLink}} property of\n\t\t * display objects to false to enable/disable this behaviour on a per instance basis.\n\t\t * @property snapToPixelEnabled\n\t\t * @type Boolean\n\t\t * @default false\n\t\t **/\n\t\tthis.snapToPixelEnabled = false;\n\t\n\t\t/**\n\t\t * Indicates whether the mouse is currently within the bounds of the canvas.\n\t\t * @property mouseInBounds\n\t\t * @type Boolean\n\t\t * @default false\n\t\t **/\n\t\tthis.mouseInBounds = false;\n\t\n\t\t/**\n\t\t * If true, tick callbacks will be called on all display objects on the stage prior to rendering to the canvas.\n\t\t * @property tickOnUpdate\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.tickOnUpdate = true;\n\t\n\t\t/**\n\t\t * If true, mouse move events will continue to be called when the mouse leaves the target canvas. See\n\t\t * {{#crossLink \"Stage/mouseInBounds:property\"}}{{/crossLink}}, and {{#crossLink \"MouseEvent\"}}{{/crossLink}}\n\t\t * x/y/rawX/rawY.\n\t\t * @property mouseMoveOutside\n\t\t * @type Boolean\n\t\t * @default false\n\t\t **/\n\t\tthis.mouseMoveOutside = false;\n\t\t\n\t\t\n\t\t/**\n\t\t * Prevents selection of other elements in the html page if the user clicks and drags, or double clicks on the canvas.\n\t\t * This works by calling `preventDefault()` on any mousedown events (or touch equivalent) originating on the canvas.\n\t\t * @property preventSelection\n\t\t * @type Boolean\n\t\t * @default true\n\t\t **/\n\t\tthis.preventSelection = true;\n\t\n\t\t/**\n\t\t * The hitArea property is not supported for Stage.\n\t\t * @property hitArea\n\t\t * @type {DisplayObject}\n\t\t * @default null\n\t\t */\n\t\t \n\t\t \n\t// private properties:\n\t\t/**\n\t\t * Holds objects with data for each active pointer id. Each object has the following properties:\n\t\t * x, y, event, target, overTarget, overX, overY, inBounds, posEvtObj (native event that last updated position)\n\t\t * @property _pointerData\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._pointerData = {};\n\t\n\t\t/**\n\t\t * Number of active pointers.\n\t\t * @property _pointerCount\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._pointerCount = 0;\n\t\n\t\t/**\n\t\t * The ID of the primary pointer.\n\t\t * @property _primaryPointerID\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._primaryPointerID = null;\n\t\n\t\t/**\n\t\t * @property _mouseOverIntervalID\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._mouseOverIntervalID = null;\n\t\t\n\t\t/**\n\t\t * @property _nextStage\n\t\t * @protected\n\t\t * @type Stage\n\t\t **/\n\t\tthis._nextStage = null;\n\t\t\n\t\t/**\n\t\t * @property _prevStage\n\t\t * @protected\n\t\t * @type Stage\n\t\t **/\n\t\tthis._prevStage = null;\n\t\t\n\t\t\n\t// initialize:\n\t\tthis.enableDOMEvents(true);\n\t}\n\tvar p = createjs.extend(Stage, createjs.Container);\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// events:\n\t/**\n\t * Dispatched when the user moves the mouse over the canvas.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event stagemousemove\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when the user presses their left mouse button on the canvas. See the {{#crossLink \"MouseEvent\"}}{{/crossLink}}\n\t * class for a listing of event properties.\n\t * @event stagemousedown\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when the user the user presses somewhere on the stage, then releases the mouse button anywhere that the page can detect it (this varies slightly between browsers).\n\t * You can use {{#crossLink \"Stage/mouseInBounds:property\"}}{{/crossLink}} to check whether the mouse is currently within the stage bounds.\n\t * See the {{#crossLink \"MouseEvent\"}}{{/crossLink}} class for a listing of event properties.\n\t * @event stagemouseup\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when the mouse moves from within the canvas area (mouseInBounds == true) to outside it (mouseInBounds == false).\n\t * This is currently only dispatched for mouse input (not touch). See the {{#crossLink \"MouseEvent\"}}{{/crossLink}}\n\t * class for a listing of event properties.\n\t * @event mouseleave\n\t * @since 0.7.0\n\t */\n\n\t/**\n\t * Dispatched when the mouse moves into the canvas area (mouseInBounds == false) from outside it (mouseInBounds == true).\n\t * This is currently only dispatched for mouse input (not touch). See the {{#crossLink \"MouseEvent\"}}{{/crossLink}}\n\t * class for a listing of event properties.\n\t * @event mouseenter\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * Dispatched each update immediately before the tick event is propagated through the display list.\n\t * You can call preventDefault on the event object to cancel propagating the tick event.\n\t * @event tickstart\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * Dispatched each update immediately after the tick event is propagated through the display list. Does not fire if\n\t * tickOnUpdate is false. Precedes the \"drawstart\" event.\n\t * @event tickend\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * Dispatched each update immediately before the canvas is cleared and the display list is drawn to it.\n\t * You can call preventDefault on the event object to cancel the draw.\n\t * @event drawstart\n\t * @since 0.7.0\n\t */\n\t \n\t/**\n\t * Dispatched each update immediately after the display list is drawn to the canvas and the canvas context is restored.\n\t * @event drawend\n\t * @since 0.7.0\n\t */\n\n\t \n// getter / setters:\n\t/**\n\t * Specifies a target stage that will have mouse / touch interactions relayed to it after this stage handles them.\n\t * This can be useful in cases where you have multiple layered canvases and want user interactions\n\t * events to pass through. For example, this would relay mouse events from topStage to bottomStage:\n\t *\n\t *      topStage.nextStage = bottomStage;\n\t *\n\t * To disable relaying, set nextStage to null.\n\t * \n\t * MouseOver, MouseOut, RollOver, and RollOut interactions are also passed through using the mouse over settings\n\t * of the top-most stage, but are only processed if the target stage has mouse over interactions enabled.\n\t * Considerations when using roll over in relay targets:<OL>\n\t * <LI> The top-most (first) stage must have mouse over interactions enabled (via enableMouseOver)</LI>\n\t * <LI> All stages that wish to participate in mouse over interaction must enable them via enableMouseOver</LI>\n\t * <LI> All relay targets will share the frequency value of the top-most stage</LI>\n\t * </OL>\n\t * To illustrate, in this example the targetStage would process mouse over interactions at 10hz (despite passing\n\t * 30 as it's desired frequency):\n\t * \ttopStage.nextStage = targetStage;\n\t * \ttopStage.enableMouseOver(10);\n\t * \ttargetStage.enableMouseOver(30);\n\t * \n\t * If the target stage's canvas is completely covered by this stage's canvas, you may also want to disable its\n\t * DOM events using:\n\t * \n\t *\ttargetStage.enableDOMEvents(false);\n\t * \n\t * @property nextStage\n\t * @type {Stage}\n\t **/\n\tp._get_nextStage = function() {\n\t\treturn this._nextStage;\n\t};\n\tp._set_nextStage = function(value) {\n\t\tif (this._nextStage) { this._nextStage._prevStage = null; }\n\t\tif (value) { value._prevStage = this; }\n\t\tthis._nextStage = value;\n\t};\n\t\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tnextStage: { get: p._get_nextStage, set: p._set_nextStage }\n\t\t});\n\t} catch (e) {} // TODO: use Log\n\n\n// public methods:\n\t/**\n\t * Each time the update method is called, the stage will call {{#crossLink \"Stage/tick\"}}{{/crossLink}}\n\t * unless {{#crossLink \"Stage/tickOnUpdate:property\"}}{{/crossLink}} is set to false,\n\t * and then render the display list to the canvas.\n\t *\n\t * @method update\n\t * @param {Object} [props] Props object to pass to `tick()`. Should usually be a {{#crossLink \"Ticker\"}}{{/crossLink}} event object, or similar object with a delta property.\n\t **/\n\tp.update = function(props) {\n\t\tif (!this.canvas) { return; }\n\t\tif (this.tickOnUpdate) { this.tick(props); }\n\t\tif (this.dispatchEvent(\"drawstart\", false, true) === false) { return; }\n\t\tcreatejs.DisplayObject._snapToPixelEnabled = this.snapToPixelEnabled;\n\t\tvar r = this.drawRect, ctx = this.canvas.getContext(\"2d\");\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\tif (this.autoClear) {\n\t\t\tif (r) { ctx.clearRect(r.x, r.y, r.width, r.height); }\n\t\t\telse { ctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1); }\n\t\t}\n\t\tctx.save();\n\t\tif (this.drawRect) {\n\t\t\tctx.beginPath();\n\t\t\tctx.rect(r.x, r.y, r.width, r.height);\n\t\t\tctx.clip();\n\t\t}\n\t\tthis.updateContext(ctx);\n\t\tthis.draw(ctx, false);\n\t\tctx.restore();\n\t\tthis.dispatchEvent(\"drawend\");\n\t};\n\t\n\t/**\n\t * Propagates a tick event through the display list. This is automatically called by {{#crossLink \"Stage/update\"}}{{/crossLink}}\n\t * unless {{#crossLink \"Stage/tickOnUpdate:property\"}}{{/crossLink}} is set to false.\n\t *\n\t * If a props object is passed to `tick()`, then all of its properties will be copied to the event object that is\n\t * propagated to listeners.\n\t *\n\t * Some time-based features in EaselJS (for example {{#crossLink \"Sprite/framerate\"}}{{/crossLink}} require that\n\t * a {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}} event object (or equivalent object with a delta property) be\n\t * passed as the `props` parameter to `tick()`. For example:\n\t *\n\t * \tTicker.on(\"tick\", handleTick);\n\t * \tfunction handleTick(evtObj) {\n\t * \t\t// clone the event object from Ticker, and add some custom data to it:\n\t * \t\tvar evt = evtObj.clone().set({greeting:\"hello\", name:\"world\"});\n\t * \t\t\n\t * \t\t// pass it to stage.update():\n\t * \t\tmyStage.update(evt); // subsequently calls tick() with the same param\n\t * \t}\n\t * \t\n\t * \t// ...\n\t * \tmyDisplayObject.on(\"tick\", handleDisplayObjectTick);\n\t * \tfunction handleDisplayObjectTick(evt) {\n\t * \t\tconsole.log(evt.delta); // the delta property from the Ticker tick event object\n\t * \t\tconsole.log(evt.greeting, evt.name); // custom data: \"hello world\"\n\t * \t}\n\t * \n\t * @method tick\n\t * @param {Object} [props] An object with properties that should be copied to the event object. Should usually be a Ticker event object, or similar object with a delta property.\n\t **/\n\tp.tick = function(props) {\n\t\tif (!this.tickEnabled || this.dispatchEvent(\"tickstart\", false, true) === false) { return; }\n\t\tvar evtObj = new createjs.Event(\"tick\");\n\t\tif (props) {\n\t\t\tfor (var n in props) {\n\t\t\t\tif (props.hasOwnProperty(n)) { evtObj[n] = props[n]; }\n\t\t\t}\n\t\t}\n\t\tthis._tick(evtObj);\n\t\tthis.dispatchEvent(\"tickend\");\n\t};\n\n\t/**\n\t * Default event handler that calls the Stage {{#crossLink \"Stage/update\"}}{{/crossLink}} method when a {{#crossLink \"DisplayObject/tick:event\"}}{{/crossLink}}\n\t * event is received. This allows you to register a Stage instance as a event listener on {{#crossLink \"Ticker\"}}{{/crossLink}}\n\t * directly, using:\n\t *\n\t *      Ticker.addEventListener(\"tick\", myStage\");\n\t *\n\t * Note that if you subscribe to ticks using this pattern, then the tick event object will be passed through to\n\t * display object tick handlers, instead of <code>delta</code> and <code>paused</code> parameters.\n\t * @property handleEvent\n\t * @type Function\n\t **/\n\tp.handleEvent = function(evt) {\n\t\tif (evt.type == \"tick\") { this.update(evt); }\n\t};\n\n\t/**\n\t * Clears the target canvas. Useful if {{#crossLink \"Stage/autoClear:property\"}}{{/crossLink}} is set to `false`.\n\t * @method clear\n\t **/\n\tp.clear = function() {\n\t\tif (!this.canvas) { return; }\n\t\tvar ctx = this.canvas.getContext(\"2d\");\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\tctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1);\n\t};\n\n\t/**\n\t * Returns a data url that contains a Base64-encoded image of the contents of the stage. The returned data url can\n\t * be specified as the src value of an image element.\n\t * @method toDataURL\n\t * @param {String} [backgroundColor] The background color to be used for the generated image. Any valid CSS color\n\t * value is allowed. The default value is a transparent background.\n\t * @param {String} [mimeType=\"image/png\"] The MIME type of the image format to be create. The default is \"image/png\". If an unknown MIME type\n\t * is passed in, or if the browser does not support the specified MIME type, the default value will be used.\n\t * @return {String} a Base64 encoded image.\n\t **/\n\tp.toDataURL = function(backgroundColor, mimeType) {\n\t\tvar data, ctx = this.canvas.getContext('2d'), w = this.canvas.width, h = this.canvas.height;\n\n\t\tif (backgroundColor) {\n\t\t\tdata = ctx.getImageData(0, 0, w, h);\n\t\t\tvar compositeOperation = ctx.globalCompositeOperation;\n\t\t\tctx.globalCompositeOperation = \"destination-over\";\n\t\t\t\n\t\t\tctx.fillStyle = backgroundColor;\n\t\t\tctx.fillRect(0, 0, w, h);\n\t\t}\n\n\t\tvar dataURL = this.canvas.toDataURL(mimeType||\"image/png\");\n\n\t\tif(backgroundColor) {\n\t\t\tctx.putImageData(data, 0, 0);\n\t\t\tctx.globalCompositeOperation = compositeOperation;\n\t\t}\n\n\t\treturn dataURL;\n\t};\n\n\t/**\n\t * Enables or disables (by passing a frequency of 0) mouse over ({{#crossLink \"DisplayObject/mouseover:event\"}}{{/crossLink}}\n\t * and {{#crossLink \"DisplayObject/mouseout:event\"}}{{/crossLink}}) and roll over events ({{#crossLink \"DisplayObject/rollover:event\"}}{{/crossLink}}\n\t * and {{#crossLink \"DisplayObject/rollout:event\"}}{{/crossLink}}) for this stage's display list. These events can\n\t * be expensive to generate, so they are disabled by default. The frequency of the events can be controlled\n\t * independently of mouse move events via the optional `frequency` parameter.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var stage = new createjs.Stage(\"canvasId\");\n\t *      stage.enableMouseOver(10); // 10 updates per second\n\t *\n\t * @method enableMouseOver\n\t * @param {Number} [frequency=20] Optional param specifying the maximum number of times per second to broadcast\n\t * mouse over/out events. Set to 0 to disable mouse over events completely. Maximum is 50. A lower frequency is less\n\t * responsive, but uses less CPU.\n\t **/\n\tp.enableMouseOver = function(frequency) {\n\t\tif (this._mouseOverIntervalID) {\n\t\t\tclearInterval(this._mouseOverIntervalID);\n\t\t\tthis._mouseOverIntervalID = null;\n\t\t\tif (frequency == 0) {\n\t\t\t\tthis._testMouseOver(true);\n\t\t\t}\n\t\t}\n\t\tif (frequency == null) { frequency = 20; }\n\t\telse if (frequency <= 0) { return; }\n\t\tvar o = this;\n\t\tthis._mouseOverIntervalID = setInterval(function(){ o._testMouseOver(); }, 1000/Math.min(50,frequency));\n\t};\n\n\t/**\n\t * Enables or disables the event listeners that stage adds to DOM elements (window, document and canvas). It is good\n\t * practice to disable events when disposing of a Stage instance, otherwise the stage will continue to receive\n\t * events from the page.\n\t *\n\t * When changing the canvas property you must disable the events on the old canvas, and enable events on the\n\t * new canvas or mouse events will not work as expected. For example:\n\t *\n\t *      myStage.enableDOMEvents(false);\n\t *      myStage.canvas = anotherCanvas;\n\t *      myStage.enableDOMEvents(true);\n\t *\n\t * @method enableDOMEvents\n\t * @param {Boolean} [enable=true] Indicates whether to enable or disable the events. Default is true.\n\t **/\n\tp.enableDOMEvents = function(enable) {\n\t\tif (enable == null) { enable = true; }\n\t\tvar n, o, ls = this._eventListeners;\n\t\tif (!enable && ls) {\n\t\t\tfor (n in ls) {\n\t\t\t\to = ls[n];\n\t\t\t\to.t.removeEventListener(n, o.f, false);\n\t\t\t}\n\t\t\tthis._eventListeners = null;\n\t\t} else if (enable && !ls && this.canvas) {\n\t\t\tvar t = window.addEventListener ? window : document;\n\t\t\tvar _this = this;\n\t\t\tls = this._eventListeners = {};\n\t\t\tls[\"mouseup\"] = {t:t, f:function(e) { _this._handleMouseUp(e)} };\n\t\t\tls[\"mousemove\"] = {t:t, f:function(e) { _this._handleMouseMove(e)} };\n\t\t\tls[\"dblclick\"] = {t:this.canvas, f:function(e) { _this._handleDoubleClick(e)} };\n\t\t\tls[\"mousedown\"] = {t:this.canvas, f:function(e) { _this._handleMouseDown(e)} };\n\n\t\t\tfor (n in ls) {\n\t\t\t\to = ls[n];\n\t\t\t\to.t.addEventListener(n, o.f, false);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Stage instances cannot be cloned.\n\t * @method clone\n\t **/\n\tp.clone = function() {\n\t\tthrow(\"Stage cannot be cloned.\");\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Stage (name=\"+  this.name +\")]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _getElementRect\n\t * @protected\n\t * @param {HTMLElement} e\n\t **/\n\tp._getElementRect = function(e) {\n\t\tvar bounds;\n\t\ttry { bounds = e.getBoundingClientRect(); } // this can fail on disconnected DOM elements in IE9\n\t\tcatch (err) { bounds = {top: e.offsetTop, left: e.offsetLeft, width:e.offsetWidth, height:e.offsetHeight}; }\n\n\t\tvar offX = (window.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || document.body.clientLeft || 0);\n\t\tvar offY = (window.pageYOffset || document.scrollTop || 0) - (document.clientTop  || document.body.clientTop  || 0);\n\n\t\tvar styles = window.getComputedStyle ? getComputedStyle(e,null) : e.currentStyle; // IE <9 compatibility.\n\t\tvar padL = parseInt(styles.paddingLeft)+parseInt(styles.borderLeftWidth);\n\t\tvar padT = parseInt(styles.paddingTop)+parseInt(styles.borderTopWidth);\n\t\tvar padR = parseInt(styles.paddingRight)+parseInt(styles.borderRightWidth);\n\t\tvar padB = parseInt(styles.paddingBottom)+parseInt(styles.borderBottomWidth);\n\n\t\t// note: in some browsers bounds properties are read only.\n\t\treturn {\n\t\t\tleft: bounds.left+offX+padL,\n\t\t\tright: bounds.right+offX-padR,\n\t\t\ttop: bounds.top+offY+padT,\n\t\t\tbottom: bounds.bottom+offY-padB\n\t\t}\n\t};\n\n\t/**\n\t * @method _getPointerData\n\t * @protected\n\t * @param {Number} id\n\t **/\n\tp._getPointerData = function(id) {\n\t\tvar data = this._pointerData[id];\n\t\tif (!data) { data = this._pointerData[id] = {x:0,y:0}; }\n\t\treturn data;\n\t};\n\n\t/**\n\t * @method _handleMouseMove\n\t * @protected\n\t * @param {MouseEvent} e\n\t **/\n\tp._handleMouseMove = function(e) {\n\t\tif(!e){ e = window.event; }\n\t\tthis._handlePointerMove(-1, e, e.pageX, e.pageY);\n\t};\n\n\t/**\n\t * @method _handlePointerMove\n\t * @protected\n\t * @param {Number} id\n\t * @param {Event} e\n\t * @param {Number} pageX\n\t * @param {Number} pageY\n\t * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t **/\n\tp._handlePointerMove = function(id, e, pageX, pageY, owner) {\n\t\tif (this._prevStage && owner === undefined) { return; } // redundant listener.\n\t\tif (!this.canvas) { return; }\n\t\tvar nextStage=this._nextStage, o=this._getPointerData(id);\n\n\t\tvar inBounds = o.inBounds;\n\t\tthis._updatePointerPosition(id, e, pageX, pageY);\n\t\tif (inBounds || o.inBounds || this.mouseMoveOutside) {\n\t\t\tif (id === -1 && o.inBounds == !inBounds) {\n\t\t\t\tthis._dispatchMouseEvent(this, (inBounds ? \"mouseleave\" : \"mouseenter\"), false, id, o, e);\n\t\t\t}\n\t\t\t\n\t\t\tthis._dispatchMouseEvent(this, \"stagemousemove\", false, id, o, e);\n\t\t\tthis._dispatchMouseEvent(o.target, \"pressmove\", true, id, o, e);\n\t\t}\n\t\t\n\t\tnextStage&&nextStage._handlePointerMove(id, e, pageX, pageY, null);\n\t};\n\n\t/**\n\t * @method _updatePointerPosition\n\t * @protected\n\t * @param {Number} id\n\t * @param {Event} e\n\t * @param {Number} pageX\n\t * @param {Number} pageY\n\t **/\n\tp._updatePointerPosition = function(id, e, pageX, pageY) {\n\t\tvar rect = this._getElementRect(this.canvas);\n\t\tpageX -= rect.left;\n\t\tpageY -= rect.top;\n\n\t\tvar w = this.canvas.width;\n\t\tvar h = this.canvas.height;\n\t\tpageX /= (rect.right-rect.left)/w;\n\t\tpageY /= (rect.bottom-rect.top)/h;\n\t\tvar o = this._getPointerData(id);\n\t\tif (o.inBounds = (pageX >= 0 && pageY >= 0 && pageX <= w-1 && pageY <= h-1)) {\n\t\t\to.x = pageX;\n\t\t\to.y = pageY;\n\t\t} else if (this.mouseMoveOutside) {\n\t\t\to.x = pageX < 0 ? 0 : (pageX > w-1 ? w-1 : pageX);\n\t\t\to.y = pageY < 0 ? 0 : (pageY > h-1 ? h-1 : pageY);\n\t\t}\n\n\t\to.posEvtObj = e;\n\t\to.rawX = pageX;\n\t\to.rawY = pageY;\n\n\t\tif (id === this._primaryPointerID || id === -1) {\n\t\t\tthis.mouseX = o.x;\n\t\t\tthis.mouseY = o.y;\n\t\t\tthis.mouseInBounds = o.inBounds;\n\t\t}\n\t};\n\n\t/**\n\t * @method _handleMouseUp\n\t * @protected\n\t * @param {MouseEvent} e\n\t **/\n\tp._handleMouseUp = function(e) {\n\t\tthis._handlePointerUp(-1, e, false);\n\t};\n\n\t/**\n\t * @method _handlePointerUp\n\t * @protected\n\t * @param {Number} id\n\t * @param {Event} e\n\t * @param {Boolean} clear\n\t * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t **/\n\tp._handlePointerUp = function(id, e, clear, owner) {\n\t\tvar nextStage = this._nextStage, o = this._getPointerData(id);\n\t\tif (this._prevStage && owner === undefined) { return; } // redundant listener.\n\t\t\n\t\tvar target=null, oTarget = o.target;\n\t\tif (!owner && (oTarget || nextStage)) { target = this._getObjectsUnderPoint(o.x, o.y, null, true); }\n\t\t\n\t\tif (o.down) { this._dispatchMouseEvent(this, \"stagemouseup\", false, id, o, e, target); o.down = false; }\n\t\t\n\t\tif (target == oTarget) { this._dispatchMouseEvent(oTarget, \"click\", true, id, o, e); }\n\t\tthis._dispatchMouseEvent(oTarget, \"pressup\", true, id, o, e);\n\t\t\n\t\tif (clear) {\n\t\t\tif (id==this._primaryPointerID) { this._primaryPointerID = null; }\n\t\t\tdelete(this._pointerData[id]);\n\t\t} else { o.target = null; }\n\t\t\n\t\tnextStage&&nextStage._handlePointerUp(id, e, clear, owner || target && this);\n\t};\n\n\t/**\n\t * @method _handleMouseDown\n\t * @protected\n\t * @param {MouseEvent} e\n\t **/\n\tp._handleMouseDown = function(e) {\n\t\tthis._handlePointerDown(-1, e, e.pageX, e.pageY);\n\t};\n\n\t/**\n\t * @method _handlePointerDown\n\t * @protected\n\t * @param {Number} id\n\t * @param {Event} e\n\t * @param {Number} pageX\n\t * @param {Number} pageY\n\t * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t **/\n\tp._handlePointerDown = function(id, e, pageX, pageY, owner) {\n\t\tif (this.preventSelection) { e.preventDefault(); }\n\t\tif (this._primaryPointerID == null || id === -1) { this._primaryPointerID = id; } // mouse always takes over.\n\t\t\n\t\tif (pageY != null) { this._updatePointerPosition(id, e, pageX, pageY); }\n\t\tvar target = null, nextStage = this._nextStage, o = this._getPointerData(id);\n\t\tif (!owner) { target = o.target = this._getObjectsUnderPoint(o.x, o.y, null, true); }\n\n\t\tif (o.inBounds) { this._dispatchMouseEvent(this, \"stagemousedown\", false, id, o, e, target); o.down = true; }\n\t\tthis._dispatchMouseEvent(target, \"mousedown\", true, id, o, e);\n\t\t\n\t\tnextStage&&nextStage._handlePointerDown(id, e, pageX, pageY, owner || target && this);\n\t};\n\n\t/**\n\t * @method _testMouseOver\n\t * @param {Boolean} clear If true, clears the mouseover / rollover (ie. no target)\n\t * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t * @param {Stage} eventTarget The stage that the cursor is actively over.\n\t * @protected\n\t **/\n\tp._testMouseOver = function(clear, owner, eventTarget) {\n\t\tif (this._prevStage && owner === undefined) { return; } // redundant listener.\n\t\t\n\t\tvar nextStage = this._nextStage;\n\t\tif (!this._mouseOverIntervalID) {\n\t\t\t// not enabled for mouseover, but should still relay the event.\n\t\t\tnextStage&&nextStage._testMouseOver(clear, owner, eventTarget);\n\t\t\treturn;\n\t\t}\n\t\tvar o = this._getPointerData(-1);\n\t\t// only update if the mouse position has changed. This provides a lot of optimization, but has some trade-offs.\n\t\tif (!o || (!clear && this.mouseX == this._mouseOverX && this.mouseY == this._mouseOverY && this.mouseInBounds)) { return; }\n\t\t\n\t\tvar e = o.posEvtObj;\n\t\tvar isEventTarget = eventTarget || e&&(e.target == this.canvas);\n\t\tvar target=null, common = -1, cursor=\"\", t, i, l;\n\t\t\n\t\tif (!owner && (clear || this.mouseInBounds && isEventTarget)) {\n\t\t\ttarget = this._getObjectsUnderPoint(this.mouseX, this.mouseY, null, true);\n\t\t\tthis._mouseOverX = this.mouseX;\n\t\t\tthis._mouseOverY = this.mouseY;\n\t\t}\n\n\t\tvar oldList = this._mouseOverTarget||[];\n\t\tvar oldTarget = oldList[oldList.length-1];\n\t\tvar list = this._mouseOverTarget = [];\n\n\t\t// generate ancestor list and check for cursor:\n\t\tt = target;\n\t\twhile (t) {\n\t\t\tlist.unshift(t);\n\t\t\tif (!cursor) { cursor = t.cursor; }\n\t\t\tt = t.parent;\n\t\t}\n\t\tthis.canvas.style.cursor = cursor;\n\t\tif (!owner && eventTarget) { eventTarget.canvas.style.cursor = cursor; }\n\n\t\t// find common ancestor:\n\t\tfor (i=0,l=list.length; i<l; i++) {\n\t\t\tif (list[i] != oldList[i]) { break; }\n\t\t\tcommon = i;\n\t\t}\n\n\t\tif (oldTarget != target) {\n\t\t\tthis._dispatchMouseEvent(oldTarget, \"mouseout\", true, -1, o, e, target);\n\t\t}\n\n\t\tfor (i=oldList.length-1; i>common; i--) {\n\t\t\tthis._dispatchMouseEvent(oldList[i], \"rollout\", false, -1, o, e, target);\n\t\t}\n\n\t\tfor (i=list.length-1; i>common; i--) {\n\t\t\tthis._dispatchMouseEvent(list[i], \"rollover\", false, -1, o, e, oldTarget);\n\t\t}\n\n\t\tif (oldTarget != target) {\n\t\t\tthis._dispatchMouseEvent(target, \"mouseover\", true, -1, o, e, oldTarget);\n\t\t}\n\t\t\n\t\tnextStage&&nextStage._testMouseOver(clear, owner || target && this, eventTarget || isEventTarget && this);\n\t};\n\n\t/**\n\t * @method _handleDoubleClick\n\t * @protected\n\t * @param {MouseEvent} e\n\t * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.\n\t **/\n\tp._handleDoubleClick = function(e, owner) {\n\t\tvar target=null, nextStage=this._nextStage, o=this._getPointerData(-1);\n\t\tif (!owner) {\n\t\t\ttarget = this._getObjectsUnderPoint(o.x, o.y, null, true);\n\t\t\tthis._dispatchMouseEvent(target, \"dblclick\", true, -1, o, e);\n\t\t}\n\t\tnextStage&&nextStage._handleDoubleClick(e, owner || target && this);\n\t};\n\n\t/**\n\t * @method _dispatchMouseEvent\n\t * @protected\n\t * @param {DisplayObject} target\n\t * @param {String} type\n\t * @param {Boolean} bubbles\n\t * @param {Number} pointerId\n\t * @param {Object} o\n\t * @param {MouseEvent} [nativeEvent]\n\t * @param {DisplayObject} [relatedTarget]\n\t **/\n\tp._dispatchMouseEvent = function(target, type, bubbles, pointerId, o, nativeEvent, relatedTarget) {\n\t\t// TODO: might be worth either reusing MouseEvent instances, or adding a willTrigger method to avoid GC.\n\t\tif (!target || (!bubbles && !target.hasEventListener(type))) { return; }\n\t\t/*\n\t\t// TODO: account for stage transformations?\n\t\tthis._mtx = this.getConcatenatedMatrix(this._mtx).invert();\n\t\tvar pt = this._mtx.transformPoint(o.x, o.y);\n\t\tvar evt = new createjs.MouseEvent(type, bubbles, false, pt.x, pt.y, nativeEvent, pointerId, pointerId==this._primaryPointerID || pointerId==-1, o.rawX, o.rawY);\n\t\t*/\n\t\tvar evt = new createjs.MouseEvent(type, bubbles, false, o.x, o.y, nativeEvent, pointerId, pointerId === this._primaryPointerID || pointerId === -1, o.rawX, o.rawY, relatedTarget);\n\t\ttarget.dispatchEvent(evt);\n\t};\n\n\n\tcreatejs.Stage = createjs.promote(Stage, \"Container\");\n}());\n\n//##############################################################################\n// Bitmap.js\n//##############################################################################\n\n(function() {\n\t\n\t/**\n\t * A Bitmap represents an Image, Canvas, or Video in the display list. A Bitmap can be instantiated using an existing\n\t * HTML element, or a string.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var bitmap = new createjs.Bitmap(\"imagePath.jpg\");\n\t *\n\t * <strong>Notes:</strong>\n\t * <ol>\n\t *     <li>When a string path or image tag that is not yet loaded is used, the stage may need to be redrawn before it\n\t *      will be displayed.</li>\n\t *     <li>Bitmaps with an SVG source currently will not respect an alpha value other than 0 or 1. To get around this,\n\t *     the Bitmap can be cached.</li>\n\t *     <li>Bitmaps with an SVG source will taint the canvas with cross-origin data, which prevents interactivity. This\n\t *     happens in all browsers except recent Firefox builds.</li>\n\t *     <li>Images loaded cross-origin will throw cross-origin security errors when interacted with using a mouse, using\n\t *     methods such as `getObjectUnderPoint`, or using filters, or caching. You can get around this by setting\n\t *     `crossOrigin` flags on your images before passing them to EaselJS, eg: `img.crossOrigin=\"Anonymous\";`</li>\n\t * </ol>\n\t *\n\t * @class Bitmap\n\t * @extends DisplayObject\n\t * @constructor\n\t * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | String} imageOrUri The source object or URI to an image to\n\t * display. This can be either an Image, Canvas, or Video object, or a string URI to an image file to load and use.\n\t * If it is a URI, a new Image object will be constructed and assigned to the .image property.\n\t **/\n\tfunction Bitmap(imageOrUri) {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The image to render. This can be an Image, a Canvas, or a Video. Not all browsers (especially\n\t\t * mobile browsers) support drawing video to a canvas.\n\t\t * @property image\n\t\t * @type HTMLImageElement | HTMLCanvasElement | HTMLVideoElement\n\t\t **/\n\t\tif (typeof imageOrUri == \"string\") {\n\t\t\tthis.image = document.createElement(\"img\");\n\t\t\tthis.image.src = imageOrUri;\n\t\t} else {\n\t\t\tthis.image = imageOrUri;\n\t\t}\n\t\n\t\t/**\n\t\t * Specifies an area of the source image to draw. If omitted, the whole image will be drawn.\n\t\t * Note that video sources must have a width / height set to work correctly with `sourceRect`.\n\t\t * @property sourceRect\n\t\t * @type Rectangle\n\t\t * @default null\n\t\t */\n\t\tthis.sourceRect = null;\n\t}\n\tvar p = createjs.extend(Bitmap, createjs.DisplayObject);\n\t\n\t\n// public methods:\n\t/**\n\t * Constructor alias for backwards compatibility. This method will be removed in future versions.\n\t * Subclasses should be updated to use {{#crossLink \"Utility Methods/extends\"}}{{/crossLink}}.\n\t * @method initialize\n\t * @deprecated in favour of `createjs.promote()`\n\t **/\n\tp.initialize = Bitmap; // TODO: deprecated.\n\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar image = this.image;\n\t\tvar hasContent = this.cacheCanvas || (image && (image.naturalWidth || image.getContext || image.readyState >= 2));\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t *\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t * @return {Boolean}\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache) || !this.image) { return true; }\n\t\tvar img = this.image, rect = this.sourceRect;\n\t\tif (rect) {\n\t\t\t// some browsers choke on out of bound values, so we'll fix them:\n\t\t\tvar x1 = rect.x, y1 = rect.y, x2 = x1 + rect.width, y2 = y1 + rect.height, x = 0, y = 0, w = img.width, h = img.height;\n\t\t\tif (x1 < 0) { x -= x1; x1 = 0; }\n\t\t\tif (x2 > w) { x2 = w; }\n\t\t\tif (y1 < 0) { y -= y1; y1 = 0; }\n\t\t\tif (y2 > h) { y2 = h; }\n\t\t\tctx.drawImage(img, x1, y1, x2-x1, y2-y1, x, y, x2-x1, y2-y1);\n\t\t} else {\n\t\t\tctx.drawImage(img, 0, 0);\n\t\t}\n\t\treturn true;\n\t};\n\t\n\t//Note, the doc sections below document using the specified APIs (from DisplayObject)  from\n\t//Bitmap. This is why they have no method implementations.\n\t\n\t/**\n\t * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.\n\t * You should <b>not</b> cache Bitmap instances as it can degrade performance.\n\t *\n\t * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>\n\t * To see the API for caching, please visit the DisplayObject {{#crossLink \"DisplayObject/cache\"}}{{/crossLink}}\n\t * method.\n\t * @method cache\n\t **/\n\t\n\t/**\n\t * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.\n\t * You should <b>not</b> cache Bitmap instances as it can degrade performance.\n\t *\n\t * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>\n\t * To see the API for caching, please visit the DisplayObject {{#crossLink \"DisplayObject/cache\"}}{{/crossLink}}\n\t * method.\n\t * @method updateCache\n\t **/\n\t\n\t/**\n\t * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.\n\t * You should <b>not</b> cache Bitmap instances as it can degrade performance.\n\t *\n\t * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>\n\t * To see the API for caching, please visit the DisplayObject {{#crossLink \"DisplayObject/cache\"}}{{/crossLink}}\n\t * method.\n\t * @method uncache\n\t **/\n\n\t/**\n\t * Docced in superclass.\n\t */\n\tp.getBounds = function() {\n\t\tvar rect = this.DisplayObject_getBounds();\n\t\tif (rect) { return rect; }\n\t\tvar image = this.image, o = this.sourceRect || image;\n\t\tvar hasContent = (image && (image.naturalWidth || image.getContext || image.readyState >= 2));\n\t\treturn hasContent ? this._rectangle.setValues(0, 0, o.width, o.height) : null;\n\t};\n\t\n\t/**\n\t * Returns a clone of the Bitmap instance.\n\t * @method clone\n\t * @return {Bitmap} a clone of the Bitmap instance.\n\t **/\n\tp.clone = function() {\n\t\tvar o = new Bitmap(this.image);\n\t\tif (this.sourceRect) { o.sourceRect = this.sourceRect.clone(); }\n\t\tthis._cloneProps(o);\n\t\treturn o;\n\t};\n\t\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Bitmap (name=\"+  this.name +\")]\";\n\t};\n\n\t\n\tcreatejs.Bitmap = createjs.promote(Bitmap, \"DisplayObject\");\n}());\n\n//##############################################################################\n// Sprite.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Displays a frame or sequence of frames (ie. an animation) from a SpriteSheet instance. A sprite sheet is a series of\n\t * images (usually animation frames) combined into a single image. For example, an animation consisting of 8 100x100\n\t * images could be combined into a 400x200 sprite sheet (4 frames across by 2 high). You can display individual frames,\n\t * play frames as an animation, and even sequence animations together.\n\t *\n\t * See the {{#crossLink \"SpriteSheet\"}}{{/crossLink}} class for more information on setting up frames and animations.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var instance = new createjs.Sprite(spriteSheet);\n\t *      instance.gotoAndStop(\"frameName\");\n\t *\n\t * Until {{#crossLink \"Sprite/gotoAndStop\"}}{{/crossLink}} or {{#crossLink \"Sprite/gotoAndPlay\"}}{{/crossLink}} is called,\n\t * only the first defined frame defined in the sprite sheet will be displayed.\n\t *\n\t * @class Sprite\n\t * @extends DisplayObject\n\t * @constructor\n\t * @param {SpriteSheet} spriteSheet The SpriteSheet instance to play back. This includes the source image(s), frame\n\t * dimensions, and frame data. See {{#crossLink \"SpriteSheet\"}}{{/crossLink}} for more information.\n\t * @param {String|Number} [frameOrAnimation] The frame number or animation to play initially.\n\t **/\n\tfunction Sprite(spriteSheet, frameOrAnimation) {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The frame index that will be drawn when draw is called. Note that with some {{#crossLink \"SpriteSheet\"}}{{/crossLink}}\n\t\t * definitions, this will advance non-sequentially. This will always be an integer value.\n\t\t * @property currentFrame\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @readonly\n\t\t **/\n\t\tthis.currentFrame = 0;\n\t\n\t\t/**\n\t\t * Returns the name of the currently playing animation.\n\t\t * @property currentAnimation\n\t\t * @type {String}\n\t\t * @final\n\t\t * @readonly\n\t\t **/\n\t\tthis.currentAnimation = null;\n\t\n\t\t/**\n\t\t * Prevents the animation from advancing each tick automatically. For example, you could create a sprite\n\t\t * sheet of icons, set paused to true, and display the appropriate icon by setting <code>currentFrame</code>.\n\t\t * @property paused\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t **/\n\t\tthis.paused = true;\n\t\n\t\t/**\n\t\t * The SpriteSheet instance to play back. This includes the source image, frame dimensions, and frame\n\t\t * data. See {{#crossLink \"SpriteSheet\"}}{{/crossLink}} for more information.\n\t\t * @property spriteSheet\n\t\t * @type {SpriteSheet}\n\t\t * @readonly\n\t\t **/\n\t\tthis.spriteSheet = spriteSheet;\n\t\n\t\t/**\n\t\t * Specifies the current frame index within the currently playing animation. When playing normally, this will increase\n\t\t * from 0 to n-1, where n is the number of frames in the current animation.\n\t\t *\n\t\t * This could be a non-integer value if\n\t\t * using time-based playback (see {{#crossLink \"Sprite/framerate\"}}{{/crossLink}}, or if the animation's speed is\n\t\t * not an integer.\n\t\t * @property currentAnimationFrame\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.currentAnimationFrame = 0;\n\t\n\t\t/**\n\t\t * By default Sprite instances advance one frame per tick. Specifying a framerate for the Sprite (or its related\n\t\t * SpriteSheet) will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\n\t\t * framerate.\n\t\t *\n\t\t * For example, if a Sprite with a framerate of 10 is placed on a Stage being updated at 40fps, then the Sprite will\n\t\t * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will\n\t\t * vary slightly between frames.\n\t\t *\n\t\t * This feature is dependent on the tick event object (or an object with an appropriate \"delta\" property) being\n\t\t * passed into {{#crossLink \"Stage/update\"}}{{/crossLink}}.\n\t\t * @property framerate\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t **/\n\t\tthis.framerate = 0;\n\t\n\t\n\t// private properties:\n\t\t/**\n\t\t * Current animation object.\n\t\t * @property _animation\n\t\t * @protected\n\t\t * @type {Object}\n\t\t * @default null\n\t\t **/\n\t\tthis._animation = null;\n\t\n\t\t/**\n\t\t * Current frame index.\n\t\t * @property _currentFrame\n\t\t * @protected\n\t\t * @type {Number}\n\t\t * @default null\n\t\t **/\n\t\tthis._currentFrame = null;\n\t\t\n\t\t/**\n\t\t * Skips the next auto advance. Used by gotoAndPlay to avoid immediately jumping to the next frame\n\t\t * @property _skipAdvance\n\t\t * @protected\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t **/\n\t\tthis._skipAdvance = false;\n\t\t\n\t\t\n\t\tif (frameOrAnimation != null) { this.gotoAndPlay(frameOrAnimation); }\n\t}\n\tvar p = createjs.extend(Sprite, createjs.DisplayObject);\n\n\t/**\n\t * Constructor alias for backwards compatibility. This method will be removed in future versions.\n\t * Subclasses should be updated to use {{#crossLink \"Utility Methods/extends\"}}{{/crossLink}}.\n\t * @method initialize\n\t * @deprecated in favour of `createjs.promote()`\n\t **/\n\tp.initialize = Sprite; // TODO: Deprecated. This is for backwards support of FlashCC spritesheet export.\n\n\n// events:\n\t/**\n\t * Dispatched when an animation reaches its ends.\n\t * @event animationend\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {String} name The name of the animation that just ended.\n\t * @param {String} next The name of the next animation that will be played, or null. This will be the same as name if the animation is looping.\n\t * @since 0.6.0\n\t */\n\t \n\t/**\n\t * Dispatched any time the current frame changes. For example, this could be due to automatic advancement on a tick,\n\t * or calling gotoAndPlay() or gotoAndStop().\n\t * @event change\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t */\n\n\n// public methods:\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar hasContent = this.cacheCanvas || this.spriteSheet.complete;\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\t\tthis._normalizeFrame();\n\t\tvar o = this.spriteSheet.getFrame(this._currentFrame|0);\n\t\tif (!o) { return false; }\n\t\tvar rect = o.rect;\n\t\tif (rect.width && rect.height) { ctx.drawImage(o.image, rect.x, rect.y, rect.width, rect.height, -o.regX, -o.regY, rect.width, rect.height); }\n\t\treturn true;\n\t};\n\n\t//Note, the doc sections below document using the specified APIs (from DisplayObject)  from\n\t//Bitmap. This is why they have no method implementations.\n\n\t/**\n\t * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.\n\t * You should not cache Sprite instances as it can degrade performance.\n\t * @method cache\n\t **/\n\n\t/**\n\t * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.\n\t * You should not cache Sprite instances as it can degrade performance.\n\t * @method updateCache\n\t **/\n\n\t/**\n\t * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.\n\t * You should not cache Sprite instances as it can degrade performance.\n\t * @method uncache\n\t **/\n\n\t/**\n\t * Play (unpause) the current animation. The Sprite will be paused if either {{#crossLink \"Sprite/stop\"}}{{/crossLink}}\n\t * or {{#crossLink \"Sprite/gotoAndStop\"}}{{/crossLink}} is called. Single frame animations will remain\n\t * unchanged.\n\t * @method play\n\t **/\n\tp.play = function() {\n\t\tthis.paused = false;\n\t};\n\n\t/**\n\t * Stop playing a running animation. The Sprite will be playing if {{#crossLink \"Sprite/gotoAndPlay\"}}{{/crossLink}}\n\t * is called. Note that calling {{#crossLink \"Sprite/gotoAndPlay\"}}{{/crossLink}} or {{#crossLink \"Sprite/play\"}}{{/crossLink}}\n\t * will resume playback.\n\t * @method stop\n\t **/\n\tp.stop = function() {\n\t\tthis.paused = true;\n\t};\n\n\t/**\n\t * Sets paused to false and plays the specified animation name, named frame, or frame number.\n\t * @method gotoAndPlay\n\t * @param {String|Number} frameOrAnimation The frame number or animation name that the playhead should move to\n\t * and begin playing.\n\t **/\n\tp.gotoAndPlay = function(frameOrAnimation) {\n\t\tthis.paused = false;\n\t\tthis._skipAdvance = true;\n\t\tthis._goto(frameOrAnimation);\n\t};\n\n\t/**\n\t * Sets paused to true and seeks to the specified animation name, named frame, or frame number.\n\t * @method gotoAndStop\n\t * @param {String|Number} frameOrAnimation The frame number or animation name that the playhead should move to\n\t * and stop.\n\t **/\n\tp.gotoAndStop = function(frameOrAnimation) {\n\t\tthis.paused = true;\n\t\tthis._goto(frameOrAnimation);\n\t};\n\n\t/**\n\t * Advances the playhead. This occurs automatically each tick by default.\n\t * @param [time] {Number} The amount of time in ms to advance by. Only applicable if framerate is set on the Sprite\n\t * or its SpriteSheet.\n\t * @method advance\n\t*/\n\tp.advance = function(time) {\n\t\tvar fps = this.framerate || this.spriteSheet.framerate;\n\t\tvar t = (fps && time != null) ? time/(1000/fps) : 1;\n\t\tthis._normalizeFrame(t);\n\t};\n\t\n\t/**\n\t * Returns a {{#crossLink \"Rectangle\"}}{{/crossLink}} instance defining the bounds of the current frame relative to\n\t * the origin. For example, a 90 x 70 frame with <code>regX=50</code> and <code>regY=40</code> would return a\n\t * rectangle with [x=-50, y=-40, width=90, height=70]. This ignores transformations on the display object.\n\t *\n\t * Also see the SpriteSheet {{#crossLink \"SpriteSheet/getFrameBounds\"}}{{/crossLink}} method.\n\t * @method getBounds\n\t * @return {Rectangle} A Rectangle instance. Returns null if the frame does not exist, or the image is not fully\n\t * loaded.\n\t **/\n\tp.getBounds = function() {\n\t\t// TODO: should this normalizeFrame?\n\t\treturn this.DisplayObject_getBounds() || this.spriteSheet.getFrameBounds(this.currentFrame, this._rectangle);\n\t};\n\n\t/**\n\t * Returns a clone of the Sprite instance. Note that the same SpriteSheet is shared between cloned\n\t * instances.\n\t * @method clone\n\t * @return {Sprite} a clone of the Sprite instance.\n\t **/\n\tp.clone = function() {\n\t\treturn this._cloneProps(new Sprite(this.spriteSheet));\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Sprite (name=\"+  this.name +\")]\";\n\t};\n\n// private methods:\n\t/**\n\t * @method _cloneProps\n\t * @param {Sprite} o\n\t * @return {Sprite} o\n\t * @protected\n\t **/\n\tp._cloneProps = function(o) {\n\t\tthis.DisplayObject__cloneProps(o);\n\t\to.currentFrame = this.currentFrame;\n\t\to.currentAnimation = this.currentAnimation;\n\t\to.paused = this.paused;\n\t\to.currentAnimationFrame = this.currentAnimationFrame;\n\t\to.framerate = this.framerate;\n\t\t\n\t\to._animation = this._animation;\n\t\to._currentFrame = this._currentFrame;\n\t\to._skipAdvance = this._skipAdvance;\n\t\treturn o;\n\t};\n\t\n\t/**\n\t * Advances the <code>currentFrame</code> if paused is not true. This is called automatically when the {{#crossLink \"Stage\"}}{{/crossLink}}\n\t * ticks.\n\t * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.\n\t * @protected\n\t * @method _tick\n\t **/\n\tp._tick = function(evtObj) {\n\t\tif (!this.paused) {\n\t\t\tif (!this._skipAdvance) { this.advance(evtObj&&evtObj.delta); }\n\t\t\tthis._skipAdvance = false;\n\t\t}\n\t\tthis.DisplayObject__tick(evtObj);\n\t};\n\n\n\t/**\n\t * Normalizes the current frame, advancing animations and dispatching callbacks as appropriate.\n\t * @protected\n\t * @method _normalizeFrame\n\t **/\n\tp._normalizeFrame = function(frameDelta) {\n\t\tframeDelta = frameDelta || 0;\n\t\tvar animation = this._animation;\n\t\tvar paused = this.paused;\n\t\tvar frame = this._currentFrame;\n\t\tvar l;\n\t\t\n\t\tif (animation) {\n\t\t\tvar speed = animation.speed || 1;\n\t\t\tvar animFrame = this.currentAnimationFrame;\n\t\t\tl = animation.frames.length;\n\t\t\tif (animFrame + frameDelta * speed >= l) {\n\t\t\t\tvar next = animation.next;\n\t\t\t\tif (this._dispatchAnimationEnd(animation, frame, paused, next, l - 1)) {\n\t\t\t\t\t// something changed in the event stack, so we shouldn't make any more changes here.\n\t\t\t\t\treturn;\n\t\t\t\t} else if (next) {\n\t\t\t\t\t// sequence. Automatically calls _normalizeFrame again with the remaining frames.\n\t\t\t\t\treturn this._goto(next, frameDelta - (l - animFrame) / speed);\n\t\t\t\t} else {\n\t\t\t\t\t// end.\n\t\t\t\t\tthis.paused = true;\n\t\t\t\t\tanimFrame = animation.frames.length - 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tanimFrame += frameDelta * speed;\n\t\t\t}\n\t\t\tthis.currentAnimationFrame = animFrame;\n\t\t\tthis._currentFrame = animation.frames[animFrame | 0]\n\t\t} else {\n\t\t\tframe = (this._currentFrame += frameDelta);\n\t\t\tl = this.spriteSheet.getNumFrames();\n\t\t\tif (frame >= l && l > 0) {\n\t\t\t\tif (!this._dispatchAnimationEnd(animation, frame, paused, l - 1)) {\n\t\t\t\t\t// looped.\n\t\t\t\t\tif ((this._currentFrame -= l) >= l) { return this._normalizeFrame(); }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tframe = this._currentFrame | 0;\n\t\tif (this.currentFrame != frame) {\n\t\t\tthis.currentFrame = frame;\n\t\t\tthis.dispatchEvent(\"change\");\n\t\t}\n\t};\n\n\t/**\n\t * Dispatches the \"animationend\" event. Returns true if a handler changed the animation (ex. calling {{#crossLink \"Sprite/stop\"}}{{/crossLink}},\n\t * {{#crossLink \"Sprite/gotoAndPlay\"}}{{/crossLink}}, etc.)\n\t * @property _dispatchAnimationEnd\n\t * @private\n\t * @type {Function}\n\t **/\n\tp._dispatchAnimationEnd = function(animation, frame, paused, next, end) {\n\t\tvar name = animation ? animation.name : null;\n\t\tif (this.hasEventListener(\"animationend\")) {\n\t\t\tvar evt = new createjs.Event(\"animationend\");\n\t\t\tevt.name = name;\n\t\t\tevt.next = next;\n\t\t\tthis.dispatchEvent(evt);\n\t\t}\n\t\t// did the animation get changed in the event stack?:\n\t\tvar changed = (this._animation != animation || this._currentFrame != frame);\n\t\t// if the animation hasn't changed, but the sprite was paused, then we want to stick to the last frame:\n\t\tif (!changed && !paused && this.paused) { this.currentAnimationFrame = end; changed = true; }\n\t\treturn changed;\n\t};\n\n\t/**\n\t * Moves the playhead to the specified frame number or animation.\n\t * @method _goto\n\t * @param {String|Number} frameOrAnimation The frame number or animation that the playhead should move to.\n\t * @param {Boolean} [frame] The frame of the animation to go to. Defaults to 0.\n\t * @protected\n\t **/\n\tp._goto = function(frameOrAnimation, frame) {\n\t\tthis.currentAnimationFrame = 0;\n\t\tif (isNaN(frameOrAnimation)) {\n\t\t\tvar data = this.spriteSheet.getAnimation(frameOrAnimation);\n\t\t\tif (data) {\n\t\t\t\tthis._animation = data;\n\t\t\t\tthis.currentAnimation = frameOrAnimation;\n\t\t\t\tthis._normalizeFrame(frame);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.currentAnimation = this._animation = null;\n\t\t\tthis._currentFrame = frameOrAnimation;\n\t\t\tthis._normalizeFrame();\n\t\t}\n\t};\n\n\n\tcreatejs.Sprite = createjs.promote(Sprite, \"DisplayObject\");\n}());\n\n//##############################################################################\n// Shape.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * A Shape allows you to display vector art in the display list. It composites a {{#crossLink \"Graphics\"}}{{/crossLink}}\n\t * instance which exposes all of the vector drawing methods. The Graphics instance can be shared between multiple Shape\n\t * instances to display the same vector graphics with different positions or transforms.\n\t *\n\t * If the vector art will not\n\t * change between draws, you may want to use the {{#crossLink \"DisplayObject/cache\"}}{{/crossLink}} method to reduce the\n\t * rendering cost.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var graphics = new createjs.Graphics().beginFill(\"#ff0000\").drawRect(0, 0, 100, 100);\n\t *      var shape = new createjs.Shape(graphics);\n\t *\n\t *      //Alternatively use can also use the graphics property of the Shape class to renderer the same as above.\n\t *      var shape = new createjs.Shape();\n\t *      shape.graphics.beginFill(\"#ff0000\").drawRect(0, 0, 100, 100);\n\t *\n\t * @class Shape\n\t * @extends DisplayObject\n\t * @constructor\n\t * @param {Graphics} graphics Optional. The graphics instance to display. If null, a new Graphics instance will be created.\n\t **/\n\tfunction Shape(graphics) {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The graphics instance to display.\n\t\t * @property graphics\n\t\t * @type Graphics\n\t\t **/\n\t\tthis.graphics = graphics ? graphics : new createjs.Graphics();\n\t}\n\tvar p = createjs.extend(Shape, createjs.DisplayObject);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// public methods:\n\t/**\n\t * Returns true or false indicating whether the Shape would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the Shape would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar hasContent = this.cacheCanvas || (this.graphics && !this.graphics.isEmpty());\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t};\n\n\t/**\n\t * Draws the Shape into the specified context ignoring its visible, alpha, shadow, and transform. Returns true if\n\t * the draw was handled (useful for overriding functionality).\n\t *\n\t * <i>NOTE: This method is mainly for internal use, though it may be useful for advanced uses.</i>\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,\n\t * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).\n\t * @return {Boolean}\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\t\tthis.graphics.draw(ctx, this);\n\t\treturn true;\n\t};\n\n\t/**\n\t * Returns a clone of this Shape. Some properties that are specific to this instance's current context are reverted to\n\t * their defaults (for example .parent).\n\t * @method clone\n\t * @param {Boolean} recursive If true, this Shape's {{#crossLink \"Graphics\"}}{{/crossLink}} instance will also be\n\t * cloned. If false, the Graphics instance will be shared with the new Shape.\n\t **/\n\tp.clone = function(recursive) {\n\t\tvar g = (recursive && this.graphics) ? this.graphics.clone() : this.graphics;\n\t\treturn  this._cloneProps(new Shape(g));\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Shape (name=\"+  this.name +\")]\";\n\t};\n\n\n\tcreatejs.Shape = createjs.promote(Shape, \"DisplayObject\");\n}());\n\n//##############################################################################\n// Text.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Display one or more lines of dynamic text (not user editable) in the display list. Line wrapping support (using the\n\t * lineWidth) is very basic, wrapping on spaces and tabs only. Note that as an alternative to Text, you can position HTML\n\t * text above or below the canvas relative to items in the display list using the {{#crossLink \"DisplayObject/localToGlobal\"}}{{/crossLink}}\n\t * method, or using {{#crossLink \"DOMElement\"}}{{/crossLink}}.\n\t *\n\t * <b>Please note that Text does not support HTML text, and can only display one font style at a time.</b> To use\n\t * multiple font styles, you will need to create multiple text instances, and position them manually.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var text = new createjs.Text(\"Hello World\", \"20px Arial\", \"#ff7700\");\n\t *      text.x = 100;\n\t *      text.textBaseline = \"alphabetic\";\n\t *\n\t * CreateJS Text supports web fonts (the same rules as Canvas). The font must be loaded and supported by the browser\n\t * before it can be displayed.\n\t *\n\t * <strong>Note:</strong> Text can be expensive to generate, so cache instances where possible. Be aware that not all\n\t * browsers will render Text exactly the same.\n\t * @class Text\n\t * @extends DisplayObject\n\t * @constructor\n\t * @param {String} [text] The text to display.\n\t * @param {String} [font] The font style to use. Any valid value for the CSS font attribute is acceptable (ex. \"bold\n\t * 36px Arial\").\n\t * @param {String} [color] The color to draw the text in. Any valid value for the CSS color attribute is acceptable (ex.\n\t * \"#F00\", \"red\", or \"#FF0000\").\n\t **/\n\tfunction Text(text, font, color) {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The text to display.\n\t\t * @property text\n\t\t * @type String\n\t\t **/\n\t\tthis.text = text;\n\t\n\t\t/**\n\t\t * The font style to use. Any valid value for the CSS font attribute is acceptable (ex. \"bold 36px Arial\").\n\t\t * @property font\n\t\t * @type String\n\t\t **/\n\t\tthis.font = font;\n\t\n\t\t/**\n\t\t * The color to draw the text in. Any valid value for the CSS color attribute is acceptable (ex. \"#F00\"). Default is \"#000\".\n\t\t * It will also accept valid canvas fillStyle values.\n\t\t * @property color\n\t\t * @type String\n\t\t **/\n\t\tthis.color = color;\n\t\n\t\t/**\n\t\t * The horizontal text alignment. Any of \"start\", \"end\", \"left\", \"right\", and \"center\". For detailed\n\t\t * information view the\n\t\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles\">\n\t\t * whatwg spec</a>. Default is \"left\".\n\t\t * @property textAlign\n\t\t * @type String\n\t\t **/\n\t\tthis.textAlign = \"left\";\n\t\n\t\t/**\n\t\t * The vertical alignment point on the font. Any of \"top\", \"hanging\", \"middle\", \"alphabetic\", \"ideographic\", or\n\t\t * \"bottom\". For detailed information view the <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles\">\n\t\t * whatwg spec</a>. Default is \"top\".\n\t\t * @property textBaseline\n\t\t * @type String\n\t\t*/\n\t\tthis.textBaseline = \"top\";\n\t\n\t\t/**\n\t\t * The maximum width to draw the text. If maxWidth is specified (not null), the text will be condensed or\n\t\t * shrunk to make it fit in this width. For detailed information view the\n\t\t * <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles\">\n\t\t * whatwg spec</a>.\n\t\t * @property maxWidth\n\t\t * @type Number\n\t\t*/\n\t\tthis.maxWidth = null;\n\t\n\t\t/**\n\t\t * If greater than 0, the text will be drawn as a stroke (outline) of the specified width.\n\t\t * @property outline\n\t\t * @type Number\n\t\t **/\n\t\tthis.outline = 0;\n\t\n\t\t/**\n\t\t * Indicates the line height (vertical distance between baselines) for multi-line text. If null or 0,\n\t\t * the value of getMeasuredLineHeight is used.\n\t\t * @property lineHeight\n\t\t * @type Number\n\t\t **/\n\t\tthis.lineHeight = 0;\n\t\n\t\t/**\n\t\t * Indicates the maximum width for a line of text before it is wrapped to multiple lines. If null,\n\t\t * the text will not be wrapped.\n\t\t * @property lineWidth\n\t\t * @type Number\n\t\t **/\n\t\tthis.lineWidth = null;\n\t}\n\tvar p = createjs.extend(Text, createjs.DisplayObject);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\t\n// static properties:\n\t/**\n\t * @property _workingContext\n\t * @type CanvasRenderingContext2D\n\t * @private\n\t **/\n\tvar canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement(\"canvas\"));\n\tif (canvas.getContext) { Text._workingContext = canvas.getContext(\"2d\"); canvas.width = canvas.height = 1; }\n\t\n\t\n// constants:\n\t/**\n\t * Lookup table for the ratio to offset bounds x calculations based on the textAlign property.\n\t * @property H_OFFSETS\n\t * @type Object\n\t * @protected\n\t * @static\n\t **/\n\tText.H_OFFSETS = {start: 0, left: 0, center: -0.5, end: -1, right: -1};\n\t\n\t/**\n\t * Lookup table for the ratio to offset bounds y calculations based on the textBaseline property.\n\t * @property H_OFFSETS\n\t * @type Object\n\t * @protected\n\t * @static\n\t **/\n\tText.V_OFFSETS = {top: 0, hanging: -0.01, middle: -0.4, alphabetic: -0.8, ideographic: -0.85, bottom: -1};\n\n\n// public methods:\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar hasContent = this.cacheCanvas || (this.text != null && this.text !== \"\");\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);\n\t};\n\n\t/**\n\t * Draws the Text into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\n\t\tvar col = this.color || \"#000\";\n\t\tif (this.outline) { ctx.strokeStyle = col; ctx.lineWidth = this.outline*1; }\n\t\telse { ctx.fillStyle = col; }\n\t\t\n\t\tthis._drawText(this._prepContext(ctx));\n\t\treturn true;\n\t};\n\n\t/**\n\t * Returns the measured, untransformed width of the text without wrapping. Use getBounds for a more robust value.\n\t * @method getMeasuredWidth\n\t * @return {Number} The measured, untransformed width of the text.\n\t **/\n\tp.getMeasuredWidth = function() {\n\t\treturn this._getMeasuredWidth(this.text);\n\t};\n\n\t/**\n\t * Returns an approximate line height of the text, ignoring the lineHeight property. This is based on the measured\n\t * width of a \"M\" character multiplied by 1.2, which provides an approximate line height for most fonts.\n\t * @method getMeasuredLineHeight\n\t * @return {Number} an approximate line height of the text, ignoring the lineHeight property. This is\n\t * based on the measured width of a \"M\" character multiplied by 1.2, which approximates em for most fonts.\n\t **/\n\tp.getMeasuredLineHeight = function() {\n\t\treturn this._getMeasuredWidth(\"M\")*1.2;\n\t};\n\n\t/**\n\t * Returns the approximate height of multi-line text by multiplying the number of lines against either the\n\t * <code>lineHeight</code> (if specified) or {{#crossLink \"Text/getMeasuredLineHeight\"}}{{/crossLink}}. Note that\n\t * this operation requires the text flowing logic to run, which has an associated CPU cost.\n\t * @method getMeasuredHeight\n\t * @return {Number} The approximate height of the untransformed multi-line text.\n\t **/\n\tp.getMeasuredHeight = function() {\n\t\treturn this._drawText(null,{}).height;\n\t};\n\n\t/**\n\t * Docced in superclass.\n\t */\n\tp.getBounds = function() {\n\t\tvar rect = this.DisplayObject_getBounds();\n\t\tif (rect) { return rect; }\n\t\tif (this.text == null || this.text === \"\") { return null; }\n\t\tvar o = this._drawText(null, {});\n\t\tvar w = (this.maxWidth && this.maxWidth < o.width) ? this.maxWidth : o.width;\n\t\tvar x = w * Text.H_OFFSETS[this.textAlign||\"left\"];\n\t\tvar lineHeight = this.lineHeight||this.getMeasuredLineHeight();\n\t\tvar y = lineHeight * Text.V_OFFSETS[this.textBaseline||\"top\"];\n\t\treturn this._rectangle.setValues(x, y, w, o.height);\n\t};\n\t\n\t/**\n\t * Returns an object with width, height, and lines properties. The width and height are the visual width and height\n\t * of the drawn text. The lines property contains an array of strings, one for\n\t * each line of text that will be drawn, accounting for line breaks and wrapping. These strings have trailing\n\t * whitespace removed.\n\t * @method getMetrics\n\t * @return {Object} An object with width, height, and lines properties.\n\t **/\n\tp.getMetrics = function() {\n\t\tvar o = {lines:[]};\n\t\to.lineHeight = this.lineHeight || this.getMeasuredLineHeight();\n\t\to.vOffset = o.lineHeight * Text.V_OFFSETS[this.textBaseline||\"top\"];\n\t\treturn this._drawText(null, o, o.lines);\n\t};\n\n\t/**\n\t * Returns a clone of the Text instance.\n\t * @method clone\n\t * @return {Text} a clone of the Text instance.\n\t **/\n\tp.clone = function() {\n\t\treturn this._cloneProps(new Text(this.text, this.font, this.color));\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Text (text=\"+  (this.text.length > 20 ? this.text.substr(0, 17)+\"...\" : this.text) +\")]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _cloneProps\n\t * @param {Text} o\n\t * @protected\n\t * @return {Text} o\n\t **/\n\tp._cloneProps = function(o) {\n\t\tthis.DisplayObject__cloneProps(o);\n\t\to.textAlign = this.textAlign;\n\t\to.textBaseline = this.textBaseline;\n\t\to.maxWidth = this.maxWidth;\n\t\to.outline = this.outline;\n\t\to.lineHeight = this.lineHeight;\n\t\to.lineWidth = this.lineWidth;\n\t\treturn o;\n\t};\n\n\t/**\n\t * @method _getWorkingContext\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @return {CanvasRenderingContext2D}\n\t * @protected\n\t **/\n\tp._prepContext = function(ctx) {\n\t\tctx.font = this.font||\"10px sans-serif\";\n\t\tctx.textAlign = this.textAlign||\"left\";\n\t\tctx.textBaseline = this.textBaseline||\"top\";\n\t\treturn ctx;\n\t};\n\n\t/**\n\t * Draws multiline text.\n\t * @method _drawText\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {Object} o\n\t * @param {Array} lines\n\t * @return {Object}\n\t * @protected\n\t **/\n\tp._drawText = function(ctx, o, lines) {\n\t\tvar paint = !!ctx;\n\t\tif (!paint) {\n\t\t\tctx = Text._workingContext;\n\t\t\tctx.save();\n\t\t\tthis._prepContext(ctx);\n\t\t}\n\t\tvar lineHeight = this.lineHeight||this.getMeasuredLineHeight();\n\t\t\n\t\tvar maxW = 0, count = 0;\n\t\tvar hardLines = String(this.text).split(/(?:\\r\\n|\\r|\\n)/);\n\t\tfor (var i=0, l=hardLines.length; i<l; i++) {\n\t\t\tvar str = hardLines[i];\n\t\t\tvar w = null;\n\t\t\t\n\t\t\tif (this.lineWidth != null && (w = ctx.measureText(str).width) > this.lineWidth) {\n\t\t\t\t// text wrapping:\n\t\t\t\tvar words = str.split(/(\\s)/);\n\t\t\t\tstr = words[0];\n\t\t\t\tw = ctx.measureText(str).width;\n\t\t\t\t\n\t\t\t\tfor (var j=1, jl=words.length; j<jl; j+=2) {\n\t\t\t\t\t// Line needs to wrap:\n\t\t\t\t\tvar wordW = ctx.measureText(words[j] + words[j+1]).width;\n\t\t\t\t\tif (w + wordW > this.lineWidth) {\n\t\t\t\t\t\tif (paint) { this._drawTextLine(ctx, str, count*lineHeight); }\n\t\t\t\t\t\tif (lines) { lines.push(str); }\n\t\t\t\t\t\tif (w > maxW) { maxW = w; }\n\t\t\t\t\t\tstr = words[j+1];\n\t\t\t\t\t\tw = ctx.measureText(str).width;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr += words[j] + words[j+1];\n\t\t\t\t\t\tw += wordW;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (paint) { this._drawTextLine(ctx, str, count*lineHeight); }\n\t\t\tif (lines) { lines.push(str); }\n\t\t\tif (o && w == null) { w = ctx.measureText(str).width; }\n\t\t\tif (w > maxW) { maxW = w; }\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\tif (o) {\n\t\t\to.width = maxW;\n\t\t\to.height = count*lineHeight;\n\t\t}\n\t\tif (!paint) { ctx.restore(); }\n\t\treturn o;\n\t};\n\n\t/**\n\t * @method _drawTextLine\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {String} text\n\t * @param {Number} y\n\t * @protected\n\t **/\n\tp._drawTextLine = function(ctx, text, y) {\n\t\t// Chrome 17 will fail to draw the text if the last param is included but null, so we feed it a large value instead:\n\t\tif (this.outline) { ctx.strokeText(text, 0, y, this.maxWidth||0xFFFF); }\n\t\telse { ctx.fillText(text, 0, y, this.maxWidth||0xFFFF); }\n\t};\n\t\n\t\n\t/**\n\t * @method _getMeasuredWidth\n\t * @param {String} text\n\t * @protected\n\t **/\n\tp._getMeasuredWidth = function(text) {\n\t\tvar ctx = Text._workingContext;\n\t\tctx.save();\n\t\tvar w = this._prepContext(ctx).measureText(text).width;\n\t\tctx.restore();\n\t\treturn w;\n\t};\n\n\n\tcreatejs.Text = createjs.promote(Text, \"DisplayObject\");\n}());\n\n//##############################################################################\n// BitmapText.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Displays text using bitmap glyphs defined in a sprite sheet. Multi-line text is supported\n\t * using new line characters, but automatic wrapping is not supported. See the \n\t * {{#crossLink \"BitmapText/spriteSheet:property\"}}{{/crossLink}}\n\t * property for more information on defining glyphs.\n\t * \n\t * <strong>Important:</strong> BitmapText extends Container, but is not designed to be used as one.\n\t * As such, methods like addChild and removeChild are disabled.\n\t * @class BitmapText\n\t * @extends DisplayObject\n\t * @param {String} [text=\"\"] The text to display.\n\t * @param {SpriteSheet} [spriteSheet=null] The spritesheet that defines the character glyphs.\n\t * @constructor\n\t **/\n\tfunction BitmapText(text, spriteSheet) {\n\t\tthis.Container_constructor();\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The text to display.\n\t\t * @property text\n\t\t * @type String\n\t\t * @default \"\"\n\t\t **/\n\t\tthis.text = text||\"\";\n\t\t\n\t\t/**\n\t\t * A SpriteSheet instance that defines the glyphs for this bitmap text. Each glyph/character\n\t\t * should have a single frame animation defined in the sprite sheet named the same as\n\t\t * corresponding character. For example, the following animation definition:\n\t\t *\n\t\t * \t\t\"A\": {frames: [0]}\n\t\t *\n\t\t * would indicate that the frame at index 0 of the spritesheet should be drawn for the \"A\" character. The short form\n\t\t * is also acceptable:\n\t\t * \n\t\t * \t\t\"A\": 0\n\t\t *\n\t\t * Note that if a character in the text is not found in the sprite sheet, it will also\n\t\t * try to use the alternate case (upper or lower).\n\t\t *\n\t\t * See SpriteSheet for more information on defining sprite sheet data.\n\t\t * @property spriteSheet\n\t\t * @type SpriteSheet\n\t\t * @default null\n\t\t **/\n\t\tthis.spriteSheet = spriteSheet;\n\t\n\t\t/**\n\t\t * The height of each line of text. If 0, then it will use a line height calculated\n\t\t * by checking for the height of the \"1\", \"T\", or \"L\" character (in that order). If\n\t\t * those characters are not defined, it will use the height of the first frame of the\n\t\t * sprite sheet.\n\t\t * @property lineHeight\n\t\t * @type Number\n\t\t * @default 0\n\t\t **/\n\t\tthis.lineHeight = 0;\n\t\n\t\t/**\n\t\t * This spacing (in pixels) will be added after each character in the output.\n\t\t * @property letterSpacing\n\t\t * @type Number\n\t\t * @default 0\n\t\t **/\n\t\tthis.letterSpacing = 0;\n\t\n\t\t/**\n\t\t * If a space character is not defined in the sprite sheet, then empty pixels equal to\n\t\t * spaceWidth will be inserted instead. If 0, then it will use a value calculated\n\t\t * by checking for the width of the \"1\", \"l\", \"E\", or \"A\" character (in that order). If\n\t\t * those characters are not defined, it will use the width of the first frame of the\n\t\t * sprite sheet.\n\t\t * @property spaceWidth\n\t\t * @type Number\n\t\t * @default 0\n\t\t **/\n\t\tthis.spaceWidth = 0;\n\t\t\n\t\t\n\t// private properties:\n\t \t/**\n\t\t * @property _oldProps\n\t\t * @type Object\n\t\t * @protected\n\t\t **/\n\t\tthis._oldProps = {text:0,spriteSheet:0,lineHeight:0,letterSpacing:0,spaceWidth:0};\n\t}\n\tvar p = createjs.extend(BitmapText, createjs.Container);\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n// static properties:\n\t/**\n\t * BitmapText uses Sprite instances to draw text. To reduce the creation and destruction of instances (and thus garbage collection), it maintains\n\t * an internal object pool of sprite instances to reuse. Increasing this value can cause more sprites to be\n\t * retained, slightly increasing memory use, but reducing instantiation.\n\t * @property maxPoolSize\n\t * @type Number\n\t * @static\n\t * @default 100\n\t **/\n\tBitmapText.maxPoolSize = 100;\n\t\n\t/**\n\t * Sprite object pool.\n\t * @type {Array}\n\t * @static\n\t * @private\n\t */\n\tBitmapText._spritePool = [];\n\n\t\n// public methods:\n\t/**\n\t * Docced in superclass.\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return; }\n\t\tthis._updateText();\n\t\tthis.Container_draw(ctx, ignoreCache);\n\t};\n\t\n\t/**\n\t * Docced in superclass.\n\t **/\n\tp.getBounds = function() {\n\t\tthis._updateText();\n\t\treturn this.Container_getBounds();\n\t};\n\t\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\tvar hasContent = this.cacheCanvas || (this.spriteSheet && this.spriteSheet.complete && this.text);\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX !== 0 && this.scaleY !== 0 && hasContent);\n\t};\n\t\n\tp.clone = function() {\n\t\treturn this._cloneProps(new BitmapText(this.text, this.spriteSheet));\n\t};\n\t\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t * @method addChild\n\t **/\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t * @method addChildAt\n\t **/\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t * @method removeChild\n\t **/\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t * @method removeChildAt\n\t **/\n\t/**\n\t * <strong>Disabled in BitmapText.</strong>\n\t * @method removeAllChildren\n\t **/\n\tp.addChild = p.addChildAt = p.removeChild = p.removeChildAt = p.removeAllChildren = function() {};\n\n\n// private methods:\n \t/**\n\t * @method _cloneProps\n\t * @param {BitmapText} o\n\t * @return {BitmapText} o\n\t * @protected\n\t **/\n\tp._cloneProps = function(o) {\n\t\tthis.Container__cloneProps(o);\n\t\to.lineHeight = this.lineHeight;\n\t\to.letterSpacing = this.letterSpacing;\n\t\to.spaceWidth = this.spaceWidth;\n\t\treturn o;\n\t};\n\t\n\t/**\n\t * @method _getFrameIndex\n\t * @param {String} character\n\t * @param {SpriteSheet} spriteSheet\n\t * @return {Number}\n\t * @protected\n\t **/\n\tp._getFrameIndex = function(character, spriteSheet) {\n\t\tvar c, o = spriteSheet.getAnimation(character);\n\t\tif (!o) {\n\t\t\t(character != (c = character.toUpperCase())) || (character != (c = character.toLowerCase())) || (c=null);\n\t\t\tif (c) { o = spriteSheet.getAnimation(c); }\n\t\t}\n\t\treturn o && o.frames[0];\n\t};\n\t\n\t/**\n\t * @method _getFrame\n\t * @param {String} character\n\t * @param {SpriteSheet} spriteSheet\n\t * @return {Object}\n\t * @protected\n\t **/\n\tp._getFrame = function(character, spriteSheet) {\n\t\tvar index = this._getFrameIndex(character, spriteSheet);\n\t\treturn index == null ? index : spriteSheet.getFrame(index);\n\t};\n\t\n\t/**\n\t * @method _getLineHeight\n\t * @param {SpriteSheet} ss\n\t * @return {Number}\n\t * @protected\n\t **/\n\tp._getLineHeight = function(ss) {\n\t\tvar frame = this._getFrame(\"1\",ss) || this._getFrame(\"T\",ss) || this._getFrame(\"L\",ss) || ss.getFrame(0);\n\t\treturn frame ? frame.rect.height : 1;\n\t};\n\t/**\n\t * @method _getSpaceWidth\n\t * @param {SpriteSheet} ss\n\t * @return {Number}\n\t * @protected\n\t **/\n\tp._getSpaceWidth = function(ss) {\n\t\tvar frame = this._getFrame(\"1\",ss) || this._getFrame(\"l\",ss) || this._getFrame(\"e\",ss) || this._getFrame(\"a\",ss) || ss.getFrame(0);\n\t\treturn frame ? frame.rect.width : 1;\n\t};\n\t\n\t/**\n\t * @method _drawText\n\t * @protected\n\t **/\n\tp._updateText = function() {\n\t\tvar x=0, y=0, o=this._oldProps, change=false, spaceW=this.spaceWidth, lineH=this.lineHeight, ss=this.spriteSheet;\n\t\tvar pool=BitmapText._spritePool, kids=this.children, childIndex=0, numKids=kids.length, sprite;\n\t\t\n\t\tfor (var n in o) {\n\t\t\tif (o[n] != this[n]) {\n\t\t\t\to[n] = this[n];\n\t\t\t\tchange = true;\n\t\t\t}\n\t\t}\n\t\tif (!change) { return; }\n\t\t\n\t\tvar hasSpace = !!this._getFrame(\" \", ss);\n\t\tif (!hasSpace && !spaceW) { spaceW = this._getSpaceWidth(ss); }\n\t\tif (!lineH) { lineH = this._getLineHeight(ss); }\n\t\t\n\t\tfor(var i=0, l=this.text.length; i<l; i++) {\n\t\t\tvar character = this.text.charAt(i);\n\t\t\tif (character == \" \" && !hasSpace) {\n\t\t\t\tx += spaceW;\n\t\t\t\tcontinue;\n\t\t\t} else if (character==\"\\n\" || character==\"\\r\") {\n\t\t\t\tif (character==\"\\r\" && this.text.charAt(i+1) == \"\\n\") { i++; } // crlf\n\t\t\t\tx = 0;\n\t\t\t\ty += lineH;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar index = this._getFrameIndex(character, ss);\n\t\t\tif (index == null) { continue; }\n\t\t\t\n\t\t\tif (childIndex < numKids) {\n\t\t\t\tsprite = kids[childIndex];\n\t\t\t} else {\n\t\t\t\tkids.push(sprite = pool.length ? pool.pop() : new createjs.Sprite());\n\t\t\t\tsprite.parent = this;\n\t\t\t\tnumKids++;\n\t\t\t}\n\t\t\tsprite.spriteSheet = ss;\n\t\t\tsprite.gotoAndStop(index);\n\t\t\tsprite.x = x;\n\t\t\tsprite.y = y;\n\t\t\tchildIndex++;\n\t\t\t\n\t\t\tx += sprite.getBounds().width + this.letterSpacing;\n\t\t}\n\t\twhile (numKids > childIndex) {\n\t\t\t // faster than removeChild.\n\t\t\tpool.push(sprite = kids.pop());\n\t\t\tsprite.parent = null;\n\t\t\tnumKids--;\n\t\t}\n\t\tif (pool.length > BitmapText.maxPoolSize) { pool.length = BitmapText.maxPoolSize; }\n\t};\n\n\n\tcreatejs.BitmapText = createjs.promote(BitmapText, \"Container\");\n}());\n\n//##############################################################################\n// MovieClip.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * The MovieClip class associates a TweenJS Timeline with an EaselJS {{#crossLink \"Container\"}}{{/crossLink}}. It allows\n\t * you to create objects which encapsulate timeline animations, state changes, and synched actions. Due to the\n\t * complexities inherent in correctly setting up a MovieClip, it is largely intended for tool output and is not included\n\t * in the main EaselJS library.\n\t *\n\t * Currently MovieClip only works properly if it is tick based (as opposed to time based) though some concessions have\n\t * been made to support time-based timelines in the future.\n\t *\n\t * <h4>Example</h4>\n\t * This example animates two shapes back and forth. The grey shape starts on the left, but we jump to a mid-point in\n\t * the animation using {{#crossLink \"MovieClip/gotoAndPlay\"}}{{/crossLink}}.\n\t *\n\t *      var stage = new createjs.Stage(\"canvas\");\n\t *      createjs.Ticker.addEventListener(\"tick\", stage);\n\t *\n\t *      var mc = new createjs.MovieClip(null, 0, true, {start:20});\n\t *      stage.addChild(mc);\n\t *\n\t *      var child1 = new createjs.Shape(\n\t *          new createjs.Graphics().beginFill(\"#999999\")\n\t *              .drawCircle(30,30,30));\n\t *      var child2 = new createjs.Shape(\n\t *          new createjs.Graphics().beginFill(\"#5a9cfb\")\n\t *              .drawCircle(30,30,30));\n\t *\n\t *      mc.timeline.addTween(\n\t *          createjs.Tween.get(child1)\n\t *              .to({x:0}).to({x:60}, 50).to({x:0}, 50));\n\t *      mc.timeline.addTween(\n\t *          createjs.Tween.get(child2)\n\t *              .to({x:60}).to({x:0}, 50).to({x:60}, 50));\n\t *\n\t *      mc.gotoAndPlay(\"start\");\n\t *\n\t * It is recommended to use <code>tween.to()</code> to animate and set properties (use no duration to have it set\n\t * immediately), and the <code>tween.wait()</code> method to create delays between animations. Note that using the\n\t * <code>tween.set()</code> method to affect properties will likely not provide the desired result.\n\t *\n\t * @class MovieClip\n\t * @main MovieClip\n\t * @extends Container\n\t * @constructor\n\t * @param {String} [mode=independent] Initial value for the mode property. One of {{#crossLink \"MovieClip/INDEPENDENT:property\"}}{{/crossLink}},\n\t * {{#crossLink \"MovieClip/SINGLE_FRAME:property\"}}{{/crossLink}}, or {{#crossLink \"MovieClip/SYNCHED:property\"}}{{/crossLink}}.\n\t * The default is {{#crossLink \"MovieClip/INDEPENDENT:property\"}}{{/crossLink}}.\n\t * @param {Number} [startPosition=0] Initial value for the {{#crossLink \"MovieClip/startPosition:property\"}}{{/crossLink}}\n\t * property.\n\t * @param {Boolean} [loop=true] Initial value for the {{#crossLink \"MovieClip/loop:property\"}}{{/crossLink}}\n\t * property. The default is `true`.\n\t * @param {Object} [labels=null] A hash of labels to pass to the {{#crossLink \"MovieClip/timeline:property\"}}{{/crossLink}}\n\t * instance associated with this MovieClip. Labels only need to be passed if they need to be used.\n\t **/\n\tfunction MovieClip(mode, startPosition, loop, labels) {\n\t\tthis.Container_constructor();\n\t\t!MovieClip.inited&&MovieClip.init(); // static init\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * Controls how this MovieClip advances its time. Must be one of 0 (INDEPENDENT), 1 (SINGLE_FRAME), or 2 (SYNCHED).\n\t\t * See each constant for a description of the behaviour.\n\t\t * @property mode\n\t\t * @type String\n\t\t * @default null\n\t\t **/\n\t\tthis.mode = mode||MovieClip.INDEPENDENT;\n\t\n\t\t/**\n\t\t * Specifies what the first frame to play in this movieclip, or the only frame to display if mode is SINGLE_FRAME.\n\t\t * @property startPosition\n\t\t * @type Number\n\t\t * @default 0\n\t\t */\n\t\tthis.startPosition = startPosition || 0;\n\t\n\t\t/**\n\t\t * Indicates whether this MovieClip should loop when it reaches the end of its timeline.\n\t\t * @property loop\n\t\t * @type Boolean\n\t\t * @default true\n\t\t */\n\t\tthis.loop = loop;\n\t\n\t\t/**\n\t\t * The current frame of the movieclip.\n\t\t * @property currentFrame\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @readonly\n\t\t */\n\t\tthis.currentFrame = 0;\n\t\n\t\t/**\n\t\t * The TweenJS Timeline that is associated with this MovieClip. This is created automatically when the MovieClip\n\t\t * instance is initialized. Animations are created by adding <a href=\"http://tweenjs.com\">TweenJS</a> Tween\n\t\t * instances to the timeline.\n\t\t *\n\t\t * <h4>Example</h4>\n\t\t *\n\t\t *      var tween = createjs.Tween.get(target).to({x:0}).to({x:100}, 30);\n\t\t *      var mc = new createjs.MovieClip();\n\t\t *      mc.timeline.addTween(tween);\n\t\t *\n\t\t * Elements can be added and removed from the timeline by toggling an \"_off\" property\n\t\t * using the <code>tweenInstance.to()</code> method. Note that using <code>Tween.set</code> is not recommended to\n\t\t * create MovieClip animations. The following example will toggle the target off on frame 0, and then back on for\n\t\t * frame 1. You can use the \"visible\" property to achieve the same effect.\n\t\t *\n\t\t *      var tween = createjs.Tween.get(target).to({_off:false})\n\t\t *          .wait(1).to({_off:true})\n\t\t *          .wait(1).to({_off:false});\n\t\t *\n\t\t * @property timeline\n\t\t * @type Timeline\n\t\t * @default null\n\t\t */\n\t\tthis.timeline = new createjs.Timeline(null, labels, {paused:true, position:startPosition, useTicks:true});\n\t\n\t\t/**\n\t\t * If true, the MovieClip's position will not advance when ticked.\n\t\t * @property paused\n\t\t * @type Boolean\n\t\t * @default false\n\t\t */\n\t\tthis.paused = false;\n\t\n\t\t/**\n\t\t * If true, actions in this MovieClip's tweens will be run when the playhead advances.\n\t\t * @property actionsEnabled\n\t\t * @type Boolean\n\t\t * @default true\n\t\t */\n\t\tthis.actionsEnabled = true;\n\t\n\t\t/**\n\t\t * If true, the MovieClip will automatically be reset to its first frame whenever the timeline adds\n\t\t * it back onto the display list. This only applies to MovieClip instances with mode=INDEPENDENT.\n\t\t * <br><br>\n\t\t * For example, if you had a character animation with a \"body\" child MovieClip instance\n\t\t * with different costumes on each frame, you could set body.autoReset = false, so that\n\t\t * you can manually change the frame it is on, without worrying that it will be reset\n\t\t * automatically.\n\t\t * @property autoReset\n\t\t * @type Boolean\n\t\t * @default true\n\t\t */\n\t\tthis.autoReset = true;\n\t\t\n\t\t/**\n\t\t * An array of bounds for each frame in the MovieClip. This is mainly intended for tool output.\n\t\t * @property frameBounds\n\t\t * @type Array\n\t\t * @default null\n\t\t */\n\t\tthis.frameBounds = this.frameBounds||null; // TODO: Deprecated. This is for backwards support of FlashCC\n\t\t\n\t\t/**\n\t\t * By default MovieClip instances advance one frame per tick. Specifying a framerate for the MovieClip\n\t\t * will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\n\t\t * framerate.\n\t\t *\n\t\t * For example, if a MovieClip with a framerate of 10 is placed on a Stage being updated at 40fps, then the MovieClip will\n\t\t * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will\n\t\t * vary slightly between frames.\n\t\t *\n\t\t * This feature is dependent on the tick event object (or an object with an appropriate \"delta\" property) being\n\t\t * passed into {{#crossLink \"Stage/update\"}}{{/crossLink}}.\n\t\t * @property framerate\n\t\t * @type {Number}\n\t\t * @default null\n\t\t **/\n\t\tthis.framerate = null;\n\t\t\n\t\t\n\t// private properties:\n\t\t/**\n\t\t * @property _synchOffset\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @private\n\t\t */\n\t\tthis._synchOffset = 0;\n\t\n\t\t/**\n\t\t * @property _prevPos\n\t\t * @type Number\n\t\t * @default -1\n\t\t * @private\n\t\t */\n\t\tthis._prevPos = -1; // TODO: evaluate using a ._reset Boolean prop instead of -1.\n\t\n\t\t/**\n\t\t * @property _prevPosition\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @private\n\t\t */\n\t\tthis._prevPosition = 0;\n\t\n\t\t/**\n\t\t * The time remaining from the previous tick, only applicable when .framerate is set.\n\t\t * @property _t\n\t\t * @type Number\n\t\t * @private\n\t\t */\n\t\tthis._t = 0;\n\t\n\t\t/**\n\t\t * List of display objects that are actively being managed by the MovieClip.\n\t\t * @property _managed\n\t\t * @type Object\n\t\t * @private\n\t\t */\n\t\tthis._managed = {};\n\t}\n\tvar p = createjs.extend(MovieClip, createjs.Container);\n\n\n// constants:\n\t/**\n\t * The MovieClip will advance independently of its parent, even if its parent is paused.\n\t * This is the default mode.\n\t * @property INDEPENDENT\n\t * @static\n\t * @type String\n\t * @default \"independent\"\n\t * @readonly\n\t **/\n\tMovieClip.INDEPENDENT = \"independent\";\n\n\t/**\n\t * The MovieClip will only display a single frame (as determined by the startPosition property).\n\t * @property SINGLE_FRAME\n\t * @static\n\t * @type String\n\t * @default \"single\"\n\t * @readonly\n\t **/\n\tMovieClip.SINGLE_FRAME = \"single\";\n\n\t/**\n\t * The MovieClip will be advanced only when its parent advances and will be synched to the position of\n\t * the parent MovieClip.\n\t * @property SYNCHED\n\t * @static\n\t * @type String\n\t * @default \"synched\"\n\t * @readonly\n\t **/\n\tMovieClip.SYNCHED = \"synched\";\n\t\n\t\n// static properties:\n\tMovieClip.inited = false;\n\t\n\t\n// static methods:\n\tMovieClip.init = function() {\n\t\tif (MovieClip.inited) { return; }\n\t\t// plugins introduce some overhead to Tween, so we only install this if an MC is instantiated.\n\t\tMovieClipPlugin.install();\n\t\tMovieClip.inited = true;\n\t};\n\t\n\t\n// getter / setters:\n\t/**\n\t * Use the {{#crossLink \"MovieClip/labels:property\"}}{{/crossLink}} property instead.\n\t * @method getLabels\n\t * @return {Array}\n\t * @deprecated\n\t **/\n\tp.getLabels = function() {\n\t\treturn this.timeline.getLabels();\n\t};\n\t\n\t/**\n\t * Use the {{#crossLink \"MovieClip/currentLabel:property\"}}{{/crossLink}} property instead.\n\t * @method getCurrentLabel\n\t * @return {String}\n\t * @deprecated\n\t **/\n\tp.getCurrentLabel = function() {\n\t\tthis._updateTimeline();\n\t\treturn this.timeline.getCurrentLabel();\n\t};\n\t\n\t/**\n\t * Use the {{#crossLink \"MovieClip/duration:property\"}}{{/crossLink}} property instead.\n\t * @method getDuration\n\t * @return {Number}\n\t * @protected\n\t **/\n\tp.getDuration = function() {\n\t\treturn this.timeline.duration;\n\t};\n\n\t/**\n\t * Returns an array of objects with label and position (aka frame) properties, sorted by position.\n\t * Shortcut to TweenJS: Timeline.getLabels();\n\t * @property labels\n\t * @type {Array}\n\t * @readonly\n\t **/\n\t\n\t/**\n\t * Returns the name of the label on or immediately before the current frame. See TweenJS: Timeline.getCurrentLabel()\n\t * for more information.\n\t * @property currentLabel\n\t * @type {String}\n\t * @readonly\n\t **/\n\t\n\t/**\n\t * Returns the duration of this MovieClip in seconds or ticks. Identical to {{#crossLink \"MovieClip/duration:property\"}}{{/crossLink}}\n\t * and provided for Flash API compatibility.\n\t * @property totalFrames\n\t * @type {Number}\n\t * @readonly\n\t **/\n\t\n\t/**\n\t * Returns the duration of this MovieClip in seconds or ticks.\n\t * @property duration\n\t * @type {Number}\n\t * @readonly\n\t **/\n\ttry {\n\t\tObject.defineProperties(p, {\n\t\t\tlabels: { get: p.getLabels },\n\t\t\tcurrentLabel: { get: p.getCurrentLabel },\n\t\t\ttotalFrames: { get: p.getDuration },\n\t\t\tduration: { get: p.getDuration }\n\t\t});\n\t} catch (e) {}\n\n\n// public methods:\n\t/**\n\t * Constructor alias for backwards compatibility. This method will be removed in future versions.\n\t * Subclasses should be updated to use {{#crossLink \"Utility Methods/extends\"}}{{/crossLink}}.\n\t * @method initialize\n\t * @deprecated in favour of `createjs.promote()`\n\t **/\n\tp.initialize = MovieClip; // TODO: Deprecated. This is for backwards support of FlashCC\n\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t **/\n\tp.isVisible = function() {\n\t\t// children are placed in draw, so we can't determine if we have content.\n\t\treturn !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0);\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t **/\n\tp.draw = function(ctx, ignoreCache) {\n\t\t// draw to cache first:\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\t\tthis._updateTimeline();\n\t\tthis.Container_draw(ctx, ignoreCache);\n\t\treturn true;\n\t};\n\t\n\t/**\n\t * Sets paused to false.\n\t * @method play\n\t **/\n\tp.play = function() {\n\t\tthis.paused = false;\n\t};\n\t\n\t/**\n\t * Sets paused to true.\n\t * @method stop\n\t **/\n\tp.stop = function() {\n\t\tthis.paused = true;\n\t};\n\t\n\t/**\n\t * Advances this movie clip to the specified position or label and sets paused to false.\n\t * @method gotoAndPlay\n\t * @param {String|Number} positionOrLabel The animation name or frame number to go to.\n\t **/\n\tp.gotoAndPlay = function(positionOrLabel) {\n\t\tthis.paused = false;\n\t\tthis._goto(positionOrLabel);\n\t};\n\t\n\t/**\n\t * Advances this movie clip to the specified position or label and sets paused to true.\n\t * @method gotoAndStop\n\t * @param {String|Number} positionOrLabel The animation or frame name to go to.\n\t **/\n\tp.gotoAndStop = function(positionOrLabel) {\n\t\tthis.paused = true;\n\t\tthis._goto(positionOrLabel);\n\t};\n\t\n\t/**\n\t * Advances the playhead. This occurs automatically each tick by default.\n\t * @param [time] {Number} The amount of time in ms to advance by. Only applicable if framerate is set.\n\t * @method advance\n\t*/\n\tp.advance = function(time) {\n\t\t// TODO: should we worry at all about clips who change their own modes via frame scripts?\n\t\tvar independent = MovieClip.INDEPENDENT;\n\t\tif (this.mode != independent) { return; }\n\t\t\n\t\tvar o=this, fps = o.framerate;\n\t\twhile ((o = o.parent) && fps == null) {\n\t\t\tif (o.mode == independent) { fps = o._framerate; }\n\t\t}\n\t\tthis._framerate = fps;\n\t\t\n\t\tvar t = (fps != null && fps != -1 && time != null) ? time/(1000/fps) + this._t : 1;\n\t\tvar frames = t|0;\n\t\tthis._t = t-frames; // leftover time\n\t\t\n\t\twhile (!this.paused && frames--) {\n\t\t\tthis._prevPosition = (this._prevPos < 0) ? 0 : this._prevPosition+1;\n\t\t\tthis._updateTimeline();\n\t\t}\n\t};\n\t\n\t/**\n\t * MovieClip instances cannot be cloned.\n\t * @method clone\n\t **/\n\tp.clone = function() {\n\t\t// TODO: add support for this? Need to clone the Timeline & retarget tweens - pretty complex.\n\t\tthrow(\"MovieClip cannot be cloned.\")\n\t};\n\t\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[MovieClip (name=\"+  this.name +\")]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _tick\n\t * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.\n\t * function.\n\t * @protected\n\t **/\n\tp._tick = function(evtObj) {\n\t\tthis.advance(evtObj&&evtObj.delta);\n\t\tthis.Container__tick(evtObj);\n\t};\n\t\n\t/**\n\t * @method _goto\n\t * @param {String|Number} positionOrLabel The animation name or frame number to go to.\n\t * @protected\n\t **/\n\tp._goto = function(positionOrLabel) {\n\t\tvar pos = this.timeline.resolve(positionOrLabel);\n\t\tif (pos == null) { return; }\n\t\t// prevent _updateTimeline from overwriting the new position because of a reset:\n\t\tif (this._prevPos == -1) { this._prevPos = NaN; }\n\t\tthis._prevPosition = pos;\n\t\tthis._t = 0;\n\t\tthis._updateTimeline();\n\t};\n\t\n\t/**\n\t * @method _reset\n\t * @private\n\t **/\n\tp._reset = function() {\n\t\tthis._prevPos = -1;\n\t\tthis._t = this.currentFrame = 0;\n\t\tthis.paused = false;\n\t};\n\t\n\t/**\n\t * @method _updateTimeline\n\t * @protected\n\t **/\n\tp._updateTimeline = function() {\n\t\tvar tl = this.timeline;\n\t\tvar synched = this.mode != MovieClip.INDEPENDENT;\n\t\ttl.loop = (this.loop==null) ? true : this.loop;\n\t\t\n\t\tvar pos = synched ? this.startPosition + (this.mode==MovieClip.SINGLE_FRAME?0:this._synchOffset) : (this._prevPos < 0 ? 0 : this._prevPosition);\n\t\tvar mode = synched || !this.actionsEnabled ? createjs.Tween.NONE : null;\n\t\t\n\t\t// pre-assign currentFrame so it is available to frame scripts:\n\t\tthis.currentFrame = tl._calcPosition(pos);\n\t\t\n\t\t// update timeline position, ignoring actions if this is a graphic.\n\t\ttl.setPosition(pos, mode);\n\n\t\tthis._prevPosition = tl._prevPosition;\n\t\tif (this._prevPos == tl._prevPos) { return; }\n\t\tthis.currentFrame = this._prevPos = tl._prevPos;\n\n\t\tfor (var n in this._managed) { this._managed[n] = 1; }\n\n\t\tvar tweens = tl._tweens;\n\t\tfor (var i=0, l=tweens.length; i<l; i++) {\n\t\t\tvar tween = tweens[i];\n\t\t\tvar target = tween._target;\n\t\t\tif (target == this || tween.passive) { continue; } // TODO: this assumes actions tween has this as the target. Valid?\n\t\t\tvar offset = tween._stepPosition;\n\n\t\t\tif (target instanceof createjs.DisplayObject) {\n\t\t\t\t// motion tween.\n\t\t\t\tthis._addManagedChild(target, offset);\n\t\t\t} else {\n\t\t\t\t// state tween.\n\t\t\t\tthis._setState(target.state, offset);\n\t\t\t}\n\t\t}\n\n\t\tvar kids = this.children;\n\t\tfor (i=kids.length-1; i>=0; i--) {\n\t\t\tvar id = kids[i].id;\n\t\t\tif (this._managed[id] == 1) {\n\t\t\t\tthis.removeChildAt(i);\n\t\t\t\tdelete(this._managed[id]);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _setState\n\t * @param {Array} state\n\t * @param {Number} offset\n\t * @protected\n\t **/\n\tp._setState = function(state, offset) {\n\t\tif (!state) { return; }\n\t\tfor (var i=state.length-1;i>=0;i--) {\n\t\t\tvar o = state[i];\n\t\t\tvar target = o.t;\n\t\t\tvar props = o.p;\n\t\t\tfor (var n in props) { target[n] = props[n]; }\n\t\t\tthis._addManagedChild(target, offset);\n\t\t}\n\t};\n\n\t/**\n\t * Adds a child to the timeline, and sets it up as a managed child.\n\t * @method _addManagedChild\n\t * @param {MovieClip} child The child MovieClip to manage\n\t * @param {Number} offset\n\t * @private\n\t **/\n\tp._addManagedChild = function(child, offset) {\n\t\tif (child._off) { return; }\n\t\tthis.addChildAt(child,0);\n\n\t\tif (child instanceof MovieClip) {\n\t\t\tchild._synchOffset = offset;\n\t\t\t// TODO: this does not precisely match Flash. Flash loses track of the clip if it is renamed or removed from the timeline, which causes it to reset.\n\t\t\tif (child.mode == MovieClip.INDEPENDENT && child.autoReset && !this._managed[child.id]) { child._reset(); }\n\t\t}\n\t\tthis._managed[child.id] = 2;\n\t};\n\t\n\t/**\n\t * @method _getBounds\n\t * @param {Matrix2D} matrix\n\t * @param {Boolean} ignoreTransform\n\t * @return {Rectangle}\n\t * @protected\n\t **/\n\tp._getBounds = function(matrix, ignoreTransform) {\n\t\tvar bounds = this.DisplayObject_getBounds();\n\t\tif (!bounds) {\n\t\t\tthis._updateTimeline();\n\t\t\tif (this.frameBounds) { bounds = this._rectangle.copy(this.frameBounds[this.currentFrame]); }\n\t\t}\n\t\tif (bounds) { return this._transformBounds(bounds, matrix, ignoreTransform); }\n\t\treturn this.Container__getBounds(matrix, ignoreTransform);\n\t};\n\n\n\tcreatejs.MovieClip = createjs.promote(MovieClip, \"Container\");\n\n\n\n// MovieClipPlugin for TweenJS:\n\t/**\n\t * This plugin works with <a href=\"http://tweenjs.com\" target=\"_blank\">TweenJS</a> to prevent the startPosition\n\t * property from tweening.\n\t * @private\n\t * @class MovieClipPlugin\n\t * @constructor\n\t **/\n\tfunction MovieClipPlugin() {\n\t\tthrow(\"MovieClipPlugin cannot be instantiated.\")\n\t}\n\t\n\t/**\n\t * @method priority\n\t * @private\n\t **/\n\tMovieClipPlugin.priority = 100; // very high priority, should run first\n\n\t/**\n\t * @method install\n\t * @private\n\t **/\n\tMovieClipPlugin.install = function() {\n\t\tcreatejs.Tween.installPlugin(MovieClipPlugin, [\"startPosition\"]);\n\t};\n\t\n\t/**\n\t * @method init\n\t * @param {Tween} tween\n\t * @param {String} prop\n\t * @param {String|Number|Boolean} value\n\t * @private\n\t **/\n\tMovieClipPlugin.init = function(tween, prop, value) {\n\t\treturn value;\n\t};\n\t\n\t/**\n\t * @method step\n\t * @private\n\t **/\n\tMovieClipPlugin.step = function() {\n\t\t// unused.\n\t};\n\n\t/**\n\t * @method tween\n\t * @param {Tween} tween\n\t * @param {String} prop\n\t * @param {String | Number | Boolean} value\n\t * @param {Array} startValues\n\t * @param {Array} endValues\n\t * @param {Number} ratio\n\t * @param {Object} wait\n\t * @param {Object} end\n\t * @return {*}\n\t */\n\tMovieClipPlugin.tween = function(tween, prop, value, startValues, endValues, ratio, wait, end) {\n\t\tif (!(tween.target instanceof MovieClip)) { return value; }\n\t\treturn (ratio == 1 ? endValues[prop] : startValues[prop]);\n\t};\n\n}());\n\n//##############################################################################\n// SpriteSheetUtils.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\t\n\t\n// constructor:\n\t/**\n\t * The SpriteSheetUtils class is a collection of static methods for working with {{#crossLink \"SpriteSheet\"}}{{/crossLink}}s.\n\t * A sprite sheet is a series of images (usually animation frames) combined into a single image on a regular grid. For\n\t * example, an animation consisting of 8 100x100 images could be combined into a 400x200 sprite sheet (4 frames across\n\t * by 2 high). The SpriteSheetUtils class uses a static interface and should not be instantiated.\n\t * @class SpriteSheetUtils\n\t * @static\n\t **/\n\tfunction SpriteSheetUtils() {\n\t\tthrow \"SpriteSheetUtils cannot be instantiated\";\n\t}\n\n\n// private static properties:\n\t/**\n\t * @property _workingCanvas\n\t * @static\n\t * @type HTMLCanvasElement | Object\n\t * @protected\n\t*/\n\t/**\n\t * @property _workingContext\n\t * @static\n\t * @type CanvasRenderingContext2D\n\t * @protected\n\t*/\n\tvar canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement(\"canvas\"));\n\tif (canvas.getContext) {\n\t\tSpriteSheetUtils._workingCanvas = canvas;\n\t\tSpriteSheetUtils._workingContext = canvas.getContext(\"2d\");\n\t\tcanvas.width = canvas.height = 1;\n\t}\n\n\n// public static methods:\n\t/**\n\t * <b>This is an experimental method, and may be buggy. Please report issues.</b><br/><br/>\n\t * Extends the existing sprite sheet by flipping the original frames horizontally, vertically, or both,\n\t * and adding appropriate animation & frame data. The flipped animations will have a suffix added to their names\n\t * (_h, _v, _hv as appropriate). Make sure the sprite sheet images are fully loaded before using this method.\n\t * <br/><br/>\n\t * For example:<br/>\n\t * SpriteSheetUtils.addFlippedFrames(mySpriteSheet, true, true);\n\t * The above would add frames that are flipped horizontally AND frames that are flipped vertically.\n\t * <br/><br/>\n\t * Note that you can also flip any display object by setting its scaleX or scaleY to a negative value. On some\n\t * browsers (especially those without hardware accelerated canvas) this can result in slightly degraded performance,\n\t * which is why addFlippedFrames is available.\n\t * @method addFlippedFrames\n\t * @static\n\t * @param {SpriteSheet} spriteSheet\n\t * @param {Boolean} horizontal If true, horizontally flipped frames will be added.\n\t * @param {Boolean} vertical If true, vertically flipped frames will be added.\n\t * @param {Boolean} both If true, frames that are flipped both horizontally and vertically will be added.\n\t * @deprecated Modern browsers perform better when flipping via a transform (ex. scaleX=-1) rendering this obsolete.\n\t **/\n\tSpriteSheetUtils.addFlippedFrames = function(spriteSheet, horizontal, vertical, both) {\n\t\tif (!horizontal && !vertical && !both) { return; }\n\n\t\tvar count = 0;\n\t\tif (horizontal) { SpriteSheetUtils._flip(spriteSheet,++count,true,false); }\n\t\tif (vertical) { SpriteSheetUtils._flip(spriteSheet,++count,false,true); }\n\t\tif (both) { SpriteSheetUtils._flip(spriteSheet,++count,true,true); }\n\t};\n\n\t/**\n\t * Returns a single frame of the specified sprite sheet as a new PNG image. An example of when this may be useful is\n\t * to use a spritesheet frame as the source for a bitmap fill.\n\t *\n\t * <strong>WARNING:</strong> In almost all cases it is better to display a single frame using a {{#crossLink \"Sprite\"}}{{/crossLink}}\n\t * with a {{#crossLink \"Sprite/gotoAndStop\"}}{{/crossLink}} call than it is to slice out a frame using this\n\t * method and display it with a Bitmap instance. You can also crop an image using the {{#crossLink \"Bitmap/sourceRect\"}}{{/crossLink}}\n\t * property of {{#crossLink \"Bitmap\"}}{{/crossLink}}.\n\t *\n\t * The extractFrame method may cause cross-domain warnings since it accesses pixels directly on the canvas.\n\t * @method extractFrame\n\t * @static\n\t * @param {SpriteSheet} spriteSheet The SpriteSheet instance to extract a frame from.\n\t * @param {Number|String} frameOrAnimation The frame number or animation name to extract. If an animation\n\t * name is specified, only the first frame of the animation will be extracted.\n\t * @return {HTMLImageElement} a single frame of the specified sprite sheet as a new PNG image.\n\t*/\n\tSpriteSheetUtils.extractFrame = function(spriteSheet, frameOrAnimation) {\n\t\tif (isNaN(frameOrAnimation)) {\n\t\t\tframeOrAnimation = spriteSheet.getAnimation(frameOrAnimation).frames[0];\n\t\t}\n\t\tvar data = spriteSheet.getFrame(frameOrAnimation);\n\t\tif (!data) { return null; }\n\t\tvar r = data.rect;\n\t\tvar canvas = SpriteSheetUtils._workingCanvas;\n\t\tcanvas.width = r.width;\n\t\tcanvas.height = r.height;\n\t\tSpriteSheetUtils._workingContext.drawImage(data.image, r.x, r.y, r.width, r.height, 0, 0, r.width, r.height);\n\t\tvar img = document.createElement(\"img\");\n\t\timg.src = canvas.toDataURL(\"image/png\");\n\t\treturn img;\n\t};\n\n\t/**\n\t * Merges the rgb channels of one image with the alpha channel of another. This can be used to combine a compressed\n\t * JPEG image containing color data with a PNG32 monochromatic image containing alpha data. With certain types of\n\t * images (those with detail that lend itself to JPEG compression) this can provide significant file size savings\n\t * versus a single RGBA PNG32. This method is very fast (generally on the order of 1-2 ms to run).\n\t * @method mergeAlpha\n\t * @static\n\t * @param {HTMLImageElement} rbgImage The image (or canvas) containing the RGB channels to use.\n\t * @param {HTMLImageElement} alphaImage The image (or canvas) containing the alpha channel to use.\n\t * @param {HTMLCanvasElement} canvas Optional. If specified, this canvas will be used and returned. If not, a new canvas will be created.\n\t * @return {HTMLCanvasElement} A canvas with the combined image data. This can be used as a source for Bitmap or SpriteSheet.\n\t * @deprecated Tools such as ImageAlpha generally provide better results. This will be moved to sandbox in the future.\n\t*/\n\tSpriteSheetUtils.mergeAlpha = function(rgbImage, alphaImage, canvas) {\n\t\tif (!canvas) { canvas = createjs.createCanvas?createjs.createCanvas():document.createElement(\"canvas\"); }\n\t\tcanvas.width = Math.max(alphaImage.width, rgbImage.width);\n\t\tcanvas.height = Math.max(alphaImage.height, rgbImage.height);\n\t\tvar ctx = canvas.getContext(\"2d\");\n\t\tctx.save();\n\t\tctx.drawImage(rgbImage,0,0);\n\t\tctx.globalCompositeOperation = \"destination-in\";\n\t\tctx.drawImage(alphaImage,0,0);\n\t\tctx.restore();\n\t\treturn canvas;\n\t};\n\n\n// private static methods:\n\tSpriteSheetUtils._flip = function(spriteSheet, count, h, v) {\n\t\tvar imgs = spriteSheet._images;\n\t\tvar canvas = SpriteSheetUtils._workingCanvas;\n\t\tvar ctx = SpriteSheetUtils._workingContext;\n\t\tvar il = imgs.length/count;\n\t\tfor (var i=0;i<il;i++) {\n\t\t\tvar src = imgs[i];\n\t\t\tsrc.__tmp = i; // a bit hacky, but faster than doing indexOf below.\n\t\t\tctx.setTransform(1,0,0,1,0,0);\n\t\t\tctx.clearRect(0,0,canvas.width+1,canvas.height+1);\n\t\t\tcanvas.width = src.width;\n\t\t\tcanvas.height = src.height;\n\t\t\tctx.setTransform(h?-1:1, 0, 0, v?-1:1, h?src.width:0, v?src.height:0);\n\t\t\tctx.drawImage(src,0,0);\n\t\t\tvar img = document.createElement(\"img\");\n\t\t\timg.src = canvas.toDataURL(\"image/png\");\n\t\t\t// work around a strange bug in Safari:\n\t\t\timg.width = src.width;\n\t\t\timg.height = src.height;\n\t\t\timgs.push(img);\n\t\t}\n\n\t\tvar frames = spriteSheet._frames;\n\t\tvar fl = frames.length/count;\n\t\tfor (i=0;i<fl;i++) {\n\t\t\tsrc = frames[i];\n\t\t\tvar rect = src.rect.clone();\n\t\t\timg = imgs[src.image.__tmp+il*count];\n\n\t\t\tvar frame = {image:img,rect:rect,regX:src.regX,regY:src.regY};\n\t\t\tif (h) {\n\t\t\t\trect.x = img.width-rect.x-rect.width; // update rect\n\t\t\t\tframe.regX = rect.width-src.regX; // update registration point\n\t\t\t}\n\t\t\tif (v) {\n\t\t\t\trect.y = img.height-rect.y-rect.height;  // update rect\n\t\t\t\tframe.regY = rect.height-src.regY; // update registration point\n\t\t\t}\n\t\t\tframes.push(frame);\n\t\t}\n\n\t\tvar sfx = \"_\"+(h?\"h\":\"\")+(v?\"v\":\"\");\n\t\tvar names = spriteSheet._animations;\n\t\tvar data = spriteSheet._data;\n\t\tvar al = names.length/count;\n\t\tfor (i=0;i<al;i++) {\n\t\t\tvar name = names[i];\n\t\t\tsrc = data[name];\n\t\t\tvar anim = {name:name+sfx,speed:src.speed,next:src.next,frames:[]};\n\t\t\tif (src.next) { anim.next += sfx; }\n\t\t\tframes = src.frames;\n\t\t\tfor (var j=0,l=frames.length;j<l;j++) {\n\t\t\t\tanim.frames.push(frames[j]+fl*count);\n\t\t\t}\n\t\t\tdata[anim.name] = anim;\n\t\t\tnames.push(anim.name);\n\t\t}\n\t};\n\n\n\tcreatejs.SpriteSheetUtils = SpriteSheetUtils;\n}());\n\n//##############################################################################\n// SpriteSheetBuilder.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * The SpriteSheetBuilder allows you to generate {{#crossLink \"SpriteSheet\"}}{{/crossLink}} instances at run time\n\t * from any display object. This can allow you to maintain your assets as vector graphics (for low file size), and\n\t * render them at run time as SpriteSheets for better performance.\n\t *\n\t * SpriteSheets can be built either synchronously, or asynchronously, so that large SpriteSheets can be generated\n\t * without locking the UI.\n\t *\n\t * Note that the \"images\" used in the generated SpriteSheet are actually canvas elements, and that they will be\n\t * sized to the nearest power of 2 up to the value of {{#crossLink \"SpriteSheetBuilder/maxWidth:property\"}}{{/crossLink}}\n\t * or {{#crossLink \"SpriteSheetBuilder/maxHeight:property\"}}{{/crossLink}}.\n\t * @class SpriteSheetBuilder\n\t * @param {Number} [framerate=0] The {{#crossLink \"SpriteSheet/framerate:property\"}}{{/crossLink}} of\n\t * {{#crossLink \"SpriteSheet\"}}{{/crossLink}} instances that are created.\n\t * @extends EventDispatcher\n\t * @constructor\n\t **/\n\tfunction SpriteSheetBuilder(framerate) {\n\t\tthis.EventDispatcher_constructor();\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The maximum width for the images (not individual frames) in the generated SpriteSheet. It is recommended to\n\t\t * use a power of 2 for this value (ex. 1024, 2048, 4096). If the frames cannot all fit within the max\n\t\t * dimensions, then additional images will be created as needed.\n\t\t * @property maxWidth\n\t\t * @type Number\n\t\t * @default 2048\n\t\t*/\n\t\tthis.maxWidth = 2048;\n\t\n\t\t/**\n\t\t * The maximum height for the images (not individual frames) in the generated SpriteSheet. It is recommended to\n\t\t * use a power of 2 for this value (ex. 1024, 2048, 4096). If the frames cannot all fit within the max\n\t\t * dimensions, then additional images will be created as needed.\n\t\t * @property maxHeight\n\t\t * @type Number\n\t\t * @default 2048\n\t\t **/\n\t\tthis.maxHeight = 2048;\n\t\n\t\t/**\n\t\t * The SpriteSheet that was generated. This will be null before a build is completed successfully.\n\t\t * @property spriteSheet\n\t\t * @type SpriteSheet\n\t\t **/\n\t\tthis.spriteSheet = null;\n\t\n\t\t/**\n\t\t * The scale to apply when drawing all frames to the SpriteSheet. This is multiplied against any scale specified\n\t\t * in the addFrame call. This can be used, for example, to generate a SpriteSheet at run time that is tailored\n\t\t * to the a specific device resolution (ex. tablet vs mobile).\n\t\t * @property scale\n\t\t * @type Number\n\t\t * @default 1\n\t\t **/\n\t\tthis.scale = 1;\n\t\n\t\t/**\n\t\t* The padding to use between frames. This is helpful to preserve antialiasing on drawn vector content.\n\t\t* @property padding\n\t\t* @type Number\n\t\t* @default 1\n\t\t**/\n\t\tthis.padding = 1;\n\t\n\t\t/**\n\t\t * A number from 0.01 to 0.99 that indicates what percentage of time the builder can use. This can be\n\t\t * thought of as the number of seconds per second the builder will use. For example, with a timeSlice value of 0.3,\n\t\t * the builder will run 20 times per second, using approximately 15ms per build (30% of available time, or 0.3s per second).\n\t\t * Defaults to 0.3.\n\t\t * @property timeSlice\n\t\t * @type Number\n\t\t * @default 0.3\n\t\t **/\n\t\tthis.timeSlice = 0.3;\n\t\n\t\t/**\n\t\t * A value between 0 and 1 that indicates the progress of a build, or -1 if a build has not\n\t\t * been initiated.\n\t\t * @property progress\n\t\t * @type Number\n\t\t * @default -1\n\t\t * @readonly\n\t\t */\n\t\tthis.progress = -1;\n\n\t\t/**\n\t\t * A {{#crossLink \"SpriteSheet/framerate:property\"}}{{/crossLink}} value that will be passed to new {{#crossLink \"SpriteSheet\"}}{{/crossLink}} instances that are\n\t\t * created. If no framerate is specified (or it is 0), then SpriteSheets will use the {{#crossLink \"Ticker\"}}{{/crossLink}}\n\t\t * framerate.\n\t\t * @property framerate\n\t\t * @type Number\n\t\t * @default 0\n\t\t */\n\t\tthis.framerate = framerate || 0;\n\t\n\t\n\t// private properties:\n\t\t/**\n\t\t * @property _frames\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._frames = [];\n\t\n\t\t/**\n\t\t * @property _animations\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._animations = {};\n\t\n\t\t/**\n\t\t * @property _data\n\t\t * @protected\n\t\t * @type Array\n\t\t **/\n\t\tthis._data = null;\n\t\n\t\t/**\n\t\t * @property _nextFrameIndex\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._nextFrameIndex = 0;\n\t\n\t\t/**\n\t\t * @property _index\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._index = 0;\n\t\n\t\t/**\n\t\t * @property _timerID\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._timerID = null;\n\t\n\t\t/**\n\t\t * @property _scale\n\t\t * @protected\n\t\t * @type Number\n\t\t **/\n\t\tthis._scale = 1;\n\t}\n\tvar p = createjs.extend(SpriteSheetBuilder, createjs.EventDispatcher);\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// constants:\n\tSpriteSheetBuilder.ERR_DIMENSIONS = \"frame dimensions exceed max spritesheet dimensions\";\n\tSpriteSheetBuilder.ERR_RUNNING = \"a build is already running\";\n\n// events:\n\t/**\n\t * Dispatched when a build completes.\n\t * @event complete\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * Dispatched when an asynchronous build has progress.\n\t * @event progress\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {Number} progress The current progress value (0-1).\n\t * @since 0.6.0\n\t */\n\n\n// public methods:\n\t/**\n\t * Adds a frame to the {{#crossLink \"SpriteSheet\"}}{{/crossLink}}. Note that the frame will not be drawn until you\n\t * call {{#crossLink \"SpriteSheetBuilder/build\"}}{{/crossLink}} method. The optional setup params allow you to have\n\t * a function run immediately before the draw occurs. For example, this allows you to add a single source multiple\n\t * times, but manipulate it or its children to change it to generate different frames.\n\t *\n\t * Note that the source's transformations (x, y, scale, rotate, alpha) will be ignored, except for regX/Y. To apply\n\t * transforms to a source object and have them captured in the SpriteSheet, simply place it into a {{#crossLink \"Container\"}}{{/crossLink}}\n\t * and pass in the Container as the source.\n\t * @method addFrame\n\t * @param {DisplayObject} source The source {{#crossLink \"DisplayObject\"}}{{/crossLink}}  to draw as the frame.\n\t * @param {Rectangle} [sourceRect] A {{#crossLink \"Rectangle\"}}{{/crossLink}} defining the portion of the\n\t * source to draw to the frame. If not specified, it will look for a `getBounds` method, bounds property, or\n\t * `nominalBounds` property on the source to use. If one is not found, the frame will be skipped.\n\t * @param {Number} [scale=1] Optional. The scale to draw this frame at. Default is 1.\n\t * @param {Function} [setupFunction] A function to call immediately before drawing this frame. It will be called with two parameters: the source, and setupData.\n\t * @param {Object} [setupData] Arbitrary setup data to pass to setupFunction as the second parameter.\n\t * @return {Number} The index of the frame that was just added, or null if a sourceRect could not be determined.\n\t **/\n\tp.addFrame = function(source, sourceRect, scale, setupFunction, setupData) {\n\t\tif (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }\n\t\tvar rect = sourceRect||source.bounds||source.nominalBounds;\n\t\tif (!rect&&source.getBounds) { rect = source.getBounds(); }\n\t\tif (!rect) { return null; }\n\t\tscale = scale||1;\n\t\treturn this._frames.push({source:source, sourceRect:rect, scale:scale, funct:setupFunction, data:setupData, index:this._frames.length, height:rect.height*scale})-1;\n\t};\n\n\t/**\n\t * Adds an animation that will be included in the created {{#crossLink \"SpriteSheet\"}}{{/crossLink}}.\n\t * @method addAnimation\n\t * @param {String} name The name for the animation.\n\t * @param {Array} frames An array of frame indexes that comprise the animation. Ex. [3,6,5] would describe an animation\n\t * that played frame indexes 3, 6, and 5 in that order.\n\t * @param {String} [next] Specifies the name of the animation to continue to after this animation ends. You can\n\t * also pass false to have the animation stop when it ends. By default it will loop to the start of the same animation.\n\t * @param {Number} [speed] Specifies a frame advance speed for this animation. For example, a value of 0.5 would\n\t * cause the animation to advance every second tick. Note that earlier versions used `frequency` instead, which had\n\t * the opposite effect.\n\t **/\n\tp.addAnimation = function(name, frames, next, speed) {\n\t\tif (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }\n\t\tthis._animations[name] = {frames:frames, next:next, speed:speed};\n\t};\n\n\t/**\n\t * This will take a {{#crossLink \"MovieClip\"}}{{/crossLink}} instance, and add its frames and labels to this\n\t * builder. Labels will be added as an animation running from the label index to the next label. For example, if\n\t * there is a label named \"foo\" at frame 0 and a label named \"bar\" at frame 10, in a MovieClip with 15 frames, it\n\t * will add an animation named \"foo\" that runs from frame index 0 to 9, and an animation named \"bar\" that runs from\n\t * frame index 10 to 14.\n\t *\n\t * Note that this will iterate through the full MovieClip with {{#crossLink \"MovieClip/actionsEnabled:property\"}}{{/crossLink}}\n\t * set to `false`, ending on the last frame.\n\t * @method addMovieClip\n\t * @param {MovieClip} source The source MovieClip instance to add to the SpriteSheet.\n\t * @param {Rectangle} [sourceRect] A {{#crossLink \"Rectangle\"}}{{/crossLink}} defining the portion of the source to\n\t * draw to the frame. If not specified, it will look for a {{#crossLink \"DisplayObject/getBounds\"}}{{/crossLink}}\n\t * method, `frameBounds` Array, `bounds` property, or `nominalBounds` property on the source to use. If one is not\n\t * found, the MovieClip will be skipped.\n\t * @param {Number} [scale=1] The scale to draw the movie clip at.\n\t * @param {Function} [setupFunction] A function to call immediately before drawing each frame. It will be called\n\t * with three parameters: the source, setupData, and the frame index.\n\t * @param {Object} [setupData] Arbitrary setup data to pass to setupFunction as the second parameter.\n\t * @param {Function} [labelFunction] This method will be called for each MovieClip label that is added with four\n\t * parameters: the label name, the source MovieClip instance, the starting frame index (in the movieclip timeline)\n\t * and the end index. It must return a new name for the label/animation, or `false` to exclude the label.\n\t **/\n\tp.addMovieClip = function(source, sourceRect, scale, setupFunction, setupData, labelFunction) {\n\t\tif (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }\n\t\tvar rects = source.frameBounds;\n\t\tvar rect = sourceRect||source.bounds||source.nominalBounds;\n\t\tif (!rect&&source.getBounds) { rect = source.getBounds(); }\n\t\tif (!rect && !rects) { return; }\n\n\t\tvar i, l, baseFrameIndex = this._frames.length;\n\t\tvar duration = source.timeline.duration;\n\t\tfor (i=0; i<duration; i++) {\n\t\t\tvar r = (rects&&rects[i]) ? rects[i] : rect;\n\t\t\tthis.addFrame(source, r, scale, this._setupMovieClipFrame, {i:i, f:setupFunction, d:setupData});\n\t\t}\n\t\tvar labels = source.timeline._labels;\n\t\tvar lbls = [];\n\t\tfor (var n in labels) {\n\t\t\tlbls.push({index:labels[n], label:n});\n\t\t}\n\t\tif (lbls.length) {\n\t\t\tlbls.sort(function(a,b){ return a.index-b.index; });\n\t\t\tfor (i=0,l=lbls.length; i<l; i++) {\n\t\t\t\tvar label = lbls[i].label;\n\t\t\t\tvar start = baseFrameIndex+lbls[i].index;\n\t\t\t\tvar end = baseFrameIndex+((i == l-1) ? duration : lbls[i+1].index);\n\t\t\t\tvar frames = [];\n\t\t\t\tfor (var j=start; j<end; j++) { frames.push(j); }\n\t\t\t\tif (labelFunction) {\n\t\t\t\t\tlabel = labelFunction(label, source, start, end);\n\t\t\t\t\tif (!label) { continue; }\n\t\t\t\t}\n\t\t\t\tthis.addAnimation(label, frames, true); // for now, this loops all animations.\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Builds a {{#crossLink \"SpriteSheet\"}}{{/crossLink}} instance based on the current frames.\n\t * @method build\n\t * @return {SpriteSheet} The created SpriteSheet instance, or null if a build is already running or an error\n\t * occurred.\n\t **/\n\tp.build = function() {\n\t\tif (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }\n\t\tthis._startBuild();\n\t\twhile (this._drawNext()) {}\n\t\tthis._endBuild();\n\t\treturn this.spriteSheet;\n\t};\n\n\t/**\n\t * Asynchronously builds a {{#crossLink \"SpriteSheet\"}}{{/crossLink}} instance based on the current frames. It will\n\t * run 20 times per second, using an amount of time defined by `timeSlice`. When it is complete it will call the\n\t * specified callback.\n\t * @method buildAsync\n\t * @param {Number} [timeSlice] Sets the timeSlice property on this instance.\n\t **/\n\tp.buildAsync = function(timeSlice) {\n\t\tif (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }\n\t\tthis.timeSlice = timeSlice;\n\t\tthis._startBuild();\n\t\tvar _this = this;\n\t\tthis._timerID = setTimeout(function() { _this._run(); }, 50-Math.max(0.01, Math.min(0.99, this.timeSlice||0.3))*50);\n\t};\n\n\t/**\n\t * Stops the current asynchronous build.\n\t * @method stopAsync\n\t **/\n\tp.stopAsync = function() {\n\t\tclearTimeout(this._timerID);\n\t\tthis._data = null;\n\t};\n\n\t/**\n\t * SpriteSheetBuilder instances cannot be cloned.\n\t * @method clone\n\t **/\n\tp.clone = function() {\n\t\tthrow(\"SpriteSheetBuilder cannot be cloned.\");\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[SpriteSheetBuilder]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _startBuild\n\t * @protected\n\t **/\n\tp._startBuild = function() {\n\t\tvar pad = this.padding||0;\n\t\tthis.progress = 0;\n\t\tthis.spriteSheet = null;\n\t\tthis._index = 0;\n\t\tthis._scale = this.scale;\n\t\tvar dataFrames = [];\n\t\tthis._data = {\n\t\t\timages: [],\n\t\t\tframes: dataFrames,\n\t\t\tframerate: this.framerate,\n\t\t\tanimations: this._animations // TODO: should we \"clone\" _animations in case someone adds more animations after a build?\n\t\t};\n\n\t\tvar frames = this._frames.slice();\n\t\tframes.sort(function(a,b) { return (a.height<=b.height) ? -1 : 1; });\n\n\t\tif (frames[frames.length-1].height+pad*2 > this.maxHeight) { throw SpriteSheetBuilder.ERR_DIMENSIONS; }\n\t\tvar y=0, x=0;\n\t\tvar img = 0;\n\t\twhile (frames.length) {\n\t\t\tvar o = this._fillRow(frames, y, img, dataFrames, pad);\n\t\t\tif (o.w > x) { x = o.w; }\n\t\t\ty += o.h;\n\t\t\tif (!o.h || !frames.length) {\n\t\t\t\tvar canvas = createjs.createCanvas?createjs.createCanvas():document.createElement(\"canvas\");\n\t\t\t\tcanvas.width = this._getSize(x,this.maxWidth);\n\t\t\t\tcanvas.height = this._getSize(y,this.maxHeight);\n\t\t\t\tthis._data.images[img] = canvas;\n\t\t\t\tif (!o.h) {\n\t\t\t\t\tx=y=0;\n\t\t\t\t\timg++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\t/**\n\t * @method _setupMovieClipFrame\n\t * @protected\n\t * @return {Number} The width & height of the row.\n\t **/\n\tp._setupMovieClipFrame = function(source, data) {\n\t\tvar ae = source.actionsEnabled;\n\t\tsource.actionsEnabled = false;\n\t\tsource.gotoAndStop(data.i);\n\t\tsource.actionsEnabled = ae;\n\t\tdata.f&&data.f(source, data.d, data.i);\n\t};\n\n\t/**\n\t * @method _getSize\n\t * @protected\n\t * @return {Number} The width & height of the row.\n\t **/\n\tp._getSize = function(size,max) {\n\t\tvar pow = 4;\n\t\twhile (Math.pow(2,++pow) < size){}\n\t\treturn Math.min(max,Math.pow(2,pow));\n\t};\n\n\t/**\n\t * @method _fillRow\n\t * @param {Array} frames\n\t * @param {Number} y\n\t * @param {HTMLImageElement} img\n\t * @param {Object} dataFrames\n\t * @param {Number} pad\n\t * @protected\n\t * @return {Number} The width & height of the row.\n\t **/\n\tp._fillRow = function(frames, y, img, dataFrames, pad) {\n\t\tvar w = this.maxWidth;\n\t\tvar maxH = this.maxHeight;\n\t\ty += pad;\n\t\tvar h = maxH-y;\n\t\tvar x = pad;\n\t\tvar height = 0;\n\t\tfor (var i=frames.length-1; i>=0; i--) {\n\t\t\tvar frame = frames[i];\n\t\t\tvar sc = this._scale*frame.scale;\n\t\t\tvar rect = frame.sourceRect;\n\t\t\tvar source = frame.source;\n\t\t\tvar rx = Math.floor(sc*rect.x-pad);\n\t\t\tvar ry = Math.floor(sc*rect.y-pad);\n\t\t\tvar rh = Math.ceil(sc*rect.height+pad*2);\n\t\t\tvar rw = Math.ceil(sc*rect.width+pad*2);\n\t\t\tif (rw > w) { throw SpriteSheetBuilder.ERR_DIMENSIONS; }\n\t\t\tif (rh > h || x+rw > w) { continue; }\n\t\t\tframe.img = img;\n\t\t\tframe.rect = new createjs.Rectangle(x,y,rw,rh);\n\t\t\theight = height || rh;\n\t\t\tframes.splice(i,1);\n\t\t\tdataFrames[frame.index] = [x,y,rw,rh,img,Math.round(-rx+sc*source.regX-pad),Math.round(-ry+sc*source.regY-pad)];\n\t\t\tx += rw;\n\t\t}\n\t\treturn {w:x, h:height};\n\t};\n\n\t/**\n\t * @method _endBuild\n\t * @protected\n\t **/\n\tp._endBuild = function() {\n\t\tthis.spriteSheet = new createjs.SpriteSheet(this._data);\n\t\tthis._data = null;\n\t\tthis.progress = 1;\n\t\tthis.dispatchEvent(\"complete\");\n\t};\n\n\t/**\n\t * @method _run\n\t * @protected\n\t **/\n\tp._run = function() {\n\t\tvar ts = Math.max(0.01, Math.min(0.99, this.timeSlice||0.3))*50;\n\t\tvar t = (new Date()).getTime()+ts;\n\t\tvar complete = false;\n\t\twhile (t > (new Date()).getTime()) {\n\t\t\tif (!this._drawNext()) { complete = true; break; }\n\t\t}\n\t\tif (complete) {\n\t\t\tthis._endBuild();\n\t\t} else {\n\t\t\tvar _this = this;\n\t\t\tthis._timerID = setTimeout(function() { _this._run(); }, 50-ts);\n\t\t}\n\t\tvar p = this.progress = this._index/this._frames.length;\n\t\tif (this.hasEventListener(\"progress\")) {\n\t\t\tvar evt = new createjs.Event(\"progress\");\n\t\t\tevt.progress = p;\n\t\t\tthis.dispatchEvent(evt);\n\t\t}\n\t};\n\n\t/**\n\t * @method _drawNext\n\t * @protected\n\t * @return Boolean Returns false if this is the last draw.\n\t **/\n\tp._drawNext = function() {\n\t\tvar frame = this._frames[this._index];\n\t\tvar sc = frame.scale*this._scale;\n\t\tvar rect = frame.rect;\n\t\tvar sourceRect = frame.sourceRect;\n\t\tvar canvas = this._data.images[frame.img];\n\t\tvar ctx = canvas.getContext(\"2d\");\n\t\tframe.funct&&frame.funct(frame.source, frame.data);\n\t\tctx.save();\n\t\tctx.beginPath();\n\t\tctx.rect(rect.x, rect.y, rect.width, rect.height);\n\t\tctx.clip();\n\t\tctx.translate(Math.ceil(rect.x-sourceRect.x*sc), Math.ceil(rect.y-sourceRect.y*sc));\n\t\tctx.scale(sc,sc);\n\t\tframe.source.draw(ctx); // display object will draw itself.\n\t\tctx.restore();\n\t\treturn (++this._index) < this._frames.length;\n\t};\n\n\n\tcreatejs.SpriteSheetBuilder = createjs.promote(SpriteSheetBuilder, \"EventDispatcher\");\n}());\n\n//##############################################################################\n// DOMElement.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * <b>This class is still experimental, and more advanced use is likely to be buggy. Please report bugs.</b>\n\t *\n\t * A DOMElement allows you to associate a HTMLElement with the display list. It will be transformed\n\t * within the DOM as though it is child of the {{#crossLink \"Container\"}}{{/crossLink}} it is added to. However, it is\n\t * not rendered to canvas, and as such will retain whatever z-index it has relative to the canvas (ie. it will be\n\t * drawn in front of or behind the canvas).\n\t *\n\t * The position of a DOMElement is relative to their parent node in the DOM. It is recommended that\n\t * the DOM Object be added to a div that also contains the canvas so that they share the same position\n\t * on the page.\n\t *\n\t * DOMElement is useful for positioning HTML elements over top of canvas content, and for elements\n\t * that you want to display outside the bounds of the canvas. For example, a tooltip with rich HTML\n\t * content.\n\t *\n\t * <h4>Mouse Interaction</h4>\n\t *\n\t * DOMElement instances are not full EaselJS display objects, and do not participate in EaselJS mouse\n\t * events or support methods like hitTest. To get mouse events from a DOMElement, you must instead add handlers to\n\t * the htmlElement (note, this does not support EventDispatcher)\n\t *\n\t *      var domElement = new createjs.DOMElement(htmlElement);\n\t *      domElement.htmlElement.onclick = function() {\n\t *          console.log(\"clicked\");\n\t *      }\n\t *\n\t * @class DOMElement\n\t * @extends DisplayObject\n\t * @constructor\n\t * @param {HTMLElement} htmlElement A reference or id for the DOM element to manage.\n\t */\n\tfunction DOMElement(htmlElement) {\n\t\tthis.DisplayObject_constructor();\n\t\t\n\t\tif (typeof(htmlElement)==\"string\") { htmlElement = document.getElementById(htmlElement); }\n\t\tthis.mouseEnabled = false;\n\t\t\n\t\tvar style = htmlElement.style;\n\t\tstyle.position = \"absolute\";\n\t\tstyle.transformOrigin = style.WebkitTransformOrigin = style.msTransformOrigin = style.MozTransformOrigin = style.OTransformOrigin = \"0% 0%\";\n\t\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * The DOM object to manage.\n\t\t * @property htmlElement\n\t\t * @type HTMLElement\n\t\t */\n\t\tthis.htmlElement = htmlElement;\n\t\n\t\n\t// private properties:\n\t\t/**\n\t\t * @property _oldMtx\n\t\t * @type Matrix2D\n\t\t * @protected\n\t\t */\n\t\tthis._oldProps = null;\n\t}\n\tvar p = createjs.extend(DOMElement, createjs.DisplayObject);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// public methods:\n\t/**\n\t * Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t * This does not account for whether it would be visible within the boundaries of the stage.\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method isVisible\n\t * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t */\n\tp.isVisible = function() {\n\t\treturn this.htmlElement != null;\n\t};\n\n\t/**\n\t * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.\n\t * Returns true if the draw was handled (useful for overriding functionality).\n\t * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t * @method draw\n\t * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.\n\t * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t * into itself).\n\t * @return {Boolean}\n\t */\n\tp.draw = function(ctx, ignoreCache) {\n\t\t// this relies on the _tick method because draw isn't called if the parent is not visible.\n\t\t// the actual update happens in _handleDrawEnd\n\t\treturn true;\n\t};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method cache\n\t */\n\tp.cache = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method uncache\n\t */\n\tp.uncache = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method updateCache\n\t */\n\tp.updateCache = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method hitTest\n\t */\n\tp.hitTest = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method localToGlobal\n\t */\n\tp.localToGlobal = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method globalToLocal\n\t */\n\tp.globalToLocal = function() {};\n\n\t/**\n\t * Not applicable to DOMElement.\n\t * @method localToLocal\n\t */\n\tp.localToLocal = function() {};\n\n\t/**\n\t * DOMElement cannot be cloned. Throws an error.\n\t * @method clone\n\t */\n\tp.clone = function() {\n\t\tthrow(\"DOMElement cannot be cloned.\")\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t */\n\tp.toString = function() {\n\t\treturn \"[DOMElement (name=\"+  this.name +\")]\";\n\t};\n\n\t/**\n     * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances\n\t * are not full EaselJS display objects and do not participate in EaselJS mouse events.\n\t * @event click\n\t */\n\n     /**\n     * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances\n \t * are not full EaselJS display objects and do not participate in EaselJS mouse events.\n\t * @event dblClick\n\t */\n\n     /**\n      * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances\n \t  * are not full EaselJS display objects and do not participate in EaselJS mouse events.\n\t  * @event mousedown\n\t  */\n\n     /**\n      * The HTMLElement can listen for the mouseover event, not the DOMElement instance.\n      * Since DOMElement instances are not full EaselJS display objects and do not participate in EaselJS mouse events.\n      * @event mouseover\n\t  */\n\n     /**\n      * Not applicable to DOMElement.\n\t  * @event tick\n\t  */\n\n\n// private methods:\n\t/**\n\t * @method _tick\n\t * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.\n\t * function.\n\t * @protected\n\t */\n\tp._tick = function(evtObj) {\n\t\tvar stage = this.getStage();\n\t\tstage&&stage.on(\"drawend\", this._handleDrawEnd, this, true);\n\t\tthis.DisplayObject__tick(evtObj);\n\t};\n\t\n\t/**\n\t * @method _handleDrawEnd\n\t * @param {Event} evt\n\t * @protected\n\t */\n\tp._handleDrawEnd = function(evt) {\n\t\tvar o = this.htmlElement;\n\t\tif (!o) { return; }\n\t\tvar style = o.style;\n\t\t\n\t\tvar props = this.getConcatenatedDisplayProps(this._props), mtx = props.matrix;\n\t\t\n\t\tvar visibility = props.visible ? \"visible\" : \"hidden\";\n\t\tif (visibility != style.visibility) { style.visibility = visibility; }\n\t\tif (!props.visible) { return; }\n\t\t\n\t\tvar oldProps = this._oldProps, oldMtx = oldProps&&oldProps.matrix;\n\t\tvar n = 10000; // precision\n\t\t\n\t\tif (!oldMtx || !oldMtx.equals(mtx)) {\n\t\t\tvar str = \"matrix(\" + (mtx.a*n|0)/n +\",\"+ (mtx.b*n|0)/n +\",\"+ (mtx.c*n|0)/n +\",\"+ (mtx.d*n|0)/n +\",\"+ (mtx.tx+0.5|0);\n\t\t\tstyle.transform = style.WebkitTransform = style.OTransform = style.msTransform = str +\",\"+ (mtx.ty+0.5|0) +\")\";\n\t\t\tstyle.MozTransform = str +\"px,\"+ (mtx.ty+0.5|0) +\"px)\";\n\t\t\tif (!oldProps) { oldProps = this._oldProps = new createjs.DisplayProps(true, NaN); }\n\t\t\toldProps.matrix.copy(mtx);\n\t\t}\n\t\t\n\t\tif (oldProps.alpha != props.alpha) {\n\t\t\tstyle.opacity = \"\"+(props.alpha*n|0)/n;\n\t\t\toldProps.alpha = props.alpha;\n\t\t}\n\t};\n\n\n\tcreatejs.DOMElement = createjs.promote(DOMElement, \"DisplayObject\");\n}());\n\n//##############################################################################\n// Filter.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Base class that all filters should inherit from. Filters need to be applied to objects that have been cached using\n\t * the {{#crossLink \"DisplayObject/cache\"}}{{/crossLink}} method. If an object changes, please cache it again, or use\n\t * {{#crossLink \"DisplayObject/updateCache\"}}{{/crossLink}}. Note that the filters must be applied before caching.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      myInstance.filters = [\n\t *          new createjs.ColorFilter(0, 0, 0, 1, 255, 0, 0),\n\t *          new createjs.BlurFilter(5, 5, 10)\n\t *      ];\n\t *      myInstance.cache(0,0, 100, 100);\n\t *\n\t * Note that each filter can implement a {{#crossLink \"Filter/getBounds\"}}{{/crossLink}} method, which returns the\n\t * margins that need to be applied in order to fully display the filter. For example, the {{#crossLink \"BlurFilter\"}}{{/crossLink}}\n\t * will cause an object to feather outwards, resulting in a margin around the shape.\n\t *\n\t * <h4>EaselJS Filters</h4>\n\t * EaselJS comes with a number of pre-built filters:\n\t * <ul><li>{{#crossLink \"AlphaMapFilter\"}}{{/crossLink}} : Map a greyscale image to the alpha channel of a display object</li>\n\t *      <li>{{#crossLink \"AlphaMaskFilter\"}}{{/crossLink}}: Map an image's alpha channel to the alpha channel of a display object</li>\n\t *      <li>{{#crossLink \"BlurFilter\"}}{{/crossLink}}: Apply vertical and horizontal blur to a display object</li>\n\t *      <li>{{#crossLink \"ColorFilter\"}}{{/crossLink}}: Color transform a display object</li>\n\t *      <li>{{#crossLink \"ColorMatrixFilter\"}}{{/crossLink}}: Transform an image using a {{#crossLink \"ColorMatrix\"}}{{/crossLink}}</li>\n\t * </ul>\n\t *\n\t * @class Filter\n\t * @constructor\n\t **/\n\tfunction Filter() {}\n\tvar p = Filter.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// public methods:\n\t/**\n\t * Provides padding values for this filter. That is, how much the filter will extend the visual bounds of an object it is applied to.\n\t * @method getBounds\n\t * @param {Rectangle} [rect] If specified, the provided Rectangle instance will be expanded by the padding amounts and returned.\n\t * @return {Rectangle} If a `rect` param was provided, it is returned. If not, either a new rectangle with the padding values, or null if no padding is required for this filter.\n\t **/\n\tp.getBounds = function(rect) {\n\t\treturn rect;\n\t};\n\n\t/**\n\t * Applies the filter to the specified context.\n\t * @method applyFilter\n\t * @param {CanvasRenderingContext2D} ctx The 2D context to use as the source.\n\t * @param {Number} x The x position to use for the source rect.\n\t * @param {Number} y The y position to use for the source rect.\n\t * @param {Number} width The width to use for the source rect.\n\t * @param {Number} height The height to use for the source rect.\n\t * @param {CanvasRenderingContext2D} [targetCtx] The 2D context to draw the result to. Defaults to the context passed to ctx.\n\t * @param {Number} [targetX] The x position to draw the result to. Defaults to the value passed to x.\n\t * @param {Number} [targetY] The y position to draw the result to. Defaults to the value passed to y.\n\t * @return {Boolean} If the filter was applied successfully.\n\t **/\n\tp.applyFilter = function(ctx, x, y, width, height, targetCtx, targetX, targetY) {\n\t\t// this is the default behaviour because most filters access pixel data. It is overridden when not needed.\n\t\ttargetCtx = targetCtx || ctx;\n\t\tif (targetX == null) { targetX = x; }\n\t\tif (targetY == null) { targetY = y; }\n\t\ttry {\n\t\t\tvar imageData = ctx.getImageData(x, y, width, height);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this._applyFilter(imageData)) {\n\t\t\ttargetCtx.putImageData(imageData, targetX, targetY);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[Filter]\";\n\t};\n\n\t/**\n\t * Returns a clone of this Filter instance.\n\t * @method clone\n\t * @return {Filter} A clone of the current Filter instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new Filter();\n\t};\n\t\n// private methods:\n\t/**\n\t * @method _applyFilter\n\t * @param {ImageData} imageData Target ImageData instance.\n\t * @return {Boolean}\n\t **/\n\tp._applyFilter = function(imageData) { return true; };\n\n\n\tcreatejs.Filter = Filter;\n}());\n\n//##############################################################################\n// BlurFilter.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Applies a box blur to DisplayObjects. Note that this filter is fairly CPU intensive, particularly if the quality is\n\t * set higher than 1.\n\t *\n\t * <h4>Example</h4>\n\t * This example creates a red circle, and then applies a 5 pixel blur to it. It uses the {{#crossLink \"Filter/getBounds\"}}{{/crossLink}}\n\t * method to account for the spread that the blur causes.\n\t *\n\t *      var shape = new createjs.Shape().set({x:100,y:100});\n\t *      shape.graphics.beginFill(\"#ff0000\").drawCircle(0,0,50);\n\t *\n\t *      var blurFilter = new createjs.BlurFilter(5, 5, 1);\n\t *      shape.filters = [blurFilter];\n\t *      var bounds = blurFilter.getBounds();\n\t *\n\t *      shape.cache(-50+bounds.x, -50+bounds.y, 100+bounds.width, 100+bounds.height);\n\t *\n\t * See {{#crossLink \"Filter\"}}{{/crossLink}} for an more information on applying filters.\n\t * @class BlurFilter\n\t * @extends Filter\n\t * @constructor\n\t * @param {Number} [blurX=0] The horizontal blur radius in pixels.\n\t * @param {Number} [blurY=0] The vertical blur radius in pixels.\n\t * @param {Number} [quality=1] The number of blur iterations.\n\t **/\n\tfunction BlurFilter( blurX, blurY, quality) {\n\t\tif ( isNaN(blurX) || blurX < 0 ) blurX = 0;\n\t\tif ( isNaN(blurY) || blurY < 0 ) blurY = 0;\n\t\tif ( isNaN(quality) || quality < 1  ) quality = 1;\n\n\n\t\t// public properties:\n\t\t/**\n\t\t * Horizontal blur radius in pixels\n\t\t * @property blurX\n\t\t * @default 0\n\t\t * @type Number\n\t\t **/\n\t\tthis.blurX = blurX | 0;\n\n\t\t/**\n\t\t * Vertical blur radius in pixels\n\t\t * @property blurY\n\t\t * @default 0\n\t\t * @type Number\n\t\t **/\n\t\tthis.blurY = blurY | 0;\n\n\t\t/**\n\t\t * Number of blur iterations. For example, a value of 1 will produce a rough blur. A value of 2 will produce a\n\t\t * smoother blur, but take twice as long to run.\n\t\t * @property quality\n\t\t * @default 1\n\t\t * @type Number\n\t\t **/\n\t\tthis.quality = quality | 0;\n\t}\n\tvar p = createjs.extend(BlurFilter, createjs.Filter);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// constants:\n\t/**\n\t * Array of multiply values for blur calculations.\n\t * @property MUL_TABLE\n\t * @type Array\n\t * @protected\n\t * @static\n\t **/\n\tBlurFilter.MUL_TABLE = [1, 171, 205, 293, 57, 373, 79, 137, 241, 27, 391, 357, 41, 19, 283, 265, 497, 469, 443, 421, 25, 191, 365, 349, 335, 161, 155, 149, 9, 278, 269, 261, 505, 245, 475, 231, 449, 437, 213, 415, 405, 395, 193, 377, 369, 361, 353, 345, 169, 331, 325, 319, 313, 307, 301, 37, 145, 285, 281, 69, 271, 267, 263, 259, 509, 501, 493, 243, 479, 118, 465, 459, 113, 446, 55, 435, 429, 423, 209, 413, 51, 403, 199, 393, 97, 3, 379, 375, 371, 367, 363, 359, 355, 351, 347, 43, 85, 337, 333, 165, 327, 323, 5, 317, 157, 311, 77, 305, 303, 75, 297, 294, 73, 289, 287, 71, 141, 279, 277, 275, 68, 135, 67, 133, 33, 262, 260, 129, 511, 507, 503, 499, 495, 491, 61, 121, 481, 477, 237, 235, 467, 232, 115, 457, 227, 451, 7, 445, 221, 439, 218, 433, 215, 427, 425, 211, 419, 417, 207, 411, 409, 203, 202, 401, 399, 396, 197, 49, 389, 387, 385, 383, 95, 189, 47, 187, 93, 185, 23, 183, 91, 181, 45, 179, 89, 177, 11, 175, 87, 173, 345, 343, 341, 339, 337, 21, 167, 83, 331, 329, 327, 163, 81, 323, 321, 319, 159, 79, 315, 313, 39, 155, 309, 307, 153, 305, 303, 151, 75, 299, 149, 37, 295, 147, 73, 291, 145, 289, 287, 143, 285, 71, 141, 281, 35, 279, 139, 69, 275, 137, 273, 17, 271, 135, 269, 267, 133, 265, 33, 263, 131, 261, 130, 259, 129, 257, 1];\n\n\t/**\n\t * Array of shift values for blur calculations.\n\t * @property SHG_TABLE\n\t * @type Array\n\t * @protected\n\t * @static\n\t **/\n\tBlurFilter.SHG_TABLE = [0, 9, 10, 11, 9, 12, 10, 11, 12, 9, 13, 13, 10, 9, 13, 13, 14, 14, 14, 14, 10, 13, 14, 14, 14, 13, 13, 13, 9, 14, 14, 14, 15, 14, 15, 14, 15, 15, 14, 15, 15, 15, 14, 15, 15, 15, 15, 15, 14, 15, 15, 15, 15, 15, 15, 12, 14, 15, 15, 13, 15, 15, 15, 15, 16, 16, 16, 15, 16, 14, 16, 16, 14, 16, 13, 16, 16, 16, 15, 16, 13, 16, 15, 16, 14, 9, 16, 16, 16, 16, 16, 16, 16, 16, 16, 13, 14, 16, 16, 15, 16, 16, 10, 16, 15, 16, 14, 16, 16, 14, 16, 16, 14, 16, 16, 14, 15, 16, 16, 16, 14, 15, 14, 15, 13, 16, 16, 15, 17, 17, 17, 17, 17, 17, 14, 15, 17, 17, 16, 16, 17, 16, 15, 17, 16, 17, 11, 17, 16, 17, 16, 17, 16, 17, 17, 16, 17, 17, 16, 17, 17, 16, 16, 17, 17, 17, 16, 14, 17, 17, 17, 17, 15, 16, 14, 16, 15, 16, 13, 16, 15, 16, 14, 16, 15, 16, 12, 16, 15, 16, 17, 17, 17, 17, 17, 13, 16, 15, 17, 17, 17, 16, 15, 17, 17, 17, 16, 15, 17, 17, 14, 16, 17, 17, 16, 17, 17, 16, 15, 17, 16, 14, 17, 16, 15, 17, 16, 17, 17, 16, 17, 15, 16, 17, 14, 17, 16, 15, 17, 16, 17, 13, 17, 16, 17, 17, 16, 17, 14, 17, 16, 17, 16, 17, 16, 17, 9];\n\n// public methods:\n\t/** docced in super class **/\n\tp.getBounds = function (rect) {\n\t\tvar x = this.blurX|0, y = this.blurY| 0;\n\t\tif (x <= 0 && y <= 0) { return rect; }\n\t\tvar q = Math.pow(this.quality, 0.2);\n\t\treturn (rect || new createjs.Rectangle()).pad(x*q+1,y*q+1,x*q+1,y*q+1);\n\t};\n\n\t/** docced in super class **/\n\tp.clone = function() {\n\t\treturn new BlurFilter(this.blurX, this.blurY, this.quality);\n\t};\n\n\t/** docced in super class **/\n\tp.toString = function() {\n\t\treturn \"[BlurFilter]\";\n\t};\n\n\n// private methods:\n\n\t/** docced in super class **/\n\tp._applyFilter = function (imageData) {\n\n\t\tvar radiusX = this.blurX >> 1;\n\t\tif (isNaN(radiusX) || radiusX < 0) return false;\n\t\tvar radiusY = this.blurY >> 1;\n\t\tif (isNaN(radiusY) || radiusY < 0) return false;\n\t\tif (radiusX == 0 && radiusY == 0) return false;\n\n\t\tvar iterations = this.quality;\n\t\tif (isNaN(iterations) || iterations < 1) iterations = 1;\n\t\titerations |= 0;\n\t\tif (iterations > 3) iterations = 3;\n\t\tif (iterations < 1) iterations = 1;\n\n\t\tvar px = imageData.data;\n\t\tvar x=0, y=0, i=0, p=0, yp=0, yi=0, yw=0, r=0, g=0, b=0, a=0, pr=0, pg=0, pb=0, pa=0;\n\n\t\tvar divx = (radiusX + radiusX + 1) | 0;\n\t\tvar divy = (radiusY + radiusY + 1) | 0;\n\t\tvar w = imageData.width | 0;\n\t\tvar h = imageData.height | 0;\n\n\t\tvar w1 = (w - 1) | 0;\n\t\tvar h1 = (h - 1) | 0;\n\t\tvar rxp1 = (radiusX + 1) | 0;\n\t\tvar ryp1 = (radiusY + 1) | 0;\n\n\t\tvar ssx = {r:0,b:0,g:0,a:0};\n\t\tvar sx = ssx;\n\t\tfor ( i = 1; i < divx; i++ )\n\t\t{\n\t\t\tsx = sx.n = {r:0,b:0,g:0,a:0};\n\t\t}\n\t\tsx.n = ssx;\n\n\t\tvar ssy = {r:0,b:0,g:0,a:0};\n\t\tvar sy = ssy;\n\t\tfor ( i = 1; i < divy; i++ )\n\t\t{\n\t\t\tsy = sy.n = {r:0,b:0,g:0,a:0};\n\t\t}\n\t\tsy.n = ssy;\n\n\t\tvar si = null;\n\n\n\t\tvar mtx = BlurFilter.MUL_TABLE[radiusX] | 0;\n\t\tvar stx = BlurFilter.SHG_TABLE[radiusX] | 0;\n\t\tvar mty = BlurFilter.MUL_TABLE[radiusY] | 0;\n\t\tvar sty = BlurFilter.SHG_TABLE[radiusY] | 0;\n\n\t\twhile (iterations-- > 0) {\n\n\t\t\tyw = yi = 0;\n\t\t\tvar ms = mtx;\n\t\t\tvar ss = stx;\n\t\t\tfor (y = h; --y > -1;) {\n\t\t\t\tr = rxp1 * (pr = px[(yi) | 0]);\n\t\t\t\tg = rxp1 * (pg = px[(yi + 1) | 0]);\n\t\t\t\tb = rxp1 * (pb = px[(yi + 2) | 0]);\n\t\t\t\ta = rxp1 * (pa = px[(yi + 3) | 0]);\n\n\t\t\t\tsx = ssx;\n\n\t\t\t\tfor( i = rxp1; --i > -1; )\n\t\t\t\t{\n\t\t\t\t\tsx.r = pr;\n\t\t\t\t\tsx.g = pg;\n\t\t\t\t\tsx.b = pb;\n\t\t\t\t\tsx.a = pa;\n\t\t\t\t\tsx = sx.n;\n\t\t\t\t}\n\n\t\t\t\tfor( i = 1; i < rxp1; i++ )\n\t\t\t\t{\n\t\t\t\t\tp = (yi + ((w1 < i ? w1 : i) << 2)) | 0;\n\t\t\t\t\tr += ( sx.r = px[p]);\n\t\t\t\t\tg += ( sx.g = px[p+1]);\n\t\t\t\t\tb += ( sx.b = px[p+2]);\n\t\t\t\t\ta += ( sx.a = px[p+3]);\n\n\t\t\t\t\tsx = sx.n;\n\t\t\t\t}\n\n\t\t\t\tsi = ssx;\n\t\t\t\tfor ( x = 0; x < w; x++ )\n\t\t\t\t{\n\t\t\t\t\tpx[yi++] = (r * ms) >>> ss;\n\t\t\t\t\tpx[yi++] = (g * ms) >>> ss;\n\t\t\t\t\tpx[yi++] = (b * ms) >>> ss;\n\t\t\t\t\tpx[yi++] = (a * ms) >>> ss;\n\n\t\t\t\t\tp = ((yw + ((p = x + radiusX + 1) < w1 ? p : w1)) << 2);\n\n\t\t\t\t\tr -= si.r - ( si.r = px[p]);\n\t\t\t\t\tg -= si.g - ( si.g = px[p+1]);\n\t\t\t\t\tb -= si.b - ( si.b = px[p+2]);\n\t\t\t\t\ta -= si.a - ( si.a = px[p+3]);\n\n\t\t\t\t\tsi = si.n;\n\n\t\t\t\t}\n\t\t\t\tyw += w;\n\t\t\t}\n\n\t\t\tms = mty;\n\t\t\tss = sty;\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\tyi = (x << 2) | 0;\n\n\t\t\t\tr = (ryp1 * (pr = px[yi])) | 0;\n\t\t\t\tg = (ryp1 * (pg = px[(yi + 1) | 0])) | 0;\n\t\t\t\tb = (ryp1 * (pb = px[(yi + 2) | 0])) | 0;\n\t\t\t\ta = (ryp1 * (pa = px[(yi + 3) | 0])) | 0;\n\n\t\t\t\tsy = ssy;\n\t\t\t\tfor( i = 0; i < ryp1; i++ )\n\t\t\t\t{\n\t\t\t\t\tsy.r = pr;\n\t\t\t\t\tsy.g = pg;\n\t\t\t\t\tsy.b = pb;\n\t\t\t\t\tsy.a = pa;\n\t\t\t\t\tsy = sy.n;\n\t\t\t\t}\n\n\t\t\t\typ = w;\n\n\t\t\t\tfor( i = 1; i <= radiusY; i++ )\n\t\t\t\t{\n\t\t\t\t\tyi = ( yp + x ) << 2;\n\n\t\t\t\t\tr += ( sy.r = px[yi]);\n\t\t\t\t\tg += ( sy.g = px[yi+1]);\n\t\t\t\t\tb += ( sy.b = px[yi+2]);\n\t\t\t\t\ta += ( sy.a = px[yi+3]);\n\n\t\t\t\t\tsy = sy.n;\n\n\t\t\t\t\tif( i < h1 )\n\t\t\t\t\t{\n\t\t\t\t\t\typ += w;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tyi = x;\n\t\t\t\tsi = ssy;\n\t\t\t\tif ( iterations > 0 )\n\t\t\t\t{\n\t\t\t\t\tfor ( y = 0; y < h; y++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tp = yi << 2;\n\t\t\t\t\t\tpx[p+3] = pa =(a * ms) >>> ss;\n\t\t\t\t\t\tif ( pa > 0 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpx[p]   = ((r * ms) >>> ss );\n\t\t\t\t\t\t\tpx[p+1] = ((g * ms) >>> ss );\n\t\t\t\t\t\t\tpx[p+2] = ((b * ms) >>> ss );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpx[p] = px[p+1] = px[p+2] = 0\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tp = ( x + (( ( p = y + ryp1) < h1 ? p : h1 ) * w )) << 2;\n\n\t\t\t\t\t\tr -= si.r - ( si.r = px[p]);\n\t\t\t\t\t\tg -= si.g - ( si.g = px[p+1]);\n\t\t\t\t\t\tb -= si.b - ( si.b = px[p+2]);\n\t\t\t\t\t\ta -= si.a - ( si.a = px[p+3]);\n\n\t\t\t\t\t\tsi = si.n;\n\n\t\t\t\t\t\tyi += w;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( y = 0; y < h; y++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tp = yi << 2;\n\t\t\t\t\t\tpx[p+3] = pa =(a * ms) >>> ss;\n\t\t\t\t\t\tif ( pa > 0 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpa = 255 / pa;\n\t\t\t\t\t\t\tpx[p]   = ((r * ms) >>> ss ) * pa;\n\t\t\t\t\t\t\tpx[p+1] = ((g * ms) >>> ss ) * pa;\n\t\t\t\t\t\t\tpx[p+2] = ((b * ms) >>> ss ) * pa;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpx[p] = px[p+1] = px[p+2] = 0\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tp = ( x + (( ( p = y + ryp1) < h1 ? p : h1 ) * w )) << 2;\n\n\t\t\t\t\t\tr -= si.r - ( si.r = px[p]);\n\t\t\t\t\t\tg -= si.g - ( si.g = px[p+1]);\n\t\t\t\t\t\tb -= si.b - ( si.b = px[p+2]);\n\t\t\t\t\t\ta -= si.a - ( si.a = px[p+3]);\n\n\t\t\t\t\t\tsi = si.n;\n\n\t\t\t\t\t\tyi += w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn true;\n\t};\n\n\tcreatejs.BlurFilter = createjs.promote(BlurFilter, \"Filter\");\n}());\n\n//##############################################################################\n// AlphaMapFilter.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\t\n\t\n// constructor:\n\t/**\n\t * Applies a greyscale alpha map image (or canvas) to the target, such that the alpha channel of the result will\n\t * be copied from the red channel of the map, and the RGB channels will be copied from the target.\n\t *\n\t * Generally, it is recommended that you use {{#crossLink \"AlphaMaskFilter\"}}{{/crossLink}}, because it has much\n\t * better performance.\n\t *\n\t * <h4>Example</h4>\n\t * This example draws a red->blue box, caches it, and then uses the cache canvas as an alpha map on a 100x100 image.\n\t *\n\t *       var box = new createjs.Shape();\n\t *       box.graphics.beginLinearGradientFill([\"#ff0000\", \"#0000ff\"], [0, 1], 0, 0, 0, 100)\n\t *       box.graphics.drawRect(0, 0, 100, 100);\n\t *       box.cache(0, 0, 100, 100);\n\t *\n\t *       var bmp = new createjs.Bitmap(\"path/to/image.jpg\");\n\t *       bmp.filters = [\n\t *           new createjs.AlphaMapFilter(box.cacheCanvas)\n\t *       ];\n\t *       bmp.cache(0, 0, 100, 100);\n\t *       stage.addChild(bmp);\n\t *\n\t * See {{#crossLink \"Filter\"}}{{/crossLink}} for more information on applying filters.\n\t * @class AlphaMapFilter\n\t * @extends Filter\n\t * @constructor\n\t * @param {HTMLImageElement|HTMLCanvasElement} alphaMap The greyscale image (or canvas) to use as the alpha value for the\n\t * result. This should be exactly the same dimensions as the target.\n\t **/\n\tfunction AlphaMapFilter(alphaMap) {\n\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * The greyscale image (or canvas) to use as the alpha value for the result. This should be exactly the same\n\t\t * dimensions as the target.\n\t\t * @property alphaMap\n\t\t * @type HTMLImageElement|HTMLCanvasElement\n\t\t **/\n\t\tthis.alphaMap = alphaMap;\n\t\t\n\t\t\n\t// private properties:\n\t\t/**\n\t\t * @property _alphaMap\n\t\t * @protected\n\t\t * @type HTMLImageElement|HTMLCanvasElement\n\t\t **/\n\t\tthis._alphaMap = null;\n\t\t\n\t\t/**\n\t\t * @property _mapData\n\t\t * @protected\n\t\t * @type Uint8ClampedArray\n\t\t **/\n\t\tthis._mapData = null;\n\t}\n\tvar p = createjs.extend(AlphaMapFilter, createjs.Filter);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// public methods:\n\t/** docced in super class **/\n\tp.clone = function () {\n\t\tvar o = new AlphaMapFilter(this.alphaMap);\n\t\to._alphaMap = this._alphaMap;\n\t\to._mapData = this._mapData;\n\t\treturn o;\n\t};\n\n\t/** docced in super class **/\n\tp.toString = function () {\n\t\treturn \"[AlphaMapFilter]\";\n\t};\n\n\n// private methods:\n\t/** docced in super class **/\n\tp._applyFilter = function (imageData) {\n\t\tif (!this.alphaMap) { return true; }\n\t\tif (!this._prepAlphaMap()) { return false; }\n\t\t\n\t\t// TODO: update to support scenarios where the target has different dimensions.\n\t\tvar data = imageData.data;\n\t\tvar map = this._mapData;\n\t\tfor(var i=0, l=data.length; i<l; i += 4) { data[i + 3] = map[i] || 0; }\n\t\t\n\t\treturn true;\n\t};\n\n\t/**\n\t * @method _prepAlphaMap\n\t * @protected\n\t **/\n\tp._prepAlphaMap = function () {\n\t\tif (!this.alphaMap) { return false; }\n\t\tif (this.alphaMap == this._alphaMap && this._mapData) { return true; }\n\n\t\tthis._mapData = null;\n\t\tvar map = this._alphaMap = this.alphaMap;\n\t\tvar canvas = map;\n\t\tvar ctx;\n\t\tif (map instanceof HTMLCanvasElement) {\n\t\t\tctx = canvas.getContext(\"2d\");\n\t\t} else {\n\t\t\tcanvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement(\"canvas\");\n\t\t\tcanvas.width = map.width;\n\t\t\tcanvas.height = map.height;\n\t\t\tctx = canvas.getContext(\"2d\");\n\t\t\tctx.drawImage(map, 0, 0);\n\t\t}\n\n\t\ttry {\n\t\t\tvar imgData = ctx.getImageData(0, 0, map.width, map.height);\n\t\t} catch (e) {\n\t\t\t//if (!this.suppressCrossDomainErrors) throw new Error(\"unable to access local image data: \" + e);\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis._mapData = imgData.data;\n\t\treturn true;\n\t};\n\n\n\tcreatejs.AlphaMapFilter = createjs.promote(AlphaMapFilter, \"Filter\");\n}());\n\n//##############################################################################\n// AlphaMaskFilter.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Applies the alpha from the mask image (or canvas) to the target, such that the alpha channel of the result will\n\t * be derived from the mask, and the RGB channels will be copied from the target. This can be used, for example, to\n\t * apply an alpha mask to a display object. This can also be used to combine a JPG compressed RGB image with a PNG32\n\t * alpha mask, which can result in a much smaller file size than a single PNG32 containing ARGB.\n\t *\n\t * <b>IMPORTANT NOTE: This filter currently does not support the targetCtx, or targetX/Y parameters correctly.</b>\n\t *\n\t * <h4>Example</h4>\n\t * This example draws a gradient box, then caches it and uses the \"cacheCanvas\" as the alpha mask on a 100x100 image.\n\t *\n\t *      var box = new createjs.Shape();\n\t *      box.graphics.beginLinearGradientFill([\"#000000\", \"rgba(0, 0, 0, 0)\"], [0, 1], 0, 0, 100, 100)\n\t *      box.graphics.drawRect(0, 0, 100, 100);\n\t *      box.cache(0, 0, 100, 100);\n\t *\n\t *      var bmp = new createjs.Bitmap(\"path/to/image.jpg\");\n\t *      bmp.filters = [\n\t *          new createjs.AlphaMaskFilter(box.cacheCanvas)\n\t *      ];\n\t *      bmp.cache(0, 0, 100, 100);\n\t *\n\t * See {{#crossLink \"Filter\"}}{{/crossLink}} for more information on applying filters.\n\t * @class AlphaMaskFilter\n\t * @extends Filter\n\t * @constructor\n\t * @param {HTMLImageElement|HTMLCanvasElement} mask\n\t **/\n\tfunction AlphaMaskFilter(mask) {\n\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * The image (or canvas) to use as the mask.\n\t\t * @property mask\n\t\t * @type HTMLImageElement|HTMLCanvasElement\n\t\t **/\n\t\tthis.mask = mask;\n\t}\n\tvar p = createjs.extend(AlphaMaskFilter, createjs.Filter);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\t\n\n// public methods:\n\t/**\n\t * Applies the filter to the specified context.\n\t *\n\t * <strong>IMPORTANT NOTE: This filter currently does not support the targetCtx, or targetX/Y parameters\n\t * correctly.</strong>\n\t * @method applyFilter\n\t * @param {CanvasRenderingContext2D} ctx The 2D context to use as the source.\n\t * @param {Number} x The x position to use for the source rect.\n\t * @param {Number} y The y position to use for the source rect.\n\t * @param {Number} width The width to use for the source rect.\n\t * @param {Number} height The height to use for the source rect.\n\t * @param {CanvasRenderingContext2D} [targetCtx] NOT SUPPORTED IN THIS FILTER. The 2D context to draw the result to. Defaults to the context passed to ctx.\n\t * @param {Number} [targetX] NOT SUPPORTED IN THIS FILTER. The x position to draw the result to. Defaults to the value passed to x.\n\t * @param {Number} [targetY] NOT SUPPORTED IN THIS FILTER. The y position to draw the result to. Defaults to the value passed to y.\n\t * @return {Boolean} If the filter was applied successfully.\n\t **/\n\tp.applyFilter = function (ctx, x, y, width, height, targetCtx, targetX, targetY) {\n\t\tif (!this.mask) { return true; }\n\t\ttargetCtx = targetCtx || ctx;\n\t\tif (targetX == null) { targetX = x; }\n\t\tif (targetY == null) { targetY = y; }\n\n\t\ttargetCtx.save();\n\t\tif (ctx != targetCtx) {\n\t\t\t// TODO: support targetCtx and targetX/Y\n\t\t\t// clearRect, then draw the ctx in?\n\t\t\treturn false;\n\t\t}\n\n\t\ttargetCtx.globalCompositeOperation = \"destination-in\";\n\t\ttargetCtx.drawImage(this.mask, targetX, targetY);\n\t\ttargetCtx.restore();\n\t\treturn true;\n\t};\n\n\t/** docced in super class **/\n\tp.clone = function () {\n\t\treturn new AlphaMaskFilter(this.mask);\n\t};\n\n\t/** docced in super class **/\n\tp.toString = function () {\n\t\treturn \"[AlphaMaskFilter]\";\n\t};\n\n\n\tcreatejs.AlphaMaskFilter = createjs.promote(AlphaMaskFilter, \"Filter\");\n}());\n\n//##############################################################################\n// ColorFilter.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Applies a color transform to DisplayObjects.\n\t *\n\t * <h4>Example</h4>\n\t * This example draws a red circle, and then transforms it to Blue. This is accomplished by multiplying all the channels\n\t * to 0 (except alpha, which is set to 1), and then adding 255 to the blue channel.\n\t *\n\t *      var shape = new createjs.Shape().set({x:100,y:100});\n\t *      shape.graphics.beginFill(\"#ff0000\").drawCircle(0,0,50);\n\t *\n\t *      shape.filters = [\n\t *          new createjs.ColorFilter(0,0,0,1, 0,0,255,0)\n\t *      ];\n\t *      shape.cache(-50, -50, 100, 100);\n\t *\n\t * See {{#crossLink \"Filter\"}}{{/crossLink}} for an more information on applying filters.\n\t * @class ColorFilter\n\t * @param {Number} [redMultiplier=1] The amount to multiply against the red channel. This is a range between 0 and 1.\n\t * @param {Number} [greenMultiplier=1] The amount to multiply against the green channel. This is a range between 0 and 1.\n\t * @param {Number} [blueMultiplier=1] The amount to multiply against the blue channel. This is a range between 0 and 1.\n\t * @param {Number} [alphaMultiplier=1] The amount to multiply against the alpha channel. This is a range between 0 and 1.\n\t * @param {Number} [redOffset=0] The amount to add to the red channel after it has been multiplied. This is a range\n\t * between -255 and 255.\n\t * @param {Number} [greenOffset=0] The amount to add to the green channel after it has been multiplied. This is a range\n\t  * between -255 and 255.\n\t * @param {Number} [blueOffset=0] The amount to add to the blue channel after it has been multiplied. This is a range\n\t  * between -255 and 255.\n\t * @param {Number} [alphaOffset=0] The amount to add to the alpha channel after it has been multiplied. This is a range\n\t  * between -255 and 255.\n\t * @constructor\n\t * @extends Filter\n\t **/\n\tfunction ColorFilter(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {\n\t\t\n\t\n\t// public properties:\n\t\t/**\n\t\t * Red channel multiplier.\n\t\t * @property redMultiplier\n\t\t * @type Number\n\t\t **/\n\t\tthis.redMultiplier = redMultiplier != null ? redMultiplier : 1;\n\t\n\t\t/**\n\t\t * Green channel multiplier.\n\t\t * @property greenMultiplier\n\t\t * @type Number\n\t\t **/\n\t\tthis.greenMultiplier = greenMultiplier != null ? greenMultiplier : 1;\n\t\n\t\t/**\n\t\t * Blue channel multiplier.\n\t\t * @property blueMultiplier\n\t\t * @type Number\n\t\t **/\n\t\tthis.blueMultiplier = blueMultiplier != null ? blueMultiplier : 1;\n\t\n\t\t/**\n\t\t * Alpha channel multiplier.\n\t\t * @property alphaMultiplier\n\t\t * @type Number\n\t\t **/\n\t\tthis.alphaMultiplier = alphaMultiplier != null ? alphaMultiplier : 1;\n\t\n\t\t/**\n\t\t * Red channel offset (added to value).\n\t\t * @property redOffset\n\t\t * @type Number\n\t\t **/\n\t\tthis.redOffset = redOffset || 0;\n\t\n\t\t/**\n\t\t * Green channel offset (added to value).\n\t\t * @property greenOffset\n\t\t * @type Number\n\t\t **/\n\t\tthis.greenOffset = greenOffset || 0;\n\t\n\t\t/**\n\t\t * Blue channel offset (added to value).\n\t\t * @property blueOffset\n\t\t * @type Number\n\t\t **/\n\t\tthis.blueOffset = blueOffset || 0;\n\t\n\t\t/**\n\t\t * Alpha channel offset (added to value).\n\t\t * @property alphaOffset\n\t\t * @type Number\n\t\t **/\n\t\tthis.alphaOffset = alphaOffset || 0;\n\t}\n\tvar p = createjs.extend(ColorFilter, createjs.Filter);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// public methods:\n\t/** docced in super class **/\n\tp.toString = function() {\n\t\treturn \"[ColorFilter]\";\n\t};\n\n\t/** docced in super class **/\n\tp.clone = function() {\n\t\treturn new ColorFilter(this.redMultiplier, this.greenMultiplier, this.blueMultiplier, this.alphaMultiplier, this.redOffset, this.greenOffset, this.blueOffset, this.alphaOffset);\n\t};\n\t\n\n// private methods:\n\t/** docced in super class **/\n\tp._applyFilter = function(imageData) {\n\t\tvar data = imageData.data;\n\t\tvar l = data.length;\n\t\tfor (var i=0; i<l; i+=4) {\n\t\t\tdata[i] = data[i]*this.redMultiplier+this.redOffset;\n\t\t\tdata[i+1] = data[i+1]*this.greenMultiplier+this.greenOffset;\n\t\t\tdata[i+2] = data[i+2]*this.blueMultiplier+this.blueOffset;\n\t\t\tdata[i+3] = data[i+3]*this.alphaMultiplier+this.alphaOffset;\n\t\t}\n\t\treturn true;\n\t};\n\n\n\tcreatejs.ColorFilter = createjs.promote(ColorFilter, \"Filter\");\n}());\n\n//##############################################################################\n// ColorMatrix.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Provides helper functions for assembling a matrix for use with the {{#crossLink \"ColorMatrixFilter\"}}{{/crossLink}}.\n\t * Most methods return the instance to facilitate chained calls.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      myColorMatrix.adjustHue(20).adjustBrightness(50);\n\t *\n\t * See {{#crossLink \"Filter\"}}{{/crossLink}} for an example of how to apply filters, or {{#crossLink \"ColorMatrixFilter\"}}{{/crossLink}}\n\t * for an example of how to use ColorMatrix to change a DisplayObject's color.\n\t * @class ColorMatrix\n\t * @param {Number} brightness\n\t * @param {Number} contrast\n\t * @param {Number} saturation\n\t * @param {Number} hue\n\t * @constructor\n\t **/\n\tfunction ColorMatrix(brightness, contrast, saturation, hue) {\n\t\tthis.setColor(brightness, contrast, saturation, hue);\n\t}\n\tvar p = ColorMatrix.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// constants:\n\t/**\n\t * Array of delta values for contrast calculations.\n\t * @property DELTA_INDEX\n\t * @type Array\n\t * @protected\n\t * @static\n\t **/\n\tColorMatrix.DELTA_INDEX = [\n\t\t0,    0.01, 0.02, 0.04, 0.05, 0.06, 0.07, 0.08, 0.1,  0.11,\n\t\t0.12, 0.14, 0.15, 0.16, 0.17, 0.18, 0.20, 0.21, 0.22, 0.24,\n\t\t0.25, 0.27, 0.28, 0.30, 0.32, 0.34, 0.36, 0.38, 0.40, 0.42,\n\t\t0.44, 0.46, 0.48, 0.5,  0.53, 0.56, 0.59, 0.62, 0.65, 0.68,\n\t\t0.71, 0.74, 0.77, 0.80, 0.83, 0.86, 0.89, 0.92, 0.95, 0.98,\n\t\t1.0,  1.06, 1.12, 1.18, 1.24, 1.30, 1.36, 1.42, 1.48, 1.54,\n\t\t1.60, 1.66, 1.72, 1.78, 1.84, 1.90, 1.96, 2.0,  2.12, 2.25,\n\t\t2.37, 2.50, 2.62, 2.75, 2.87, 3.0,  3.2,  3.4,  3.6,  3.8,\n\t\t4.0,  4.3,  4.7,  4.9,  5.0,  5.5,  6.0,  6.5,  6.8,  7.0,\n\t\t7.3,  7.5,  7.8,  8.0,  8.4,  8.7,  9.0,  9.4,  9.6,  9.8,\n\t\t10.0\n\t];\n\n\t/**\n\t * Identity matrix values.\n\t * @property IDENTITY_MATRIX\n\t * @type Array\n\t * @protected\n\t * @static\n\t **/\n\tColorMatrix.IDENTITY_MATRIX = [\n\t\t1,0,0,0,0,\n\t\t0,1,0,0,0,\n\t\t0,0,1,0,0,\n\t\t0,0,0,1,0,\n\t\t0,0,0,0,1\n\t];\n\n\t/**\n\t * The constant length of a color matrix.\n\t * @property LENGTH\n\t * @type Number\n\t * @protected\n\t * @static\n\t **/\n\tColorMatrix.LENGTH = ColorMatrix.IDENTITY_MATRIX.length;\n\n\n// public methods:\n\t/**\n\t * Resets the instance with the specified values.\n\t * @method setColor\n\t * @param {Number} brightness\n\t * @param {Number} contrast\n\t * @param {Number} saturation\n\t * @param {Number} hue\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tp.setColor = function(brightness,contrast,saturation,hue) {\n\t\treturn this.reset().adjustColor(brightness,contrast,saturation,hue);\n\t};\n\n\t/**\n\t * Resets the matrix to identity values.\n\t * @method reset\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t */\n\tp.reset = function() {\n\t\treturn this.copy(ColorMatrix.IDENTITY_MATRIX);\n\t};\n\n\t/**\n\t * Shortcut method to adjust brightness, contrast, saturation and hue.\n\t * Equivalent to calling adjustHue(hue), adjustContrast(contrast),\n\t * adjustBrightness(brightness), adjustSaturation(saturation), in that order.\n\t * @method adjustColor\n\t * @param {Number} brightness\n\t * @param {Number} contrast\n\t * @param {Number} saturation\n\t * @param {Number} hue\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.adjustColor = function(brightness,contrast,saturation,hue) {\n\t\tthis.adjustHue(hue);\n\t\tthis.adjustContrast(contrast);\n\t\tthis.adjustBrightness(brightness);\n\t\treturn this.adjustSaturation(saturation);\n\t};\n\n\t/**\n\t * Adjusts the brightness of pixel color by adding the specified value to the red, green and blue channels.\n\t * Positive values will make the image brighter, negative values will make it darker.\n\t * @method adjustBrightness\n\t * @param {Number} value A value between -255 & 255 that will be added to the RGB channels.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.adjustBrightness = function(value) {\n\t\tif (value == 0 || isNaN(value)) { return this; }\n\t\tvalue = this._cleanValue(value,255);\n\t\tthis._multiplyMatrix([\n\t\t\t1,0,0,0,value,\n\t\t\t0,1,0,0,value,\n\t\t\t0,0,1,0,value,\n\t\t\t0,0,0,1,0,\n\t\t\t0,0,0,0,1\n\t\t]);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Adjusts the contrast of pixel color.\n\t * Positive values will increase contrast, negative values will decrease contrast.\n\t * @method adjustContrast\n\t * @param {Number} value A value between -100 & 100.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.adjustContrast = function(value) {\n\t\tif (value == 0 || isNaN(value)) { return this; }\n\t\tvalue = this._cleanValue(value,100);\n\t\tvar x;\n\t\tif (value<0) {\n\t\t\tx = 127+value/100*127;\n\t\t} else {\n\t\t\tx = value%1;\n\t\t\tif (x == 0) {\n\t\t\t\tx = ColorMatrix.DELTA_INDEX[value];\n\t\t\t} else {\n\t\t\t\tx = ColorMatrix.DELTA_INDEX[(value<<0)]*(1-x)+ColorMatrix.DELTA_INDEX[(value<<0)+1]*x; // use linear interpolation for more granularity.\n\t\t\t}\n\t\t\tx = x*127+127;\n\t\t}\n\t\tthis._multiplyMatrix([\n\t\t\tx/127,0,0,0,0.5*(127-x),\n\t\t\t0,x/127,0,0,0.5*(127-x),\n\t\t\t0,0,x/127,0,0.5*(127-x),\n\t\t\t0,0,0,1,0,\n\t\t\t0,0,0,0,1\n\t\t]);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Adjusts the color saturation of the pixel.\n\t * Positive values will increase saturation, negative values will decrease saturation (trend towards greyscale).\n\t * @method adjustSaturation\n\t * @param {Number} value A value between -100 & 100.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.adjustSaturation = function(value) {\n\t\tif (value == 0 || isNaN(value)) { return this; }\n\t\tvalue = this._cleanValue(value,100);\n\t\tvar x = 1+((value > 0) ? 3*value/100 : value/100);\n\t\tvar lumR = 0.3086;\n\t\tvar lumG = 0.6094;\n\t\tvar lumB = 0.0820;\n\t\tthis._multiplyMatrix([\n\t\t\tlumR*(1-x)+x,lumG*(1-x),lumB*(1-x),0,0,\n\t\t\tlumR*(1-x),lumG*(1-x)+x,lumB*(1-x),0,0,\n\t\t\tlumR*(1-x),lumG*(1-x),lumB*(1-x)+x,0,0,\n\t\t\t0,0,0,1,0,\n\t\t\t0,0,0,0,1\n\t\t]);\n\t\treturn this;\n\t};\n\n\n\t/**\n\t * Adjusts the hue of the pixel color.\n\t * @method adjustHue\n\t * @param {Number} value A value between -180 & 180.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.adjustHue = function(value) {\n\t\tif (value == 0 || isNaN(value)) { return this; }\n\t\tvalue = this._cleanValue(value,180)/180*Math.PI;\n\t\tvar cosVal = Math.cos(value);\n\t\tvar sinVal = Math.sin(value);\n\t\tvar lumR = 0.213;\n\t\tvar lumG = 0.715;\n\t\tvar lumB = 0.072;\n\t\tthis._multiplyMatrix([\n\t\t\tlumR+cosVal*(1-lumR)+sinVal*(-lumR),lumG+cosVal*(-lumG)+sinVal*(-lumG),lumB+cosVal*(-lumB)+sinVal*(1-lumB),0,0,\n\t\t\tlumR+cosVal*(-lumR)+sinVal*(0.143),lumG+cosVal*(1-lumG)+sinVal*(0.140),lumB+cosVal*(-lumB)+sinVal*(-0.283),0,0,\n\t\t\tlumR+cosVal*(-lumR)+sinVal*(-(1-lumR)),lumG+cosVal*(-lumG)+sinVal*(lumG),lumB+cosVal*(1-lumB)+sinVal*(lumB),0,0,\n\t\t\t0,0,0,1,0,\n\t\t\t0,0,0,0,1\n\t\t]);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Concatenates (multiplies) the specified matrix with this one.\n\t * @method concat\n\t * @param {Array} matrix An array or ColorMatrix instance.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.concat = function(matrix) {\n\t\tmatrix = this._fixMatrix(matrix);\n\t\tif (matrix.length != ColorMatrix.LENGTH) { return this; }\n\t\tthis._multiplyMatrix(matrix);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Returns a clone of this ColorMatrix.\n\t * @method clone\n\t * @return {ColorMatrix} A clone of this ColorMatrix.\n\t **/\n\tp.clone = function() {\n\t\treturn (new ColorMatrix()).copy(this);\n\t};\n\n\t/**\n\t * Return a length 25 (5x5) array instance containing this matrix's values.\n\t * @method toArray\n\t * @return {Array} An array holding this matrix's values.\n\t **/\n\tp.toArray = function() {\n\t\tvar arr = [];\n\t\tfor (var i= 0, l=ColorMatrix.LENGTH; i<l; i++) {\n\t\t\tarr[i] = this[i];\n\t\t}\n\t\treturn arr;\n\t};\n\n\t/**\n\t * Copy the specified matrix's values to this matrix.\n\t * @method copy\n\t * @param {Array} matrix An array or ColorMatrix instance.\n\t * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)\n\t * @chainable\n\t **/\n\tp.copy = function(matrix) {\n\t\tvar l = ColorMatrix.LENGTH;\n\t\tfor (var i=0;i<l;i++) {\n\t\t\tthis[i] = matrix[i];\n\t\t}\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t **/\n\tp.toString = function() {\n\t\treturn \"[ColorMatrix]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * @method _multiplyMatrix\n\t * @param {Array} matrix\n\t * @protected\n\t **/\n\tp._multiplyMatrix = function(matrix) {\n\t\tvar i, j, k, col = [];\n\n\t\tfor (i=0;i<5;i++) {\n\t\t\tfor (j=0;j<5;j++) {\n\t\t\t\tcol[j] = this[j+i*5];\n\t\t\t}\n\t\t\tfor (j=0;j<5;j++) {\n\t\t\t\tvar val=0;\n\t\t\t\tfor (k=0;k<5;k++) {\n\t\t\t\t\tval += matrix[j+k*5]*col[k];\n\t\t\t\t}\n\t\t\t\tthis[j+i*5] = val;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Make sure values are within the specified range, hue has a limit of 180, brightness is 255, others are 100.\n\t * @method _cleanValue\n\t * @param {Number} value The raw number\n\t * @param {Number} limit The maximum that the number can be. The minimum is the limit * -1.\n\t * @protected\n\t **/\n\tp._cleanValue = function(value, limit) {\n\t\treturn Math.min(limit,Math.max(-limit,value));\n\t};\n\n\t/**\n\t * Makes sure matrixes are 5x5 (25 long).\n\t * @method _fixMatrix\n\t * @param {Array} matrix\n\t * @protected\n\t **/\n\tp._fixMatrix = function(matrix) {\n\t\tif (matrix instanceof ColorMatrix) { matrix = matrix.toArray(); }\n\t\tif (matrix.length < ColorMatrix.LENGTH) {\n\t\t\tmatrix = matrix.slice(0,matrix.length).concat(ColorMatrix.IDENTITY_MATRIX.slice(matrix.length,ColorMatrix.LENGTH));\n\t\t} else if (matrix.length > ColorMatrix.LENGTH) {\n\t\t\tmatrix = matrix.slice(0,ColorMatrix.LENGTH);\n\t\t}\n\t\treturn matrix;\n\t};\n\n\n\tcreatejs.ColorMatrix = ColorMatrix;\n}());\n\n//##############################################################################\n// ColorMatrixFilter.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n\t * Allows you to carry out complex color operations such as modifying saturation, brightness, or inverting. See the\n\t * {{#crossLink \"ColorMatrix\"}}{{/crossLink}} for more information on changing colors. For an easier color transform,\n\t * consider the {{#crossLink \"ColorFilter\"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t * This example creates a red circle, inverts its hue, and then saturates it to brighten it up.\n\t *\n\t *      var shape = new createjs.Shape().set({x:100,y:100});\n\t *      shape.graphics.beginFill(\"#ff0000\").drawCircle(0,0,50);\n\t *\n\t *      var matrix = new createjs.ColorMatrix().adjustHue(180).adjustSaturation(100);\n\t *      shape.filters = [\n\t *          new createjs.ColorMatrixFilter(matrix)\n\t *      ];\n\t *\n\t *      shape.cache(-50, -50, 100, 100);\n\t *\n\t * See {{#crossLink \"Filter\"}}{{/crossLink}} for an more information on applying filters.\n\t * @class ColorMatrixFilter\n\t * @constructor\n\t * @extends Filter\n\t * @param {Array | ColorMatrix} matrix A 4x5 matrix describing the color operation to perform. See also the {{#crossLink \"ColorMatrix\"}}{{/crossLink}}\n\t * class.\n\t **/\n\tfunction ColorMatrixFilter(matrix) {\n\t\n\t\t\n\t// public properties:\n\t\t/**\n\t\t * A 4x5 matrix describing the color operation to perform. See also the {{#crossLink \"ColorMatrix\"}}{{/crossLink}}\n\t\t * @property matrix\n\t\t * @type Array | ColorMatrix\n\t\t **/\n\t\tthis.matrix = matrix;\n\t}\n\tvar p = createjs.extend(ColorMatrixFilter, createjs.Filter);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\t\n\n// public methods:\n\t/** docced in super class **/\n\tp.toString = function() {\n\t\treturn \"[ColorMatrixFilter]\";\n\t};\n\n\t/** docced in super class **/\n\tp.clone = function() {\n\t\treturn new ColorMatrixFilter(this.matrix);\n\t};\n\n// private methods:\n\t/** docced in super class **/\n\tp._applyFilter = function(imageData) { \n\t\tvar data = imageData.data;\n\t\tvar l = data.length;\n\t\tvar r,g,b,a;\n\t\tvar mtx = this.matrix;\n\t\tvar m0 =  mtx[0],  m1 =  mtx[1],  m2 =  mtx[2],  m3 =  mtx[3],  m4 =  mtx[4];\n\t\tvar m5 =  mtx[5],  m6 =  mtx[6],  m7 =  mtx[7],  m8 =  mtx[8],  m9 =  mtx[9];\n\t\tvar m10 = mtx[10], m11 = mtx[11], m12 = mtx[12], m13 = mtx[13], m14 = mtx[14];\n\t\tvar m15 = mtx[15], m16 = mtx[16], m17 = mtx[17], m18 = mtx[18], m19 = mtx[19];\n\n\t\tfor (var i=0; i<l; i+=4) {\n\t\t\tr = data[i];\n\t\t\tg = data[i+1];\n\t\t\tb = data[i+2];\n\t\t\ta = data[i+3];\n\t\t\tdata[i] = r*m0+g*m1+b*m2+a*m3+m4; // red\n\t\t\tdata[i+1] = r*m5+g*m6+b*m7+a*m8+m9; // green\n\t\t\tdata[i+2] = r*m10+g*m11+b*m12+a*m13+m14; // blue\n\t\t\tdata[i+3] = r*m15+g*m16+b*m17+a*m18+m19; // alpha\n\t\t}\n\t\treturn true;\n\t};\n\n\n\tcreatejs.ColorMatrixFilter = createjs.promote(ColorMatrixFilter, \"Filter\");\n}());\n\n//##############################################################################\n// Touch.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\n// constructor:\n\t/**\n * Global utility for working with multi-touch enabled devices in EaselJS. Currently supports W3C Touch API (iOS and\n * modern Android browser) and the Pointer API (IE), including ms-prefixed events in IE10, and unprefixed in IE11.\n *\n * Ensure that you {{#crossLink \"Touch/disable\"}}{{/crossLink}} touch when cleaning up your application. You do not have\n * to check if touch is supported to enable it, as it will fail gracefully if it is not supported.\n *\n * <h4>Example</h4>\n *\n *      var stage = new createjs.Stage(\"canvasId\");\n *      createjs.Touch.enable(stage);\n *\n * <strong>Note:</strong> It is important to disable Touch on a stage that you are no longer using:\n *\n *      createjs.Touch.disable(stage);\n *\n * @class Touch\n * @static\n **/\n\tfunction Touch() {\n\t\tthrow \"Touch cannot be instantiated\";\n\t}\n\n\n// public static methods:\n\t/**\n\t * Returns `true` if touch is supported in the current browser.\n\t * @method isSupported\n\t * @return {Boolean} Indicates whether touch is supported in the current browser.\n\t * @static\n\t **/\n\tTouch.isSupported = function() {\n\t\treturn\t!!(('ontouchstart' in window) // iOS & Android\n\t\t\t|| (window.navigator['msPointerEnabled'] && window.navigator['msMaxTouchPoints'] > 0) // IE10\n\t\t\t|| (window.navigator['pointerEnabled'] && window.navigator['maxTouchPoints'] > 0)); // IE11+\n\t};\n\n\t/**\n\t * Enables touch interaction for the specified EaselJS {{#crossLink \"Stage\"}}{{/crossLink}}. Currently supports iOS\n\t * (and compatible browsers, such as modern Android browsers), and IE10/11. Supports both single touch and\n\t * multi-touch modes. Extends the EaselJS {{#crossLink \"MouseEvent\"}}{{/crossLink}} model, but without support for\n\t * double click or over/out events. See the MouseEvent {{#crossLink \"MouseEvent/pointerId:property\"}}{{/crossLink}}\n\t * for more information.\n\t * @method enable\n\t * @param {Stage} stage The {{#crossLink \"Stage\"}}{{/crossLink}} to enable touch on.\n\t * @param {Boolean} [singleTouch=false] If `true`, only a single touch will be active at a time.\n\t * @param {Boolean} [allowDefault=false] If `true`, then default gesture actions (ex. scrolling, zooming) will be\n\t * allowed when the user is interacting with the target canvas.\n\t * @return {Boolean} Returns `true` if touch was successfully enabled on the target stage.\n\t * @static\n\t **/\n\tTouch.enable = function(stage, singleTouch, allowDefault) {\n\t\tif (!stage || !stage.canvas || !Touch.isSupported()) { return false; }\n\t\tif (stage.__touch) { return true; }\n\n\t\t// inject required properties on stage:\n\t\tstage.__touch = {pointers:{}, multitouch:!singleTouch, preventDefault:!allowDefault, count:0};\n\n\t\t// note that in the future we may need to disable the standard mouse event model before adding\n\t\t// these to prevent duplicate calls. It doesn't seem to be an issue with iOS devices though.\n\t\tif ('ontouchstart' in window) { Touch._IOS_enable(stage); }\n\t\telse if (window.navigator['msPointerEnabled'] || window.navigator[\"pointerEnabled\"]) { Touch._IE_enable(stage); }\n\t\treturn true;\n\t};\n\n\t/**\n\t * Removes all listeners that were set up when calling `Touch.enable()` on a stage.\n\t * @method disable\n\t * @param {Stage} stage The {{#crossLink \"Stage\"}}{{/crossLink}} to disable touch on.\n\t * @static\n\t **/\n\tTouch.disable = function(stage) {\n\t\tif (!stage) { return; }\n\t\tif ('ontouchstart' in window) { Touch._IOS_disable(stage); }\n\t\telse if (window.navigator['msPointerEnabled'] || window.navigator[\"pointerEnabled\"]) { Touch._IE_disable(stage); }\n\t\t\n\t\tdelete stage.__touch;\n\t};\n\n\n// Private static methods:\n\t/**\n\t * @method _IOS_enable\n\t * @protected\n\t * @param {Stage} stage\n\t * @static\n\t **/\n\tTouch._IOS_enable = function(stage) {\n\t\tvar canvas = stage.canvas;\n\t\tvar f = stage.__touch.f = function(e) { Touch._IOS_handleEvent(stage,e); };\n\t\tcanvas.addEventListener(\"touchstart\", f, false);\n\t\tcanvas.addEventListener(\"touchmove\", f, false);\n\t\tcanvas.addEventListener(\"touchend\", f, false);\n\t\tcanvas.addEventListener(\"touchcancel\", f, false);\n\t};\n\n\t/**\n\t * @method _IOS_disable\n\t * @protected\n\t * @param {Stage} stage\n\t * @static\n\t **/\n\tTouch._IOS_disable = function(stage) {\n\t\tvar canvas = stage.canvas;\n\t\tif (!canvas) { return; }\n\t\tvar f = stage.__touch.f;\n\t\tcanvas.removeEventListener(\"touchstart\", f, false);\n\t\tcanvas.removeEventListener(\"touchmove\", f, false);\n\t\tcanvas.removeEventListener(\"touchend\", f, false);\n\t\tcanvas.removeEventListener(\"touchcancel\", f, false);\n\t};\n\n\t/**\n\t * @method _IOS_handleEvent\n\t * @param {Stage} stage\n\t * @param {Object} e The event to handle\n\t * @protected\n\t * @static\n\t **/\n\tTouch._IOS_handleEvent = function(stage, e) {\n\t\tif (!stage) { return; }\n\t\tif (stage.__touch.preventDefault) { e.preventDefault&&e.preventDefault(); }\n\t\tvar touches = e.changedTouches;\n\t\tvar type = e.type;\n\t\tfor (var i= 0,l=touches.length; i<l; i++) {\n\t\t\tvar touch = touches[i];\n\t\t\tvar id = touch.identifier;\n\t\t\tif (touch.target != stage.canvas) { continue; }\n\n\t\t\tif (type == \"touchstart\") {\n\t\t\t\tthis._handleStart(stage, id, e, touch.pageX, touch.pageY);\n\t\t\t} else if (type == \"touchmove\") {\n\t\t\t\tthis._handleMove(stage, id, e, touch.pageX, touch.pageY);\n\t\t\t} else if (type == \"touchend\" || type == \"touchcancel\") {\n\t\t\t\tthis._handleEnd(stage, id, e);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _IE_enable\n\t * @protected\n\t * @param {Stage} stage\n\t * @static\n\t **/\n\tTouch._IE_enable = function(stage) {\n\t\tvar canvas = stage.canvas;\n\t\tvar f = stage.__touch.f = function(e) { Touch._IE_handleEvent(stage,e); };\n\n\t\tif (window.navigator[\"pointerEnabled\"] === undefined) {\n\t\t\tcanvas.addEventListener(\"MSPointerDown\", f, false);\n\t\t\twindow.addEventListener(\"MSPointerMove\", f, false);\n\t\t\twindow.addEventListener(\"MSPointerUp\", f, false);\n\t\t\twindow.addEventListener(\"MSPointerCancel\", f, false);\n\t\t\tif (stage.__touch.preventDefault) { canvas.style.msTouchAction = \"none\"; }\n\t\t} else {\n\t\t\tcanvas.addEventListener(\"pointerdown\", f, false);\n\t\t\twindow.addEventListener(\"pointermove\", f, false);\n\t\t\twindow.addEventListener(\"pointerup\", f, false);\n\t\t\twindow.addEventListener(\"pointercancel\", f, false);\n\t\t\tif (stage.__touch.preventDefault) { canvas.style.touchAction = \"none\"; }\n\n\t\t}\n\t\tstage.__touch.activeIDs = {};\n\t};\n\n\t/**\n\t * @method _IE_disable\n\t * @protected\n\t * @param {Stage} stage\n\t * @static\n\t **/\n\tTouch._IE_disable = function(stage) {\n\t\tvar f = stage.__touch.f;\n\n\t\tif (window.navigator[\"pointerEnabled\"] === undefined) {\n\t\t\twindow.removeEventListener(\"MSPointerMove\", f, false);\n\t\t\twindow.removeEventListener(\"MSPointerUp\", f, false);\n\t\t\twindow.removeEventListener(\"MSPointerCancel\", f, false);\n\t\t\tif (stage.canvas) {\n\t\t\t\tstage.canvas.removeEventListener(\"MSPointerDown\", f, false);\n\t\t\t}\n\t\t} else {\n\t\t\twindow.removeEventListener(\"pointermove\", f, false);\n\t\t\twindow.removeEventListener(\"pointerup\", f, false);\n\t\t\twindow.removeEventListener(\"pointercancel\", f, false);\n\t\t\tif (stage.canvas) {\n\t\t\t\tstage.canvas.removeEventListener(\"pointerdown\", f, false);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _IE_handleEvent\n\t * @param {Stage} stage\n\t * @param {Object} e The event to handle.\n\t * @protected\n\t * @static\n\t **/\n\tTouch._IE_handleEvent = function(stage, e) {\n\t\tif (!stage) { return; }\n\t\tif (stage.__touch.preventDefault) { e.preventDefault && e.preventDefault(); }\n\t\tvar type = e.type;\n\t\tvar id = e.pointerId;\n\t\tvar ids = stage.__touch.activeIDs;\n\n\t\tif (type == \"MSPointerDown\" || type == \"pointerdown\") {\n\t\t\tif (e.srcElement != stage.canvas) { return; }\n\t\t\tids[id] = true;\n\t\t\tthis._handleStart(stage, id, e, e.pageX, e.pageY);\n\t\t} else if (ids[id]) { // it's an id we're watching\n\t\t\tif (type == \"MSPointerMove\" || type == \"pointermove\") {\n\t\t\t\tthis._handleMove(stage, id, e, e.pageX, e.pageY);\n\t\t\t} else if (type == \"MSPointerUp\" || type == \"MSPointerCancel\"\n\t\t\t\t\t|| type == \"pointerup\" || type == \"pointercancel\") {\n\t\t\t\tdelete(ids[id]);\n\t\t\t\tthis._handleEnd(stage, id, e);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _handleStart\n\t * @param {Stage} stage\n\t * @param {String|Number} id\n\t * @param {Object} e\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @protected\n\t **/\n\tTouch._handleStart = function(stage, id, e, x, y) {\n\t\tvar props = stage.__touch;\n\t\tif (!props.multitouch && props.count) { return; }\n\t\tvar ids = props.pointers;\n\t\tif (ids[id]) { return; }\n\t\tids[id] = true;\n\t\tprops.count++;\n\t\tstage._handlePointerDown(id, e, x, y);\n\t};\n\n\t/**\n\t * @method _handleMove\n\t * @param {Stage} stage\n\t * @param {String|Number} id\n\t * @param {Object} e\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @protected\n\t **/\n\tTouch._handleMove = function(stage, id, e, x, y) {\n\t\tif (!stage.__touch.pointers[id]) { return; }\n\t\tstage._handlePointerMove(id, e, x, y);\n\t};\n\n\t/**\n\t * @method _handleEnd\n\t * @param {Stage} stage\n\t * @param {String|Number} id\n\t * @param {Object} e\n\t * @protected\n\t **/\n\tTouch._handleEnd = function(stage, id, e) {\n\t\t// TODO: cancel should be handled differently for proper UI (ex. an up would trigger a click, a cancel would more closely resemble an out).\n\t\tvar props = stage.__touch;\n\t\tvar ids = props.pointers;\n\t\tif (!ids[id]) { return; }\n\t\tprops.count--;\n\t\tstage._handlePointerUp(id, e, true);\n\t\tdelete(ids[id]);\n\t};\n\n\n\tcreatejs.Touch = Touch;\n}());\n\n//##############################################################################\n// version.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * Static class holding library specific information such as the version and buildDate of\n\t * the library.\n\t * @class EaselJS\n\t **/\n\tvar s = createjs.EaselJS = createjs.EaselJS || {};\n\n\t/**\n\t * The version string for this release.\n\t * @property version\n\t * @type String\n\t * @static\n\t **/\n\ts.version = /*=version*/\"0.8.2\"; // injected by build process\n\n\t/**\n\t * The build date for this release in UTC format.\n\t * @property buildDate\n\t * @type String\n\t * @static\n\t **/\n\ts.buildDate = /*=date*/\"Thu, 26 Nov 2015 20:44:34 GMT\"; // injected by build process\n\n})();\n\n//##############################################################################\n// version.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * Static class holding library specific information such as the version and buildDate of the library.\n\t * @class PreloadJS\n\t **/\n\tvar s = createjs.PreloadJS = createjs.PreloadJS || {};\n\n\t/**\n\t * The version string for this release.\n\t * @property version\n\t * @type {String}\n\t * @static\n\t **/\n\ts.version = /*=version*/\"0.6.2\"; // injected by build process\n\n\t/**\n\t * The build date for this release in UTC format.\n\t * @property buildDate\n\t * @type {String}\n\t * @static\n\t **/\n\ts.buildDate = /*=date*/\"Thu, 26 Nov 2015 20:44:31 GMT\"; // injected by build process\n\n})();\n\n//##############################################################################\n// proxy.js\n//##############################################################################\n\n/**\n * Various utilities that the CreateJS Suite uses. Utilities are created as separate files, and will be available on the\n * createjs namespace directly.\n *\n * <h4>Example</h4>\n *\n *      myObject.addEventListener(\"change\", createjs.proxy(myMethod, scope));\n *\n * @class Utility Methods\n * @main Utility Methods\n */\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * A function proxy for methods. By default, JavaScript methods do not maintain scope, so passing a method as a\n\t * callback will result in the method getting called in the scope of the caller. Using a proxy ensures that the\n\t * method gets called in the correct scope.\n\t *\n\t * Additional arguments can be passed that will be applied to the function when it is called.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      myObject.addEventListener(\"event\", createjs.proxy(myHandler, this, arg1, arg2));\n\t *\n\t *      function myHandler(arg1, arg2) {\n\t *           // This gets called when myObject.myCallback is executed.\n\t *      }\n\t *\n\t * @method proxy\n\t * @param {Function} method The function to call\n\t * @param {Object} scope The scope to call the method name on\n\t * @param {mixed} [arg] * Arguments that are appended to the callback for additional params.\n\t * @public\n\t * @static\n\t */\n\tcreatejs.proxy = function (method, scope) {\n\t\tvar aArgs = Array.prototype.slice.call(arguments, 2);\n\t\treturn function () {\n\t\t\treturn method.apply(scope, Array.prototype.slice.call(arguments, 0).concat(aArgs));\n\t\t};\n\t}\n\n}());\n\n//##############################################################################\n// ErrorEvent.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * A general error {{#crossLink \"Event\"}}{{/crossLink}}, that describes an error that occurred, as well as any details.\n\t * @class ErrorEvent\n\t * @param {String} [title] The error title\n\t * @param {String} [message] The error description\n\t * @param {Object} [data] Additional error data\n\t * @constructor\n\t */\n\tfunction ErrorEvent(title, message, data) {\n\t\tthis.Event_constructor(\"error\");\n\n\t\t/**\n\t\t * The short error title, which indicates the type of error that occurred.\n\t\t * @property title\n\t\t * @type String\n\t\t */\n\t\tthis.title = title;\n\n\t\t/**\n\t\t * The verbose error message, containing details about the error.\n\t\t * @property message\n\t\t * @type String\n\t\t */\n\t\tthis.message = message;\n\n\t\t/**\n\t\t * Additional data attached to an error.\n\t\t * @property data\n\t\t * @type {Object}\n\t\t */\n\t\tthis.data = data;\n\t}\n\n\tvar p = createjs.extend(ErrorEvent, createjs.Event);\n\n\tp.clone = function() {\n\t\treturn new createjs.ErrorEvent(this.title, this.message, this.data);\n\t};\n\n\tcreatejs.ErrorEvent = createjs.promote(ErrorEvent, \"Event\");\n\n}());\n\n//##############################################################################\n// ProgressEvent.js\n//##############################################################################\n\n(function (scope) {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A CreateJS {{#crossLink \"Event\"}}{{/crossLink}} that is dispatched when progress changes.\n\t * @class ProgressEvent\n\t * @param {Number} loaded The amount that has been loaded. This can be any number relative to the total.\n\t * @param {Number} [total=1] The total amount that will load. This will default to 1, so if the `loaded` value is\n\t * a percentage (between 0 and 1), it can be omitted.\n\t * @todo Consider having this event be a \"fileprogress\" event as well\n\t * @constructor\n\t */\n\tfunction ProgressEvent(loaded, total) {\n\t\tthis.Event_constructor(\"progress\");\n\n\t\t/**\n\t\t * The amount that has been loaded (out of a total amount)\n\t\t * @property loaded\n\t\t * @type {Number}\n\t\t */\n\t\tthis.loaded = loaded;\n\n\t\t/**\n\t\t * The total \"size\" of the load.\n\t\t * @property total\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.total = (total == null) ? 1 : total;\n\n\t\t/**\n\t\t * The percentage (out of 1) that the load has been completed. This is calculated using `loaded/total`.\n\t\t * @property progress\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.progress = (total == 0) ? 0 : this.loaded / this.total;\n\t};\n\n\tvar p = createjs.extend(ProgressEvent, createjs.Event);\n\n\t/**\n\t * Returns a clone of the ProgressEvent instance.\n\t * @method clone\n\t * @return {ProgressEvent} a clone of the Event instance.\n\t **/\n\tp.clone = function() {\n\t\treturn new createjs.ProgressEvent(this.loaded, this.total);\n\t};\n\n\tcreatejs.ProgressEvent = createjs.promote(ProgressEvent, \"Event\");\n\n}(window));\n\n//##############################################################################\n// json3.js\n//##############################################################################\n\n/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */\n;(function () {\n  // Detect the `define` function exposed by asynchronous module loaders. The\n  // strict `define` check is necessary for compatibility with `r.js`.\n  var isLoader = \"function\" === \"function\" && __webpack_require__(1342);\n\n  // A set of types used to distinguish objects from primitives.\n  var objectTypes = {\n    \"function\": true,\n    \"object\": true\n  };\n\n  // Detect the `exports` object exposed by CommonJS implementations.\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\n  // Use the `global` object exposed by Node (including Browserify via\n  // `insert-module-globals`), Narwhal, and Ringo as the default context,\n  // and the `window` object in browsers. Rhino exports a `global` function\n  // instead.\n  var root = objectTypes[typeof window] && window || this,\n      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == \"object\" && global;\n\n  if (freeGlobal && (freeGlobal[\"global\"] === freeGlobal || freeGlobal[\"window\"] === freeGlobal || freeGlobal[\"self\"] === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  // Public: Initializes JSON 3 using the given `context` object, attaching the\n  // `stringify` and `parse` functions to the specified `exports` object.\n  function runInContext(context, exports) {\n    context || (context = root[\"Object\"]());\n    exports || (exports = root[\"Object\"]());\n\n    // Native constructor aliases.\n    var Number = context[\"Number\"] || root[\"Number\"],\n        String = context[\"String\"] || root[\"String\"],\n        Object = context[\"Object\"] || root[\"Object\"],\n        Date = context[\"Date\"] || root[\"Date\"],\n        SyntaxError = context[\"SyntaxError\"] || root[\"SyntaxError\"],\n        TypeError = context[\"TypeError\"] || root[\"TypeError\"],\n        Math = context[\"Math\"] || root[\"Math\"],\n        nativeJSON = context[\"JSON\"] || root[\"JSON\"];\n\n    // Delegate to the native `stringify` and `parse` implementations.\n    if (typeof nativeJSON == \"object\" && nativeJSON) {\n      exports.stringify = nativeJSON.stringify;\n      exports.parse = nativeJSON.parse;\n    }\n\n    // Convenience aliases.\n    var objectProto = Object.prototype,\n        getClass = objectProto.toString,\n        isProperty, forEach, undef;\n\n    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\n    var isExtended = new Date(-3509827334573292);\n    try {\n      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\n      // results for certain dates in Opera >= 10.53.\n      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\n        // Safari < 2.0.2 stores the internal millisecond time value correctly,\n        // but clips the values returned by the date methods to the range of\n        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\n        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\n    } catch (exception) {}\n\n    // Internal: Determines whether the native `JSON.stringify` and `parse`\n    // implementations are spec-compliant. Based on work by Ken Snyder.\n    function has(name) {\n      if (has[name] !== undef) {\n        // Return cached feature test result.\n        return has[name];\n      }\n      var isSupported;\n      if (name == \"bug-string-char-index\") {\n        // IE <= 7 doesn't support accessing string characters using square\n        // bracket notation. IE 8 only supports this for primitives.\n        isSupported = \"a\"[0] != \"a\";\n      } else if (name == \"json\") {\n        // Indicates whether both `JSON.stringify` and `JSON.parse` are\n        // supported.\n        isSupported = has(\"json-stringify\") && has(\"json-parse\");\n      } else {\n        var value, serialized = '{\"a\":[1,true,false,null,\"\\\\u0000\\\\b\\\\n\\\\f\\\\r\\\\t\"]}';\n        // Test `JSON.stringify`.\n        if (name == \"json-stringify\") {\n          var stringify = exports.stringify, stringifySupported = typeof stringify == \"function\" && isExtended;\n          if (stringifySupported) {\n            // A test function object with a custom `toJSON` method.\n            (value = function () {\n              return 1;\n            }).toJSON = value;\n            try {\n              stringifySupported =\n                // Firefox 3.1b1 and b2 serialize string, number, and boolean\n                // primitives as object literals.\n                stringify(0) === \"0\" &&\n                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\n                // literals.\n                stringify(new Number()) === \"0\" &&\n                stringify(new String()) == '\"\"' &&\n                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\n                // does not define a canonical JSON representation (this applies to\n                // objects with `toJSON` properties as well, *unless* they are nested\n                // within an object or array).\n                stringify(getClass) === undef &&\n                // IE 8 serializes `undefined` as `\"undefined\"`. Safari <= 5.1.7 and\n                // FF 3.1b3 pass this test.\n                stringify(undef) === undef &&\n                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\n                // respectively, if the value is omitted entirely.\n                stringify() === undef &&\n                // FF 3.1b1, 2 throw an error if the given value is not a number,\n                // string, array, object, Boolean, or `null` literal. This applies to\n                // objects with custom `toJSON` methods as well, unless they are nested\n                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\n                // methods entirely.\n                stringify(value) === \"1\" &&\n                stringify([value]) == \"[1]\" &&\n                // Prototype <= 1.6.1 serializes `[undefined]` as `\"[]\"` instead of\n                // `\"[null]\"`.\n                stringify([undef]) == \"[null]\" &&\n                // YUI 3.0.0b1 fails to serialize `null` literals.\n                stringify(null) == \"null\" &&\n                // FF 3.1b1, 2 halts serialization if an array contains a function:\n                // `[1, true, getClass, 1]` serializes as \"[1,true,],\". FF 3.1b3\n                // elides non-JSON values from objects and arrays, unless they\n                // define custom `toJSON` methods.\n                stringify([undef, getClass, null]) == \"[null,null,null]\" &&\n                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\n                // where character escape codes are expected (e.g., `\\b` => `\\u0008`).\n                stringify({ \"a\": [value, true, false, null, \"\\x00\\b\\n\\f\\r\\t\"] }) == serialized &&\n                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\n                stringify(null, value) === \"1\" &&\n                stringify([1, 2], null, 1) == \"[\\n 1,\\n 2\\n]\" &&\n                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\n                // serialize extended years.\n                stringify(new Date(-8.64e15)) == '\"-271821-04-20T00:00:00.000Z\"' &&\n                // The milliseconds are optional in ES 5, but required in 5.1.\n                stringify(new Date(8.64e15)) == '\"+275760-09-13T00:00:00.000Z\"' &&\n                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\n                // four-digit years instead of six-digit years. Credits: @Yaffle.\n                stringify(new Date(-621987552e5)) == '\"-000001-01-01T00:00:00.000Z\"' &&\n                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\n                // values less than 1000. Credits: @Yaffle.\n                stringify(new Date(-1)) == '\"1969-12-31T23:59:59.999Z\"';\n            } catch (exception) {\n              stringifySupported = false;\n            }\n          }\n          isSupported = stringifySupported;\n        }\n        // Test `JSON.parse`.\n        if (name == \"json-parse\") {\n          var parse = exports.parse;\n          if (typeof parse == \"function\") {\n            try {\n              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\n              // Conforming implementations should also coerce the initial argument to\n              // a string prior to parsing.\n              if (parse(\"0\") === 0 && !parse(false)) {\n                // Simple parsing test.\n                value = parse(serialized);\n                var parseSupported = value[\"a\"].length == 5 && value[\"a\"][0] === 1;\n                if (parseSupported) {\n                  try {\n                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\n                    parseSupported = !parse('\"\\t\"');\n                  } catch (exception) {}\n                  if (parseSupported) {\n                    try {\n                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading\n                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\n                      // certain octal literals.\n                      parseSupported = parse(\"01\") !== 1;\n                    } catch (exception) {}\n                  }\n                  if (parseSupported) {\n                    try {\n                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\n                      // points. These environments, along with FF 3.1b1 and 2,\n                      // also allow trailing commas in JSON objects and arrays.\n                      parseSupported = parse(\"1.\") !== 1;\n                    } catch (exception) {}\n                  }\n                }\n              }\n            } catch (exception) {\n              parseSupported = false;\n            }\n          }\n          isSupported = parseSupported;\n        }\n      }\n      return has[name] = !!isSupported;\n    }\n\n    if (!has(\"json\")) {\n      // Common `[[Class]]` name aliases.\n      var functionClass = \"[object Function]\",\n          dateClass = \"[object Date]\",\n          numberClass = \"[object Number]\",\n          stringClass = \"[object String]\",\n          arrayClass = \"[object Array]\",\n          booleanClass = \"[object Boolean]\";\n\n      // Detect incomplete support for accessing string characters by index.\n      var charIndexBuggy = has(\"bug-string-char-index\");\n\n      // Define additional utility methods if the `Date` methods are buggy.\n      if (!isExtended) {\n        var floor = Math.floor;\n        // A mapping between the months of the year and the number of days between\n        // January 1st and the first of the respective month.\n        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n        // Internal: Calculates the number of days between the Unix epoch and the\n        // first day of the given month.\n        var getDay = function (year, month) {\n          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\n        };\n      }\n\n      // Internal: Determines if a property is a direct property of the given\n      // object. Delegates to the native `Object#hasOwnProperty` method.\n      if (!(isProperty = objectProto.hasOwnProperty)) {\n        isProperty = function (property) {\n          var members = {}, constructor;\n          if ((members.__proto__ = null, members.__proto__ = {\n            // The *proto* property cannot be set multiple times in recent\n            // versions of Firefox and SeaMonkey.\n            \"toString\": 1\n          }, members).toString != getClass) {\n            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but\n            // supports the mutable *proto* property.\n            isProperty = function (property) {\n              // Capture and break the object's prototype chain (see section 8.6.2\n              // of the ES 5.1 spec). The parenthesized expression prevents an\n              // unsafe transformation by the Closure Compiler.\n              var original = this.__proto__, result = property in (this.__proto__ = null, this);\n              // Restore the original prototype chain.\n              this.__proto__ = original;\n              return result;\n            };\n          } else {\n            // Capture a reference to the top-level `Object` constructor.\n            constructor = members.constructor;\n            // Use the `constructor` property to simulate `Object#hasOwnProperty` in\n            // other environments.\n            isProperty = function (property) {\n              var parent = (this.constructor || constructor).prototype;\n              return property in this && !(property in parent && this[property] === parent[property]);\n            };\n          }\n          members = null;\n          return isProperty.call(this, property);\n        };\n      }\n\n      // Internal: Normalizes the `for...in` iteration algorithm across\n      // environments. Each enumerated key is yielded to a `callback` function.\n      forEach = function (object, callback) {\n        var size = 0, Properties, members, property;\n\n        // Tests for bugs in the current environment's `for...in` algorithm. The\n        // `valueOf` property inherits the non-enumerable flag from\n        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\n        (Properties = function () {\n          this.valueOf = 0;\n        }).prototype.valueOf = 0;\n\n        // Iterate over a new instance of the `Properties` class.\n        members = new Properties();\n        for (property in members) {\n          // Ignore all properties inherited from `Object.prototype`.\n          if (isProperty.call(members, property)) {\n            size++;\n          }\n        }\n        Properties = members = null;\n\n        // Normalize the iteration algorithm.\n        if (!size) {\n          // A list of non-enumerable properties inherited from `Object.prototype`.\n          members = [\"valueOf\", \"toString\", \"toLocaleString\", \"propertyIsEnumerable\", \"isPrototypeOf\", \"hasOwnProperty\", \"constructor\"];\n          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\n          // properties.\n          forEach = function (object, callback) {\n            var isFunction = getClass.call(object) == functionClass, property, length;\n            var hasProperty = !isFunction && typeof object.constructor != \"function\" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;\n            for (property in object) {\n              // Gecko <= 1.0 enumerates the `prototype` property of functions under\n              // certain conditions; IE does not.\n              if (!(isFunction && property == \"prototype\") && hasProperty.call(object, property)) {\n                callback(property);\n              }\n            }\n            // Manually invoke the callback for each non-enumerable property.\n            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));\n          };\n        } else if (size == 2) {\n          // Safari <= 2.0.4 enumerates shadowed properties twice.\n          forEach = function (object, callback) {\n            // Create a set of iterated properties.\n            var members = {}, isFunction = getClass.call(object) == functionClass, property;\n            for (property in object) {\n              // Store each property name to prevent double enumeration. The\n              // `prototype` property of functions is not enumerated due to cross-\n              // environment inconsistencies.\n              if (!(isFunction && property == \"prototype\") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {\n                callback(property);\n              }\n            }\n          };\n        } else {\n          // No bugs detected; use the standard `for...in` algorithm.\n          forEach = function (object, callback) {\n            var isFunction = getClass.call(object) == functionClass, property, isConstructor;\n            for (property in object) {\n              if (!(isFunction && property == \"prototype\") && isProperty.call(object, property) && !(isConstructor = property === \"constructor\")) {\n                callback(property);\n              }\n            }\n            // Manually invoke the callback for the `constructor` property due to\n            // cross-environment inconsistencies.\n            if (isConstructor || isProperty.call(object, (property = \"constructor\"))) {\n              callback(property);\n            }\n          };\n        }\n        return forEach(object, callback);\n      };\n\n      // Public: Serializes a JavaScript `value` as a JSON string. The optional\n      // `filter` argument may specify either a function that alters how object and\n      // array members are serialized, or an array of strings and numbers that\n      // indicates which properties should be serialized. The optional `width`\n      // argument may be either a string or number that specifies the indentation\n      // level of the output.\n      if (!has(\"json-stringify\")) {\n        // Internal: A map of control characters and their escaped equivalents.\n        var Escapes = {\n          92: \"\\\\\\\\\",\n          34: '\\\\\"',\n          8: \"\\\\b\",\n          12: \"\\\\f\",\n          10: \"\\\\n\",\n          13: \"\\\\r\",\n          9: \"\\\\t\"\n        };\n\n        // Internal: Converts `value` into a zero-padded string such that its\n        // length is at least equal to `width`. The `width` must be <= 6.\n        var leadingZeroes = \"000000\";\n        var toPaddedString = function (width, value) {\n          // The `|| 0` expression is necessary to work around a bug in\n          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== \"0\"`.\n          return (leadingZeroes + (value || 0)).slice(-width);\n        };\n\n        // Internal: Double-quotes a string `value`, replacing all ASCII control\n        // characters (characters with code unit values between 0 and 31) with\n        // their escaped equivalents. This is an implementation of the\n        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\n        var unicodePrefix = \"\\\\u00\";\n        var quote = function (value) {\n          var result = '\"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;\n          var symbols = useCharIndex && (charIndexBuggy ? value.split(\"\") : value);\n          for (; index < length; index++) {\n            var charCode = value.charCodeAt(index);\n            // If the character is a control character, append its Unicode or\n            // shorthand escape sequence; otherwise, append the character as-is.\n            switch (charCode) {\n              case 8: case 9: case 10: case 12: case 13: case 34: case 92:\n                result += Escapes[charCode];\n                break;\n              default:\n                if (charCode < 32) {\n                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));\n                  break;\n                }\n                result += useCharIndex ? symbols[index] : value.charAt(index);\n            }\n          }\n          return result + '\"';\n        };\n\n        // Internal: Recursively serializes an object. Implements the\n        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\n        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {\n          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\n          try {\n            // Necessary for host object support.\n            value = object[property];\n          } catch (exception) {}\n          if (typeof value == \"object\" && value) {\n            className = getClass.call(value);\n            if (className == dateClass && !isProperty.call(value, \"toJSON\")) {\n              if (value > -1 / 0 && value < 1 / 0) {\n                // Dates are serialized according to the `Date#toJSON` method\n                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\n                // for the ISO 8601 date time string format.\n                if (getDay) {\n                  // Manually compute the year, month, date, hours, minutes,\n                  // seconds, and milliseconds if the `getUTC*` methods are\n                  // buggy. Adapted from @Yaffle's `date-shim` project.\n                  date = floor(value / 864e5);\n                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);\n                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);\n                  date = 1 + date - getDay(year, month);\n                  // The `time` value specifies the time within the day (see ES\n                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\n                  // to compute `A modulo B`, as the `%` operator does not\n                  // correspond to the `modulo` operation for negative numbers.\n                  time = (value % 864e5 + 864e5) % 864e5;\n                  // The hours, minutes, seconds, and milliseconds are obtained by\n                  // decomposing the time within the day. See section 15.9.1.10.\n                  hours = floor(time / 36e5) % 24;\n                  minutes = floor(time / 6e4) % 60;\n                  seconds = floor(time / 1e3) % 60;\n                  milliseconds = time % 1e3;\n                } else {\n                  year = value.getUTCFullYear();\n                  month = value.getUTCMonth();\n                  date = value.getUTCDate();\n                  hours = value.getUTCHours();\n                  minutes = value.getUTCMinutes();\n                  seconds = value.getUTCSeconds();\n                  milliseconds = value.getUTCMilliseconds();\n                }\n                // Serialize extended years correctly.\n                value = (year <= 0 || year >= 1e4 ? (year < 0 ? \"-\" : \"+\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +\n                  \"-\" + toPaddedString(2, month + 1) + \"-\" + toPaddedString(2, date) +\n                  // Months, dates, hours, minutes, and seconds should have two\n                  // digits; milliseconds should have three.\n                  \"T\" + toPaddedString(2, hours) + \":\" + toPaddedString(2, minutes) + \":\" + toPaddedString(2, seconds) +\n                  // Milliseconds are optional in ES 5.0, but required in 5.1.\n                  \".\" + toPaddedString(3, milliseconds) + \"Z\";\n              } else {\n                value = null;\n              }\n            } else if (typeof value.toJSON == \"function\" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, \"toJSON\"))) {\n              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\n              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\n              // ignores all `toJSON` methods on these objects unless they are\n              // defined directly on an instance.\n              value = value.toJSON(property);\n            }\n          }\n          if (callback) {\n            // If a replacement function was provided, call it to obtain the value\n            // for serialization.\n            value = callback.call(object, property, value);\n          }\n          if (value === null) {\n            return \"null\";\n          }\n          className = getClass.call(value);\n          if (className == booleanClass) {\n            // Booleans are represented literally.\n            return \"\" + value;\n          } else if (className == numberClass) {\n            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\n            // `\"null\"`.\n            return value > -1 / 0 && value < 1 / 0 ? \"\" + value : \"null\";\n          } else if (className == stringClass) {\n            // Strings are double-quoted and escaped.\n            return quote(\"\" + value);\n          }\n          // Recursively serialize objects and arrays.\n          if (typeof value == \"object\") {\n            // Check for cyclic structures. This is a linear search; performance\n            // is inversely proportional to the number of unique nested objects.\n            for (length = stack.length; length--;) {\n              if (stack[length] === value) {\n                // Cyclic structures cannot be serialized by `JSON.stringify`.\n                throw TypeError();\n              }\n            }\n            // Add the object to the stack of traversed objects.\n            stack.push(value);\n            results = [];\n            // Save the current indentation level and indent one additional level.\n            prefix = indentation;\n            indentation += whitespace;\n            if (className == arrayClass) {\n              // Recursively serialize array elements.\n              for (index = 0, length = value.length; index < length; index++) {\n                element = serialize(index, value, callback, properties, whitespace, indentation, stack);\n                results.push(element === undef ? \"null\" : element);\n              }\n              result = results.length ? (whitespace ? \"[\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"]\" : (\"[\" + results.join(\",\") + \"]\")) : \"[]\";\n            } else {\n              // Recursively serialize object members. Members are selected from\n              // either a user-specified list of property names, or the object\n              // itself.\n              forEach(properties || value, function (property) {\n                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\n                if (element !== undef) {\n                  // According to ES 5.1 section 15.12.3: \"If `gap` {whitespace}\n                  // is not the empty string, let `member` {quote(property) + \":\"}\n                  // be the concatenation of `member` and the `space` character.\"\n                  // The \"`space` character\" refers to the literal space\n                  // character, not the `space` {width} argument provided to\n                  // `JSON.stringify`.\n                  results.push(quote(property) + \":\" + (whitespace ? \" \" : \"\") + element);\n                }\n              });\n              result = results.length ? (whitespace ? \"{\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"}\" : (\"{\" + results.join(\",\") + \"}\")) : \"{}\";\n            }\n            // Remove the object from the traversed object stack.\n            stack.pop();\n            return result;\n          }\n        };\n\n        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\n        exports.stringify = function (source, filter, width) {\n          var whitespace, callback, properties, className;\n          if (objectTypes[typeof filter] && filter) {\n            if ((className = getClass.call(filter)) == functionClass) {\n              callback = filter;\n            } else if (className == arrayClass) {\n              // Convert the property names array into a makeshift set.\n              properties = {};\n              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));\n            }\n          }\n          if (width) {\n            if ((className = getClass.call(width)) == numberClass) {\n              // Convert the `width` to an integer and create a string containing\n              // `width` number of space characters.\n              if ((width -= width % 1) > 0) {\n                for (whitespace = \"\", width > 10 && (width = 10); whitespace.length < width; whitespace += \" \");\n              }\n            } else if (className == stringClass) {\n              whitespace = width.length <= 10 ? width : width.slice(0, 10);\n            }\n          }\n          // Opera <= 7.54u2 discards the values associated with empty string keys\n          // (`\"\"`) only if they are used directly within an object member list\n          // (e.g., `!(\"\" in { \"\": 1})`).\n          return serialize(\"\", (value = {}, value[\"\"] = source, value), callback, properties, whitespace, \"\", []);\n        };\n      }\n\n      // Public: Parses a JSON source string.\n      if (!has(\"json-parse\")) {\n        var fromCharCode = String.fromCharCode;\n\n        // Internal: A map of escaped control characters and their unescaped\n        // equivalents.\n        var Unescapes = {\n          92: \"\\\\\",\n          34: '\"',\n          47: \"/\",\n          98: \"\\b\",\n          116: \"\\t\",\n          110: \"\\n\",\n          102: \"\\f\",\n          114: \"\\r\"\n        };\n\n        // Internal: Stores the parser state.\n        var Index, Source;\n\n        // Internal: Resets the parser state and throws a `SyntaxError`.\n        var abort = function () {\n          Index = Source = null;\n          throw SyntaxError();\n        };\n\n        // Internal: Returns the next token, or `\"$\"` if the parser has reached\n        // the end of the source string. A token may be a string, number, `null`\n        // literal, or Boolean literal.\n        var lex = function () {\n          var source = Source, length = source.length, value, begin, position, isSigned, charCode;\n          while (Index < length) {\n            charCode = source.charCodeAt(Index);\n            switch (charCode) {\n              case 9: case 10: case 13: case 32:\n                // Skip whitespace tokens, including tabs, carriage returns, line\n                // feeds, and space characters.\n                Index++;\n                break;\n              case 123: case 125: case 91: case 93: case 58: case 44:\n                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\n                // the current position.\n                value = charIndexBuggy ? source.charAt(Index) : source[Index];\n                Index++;\n                return value;\n              case 34:\n                // `\"` delimits a JSON string; advance to the next character and\n                // begin parsing the string. String tokens are prefixed with the\n                // sentinel `@` character to distinguish them from punctuators and\n                // end-of-string tokens.\n                for (value = \"@\", Index++; Index < length;) {\n                  charCode = source.charCodeAt(Index);\n                  if (charCode < 32) {\n                    // Unescaped ASCII control characters (those with a code unit\n                    // less than the space character) are not permitted.\n                    abort();\n                  } else if (charCode == 92) {\n                    // A reverse solidus (`\\`) marks the beginning of an escaped\n                    // control character (including `\"`, `\\`, and `/`) or Unicode\n                    // escape sequence.\n                    charCode = source.charCodeAt(++Index);\n                    switch (charCode) {\n                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:\n                        // Revive escaped control characters.\n                        value += Unescapes[charCode];\n                        Index++;\n                        break;\n                      case 117:\n                        // `\\u` marks the beginning of a Unicode escape sequence.\n                        // Advance to the first character and validate the\n                        // four-digit code point.\n                        begin = ++Index;\n                        for (position = Index + 4; Index < position; Index++) {\n                          charCode = source.charCodeAt(Index);\n                          // A valid sequence comprises four hexdigits (case-\n                          // insensitive) that form a single hexadecimal value.\n                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\n                            // Invalid Unicode escape sequence.\n                            abort();\n                          }\n                        }\n                        // Revive the escaped character.\n                        value += fromCharCode(\"0x\" + source.slice(begin, Index));\n                        break;\n                      default:\n                        // Invalid escape sequence.\n                        abort();\n                    }\n                  } else {\n                    if (charCode == 34) {\n                      // An unescaped double-quote character marks the end of the\n                      // string.\n                      break;\n                    }\n                    charCode = source.charCodeAt(Index);\n                    begin = Index;\n                    // Optimize for the common case where a string is valid.\n                    while (charCode >= 32 && charCode != 92 && charCode != 34) {\n                      charCode = source.charCodeAt(++Index);\n                    }\n                    // Append the string as-is.\n                    value += source.slice(begin, Index);\n                  }\n                }\n                if (source.charCodeAt(Index) == 34) {\n                  // Advance to the next character and return the revived string.\n                  Index++;\n                  return value;\n                }\n                // Unterminated string.\n                abort();\n              default:\n                // Parse numbers and literals.\n                begin = Index;\n                // Advance past the negative sign, if one is specified.\n                if (charCode == 45) {\n                  isSigned = true;\n                  charCode = source.charCodeAt(++Index);\n                }\n                // Parse an integer or floating-point value.\n                if (charCode >= 48 && charCode <= 57) {\n                  // Leading zeroes are interpreted as octal literals.\n                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {\n                    // Illegal octal literal.\n                    abort();\n                  }\n                  isSigned = false;\n                  // Parse the integer component.\n                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);\n                  // Floats cannot contain a leading decimal point; however, this\n                  // case is already accounted for by the parser.\n                  if (source.charCodeAt(Index) == 46) {\n                    position = ++Index;\n                    // Parse the decimal component.\n                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                    if (position == Index) {\n                      // Illegal trailing decimal.\n                      abort();\n                    }\n                    Index = position;\n                  }\n                  // Parse exponents. The `e` denoting the exponent is\n                  // case-insensitive.\n                  charCode = source.charCodeAt(Index);\n                  if (charCode == 101 || charCode == 69) {\n                    charCode = source.charCodeAt(++Index);\n                    // Skip past the sign following the exponent, if one is\n                    // specified.\n                    if (charCode == 43 || charCode == 45) {\n                      Index++;\n                    }\n                    // Parse the exponential component.\n                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                    if (position == Index) {\n                      // Illegal empty exponent.\n                      abort();\n                    }\n                    Index = position;\n                  }\n                  // Coerce the parsed value to a JavaScript number.\n                  return +source.slice(begin, Index);\n                }\n                // A negative sign may only precede numbers.\n                if (isSigned) {\n                  abort();\n                }\n                // `true`, `false`, and `null` literals.\n                if (source.slice(Index, Index + 4) == \"true\") {\n                  Index += 4;\n                  return true;\n                } else if (source.slice(Index, Index + 5) == \"false\") {\n                  Index += 5;\n                  return false;\n                } else if (source.slice(Index, Index + 4) == \"null\") {\n                  Index += 4;\n                  return null;\n                }\n                // Unrecognized token.\n                abort();\n            }\n          }\n          // Return the sentinel `$` character if the parser has reached the end\n          // of the source string.\n          return \"$\";\n        };\n\n        // Internal: Parses a JSON `value` token.\n        var get = function (value) {\n          var results, hasMembers;\n          if (value == \"$\") {\n            // Unexpected end of input.\n            abort();\n          }\n          if (typeof value == \"string\") {\n            if ((charIndexBuggy ? value.charAt(0) : value[0]) == \"@\") {\n              // Remove the sentinel `@` character.\n              return value.slice(1);\n            }\n            // Parse object and array literals.\n            if (value == \"[\") {\n              // Parses a JSON array, returning a new JavaScript array.\n              results = [];\n              for (;; hasMembers || (hasMembers = true)) {\n                value = lex();\n                // A closing square bracket marks the end of the array literal.\n                if (value == \"]\") {\n                  break;\n                }\n                // If the array literal contains elements, the current token\n                // should be a comma separating the previous element from the\n                // next.\n                if (hasMembers) {\n                  if (value == \",\") {\n                    value = lex();\n                    if (value == \"]\") {\n                      // Unexpected trailing `,` in array literal.\n                      abort();\n                    }\n                  } else {\n                    // A `,` must separate each array element.\n                    abort();\n                  }\n                }\n                // Elisions and leading commas are not permitted.\n                if (value == \",\") {\n                  abort();\n                }\n                results.push(get(value));\n              }\n              return results;\n            } else if (value == \"{\") {\n              // Parses a JSON object, returning a new JavaScript object.\n              results = {};\n              for (;; hasMembers || (hasMembers = true)) {\n                value = lex();\n                // A closing curly brace marks the end of the object literal.\n                if (value == \"}\") {\n                  break;\n                }\n                // If the object literal contains members, the current token\n                // should be a comma separator.\n                if (hasMembers) {\n                  if (value == \",\") {\n                    value = lex();\n                    if (value == \"}\") {\n                      // Unexpected trailing `,` in object literal.\n                      abort();\n                    }\n                  } else {\n                    // A `,` must separate each object member.\n                    abort();\n                  }\n                }\n                // Leading commas are not permitted, object property names must be\n                // double-quoted strings, and a `:` must separate each property\n                // name and value.\n                if (value == \",\" || typeof value != \"string\" || (charIndexBuggy ? value.charAt(0) : value[0]) != \"@\" || lex() != \":\") {\n                  abort();\n                }\n                results[value.slice(1)] = get(lex());\n              }\n              return results;\n            }\n            // Unexpected token encountered.\n            abort();\n          }\n          return value;\n        };\n\n        // Internal: Updates a traversed object member.\n        var update = function (source, property, callback) {\n          var element = walk(source, property, callback);\n          if (element === undef) {\n            delete source[property];\n          } else {\n            source[property] = element;\n          }\n        };\n\n        // Internal: Recursively traverses a parsed JSON object, invoking the\n        // `callback` function for each value. This is an implementation of the\n        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\n        var walk = function (source, property, callback) {\n          var value = source[property], length;\n          if (typeof value == \"object\" && value) {\n            // `forEach` can't be used to traverse an array in Opera <= 8.54\n            // because its `Object#hasOwnProperty` implementation returns `false`\n            // for array indices (e.g., `![1, 2, 3].hasOwnProperty(\"0\")`).\n            if (getClass.call(value) == arrayClass) {\n              for (length = value.length; length--;) {\n                update(value, length, callback);\n              }\n            } else {\n              forEach(value, function (property) {\n                update(value, property, callback);\n              });\n            }\n          }\n          return callback.call(source, property, value);\n        };\n\n        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\n        exports.parse = function (source, callback) {\n          var result, value;\n          Index = 0;\n          Source = \"\" + source;\n          result = get(lex());\n          // If a JSON string contains multiple tokens, it is invalid.\n          if (lex() != \"$\") {\n            abort();\n          }\n          // Reset the parser state.\n          Index = Source = null;\n          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[\"\"] = result, value), \"\", callback) : result;\n        };\n      }\n    }\n\n    exports[\"runInContext\"] = runInContext;\n    return exports;\n  }\n\n  if (freeExports && !isLoader) {\n    // Export for CommonJS environments.\n    runInContext(root, freeExports);\n  } else {\n    // Export for web browsers and JavaScript engines.\n    var nativeJSON = root.JSON,\n        previousJSON = root[\"JSON3\"],\n        isRestored = false;\n\n    var JSON3 = runInContext(root, (root[\"JSON3\"] = {\n      // Public: Restores the original value of the global `JSON` object and\n      // returns a reference to the `JSON3` object.\n      \"noConflict\": function () {\n        if (!isRestored) {\n          isRestored = true;\n          root.JSON = nativeJSON;\n          root[\"JSON3\"] = previousJSON;\n          nativeJSON = previousJSON = null;\n        }\n        return JSON3;\n      }\n    }));\n\n    root.JSON = {\n      \"parse\": JSON3.parse,\n      \"stringify\": JSON3.stringify\n    };\n  }\n\n  // Export for asynchronous module loaders.\n  if (isLoader) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n      return JSON3;\n    }.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n}).call(this);\n\n//##############################################################################\n// DomUtils.js\n//##############################################################################\n\n(function () {\n\n\t/**\n\t * A few utilities for interacting with the dom.\n\t * @class DomUtils\n\t */\n\tvar s = {};\n\n\ts.appendToHead = function (el) {\n\t\ts.getHead().appendChild(el)\n\t}\n\n\ts.getHead = function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}\n\n\ts.getBody = function () {\n\t\treturn document.body || document.getElementsByTagName(\"body\")[0];\n\t}\n\n\tcreatejs.DomUtils = s;\n\n}());\n\n//##############################################################################\n// DataUtils.js\n//##############################################################################\n\n(function () {\n\n\t/**\n\t * A few data utilities for formatting different data types.\n\t * @class DataUtils\n\t */\n\tvar s = {};\n\n\t// static methods\n\t/**\n\t * Parse XML using the DOM. This is required when preloading XML or SVG.\n\t * @method parseXML\n\t * @param {String} text The raw text or XML that is loaded by XHR.\n\t * @param {String} type The mime type of the XML. Use \"text/xml\" for XML, and  \"image/svg+xml\" for SVG parsing.\n\t * @return {XML} An XML document\n\t * @static\n\t */\n\ts.parseXML = function (text, type) {\n\t\tvar xml = null;\n\t\t// CocoonJS does not support XML parsing with either method.\n\n\t\t// Most browsers will use DOMParser\n\t\t// IE fails on certain SVG files, so we have a fallback below.\n\t\ttry {\n\t\t\tif (window.DOMParser) {\n\t\t\t\tvar parser = new DOMParser();\n\t\t\t\txml = parser.parseFromString(text, type);\n\t\t\t}\n\t\t} catch (e) {\n\t\t}\n\n\t\t// Fallback for IE support.\n\t\tif (!xml) {\n\t\t\ttry {\n\t\t\t\txml = new ActiveXObject(\"Microsoft.XMLDOM\");\n\t\t\t\txml.async = false;\n\t\t\t\txml.loadXML(text);\n\t\t\t} catch (e) {\n\t\t\t\txml = null;\n\t\t\t}\n\t\t}\n\n\t\treturn xml;\n\t};\n\n\t/**\n\t * Parse a string into an Object.\n\t * @method parseJSON\n\t * @param {String} value The loaded JSON string\n\t * @returns {Object} A JavaScript object.\n\t */\n\ts.parseJSON = function (value) {\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\treturn JSON.parse(value);\n\t\t} catch (e) {\n\t\t\t// TODO; Handle this with a custom error?\n\t\t\tthrow e;\n\t\t}\n\t};\n\n\tcreatejs.DataUtils = s;\n\n}());\n\n//##############################################################################\n// LoadItem.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * All loaders accept an item containing the properties defined in this class. If a raw object is passed instead,\n\t * it will not be affected, but it must contain at least a {{#crossLink \"src:property\"}}{{/crossLink}} property. A\n\t * string path or HTML tag is also acceptable, but it will be automatically converted to a LoadItem using the\n\t * {{#crossLink \"create\"}}{{/crossLink}} method by {{#crossLink \"AbstractLoader\"}}{{/crossLink}}\n\t * @class LoadItem\n\t * @constructor\n\t * @since 0.6.0\n\t */\n\tfunction LoadItem() {\n\t\t/**\n\t\t * The source of the file that is being loaded. This property is <b>required</b>. The source can either be a\n\t\t * string (recommended), or an HTML tag.\n\t\t * This can also be an object, but in that case it has to include a type and be handled by a plugin.\n\t\t * @property src\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.src = null;\n\n\t\t/**\n\t\t * The type file that is being loaded. The type of the file is usually inferred by the extension, but can also\n\t\t * be set manually. This is helpful in cases where a file does not have an extension.\n\t\t * @property type\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.type = null;\n\n\t\t/**\n\t\t * A string identifier which can be used to reference the loaded object. If none is provided, this will be\n\t\t * automatically set to the {{#crossLink \"src:property\"}}{{/crossLink}}.\n\t\t * @property id\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.id = null;\n\n\t\t/**\n\t\t * Determines if a manifest will maintain the order of this item, in relation to other items in the manifest\n\t\t * that have also set the `maintainOrder` property to `true`. This only applies when the max connections has\n\t\t * been set above 1 (using {{#crossLink \"LoadQueue/setMaxConnections\"}}{{/crossLink}}). Everything with this\n\t\t * property set to `false` will finish as it is loaded. Ordered items are combined with script tags loading in\n\t\t * order when {{#crossLink \"LoadQueue/maintainScriptOrder:property\"}}{{/crossLink}} is set to `true`.\n\t\t * @property maintainOrder\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.maintainOrder = false;\n\n\t\t/**\n\t\t * A callback used by JSONP requests that defines what global method to call when the JSONP content is loaded.\n\t\t * @property callback\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.callback = null;\n\n\t\t/**\n\t\t * An arbitrary data object, which is included with the loaded object.\n\t\t * @property data\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis.data = null;\n\n\t\t/**\n\t\t * The request method used for HTTP calls. Both {{#crossLink \"AbstractLoader/GET:property\"}}{{/crossLink}} or\n\t\t * {{#crossLink \"AbstractLoader/POST:property\"}}{{/crossLink}} request types are supported, and are defined as\n\t\t * constants on {{#crossLink \"AbstractLoader\"}}{{/crossLink}}.\n\t\t * @property method\n\t\t * @type {String}\n\t\t * @default get\n\t\t */\n\t\tthis.method = createjs.LoadItem.GET;\n\n\t\t/**\n\t\t * An object hash of name/value pairs to send to the server.\n\t\t * @property values\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis.values = null;\n\n\t\t/**\n\t\t * An object hash of headers to attach to an XHR request. PreloadJS will automatically attach some default\n\t\t * headers when required, including \"Origin\", \"Content-Type\", and \"X-Requested-With\". You may override the\n\t\t * default headers by including them in your headers object.\n\t\t * @property headers\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis.headers = null;\n\n\t\t/**\n\t\t * Enable credentials for XHR requests.\n\t\t * @property withCredentials\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.withCredentials = false;\n\n\t\t/**\n\t\t * Set the mime type of XHR-based requests. This is automatically set to \"text/plain; charset=utf-8\" for text\n\t\t * based files (json, xml, text, css, js).\n\t\t * @property mimeType\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.mimeType = null;\n\n\t\t/**\n\t\t * Sets the crossOrigin attribute for CORS-enabled images loading cross-domain.\n\t\t * @property crossOrigin\n\t\t * @type {boolean}\n\t\t * @default Anonymous\n\t\t */\n\t\tthis.crossOrigin = null;\n\n\t\t/**\n\t\t * The duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR\n\t\t * (level one) loading, as XHR (level 2) provides its own timeout event.\n\t\t * @property loadTimeout\n\t\t * @type {Number}\n\t\t * @default 8000 (8 seconds)\n\t\t */\n\t\tthis.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;\n\t};\n\n\tvar p = LoadItem.prototype = {};\n\tvar s = LoadItem;\n\n\t/**\n\t * Default duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR\n\t * (level one) loading, as XHR (level 2) provides its own timeout event.\n\t * @property LOAD_TIMEOUT_DEFAULT\n\t * @type {number}\n\t * @static\n\t */\n\ts.LOAD_TIMEOUT_DEFAULT = 8000;\n\n\t/**\n\t * Create a LoadItem.\n\t * <ul>\n\t *     <li>String-based items are converted to a LoadItem with a populated {{#crossLink \"src:property\"}}{{/crossLink}}.</li>\n\t *     <li>LoadItem instances are returned as-is</li>\n\t *     <li>Objects are returned with any needed properties added</li>\n\t * </ul>\n\t * @method create\n\t * @param {LoadItem|String|Object} value The load item value\n\t * @returns {LoadItem|Object}\n\t * @static\n\t */\n\ts.create = function (value) {\n\t\tif (typeof value == \"string\") {\n\t\t\tvar item = new LoadItem();\n\t\t\titem.src = value;\n\t\t\treturn item;\n\t\t} else if (value instanceof s) {\n\t\t\treturn value;\n\t\t} else if (value instanceof Object && value.src) {\n\t\t\tif (value.loadTimeout == null) {\n\t\t\t\tvalue.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;\n\t\t\t}\n\t\t\treturn value;\n\t\t} else {\n\t\t\tthrow new Error(\"Type not recognized.\");\n\t\t}\n\t};\n\n\t/**\n\t * Provides a chainable shortcut method for setting a number of properties on the instance.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var loadItem = new createjs.LoadItem().set({src:\"image.png\", maintainOrder:true});\n\t *\n\t * @method set\n\t * @param {Object} props A generic object containing properties to copy to the LoadItem instance.\n\t * @return {LoadItem} Returns the instance the method is called on (useful for chaining calls.)\n\t*/\n\tp.set = function(props) {\n\t\tfor (var n in props) { this[n] = props[n]; }\n\t\treturn this;\n\t};\n\n\tcreatejs.LoadItem = s;\n\n}());\n\n//##############################################################################\n// RequestUtils.js\n//##############################################################################\n\n(function () {\n\n\t/**\n\t * Utilities that assist with parsing load items, and determining file types, etc.\n\t * @class RequestUtils\n\t */\n\tvar s = {};\n\n\t/**\n\t * The Regular Expression used to test file URLS for an absolute path.\n\t * @property ABSOLUTE_PATH\n\t * @type {RegExp}\n\t * @static\n\t */\n\ts.ABSOLUTE_PATT = /^(?:\\w+:)?\\/{2}/i;\n\n\t/**\n\t * The Regular Expression used to test file URLS for a relative path.\n\t * @property RELATIVE_PATH\n\t * @type {RegExp}\n\t * @static\n\t */\n\ts.RELATIVE_PATT = (/^[./]*?\\//i);\n\n\t/**\n\t * The Regular Expression used to test file URLS for an extension. Note that URIs must already have the query string\n\t * removed.\n\t * @property EXTENSION_PATT\n\t * @type {RegExp}\n\t * @static\n\t */\n\ts.EXTENSION_PATT = /\\/?[^/]+\\.(\\w{1,5})$/i;\n\n\t/**\n\t * Parse a file path to determine the information we need to work with it. Currently, PreloadJS needs to know:\n\t * <ul>\n\t *     <li>If the path is absolute. Absolute paths start with a protocol (such as `http://`, `file://`, or\n\t *     `//networkPath`)</li>\n\t *     <li>If the path is relative. Relative paths start with `../` or `/path` (or similar)</li>\n\t *     <li>The file extension. This is determined by the filename with an extension. Query strings are dropped, and\n\t *     the file path is expected to follow the format `name.ext`.</li>\n\t * </ul>\n\t * @method parseURI\n\t * @param {String} path\n\t * @returns {Object} An Object with an `absolute` and `relative` Boolean values, as well as an optional 'extension`\n\t * property, which is the lowercase extension.\n\t * @static\n\t */\n\ts.parseURI = function (path) {\n\t\tvar info = {absolute: false, relative: false};\n\t\tif (path == null) { return info; }\n\n\t\t// Drop the query string\n\t\tvar queryIndex = path.indexOf(\"?\");\n\t\tif (queryIndex > -1) {\n\t\t\tpath = path.substr(0, queryIndex);\n\t\t}\n\n\t\t// Absolute\n\t\tvar match;\n\t\tif (s.ABSOLUTE_PATT.test(path)) {\n\t\t\tinfo.absolute = true;\n\n\t\t\t// Relative\n\t\t} else if (s.RELATIVE_PATT.test(path)) {\n\t\t\tinfo.relative = true;\n\t\t}\n\n\t\t// Extension\n\t\tif (match = path.match(s.EXTENSION_PATT)) {\n\t\t\tinfo.extension = match[1].toLowerCase();\n\t\t}\n\t\treturn info;\n\t};\n\n\t/**\n\t * Formats an object into a query string for either a POST or GET request.\n\t * @method formatQueryString\n\t * @param {Object} data The data to convert to a query string.\n\t * @param {Array} [query] Existing name/value pairs to append on to this query.\n\t * @static\n\t */\n\ts.formatQueryString = function (data, query) {\n\t\tif (data == null) {\n\t\t\tthrow new Error('You must specify data.');\n\t\t}\n\t\tvar params = [];\n\t\tfor (var n in data) {\n\t\t\tparams.push(n + '=' + escape(data[n]));\n\t\t}\n\t\tif (query) {\n\t\t\tparams = params.concat(query);\n\t\t}\n\t\treturn params.join('&');\n\t};\n\n\t/**\n\t * A utility method that builds a file path using a source and a data object, and formats it into a new path.\n\t * @method buildPath\n\t * @param {String} src The source path to add values to.\n\t * @param {Object} [data] Object used to append values to this request as a query string. Existing parameters on the\n\t * path will be preserved.\n\t * @returns {string} A formatted string that contains the path and the supplied parameters.\n\t * @static\n\t */\n\ts.buildPath = function (src, data) {\n\t\tif (data == null) {\n\t\t\treturn src;\n\t\t}\n\n\t\tvar query = [];\n\t\tvar idx = src.indexOf('?');\n\n\t\tif (idx != -1) {\n\t\t\tvar q = src.slice(idx + 1);\n\t\t\tquery = query.concat(q.split('&'));\n\t\t}\n\n\t\tif (idx != -1) {\n\t\t\treturn src.slice(0, idx) + '?' + this.formatQueryString(data, query);\n\t\t} else {\n\t\t\treturn src + '?' + this.formatQueryString(data, query);\n\t\t}\n\t};\n\n\t/**\n\t * @method isCrossDomain\n\t * @param {LoadItem|Object} item A load item with a `src` property.\n\t * @return {Boolean} If the load item is loading from a different domain than the current location.\n\t * @static\n\t */\n\ts.isCrossDomain = function (item) {\n\t\tvar target = document.createElement(\"a\");\n\t\ttarget.href = item.src;\n\n\t\tvar host = document.createElement(\"a\");\n\t\thost.href = location.href;\n\n\t\tvar crossdomain = (target.hostname != \"\") &&\n\t\t\t\t\t\t  (target.port != host.port ||\n\t\t\t\t\t\t   target.protocol != host.protocol ||\n\t\t\t\t\t\t   target.hostname != host.hostname);\n\t\treturn crossdomain;\n\t};\n\n\t/**\n\t * @method isLocal\n\t * @param {LoadItem|Object} item A load item with a `src` property\n\t * @return {Boolean} If the load item is loading from the \"file:\" protocol. Assume that the host must be local as\n\t * well.\n\t * @static\n\t */\n\ts.isLocal = function (item) {\n\t\tvar target = document.createElement(\"a\");\n\t\ttarget.href = item.src;\n\t\treturn target.hostname == \"\" && target.protocol == \"file:\";\n\t};\n\n\t/**\n\t * Determine if a specific type should be loaded as a binary file. Currently, only images and items marked\n\t * specifically as \"binary\" are loaded as binary. Note that audio is <b>not</b> a binary type, as we can not play\n\t * back using an audio tag if it is loaded as binary. Plugins can change the item type to binary to ensure they get\n\t * a binary result to work with. Binary files are loaded using XHR2. Types are defined as static constants on\n\t * {{#crossLink \"AbstractLoader\"}}{{/crossLink}}.\n\t * @method isBinary\n\t * @param {String} type The item type.\n\t * @return {Boolean} If the specified type is binary.\n\t * @static\n\t */\n\ts.isBinary = function (type) {\n\t\tswitch (type) {\n\t\t\tcase createjs.AbstractLoader.IMAGE:\n\t\t\tcase createjs.AbstractLoader.BINARY:\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Check if item is a valid HTMLImageElement\n\t * @method isImageTag\n\t * @param {Object} item\n\t * @returns {Boolean}\n\t * @static\n\t */\n\ts.isImageTag = function(item) {\n\t\treturn item instanceof HTMLImageElement;\n\t};\n\n\t/**\n\t * Check if item is a valid HTMLAudioElement\n\t * @method isAudioTag\n\t * @param {Object} item\n\t * @returns {Boolean}\n\t * @static\n\t */\n\ts.isAudioTag = function(item) {\n\t\tif (window.HTMLAudioElement) {\n\t\t\treturn item instanceof HTMLAudioElement;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Check if item is a valid HTMLVideoElement\n\t * @method isVideoTag\n\t * @param {Object} item\n\t * @returns {Boolean}\n\t * @static\n\t */\n\ts.isVideoTag = function(item) {\n\t\tif (window.HTMLVideoElement) {\n\t\t\treturn item instanceof HTMLVideoElement;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Determine if a specific type is a text-based asset, and should be loaded as UTF-8.\n\t * @method isText\n\t * @param {String} type The item type.\n\t * @return {Boolean} If the specified type is text.\n\t * @static\n\t */\n\ts.isText = function (type) {\n\t\tswitch (type) {\n\t\t\tcase createjs.AbstractLoader.TEXT:\n\t\t\tcase createjs.AbstractLoader.JSON:\n\t\t\tcase createjs.AbstractLoader.MANIFEST:\n\t\t\tcase createjs.AbstractLoader.XML:\n\t\t\tcase createjs.AbstractLoader.CSS:\n\t\t\tcase createjs.AbstractLoader.SVG:\n\t\t\tcase createjs.AbstractLoader.JAVASCRIPT:\n\t\t\tcase createjs.AbstractLoader.SPRITESHEET:\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Determine the type of the object using common extensions. Note that the type can be passed in with the load item\n\t * if it is an unusual extension.\n\t * @method getTypeByExtension\n\t * @param {String} extension The file extension to use to determine the load type.\n\t * @return {String} The determined load type (for example, <code>AbstractLoader.IMAGE</code>). Will return `null` if\n\t * the type can not be determined by the extension.\n\t * @static\n\t */\n\ts.getTypeByExtension = function (extension) {\n\t\tif (extension == null) {\n\t\t\treturn createjs.AbstractLoader.TEXT;\n\t\t}\n\n\t\tswitch (extension.toLowerCase()) {\n\t\t\tcase \"jpeg\":\n\t\t\tcase \"jpg\":\n\t\t\tcase \"gif\":\n\t\t\tcase \"png\":\n\t\t\tcase \"webp\":\n\t\t\tcase \"bmp\":\n\t\t\t\treturn createjs.AbstractLoader.IMAGE;\n\t\t\tcase \"ogg\":\n\t\t\tcase \"mp3\":\n\t\t\tcase \"webm\":\n\t\t\t\treturn createjs.AbstractLoader.SOUND;\n\t\t\tcase \"mp4\":\n\t\t\tcase \"webm\":\n\t\t\tcase \"ts\":\n\t\t\t\treturn createjs.AbstractLoader.VIDEO;\n\t\t\tcase \"json\":\n\t\t\t\treturn createjs.AbstractLoader.JSON;\n\t\t\tcase \"xml\":\n\t\t\t\treturn createjs.AbstractLoader.XML;\n\t\t\tcase \"css\":\n\t\t\t\treturn createjs.AbstractLoader.CSS;\n\t\t\tcase \"js\":\n\t\t\t\treturn createjs.AbstractLoader.JAVASCRIPT;\n\t\t\tcase 'svg':\n\t\t\t\treturn createjs.AbstractLoader.SVG;\n\t\t\tdefault:\n\t\t\t\treturn createjs.AbstractLoader.TEXT;\n\t\t}\n\t};\n\n\tcreatejs.RequestUtils = s;\n\n}());\n\n//##############################################################################\n// AbstractLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n// constructor\n\t/**\n\t * The base loader, which defines all the generic methods, properties, and events. All loaders extend this class,\n\t * including the {{#crossLink \"LoadQueue\"}}{{/crossLink}}.\n\t * @class AbstractLoader\n\t * @param {LoadItem|object|string} loadItem The item to be loaded.\n\t * @param {Boolean} [preferXHR] Determines if the LoadItem should <em>try</em> and load using XHR, or take a\n\t * tag-based approach, which can be better in cross-domain situations. Not all loaders can load using one or the\n\t * other, so this is a suggested directive.\n\t * @param {String} [type] The type of loader. Loader types are defined as constants on the AbstractLoader class,\n\t * such as {{#crossLink \"IMAGE:property\"}}{{/crossLink}}, {{#crossLink \"CSS:property\"}}{{/crossLink}}, etc.\n\t * @extends EventDispatcher\n\t */\n\tfunction AbstractLoader(loadItem, preferXHR, type) {\n\t\tthis.EventDispatcher_constructor();\n\n\t\t// public properties\n\t\t/**\n\t\t * If the loader has completed loading. This provides a quick check, but also ensures that the different approaches\n\t\t * used for loading do not pile up resulting in more than one `complete` {{#crossLink \"Event\"}}{{/crossLink}}.\n\t\t * @property loaded\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.loaded = false;\n\n\t\t/**\n\t\t * Determine if the loader was canceled. Canceled loads will not fire complete events. Note that this property\n\t\t * is readonly, so {{#crossLink \"LoadQueue\"}}{{/crossLink}} queues should be closed using {{#crossLink \"LoadQueue/close\"}}{{/crossLink}}\n\t\t * instead.\n\t\t * @property canceled\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @readonly\n\t\t */\n\t\tthis.canceled = false;\n\n\t\t/**\n\t\t * The current load progress (percentage) for this item. This will be a number between 0 and 1.\n\t\t *\n\t\t * <h4>Example</h4>\n\t\t *\n\t\t *     var queue = new createjs.LoadQueue();\n\t\t *     queue.loadFile(\"largeImage.png\");\n\t\t *     queue.on(\"progress\", function() {\n\t\t *         console.log(\"Progress:\", queue.progress, event.progress);\n\t\t *     });\n\t\t *\n\t\t * @property progress\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.progress = 0;\n\n\t\t/**\n\t\t * The type of item this loader will load. See {{#crossLink \"AbstractLoader\"}}{{/crossLink}} for a full list of\n\t\t * supported types.\n\t\t * @property type\n\t\t * @type {String}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * A formatter function that converts the loaded raw result into the final result. For example, the JSONLoader\n\t\t * converts a string of text into a JavaScript object. Not all loaders have a resultFormatter, and this property\n\t\t * can be overridden to provide custom formatting.\n\t\t *\n\t\t * Optionally, a resultFormatter can return a callback function in cases where the formatting needs to be\n\t\t * asynchronous, such as creating a new image. The callback function is passed 2 parameters, which are callbacks\n\t\t * to handle success and error conditions in the resultFormatter. Note that the resultFormatter method is\n\t\t * called in the current scope, as well as the success and error callbacks.\n\t\t *\n\t\t * <h4>Example asynchronous resultFormatter</h4>\n\t\t *\n\t\t * \tfunction _formatResult(loader) {\n\t\t * \t\treturn function(success, error) {\n\t\t * \t\t\tif (errorCondition) { error(errorDetailEvent); }\n\t\t * \t\t\tsuccess(result);\n\t\t * \t\t}\n\t\t * \t}\n\t\t * @property resultFormatter\n\t\t * @type {Function}\n\t\t * @default null\n\t\t */\n\t\tthis.resultFormatter = null;\n\n\t\t// protected properties\n\t\t/**\n\t\t * The {{#crossLink \"LoadItem\"}}{{/crossLink}} this loader represents. Note that this is null in a {{#crossLink \"LoadQueue\"}}{{/crossLink}},\n\t\t * but will be available on loaders such as {{#crossLink \"XMLLoader\"}}{{/crossLink}} and {{#crossLink \"ImageLoader\"}}{{/crossLink}}.\n\t\t * @property _item\n\t\t * @type {LoadItem|Object}\n\t\t * @private\n\t\t */\n\t\tif (loadItem) {\n\t\t\tthis._item = createjs.LoadItem.create(loadItem);\n\t\t} else {\n\t\t\tthis._item = null;\n\t\t}\n\n\t\t/**\n\t\t * Whether the loader will try and load content using XHR (true) or HTML tags (false).\n\t\t * @property _preferXHR\n\t\t * @type {Boolean}\n\t\t * @private\n\t\t */\n\t\tthis._preferXHR = preferXHR;\n\n\t\t/**\n\t\t * The loaded result after it is formatted by an optional {{#crossLink \"resultFormatter\"}}{{/crossLink}}. For\n\t\t * items that are not formatted, this will be the same as the {{#crossLink \"_rawResult:property\"}}{{/crossLink}}.\n\t\t * The result is accessed using the {{#crossLink \"getResult\"}}{{/crossLink}} method.\n\t\t * @property _result\n\t\t * @type {Object|String}\n\t\t * @private\n\t\t */\n\t\tthis._result = null;\n\n\t\t/**\n\t\t * The loaded result before it is formatted. The rawResult is accessed using the {{#crossLink \"getResult\"}}{{/crossLink}}\n\t\t * method, and passing `true`.\n\t\t * @property _rawResult\n\t\t * @type {Object|String}\n\t\t * @private\n\t\t */\n\t\tthis._rawResult = null;\n\n\t\t/**\n\t\t * A list of items that loaders load behind the scenes. This does not include the main item the loader is\n\t\t * responsible for loading. Examples of loaders that have sub-items include the {{#crossLink \"SpriteSheetLoader\"}}{{/crossLink}} and\n\t\t * {{#crossLink \"ManifestLoader\"}}{{/crossLink}}.\n\t\t * @property _loadItems\n\t\t * @type {null}\n\t\t * @protected\n\t\t */\n\t\tthis._loadedItems = null;\n\n\t\t/**\n\t\t * The attribute the items loaded using tags use for the source.\n\t\t * @type {string}\n\t\t * @default null\n\t\t * @private\n\t\t */\n\t\tthis._tagSrcAttribute = null;\n\n\t\t/**\n\t\t * An HTML tag (or similar) that a loader may use to load HTML content, such as images, scripts, etc.\n\t\t * @property _tag\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._tag = null;\n\t};\n\n\tvar p = createjs.extend(AbstractLoader, createjs.EventDispatcher);\n\tvar s = AbstractLoader;\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n\t/**\n\t * Defines a POST request, use for a method value when loading data.\n\t * @property POST\n\t * @type {string}\n\t * @default post\n\t * @static\n\t */\n\ts.POST = \"POST\";\n\n\t/**\n\t * Defines a GET request, use for a method value when loading data.\n\t * @property GET\n\t * @type {string}\n\t * @default get\n\t * @static\n\t */\n\ts.GET = \"GET\";\n\n\t/**\n\t * The preload type for generic binary types. Note that images are loaded as binary files when using XHR.\n\t * @property BINARY\n\t * @type {String}\n\t * @default binary\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.BINARY = \"binary\";\n\n\t/**\n\t * The preload type for css files. CSS files are loaded using a &lt;link&gt; when loaded with XHR, or a\n\t * &lt;style&gt; tag when loaded with tags.\n\t * @property CSS\n\t * @type {String}\n\t * @default css\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.CSS = \"css\";\n\n\t/**\n\t * The preload type for image files, usually png, gif, or jpg/jpeg. Images are loaded into an &lt;image&gt; tag.\n\t * @property IMAGE\n\t * @type {String}\n\t * @default image\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.IMAGE = \"image\";\n\n\t/**\n\t * The preload type for javascript files, usually with the \"js\" file extension. JavaScript files are loaded into a\n\t * &lt;script&gt; tag.\n\t *\n\t * Since version 0.4.1+, due to how tag-loaded scripts work, all JavaScript files are automatically injected into\n\t * the body of the document to maintain parity between XHR and tag-loaded scripts. In version 0.4.0 and earlier,\n\t * only tag-loaded scripts are injected.\n\t * @property JAVASCRIPT\n\t * @type {String}\n\t * @default javascript\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.JAVASCRIPT = \"javascript\";\n\n\t/**\n\t * The preload type for json files, usually with the \"json\" file extension. JSON data is loaded and parsed into a\n\t * JavaScript object. Note that if a `callback` is present on the load item, the file will be loaded with JSONP,\n\t * no matter what the {{#crossLink \"LoadQueue/preferXHR:property\"}}{{/crossLink}} property is set to, and the JSON\n\t * must contain a matching wrapper function.\n\t * @property JSON\n\t * @type {String}\n\t * @default json\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.JSON = \"json\";\n\n\t/**\n\t * The preload type for jsonp files, usually with the \"json\" file extension. JSON data is loaded and parsed into a\n\t * JavaScript object. You are required to pass a callback parameter that matches the function wrapper in the JSON.\n\t * Note that JSONP will always be used if there is a callback present, no matter what the {{#crossLink \"LoadQueue/preferXHR:property\"}}{{/crossLink}}\n\t * property is set to.\n\t * @property JSONP\n\t * @type {String}\n\t * @default jsonp\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.JSONP = \"jsonp\";\n\n\t/**\n\t * The preload type for json-based manifest files, usually with the \"json\" file extension. The JSON data is loaded\n\t * and parsed into a JavaScript object. PreloadJS will then look for a \"manifest\" property in the JSON, which is an\n\t * Array of files to load, following the same format as the {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}\n\t * method. If a \"callback\" is specified on the manifest object, then it will be loaded using JSONP instead,\n\t * regardless of what the {{#crossLink \"LoadQueue/preferXHR:property\"}}{{/crossLink}} property is set to.\n\t * @property MANIFEST\n\t * @type {String}\n\t * @default manifest\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.MANIFEST = \"manifest\";\n\n\t/**\n\t * The preload type for sound files, usually mp3, ogg, or wav. When loading via tags, audio is loaded into an\n\t * &lt;audio&gt; tag.\n\t * @property SOUND\n\t * @type {String}\n\t * @default sound\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.SOUND = \"sound\";\n\n\t/**\n\t * The preload type for video files, usually mp4, ts, or ogg. When loading via tags, video is loaded into an\n\t * &lt;video&gt; tag.\n\t * @property VIDEO\n\t * @type {String}\n\t * @default video\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.VIDEO = \"video\";\n\n\t/**\n\t * The preload type for SpriteSheet files. SpriteSheet files are JSON files that contain string image paths.\n\t * @property SPRITESHEET\n\t * @type {String}\n\t * @default spritesheet\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.SPRITESHEET = \"spritesheet\";\n\n\t/**\n\t * The preload type for SVG files.\n\t * @property SVG\n\t * @type {String}\n\t * @default svg\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.SVG = \"svg\";\n\n\t/**\n\t * The preload type for text files, which is also the default file type if the type can not be determined. Text is\n\t * loaded as raw text.\n\t * @property TEXT\n\t * @type {String}\n\t * @default text\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.TEXT = \"text\";\n\n\t/**\n\t * The preload type for xml files. XML is loaded into an XML document.\n\t * @property XML\n\t * @type {String}\n\t * @default xml\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.XML = \"xml\";\n\n// Events\n\t/**\n\t * The {{#crossLink \"ProgressEvent\"}}{{/crossLink}} that is fired when the overall progress changes. Prior to\n\t * version 0.6.0, this was just a regular {{#crossLink \"Event\"}}{{/crossLink}}.\n\t * @event progress\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * The {{#crossLink \"Event\"}}{{/crossLink}} that is fired when a load starts.\n\t * @event loadstart\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @since 0.3.1\n\t */\n\n\t/**\n\t * The {{#crossLink \"Event\"}}{{/crossLink}} that is fired when the entire queue has been loaded.\n\t * @event complete\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * The {{#crossLink \"ErrorEvent\"}}{{/crossLink}} that is fired when the loader encounters an error. If the error was\n\t * encountered by a file, the event will contain the item that caused the error. Prior to version 0.6.0, this was\n\t * just a regular {{#crossLink \"Event\"}}{{/crossLink}}.\n\t * @event error\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * The {{#crossLink \"Event\"}}{{/crossLink}} that is fired when the loader encounters an internal file load error.\n\t * This enables loaders to maintain internal queues, and surface file load errors.\n\t * @event fileerror\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The even type (\"fileerror\")\n\t * @param {LoadItem|object} The item that encountered the error\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * The {{#crossLink \"Event\"}}{{/crossLink}} that is fired when a loader internally loads a file. This enables\n\t * loaders such as {{#crossLink \"ManifestLoader\"}}{{/crossLink}} to maintain internal {{#crossLink \"LoadQueue\"}}{{/crossLink}}s\n\t * and notify when they have loaded a file. The {{#crossLink \"LoadQueue\"}}{{/crossLink}} class dispatches a\n\t * slightly different {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}} event.\n\t * @event fileload\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type (\"fileload\")\n\t * @param {Object} item The file item which was specified in the {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}}\n\t * or {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}} call. If only a string path or tag was specified, the\n\t * object will contain that value as a `src` property.\n\t * @param {Object} result The HTML tag or parsed result of the loaded item.\n\t * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted\n\t * to a usable object.\n\t * @since 0.6.0\n\t */\n\n\t/**\n\t * The {{#crossLink \"Event\"}}{{/crossLink}} that is fired after the internal request is created, but before a load.\n\t * This allows updates to the loader for specific loading needs, such as binary or XHR image loading.\n\t * @event initialize\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type (\"initialize\")\n\t * @param {AbstractLoader} loader The loader that has been initialized.\n\t */\n\n\n\t/**\n\t * Get a reference to the manifest item that is loaded by this loader. In some cases this will be the value that was\n\t * passed into {{#crossLink \"LoadQueue\"}}{{/crossLink}} using {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}} or\n\t * {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}. However if only a String path was passed in, then it will\n\t * be a {{#crossLink \"LoadItem\"}}{{/crossLink}}.\n\t * @method getItem\n\t * @return {Object} The manifest item that this loader is responsible for loading.\n\t * @since 0.6.0\n\t */\n\tp.getItem = function () {\n\t\treturn this._item;\n\t};\n\n\t/**\n\t * Get a reference to the content that was loaded by the loader (only available after the {{#crossLink \"complete:event\"}}{{/crossLink}}\n\t * event is dispatched.\n\t * @method getResult\n\t * @param {Boolean} [raw=false] Determines if the returned result will be the formatted content, or the raw loaded\n\t * data (if it exists).\n\t * @return {Object}\n\t * @since 0.6.0\n\t */\n\tp.getResult = function (raw) {\n\t\treturn raw ? this._rawResult : this._result;\n\t};\n\n\t/**\n\t * Return the `tag` this object creates or uses for loading.\n\t * @method getTag\n\t * @return {Object} The tag instance\n\t * @since 0.6.0\n\t */\n\tp.getTag = function () {\n\t\treturn this._tag;\n\t};\n\n\t/**\n\t * Set the `tag` this item uses for loading.\n\t * @method setTag\n\t * @param {Object} tag The tag instance\n\t * @since 0.6.0\n\t */\n\tp.setTag = function(tag) {\n\t  this._tag = tag;\n\t};\n\n\t/**\n\t * Begin loading the item. This method is required when using a loader by itself.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var queue = new createjs.LoadQueue();\n\t *      queue.on(\"complete\", handleComplete);\n\t *      queue.loadManifest(fileArray, false); // Note the 2nd argument that tells the queue not to start loading yet\n\t *      queue.load();\n\t *\n\t * @method load\n\t */\n\tp.load = function () {\n\t\tthis._createRequest();\n\n\t\tthis._request.on(\"complete\", this, this);\n\t\tthis._request.on(\"progress\", this, this);\n\t\tthis._request.on(\"loadStart\", this, this);\n\t\tthis._request.on(\"abort\", this, this);\n\t\tthis._request.on(\"timeout\", this, this);\n\t\tthis._request.on(\"error\", this, this);\n\n\t\tvar evt = new createjs.Event(\"initialize\");\n\t\tevt.loader = this._request;\n\t\tthis.dispatchEvent(evt);\n\n\t\tthis._request.load();\n\t};\n\n\t/**\n\t * Close the the item. This will stop any open requests (although downloads using HTML tags may still continue in\n\t * the background), but events will not longer be dispatched.\n\t * @method cancel\n\t */\n\tp.cancel = function () {\n\t\tthis.canceled = true;\n\t\tthis.destroy();\n\t};\n\n\t/**\n\t * Clean up the loader.\n\t * @method destroy\n\t */\n\tp.destroy = function() {\n\t\tif (this._request) {\n\t\t\tthis._request.removeAllEventListeners();\n\t\t\tthis._request.destroy();\n\t\t}\n\n\t\tthis._request = null;\n\n\t\tthis._item = null;\n\t\tthis._rawResult = null;\n\t\tthis._result = null;\n\n\t\tthis._loadItems = null;\n\n\t\tthis.removeAllEventListeners();\n\t};\n\n\t/**\n\t * Get any items loaded internally by the loader. The enables loaders such as {{#crossLink \"ManifestLoader\"}}{{/crossLink}}\n\t * to expose items it loads internally.\n\t * @method getLoadedItems\n\t * @return {Array} A list of the items loaded by the loader.\n\t * @since 0.6.0\n\t */\n\tp.getLoadedItems = function () {\n\t\treturn this._loadedItems;\n\t};\n\n\n\t// Private methods\n\t/**\n\t * Create an internal request used for loading. By default, an {{#crossLink \"XHRRequest\"}}{{/crossLink}} or\n\t * {{#crossLink \"TagRequest\"}}{{/crossLink}} is created, depending on the value of {{#crossLink \"preferXHR:property\"}}{{/crossLink}}.\n\t * Other loaders may override this to use different request types, such as {{#crossLink \"ManifestLoader\"}}{{/crossLink}},\n\t * which uses {{#crossLink \"JSONLoader\"}}{{/crossLink}} or {{#crossLink \"JSONPLoader\"}}{{/crossLink}} under the hood.\n\t * @method _createRequest\n\t * @protected\n\t */\n\tp._createRequest = function() {\n\t\tif (!this._preferXHR) {\n\t\t\tthis._request = new createjs.TagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);\n\t\t} else {\n\t\t\tthis._request = new createjs.XHRRequest(this._item);\n\t\t}\n\t};\n\n\t/**\n\t * Create the HTML tag used for loading. This method does nothing by default, and needs to be implemented\n\t * by loaders that require tag loading.\n\t * @method _createTag\n\t * @param {String} src The tag source\n\t * @return {HTMLElement} The tag that was created\n\t * @protected\n\t */\n\tp._createTag = function(src) { return null; };\n\n\t/**\n\t * Dispatch a loadstart {{#crossLink \"Event\"}}{{/crossLink}}. Please see the {{#crossLink \"AbstractLoader/loadstart:event\"}}{{/crossLink}}\n\t * event for details on the event payload.\n\t * @method _sendLoadStart\n\t * @protected\n\t */\n\tp._sendLoadStart = function () {\n\t\tif (this._isCanceled()) { return; }\n\t\tthis.dispatchEvent(\"loadstart\");\n\t};\n\n\t/**\n\t * Dispatch a {{#crossLink \"ProgressEvent\"}}{{/crossLink}}.\n\t * @method _sendProgress\n\t * @param {Number | Object} value The progress of the loaded item, or an object containing <code>loaded</code>\n\t * and <code>total</code> properties.\n\t * @protected\n\t */\n\tp._sendProgress = function (value) {\n\t\tif (this._isCanceled()) { return; }\n\t\tvar event = null;\n\t\tif (typeof(value) == \"number\") {\n\t\t\tthis.progress = value;\n\t\t\tevent = new createjs.ProgressEvent(this.progress);\n\t\t} else {\n\t\t\tevent = value;\n\t\t\tthis.progress = value.loaded / value.total;\n\t\t\tevent.progress = this.progress;\n\t\t\tif (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }\n\t\t}\n\t\tthis.hasEventListener(\"progress\") && this.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Dispatch a complete {{#crossLink \"Event\"}}{{/crossLink}}. Please see the {{#crossLink \"AbstractLoader/complete:event\"}}{{/crossLink}} event\n\t * @method _sendComplete\n\t * @protected\n\t */\n\tp._sendComplete = function () {\n\t\tif (this._isCanceled()) { return; }\n\n\t\tthis.loaded = true;\n\n\t\tvar event = new createjs.Event(\"complete\");\n\t\tevent.rawResult = this._rawResult;\n\n\t\tif (this._result != null) {\n\t\t\tevent.result = this._result;\n\t\t}\n\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Dispatch an error {{#crossLink \"Event\"}}{{/crossLink}}. Please see the {{#crossLink \"AbstractLoader/error:event\"}}{{/crossLink}}\n\t * event for details on the event payload.\n\t * @method _sendError\n\t * @param {ErrorEvent} event The event object containing specific error properties.\n\t * @protected\n\t */\n\tp._sendError = function (event) {\n\t\tif (this._isCanceled() || !this.hasEventListener(\"error\")) { return; }\n\t\tif (event == null) {\n\t\t\tevent = new createjs.ErrorEvent(\"PRELOAD_ERROR_EMPTY\"); // TODO: Populate error\n\t\t}\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Determine if the load has been canceled. This is important to ensure that method calls or asynchronous events\n\t * do not cause issues after the queue has been cleaned up.\n\t * @method _isCanceled\n\t * @return {Boolean} If the loader has been canceled.\n\t * @protected\n\t */\n\tp._isCanceled = function () {\n\t\tif (window.createjs == null || this.canceled) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * A custom result formatter function, which is called just before a request dispatches its complete event. Most\n\t * loader types already have an internal formatter, but this can be user-overridden for custom formatting. The\n\t * formatted result will be available on Loaders using {{#crossLink \"getResult\"}}{{/crossLink}}, and passing `true`.\n\t * @property resultFormatter\n\t * @type Function\n\t * @return {Object} The formatted result\n\t * @since 0.6.0\n\t */\n\tp.resultFormatter = null;\n\n\t/**\n\t * Handle events from internal requests. By default, loaders will handle, and redispatch the necessary events, but\n\t * this method can be overridden for custom behaviours.\n\t * @method handleEvent\n\t * @param {Event} event The event that the internal request dispatches.\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp.handleEvent = function (event) {\n\t\tswitch (event.type) {\n\t\t\tcase \"complete\":\n\t\t\t\tthis._rawResult = event.target._response;\n\t\t\t\tvar result = this.resultFormatter && this.resultFormatter(this);\n\t\t\t\tif (result instanceof Function) {\n\t\t\t\t\tresult.call(this,\n\t\t\t\t\t\t\tcreatejs.proxy(this._resultFormatSuccess, this),\n\t\t\t\t\t\t\tcreatejs.proxy(this._resultFormatFailed, this)\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthis._result =  result || this._rawResult;\n\t\t\t\t\tthis._sendComplete();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"progress\":\n\t\t\t\tthis._sendProgress(event);\n\t\t\t\tbreak;\n\t\t\tcase \"error\":\n\t\t\t\tthis._sendError(event);\n\t\t\t\tbreak;\n\t\t\tcase \"loadstart\":\n\t\t\t\tthis._sendLoadStart();\n\t\t\t\tbreak;\n\t\t\tcase \"abort\":\n\t\t\tcase \"timeout\":\n\t\t\t\tif (!this._isCanceled()) {\n\t\t\t\t\tthis.dispatchEvent(new createjs.ErrorEvent(\"PRELOAD_\" + event.type.toUpperCase() + \"_ERROR\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\t/**\n\t * The \"success\" callback passed to {{#crossLink \"AbstractLoader/resultFormatter\"}}{{/crossLink}} asynchronous\n\t * functions.\n\t * @method _resultFormatSuccess\n\t * @param {Object} result The formatted result\n\t * @private\n\t */\n\tp._resultFormatSuccess = function (result) {\n\t\tthis._result = result;\n\t\tthis._sendComplete();\n\t};\n\n\t/**\n\t * The \"error\" callback passed to {{#crossLink \"AbstractLoader/resultFormatter\"}}{{/crossLink}} asynchronous\n\t * functions.\n\t * @method _resultFormatSuccess\n\t * @param {Object} error The error event\n\t * @private\n\t */\n\tp._resultFormatFailed = function (event) {\n\t\tthis._sendError(event);\n\t};\n\n\t/**\n\t * @method buildPath\n\t * @protected\n\t * @deprecated Use the {{#crossLink \"RequestUtils\"}}{{/crossLink}} method {{#crossLink \"RequestUtils/buildPath\"}}{{/crossLink}}\n\t * instead.\n\t */\n\tp.buildPath = function (src, data) {\n\t\treturn createjs.RequestUtils.buildPath(src, data);\n\t};\n\n\t/**\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t */\n\tp.toString = function () {\n\t\treturn \"[PreloadJS AbstractLoader]\";\n\t};\n\n\tcreatejs.AbstractLoader = createjs.promote(AbstractLoader, \"EventDispatcher\");\n\n}());\n\n//##############################################################################\n// AbstractMediaLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * The AbstractMediaLoader is a base class that handles some of the shared methods and properties of loaders that\n\t * handle HTML media elements, such as Video and Audio.\n\t * @class AbstractMediaLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @param {String} type The type of media to load. Usually \"video\" or \"audio\".\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction AbstractMediaLoader(loadItem, preferXHR, type) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, type);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = \"src\";\n\n        this.on(\"initialize\", this._updateXHR, this);\n\t};\n\n\tvar p = createjs.extend(AbstractMediaLoader, createjs.AbstractLoader);\n\n\t// static properties\n\t// public methods\n\tp.load = function () {\n\t\t// TagRequest will handle most of this, but Sound / Video need a few custom properties, so just handle them here.\n\t\tif (!this._tag) {\n\t\t\tthis._tag = this._createTag(this._item.src);\n\t\t}\n\n\t\tthis._tag.preload = \"auto\";\n\t\tthis._tag.load();\n\n\t\tthis.AbstractLoader_load();\n\t};\n\n\t// protected methods\n\t/**\n\t * Creates a new tag for loading if it doesn't exist yet.\n\t * @method _createTag\n\t * @private\n\t */\n\tp._createTag = function () {};\n\n\n\tp._createRequest = function() {\n\t\tif (!this._preferXHR) {\n\t\t\tthis._request = new createjs.MediaTagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);\n\t\t} else {\n\t\t\tthis._request = new createjs.XHRRequest(this._item);\n\t\t}\n\t};\n\n    // protected methods\n    /**\n     * Before the item loads, set its mimeType and responseType.\n     * @property _updateXHR\n     * @param {Event} event\n     * @private\n     */\n    p._updateXHR = function (event) {\n        // Only exists for XHR\n        if (event.loader.setResponseType) {\n            event.loader.setResponseType(\"blob\");\n        }\n    };\n\n\t/**\n\t * The result formatter for media files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLVideoElement|HTMLAudioElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\tthis._tag.removeEventListener && this._tag.removeEventListener(\"canplaythrough\", this._loadedHandler);\n\t\tthis._tag.onstalled = null;\n\t\tif (this._preferXHR) {\n            var URL = window.URL || window.webkitURL;\n            var result = loader.getResult(true);\n\n\t\t\tloader.getTag().src = URL.createObjectURL(result);\n\t\t}\n\t\treturn loader.getTag();\n\t};\n\n\tcreatejs.AbstractMediaLoader = createjs.promote(AbstractMediaLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// AbstractRequest.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * A base class for actual data requests, such as {{#crossLink \"XHRRequest\"}}{{/crossLink}}, {{#crossLink \"TagRequest\"}}{{/crossLink}},\n\t * and {{#crossLink \"MediaRequest\"}}{{/crossLink}}. PreloadJS loaders will typically use a data loader under the\n\t * hood to get data.\n\t * @class AbstractRequest\n\t * @param {LoadItem} item\n\t * @constructor\n\t */\n\tvar AbstractRequest = function (item) {\n\t\tthis._item = item;\n\t};\n\n\tvar p = createjs.extend(AbstractRequest, createjs.EventDispatcher);\n\n\t// public methods\n\t/**\n\t * Begin a load.\n\t * @method load\n\t */\n\tp.load =  function() {};\n\n\t/**\n\t * Clean up a request.\n\t * @method destroy\n\t */\n\tp.destroy = function() {};\n\n\t/**\n\t * Cancel an in-progress request.\n\t * @method cancel\n\t */\n\tp.cancel = function() {};\n\n\tcreatejs.AbstractRequest = createjs.promote(AbstractRequest, \"EventDispatcher\");\n\n}());\n\n//##############################################################################\n// TagRequest.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * An {{#crossLink \"AbstractRequest\"}}{{/crossLink}} that loads HTML tags, such as images and scripts.\n\t * @class TagRequest\n\t * @param {LoadItem} loadItem\n\t * @param {HTMLElement} tag\n\t * @param {String} srcAttribute The tag attribute that specifies the source, such as \"src\", \"href\", etc.\n\t */\n\tfunction TagRequest(loadItem, tag, srcAttribute) {\n\t\tthis.AbstractRequest_constructor(loadItem);\n\n\t\t// protected properties\n\t\t/**\n\t\t * The HTML tag instance that is used to load.\n\t\t * @property _tag\n\t\t * @type {HTMLElement}\n\t\t * @protected\n\t\t */\n\t\tthis._tag = tag;\n\n\t\t/**\n\t\t * The tag attribute that specifies the source, such as \"src\", \"href\", etc.\n\t\t * @property _tagSrcAttribute\n\t\t * @type {String}\n\t\t * @protected\n\t\t */\n\t\tthis._tagSrcAttribute = srcAttribute;\n\n\t\t/**\n\t\t * A method closure used for handling the tag load event.\n\t\t * @property _loadedHandler\n\t\t * @type {Function}\n\t\t * @private\n\t\t */\n\t\tthis._loadedHandler = createjs.proxy(this._handleTagComplete, this);\n\n\t\t/**\n\t\t * Determines if the element was added to the DOM automatically by PreloadJS, so it can be cleaned up after.\n\t\t * @property _addedToDOM\n\t\t * @type {Boolean}\n\t\t * @private\n\t\t */\n\t\tthis._addedToDOM = false;\n\n\t\t/**\n\t\t * Determines what the tags initial style.visibility was, so we can set it correctly after a load.\n\t\t *\n\t\t * @type {null}\n\t\t * @private\n\t\t */\n\t\tthis._startTagVisibility = null;\n\t};\n\n\tvar p = createjs.extend(TagRequest, createjs.AbstractRequest);\n\n\t// public methods\n\tp.load = function () {\n\t\tthis._tag.onload = createjs.proxy(this._handleTagComplete, this);\n\t\tthis._tag.onreadystatechange = createjs.proxy(this._handleReadyStateChange, this);\n\t\tthis._tag.onerror = createjs.proxy(this._handleError, this);\n\n\t\tvar evt = new createjs.Event(\"initialize\");\n\t\tevt.loader = this._tag;\n\n\t\tthis.dispatchEvent(evt);\n\n\t\tthis._hideTag();\n\n\t\tthis._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);\n\n\t\tthis._tag[this._tagSrcAttribute] = this._item.src;\n\n\t\t// wdg:: Append the tag AFTER setting the src, or SVG loading on iOS will fail.\n\t\tif (this._tag.parentNode == null) {\n\t\t\twindow.document.body.appendChild(this._tag);\n\t\t\tthis._addedToDOM = true;\n\t\t}\n\t};\n\n\tp.destroy = function() {\n\t\tthis._clean();\n\t\tthis._tag = null;\n\n\t\tthis.AbstractRequest_destroy();\n\t};\n\n\t// private methods\n\t/**\n\t * Handle the readyStateChange event from a tag. We need this in place of the `onload` callback (mainly SCRIPT\n\t * and LINK tags), but other cases may exist.\n\t * @method _handleReadyStateChange\n\t * @private\n\t */\n\tp._handleReadyStateChange = function () {\n\t\tclearTimeout(this._loadTimeout);\n\t\t// This is strictly for tags in browsers that do not support onload.\n\t\tvar tag = this._tag;\n\n\t\t// Complete is for old IE support.\n\t\tif (tag.readyState == \"loaded\" || tag.readyState == \"complete\") {\n\t\t\tthis._handleTagComplete();\n\t\t}\n\t};\n\n\t/**\n\t * Handle any error events from the tag.\n\t * @method _handleError\n\t * @protected\n\t */\n\tp._handleError = function() {\n\t\tthis._clean();\n\t\tthis.dispatchEvent(\"error\");\n\t};\n\n\t/**\n\t * Handle the tag's onload callback.\n\t * @method _handleTagComplete\n\t * @private\n\t */\n\tp._handleTagComplete = function () {\n\t\tthis._rawResult = this._tag;\n\t\tthis._result = this.resultFormatter && this.resultFormatter(this) || this._rawResult;\n\n\t\tthis._clean();\n\t\tthis._showTag();\n\n\t\tthis.dispatchEvent(\"complete\");\n\t};\n\n\t/**\n\t * The tag request has not loaded within the time specified in loadTimeout.\n\t * @method _handleError\n\t * @param {Object} event The XHR error event.\n\t * @private\n\t */\n\tp._handleTimeout = function () {\n\t\tthis._clean();\n\t\tthis.dispatchEvent(new createjs.Event(\"timeout\"));\n\t};\n\n\t/**\n\t * Remove event listeners, but don't destroy the request object\n\t * @method _clean\n\t * @private\n\t */\n\tp._clean = function() {\n\t\tthis._tag.onload = null;\n\t\tthis._tag.onreadystatechange = null;\n\t\tthis._tag.onerror = null;\n\t\tif (this._addedToDOM && this._tag.parentNode != null) {\n\t\t\tthis._tag.parentNode.removeChild(this._tag);\n\t\t}\n\t\tclearTimeout(this._loadTimeout);\n\t};\n\n\tp._hideTag = function() {\n\t\tthis._startTagVisibility = this._tag.style.visibility;\n\t\tthis._tag.style.visibility = \"hidden\";\n\t};\n\n\tp._showTag = function() {\n\t\tthis._tag.style.visibility = this._startTagVisibility;\n\t};\n\n\t/**\n\t * Handle a stalled audio event. The main place this happens is with HTMLAudio in Chrome when playing back audio\n\t * that is already in a load, but not complete.\n\t * @method _handleStalled\n\t * @private\n\t */\n\tp._handleStalled = function () {\n\t\t//Ignore, let the timeout take care of it. Sometimes its not really stopped.\n\t};\n\n\tcreatejs.TagRequest = createjs.promote(TagRequest, \"AbstractRequest\");\n\n}());\n\n//##############################################################################\n// MediaTagRequest.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * An {{#crossLink \"TagRequest\"}}{{/crossLink}} that loads HTML tags for video and audio.\n\t * @class MediaTagRequest\n\t * @param {LoadItem} loadItem\n\t * @param {HTMLAudioElement|HTMLVideoElement} tag\n\t * @param {String} srcAttribute The tag attribute that specifies the source, such as \"src\", \"href\", etc.\n\t * @constructor\n\t */\n\tfunction MediaTagRequest(loadItem, tag, srcAttribute) {\n\t\tthis.AbstractRequest_constructor(loadItem);\n\n\t\t// protected properties\n\t\tthis._tag = tag;\n\t\tthis._tagSrcAttribute = srcAttribute;\n\t\tthis._loadedHandler = createjs.proxy(this._handleTagComplete, this);\n\t};\n\n\tvar p = createjs.extend(MediaTagRequest, createjs.TagRequest);\n\tvar s = MediaTagRequest;\n\n\t// public methods\n\tp.load = function () {\n\t\tvar sc = createjs.proxy(this._handleStalled, this);\n\t\tthis._stalledCallback = sc;\n\n\t\tvar pc = createjs.proxy(this._handleProgress, this);\n\t\tthis._handleProgress = pc;\n\n\t\tthis._tag.addEventListener(\"stalled\", sc);\n\t\tthis._tag.addEventListener(\"progress\", pc);\n\n\t\t// This will tell us when audio is buffered enough to play through, but not when its loaded.\n\t\t// The tag doesn't keep loading in Chrome once enough has buffered, and we have decided that behaviour is sufficient.\n\t\tthis._tag.addEventListener && this._tag.addEventListener(\"canplaythrough\", this._loadedHandler, false); // canplaythrough callback doesn't work in Chrome, so we use an event.\n\n\t\tthis.TagRequest_load();\n\t};\n\n\t// private methods\n\tp._handleReadyStateChange = function () {\n\t\tclearTimeout(this._loadTimeout);\n\t\t// This is strictly for tags in browsers that do not support onload.\n\t\tvar tag = this._tag;\n\n\t\t// Complete is for old IE support.\n\t\tif (tag.readyState == \"loaded\" || tag.readyState == \"complete\") {\n\t\t\tthis._handleTagComplete();\n\t\t}\n\t};\n\n\tp._handleStalled = function () {\n\t\t//Ignore, let the timeout take care of it. Sometimes its not really stopped.\n\t};\n\n\t/**\n\t * An XHR request has reported progress.\n\t * @method _handleProgress\n\t * @param {Object} event The XHR progress event.\n\t * @private\n\t */\n\tp._handleProgress = function (event) {\n\t\tif (!event || event.loaded > 0 && event.total == 0) {\n\t\t\treturn; // Sometimes we get no \"total\", so just ignore the progress event.\n\t\t}\n\n\t\tvar newEvent = new createjs.ProgressEvent(event.loaded, event.total);\n\t\tthis.dispatchEvent(newEvent);\n\t};\n\n\t// protected methods\n\tp._clean = function () {\n\t\tthis._tag.removeEventListener && this._tag.removeEventListener(\"canplaythrough\", this._loadedHandler);\n\t\tthis._tag.removeEventListener(\"stalled\", this._stalledCallback);\n\t\tthis._tag.removeEventListener(\"progress\", this._progressCallback);\n\n\t\tthis.TagRequest__clean();\n\t};\n\n\tcreatejs.MediaTagRequest = createjs.promote(MediaTagRequest, \"TagRequest\");\n\n}());\n\n//##############################################################################\n// XHRRequest.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n// constructor\n\t/**\n\t * A preloader that loads items using XHR requests, usually XMLHttpRequest. However XDomainRequests will be used\n\t * for cross-domain requests if possible, and older versions of IE fall back on to ActiveX objects when necessary.\n\t * XHR requests load the content as text or binary data, provide progress and consistent completion events, and\n\t * can be canceled during load. Note that XHR is not supported in IE 6 or earlier, and is not recommended for\n\t * cross-domain loading.\n\t * @class XHRRequest\n\t * @constructor\n\t * @param {Object} item The object that defines the file to load. Please see the {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}}\n\t * for an overview of supported file properties.\n\t * @extends AbstractLoader\n\t */\n\tfunction XHRRequest (item) {\n\t\tthis.AbstractRequest_constructor(item);\n\n\t\t// protected properties\n\t\t/**\n\t\t * A reference to the XHR request used to load the content.\n\t\t * @property _request\n\t\t * @type {XMLHttpRequest | XDomainRequest | ActiveX.XMLHTTP}\n\t\t * @private\n\t\t */\n\t\tthis._request = null;\n\n\t\t/**\n\t\t * A manual load timeout that is used for browsers that do not support the onTimeout event on XHR (XHR level 1,\n\t\t * typically IE9).\n\t\t * @property _loadTimeout\n\t\t * @type {Number}\n\t\t * @private\n\t\t */\n\t\tthis._loadTimeout = null;\n\n\t\t/**\n\t\t * The browser's XHR (XMLHTTPRequest) version. Supported versions are 1 and 2. There is no official way to detect\n\t\t * the version, so we use capabilities to make a best guess.\n\t\t * @property _xhrLevel\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t * @private\n\t\t */\n\t\tthis._xhrLevel = 1;\n\n\t\t/**\n\t\t * The response of a loaded file. This is set because it is expensive to look up constantly. This property will be\n\t\t * null until the file is loaded.\n\t\t * @property _response\n\t\t * @type {mixed}\n\t\t * @private\n\t\t */\n\t\tthis._response = null;\n\n\t\t/**\n\t\t * The response of the loaded file before it is modified. In most cases, content is converted from raw text to\n\t\t * an HTML tag or a formatted object which is set to the <code>result</code> property, but the developer may still\n\t\t * want to access the raw content as it was loaded.\n\t\t * @property _rawResponse\n\t\t * @type {String|Object}\n\t\t * @private\n\t\t */\n\t\tthis._rawResponse = null;\n\n\t\tthis._canceled = false;\n\n\t\t// Setup our event handlers now.\n\t\tthis._handleLoadStartProxy = createjs.proxy(this._handleLoadStart, this);\n\t\tthis._handleProgressProxy = createjs.proxy(this._handleProgress, this);\n\t\tthis._handleAbortProxy = createjs.proxy(this._handleAbort, this);\n\t\tthis._handleErrorProxy = createjs.proxy(this._handleError, this);\n\t\tthis._handleTimeoutProxy = createjs.proxy(this._handleTimeout, this);\n\t\tthis._handleLoadProxy = createjs.proxy(this._handleLoad, this);\n\t\tthis._handleReadyStateChangeProxy = createjs.proxy(this._handleReadyStateChange, this);\n\n\t\tif (!this._createXHR(item)) {\n\t\t\t//TODO: Throw error?\n\t\t}\n\t};\n\n\tvar p = createjs.extend(XHRRequest, createjs.AbstractRequest);\n\n// static properties\n\t/**\n\t * A list of XMLHTTP object IDs to try when building an ActiveX object for XHR requests in earlier versions of IE.\n\t * @property ACTIVEX_VERSIONS\n\t * @type {Array}\n\t * @since 0.4.2\n\t * @private\n\t */\n\tXHRRequest.ACTIVEX_VERSIONS = [\n\t\t\"Msxml2.XMLHTTP.6.0\",\n\t\t\"Msxml2.XMLHTTP.5.0\",\n\t\t\"Msxml2.XMLHTTP.4.0\",\n\t\t\"MSXML2.XMLHTTP.3.0\",\n\t\t\"MSXML2.XMLHTTP\",\n\t\t\"Microsoft.XMLHTTP\"\n\t];\n\n// Public methods\n\t/**\n\t * Look up the loaded result.\n\t * @method getResult\n\t * @param {Boolean} [raw=false] Return a raw result instead of a formatted result. This applies to content\n\t * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be\n\t * returned instead.\n\t * @return {Object} A result object containing the content that was loaded, such as:\n\t * <ul>\n\t *      <li>An image tag (&lt;image /&gt;) for images</li>\n\t *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts loaded with tags may be added to the\n\t *      HTML head.</li>\n\t *      <li>A style tag for CSS (&lt;style /&gt;)</li>\n\t *      <li>Raw text for TEXT</li>\n\t *      <li>A formatted JavaScript object defined by JSON</li>\n\t *      <li>An XML document</li>\n\t *      <li>An binary arraybuffer loaded by XHR</li>\n\t * </ul>\n\t * Note that if a raw result is requested, but not found, the result will be returned instead.\n\t */\n\tp.getResult = function (raw) {\n\t\tif (raw && this._rawResponse) {\n\t\t\treturn this._rawResponse;\n\t\t}\n\t\treturn this._response;\n\t};\n\n\t// Overrides abstract method in AbstractRequest\n\tp.cancel = function () {\n\t\tthis.canceled = true;\n\t\tthis._clean();\n\t\tthis._request.abort();\n\t};\n\n\t// Overrides abstract method in AbstractLoader\n\tp.load = function () {\n\t\tif (this._request == null) {\n\t\t\tthis._handleError();\n\t\t\treturn;\n\t\t}\n\n\t\t//Events\n\t\tif (this._request.addEventListener != null) {\n\t\t\tthis._request.addEventListener(\"loadstart\", this._handleLoadStartProxy, false);\n\t\t\tthis._request.addEventListener(\"progress\", this._handleProgressProxy, false);\n\t\t\tthis._request.addEventListener(\"abort\", this._handleAbortProxy, false);\n\t\t\tthis._request.addEventListener(\"error\", this._handleErrorProxy, false);\n\t\t\tthis._request.addEventListener(\"timeout\", this._handleTimeoutProxy, false);\n\n\t\t\t// Note: We don't get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.\n\t\t\tthis._request.addEventListener(\"load\", this._handleLoadProxy, false);\n\t\t\tthis._request.addEventListener(\"readystatechange\", this._handleReadyStateChangeProxy, false);\n\t\t} else {\n\t\t\t// IE9 support\n\t\t\tthis._request.onloadstart = this._handleLoadStartProxy;\n\t\t\tthis._request.onprogress = this._handleProgressProxy;\n\t\t\tthis._request.onabort = this._handleAbortProxy;\n\t\t\tthis._request.onerror = this._handleErrorProxy;\n\t\t\tthis._request.ontimeout = this._handleTimeoutProxy;\n\n\t\t\t// Note: We don't get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.\n\t\t\tthis._request.onload = this._handleLoadProxy;\n\t\t\tthis._request.onreadystatechange = this._handleReadyStateChangeProxy;\n\t\t}\n\n\t\t// Set up a timeout if we don't have XHR2\n\t\tif (this._xhrLevel == 1) {\n\t\t\tthis._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);\n\t\t}\n\n\t\t// Sometimes we get back 404s immediately, particularly when there is a cross origin request.  // note this does not catch in Chrome\n\t\ttry {\n\t\t\tif (!this._item.values || this._item.method == createjs.AbstractLoader.GET) {\n\t\t\t\tthis._request.send();\n\t\t\t} else if (this._item.method == createjs.AbstractLoader.POST) {\n\t\t\t\tthis._request.send(createjs.RequestUtils.formatQueryString(this._item.values));\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.dispatchEvent(new createjs.ErrorEvent(\"XHR_SEND\", null, error));\n\t\t}\n\t};\n\n\tp.setResponseType = function (type) {\n\t\t// Some old browsers doesn't support blob, so we convert arraybuffer to blob after response is downloaded\n\t\tif (type === 'blob') {\n\t\t\ttype = window.URL ? 'blob' : 'arraybuffer';\n\t\t\tthis._responseType = type;\n\t\t}\n\t\tthis._request.responseType = type;\n\t};\n\n\t/**\n\t * Get all the response headers from the XmlHttpRequest.\n\t *\n\t * <strong>From the docs:</strong> Return all the HTTP headers, excluding headers that are a case-insensitive match\n\t * for Set-Cookie or Set-Cookie2, as a single string, with each header line separated by a U+000D CR U+000A LF pair,\n\t * excluding the status line, and with each header name and header value separated by a U+003A COLON U+0020 SPACE\n\t * pair.\n\t * @method getAllResponseHeaders\n\t * @return {String}\n\t * @since 0.4.1\n\t */\n\tp.getAllResponseHeaders = function () {\n\t\tif (this._request.getAllResponseHeaders instanceof Function) {\n\t\t\treturn this._request.getAllResponseHeaders();\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t};\n\n\t/**\n\t * Get a specific response header from the XmlHttpRequest.\n\t *\n\t * <strong>From the docs:</strong> Returns the header field value from the response of which the field name matches\n\t * header, unless the field name is Set-Cookie or Set-Cookie2.\n\t * @method getResponseHeader\n\t * @param {String} header The header name to retrieve.\n\t * @return {String}\n\t * @since 0.4.1\n\t */\n\tp.getResponseHeader = function (header) {\n\t\tif (this._request.getResponseHeader instanceof Function) {\n\t\t\treturn this._request.getResponseHeader(header);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t};\n\n// protected methods\n\t/**\n\t * The XHR request has reported progress.\n\t * @method _handleProgress\n\t * @param {Object} event The XHR progress event.\n\t * @private\n\t */\n\tp._handleProgress = function (event) {\n\t\tif (!event || event.loaded > 0 && event.total == 0) {\n\t\t\treturn; // Sometimes we get no \"total\", so just ignore the progress event.\n\t\t}\n\n\t\tvar newEvent = new createjs.ProgressEvent(event.loaded, event.total);\n\t\tthis.dispatchEvent(newEvent);\n\t};\n\n\t/**\n\t * The XHR request has reported a load start.\n\t * @method _handleLoadStart\n\t * @param {Object} event The XHR loadStart event.\n\t * @private\n\t */\n\tp._handleLoadStart = function (event) {\n\t\tclearTimeout(this._loadTimeout);\n\t\tthis.dispatchEvent(\"loadstart\");\n\t};\n\n\t/**\n\t * The XHR request has reported an abort event.\n\t * @method handleAbort\n\t * @param {Object} event The XHR abort event.\n\t * @private\n\t */\n\tp._handleAbort = function (event) {\n\t\tthis._clean();\n\t\tthis.dispatchEvent(new createjs.ErrorEvent(\"XHR_ABORTED\", null, event));\n\t};\n\n\t/**\n\t * The XHR request has reported an error event.\n\t * @method _handleError\n\t * @param {Object} event The XHR error event.\n\t * @private\n\t */\n\tp._handleError = function (event) {\n\t\tthis._clean();\n\t\tthis.dispatchEvent(new createjs.ErrorEvent(event.message));\n\t};\n\n\t/**\n\t * The XHR request has reported a readyState change. Note that older browsers (IE 7 & 8) do not provide an onload\n\t * event, so we must monitor the readyStateChange to determine if the file is loaded.\n\t * @method _handleReadyStateChange\n\t * @param {Object} event The XHR readyStateChange event.\n\t * @private\n\t */\n\tp._handleReadyStateChange = function (event) {\n\t\tif (this._request.readyState == 4) {\n\t\t\tthis._handleLoad();\n\t\t}\n\t};\n\n\t/**\n\t * The XHR request has completed. This is called by the XHR request directly, or by a readyStateChange that has\n\t * <code>request.readyState == 4</code>. Only the first call to this method will be processed.\n\t * @method _handleLoad\n\t * @param {Object} event The XHR load event.\n\t * @private\n\t */\n\tp._handleLoad = function (event) {\n\t\tif (this.loaded) {\n\t\t\treturn;\n\t\t}\n\t\tthis.loaded = true;\n\n\t\tvar error = this._checkError();\n\t\tif (error) {\n\t\t\tthis._handleError(error);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._response = this._getResponse();\n\t\t// Convert arraybuffer back to blob\n\t\tif (this._responseType === 'arraybuffer') {\n\t\t\ttry {\n\t\t\t\tthis._response = new Blob([this._response]);\n\t\t\t} catch (e) {\n\t\t\t\t// Fallback to use BlobBuilder if Blob constructor is not supported\n\t\t\t\t// Tested on Android 2.3 ~ 4.2 and iOS5 safari\n\t\t\t\twindow.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\t\t\t\tif (e.name === 'TypeError' && window.BlobBuilder) {\n\t\t\t\t\tvar builder = new BlobBuilder();\n\t\t\t\t\tbuilder.append(this._response);\n\t\t\t\t\tthis._response = builder.getBlob();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._clean();\n\n\t\tthis.dispatchEvent(new createjs.Event(\"complete\"));\n\t};\n\n\t/**\n\t * The XHR request has timed out. This is called by the XHR request directly, or via a <code>setTimeout</code>\n\t * callback.\n\t * @method _handleTimeout\n\t * @param {Object} [event] The XHR timeout event. This is occasionally null when called by the backup setTimeout.\n\t * @private\n\t */\n\tp._handleTimeout = function (event) {\n\t\tthis._clean();\n\n\t\tthis.dispatchEvent(new createjs.ErrorEvent(\"PRELOAD_TIMEOUT\", null, event));\n\t};\n\n// Protected\n\t/**\n\t * Determine if there is an error in the current load. This checks the status of the request for problem codes. Note\n\t * that this does not check for an actual response. Currently, it only checks for 404 or 0 error code.\n\t * @method _checkError\n\t * @return {int} If the request status returns an error code.\n\t * @private\n\t */\n\tp._checkError = function () {\n\t\t//LM: Probably need additional handlers here, maybe 501\n\t\tvar status = parseInt(this._request.status);\n\n\t\tswitch (status) {\n\t\t\tcase 404:   // Not Found\n\t\t\tcase 0:     // Not Loaded\n\t\t\t\treturn new Error(status);\n\t\t}\n\t\treturn null;\n\t};\n\n\t/**\n\t * Validate the response. Different browsers have different approaches, some of which throw errors when accessed\n\t * in other browsers. If there is no response, the <code>_response</code> property will remain null.\n\t * @method _getResponse\n\t * @private\n\t */\n\tp._getResponse = function () {\n\t\tif (this._response != null) {\n\t\t\treturn this._response;\n\t\t}\n\n\t\tif (this._request.response != null) {\n\t\t\treturn this._request.response;\n\t\t}\n\n\t\t// Android 2.2 uses .responseText\n\t\ttry {\n\t\t\tif (this._request.responseText != null) {\n\t\t\t\treturn this._request.responseText;\n\t\t\t}\n\t\t} catch (e) {\n\t\t}\n\n\t\t// When loading XML, IE9 does not return .response, instead it returns responseXML.xml\n\t\ttry {\n\t\t\tif (this._request.responseXML != null) {\n\t\t\t\treturn this._request.responseXML;\n\t\t\t}\n\t\t} catch (e) {\n\t\t}\n\n\t\treturn null;\n\t};\n\n\t/**\n\t * Create an XHR request. Depending on a number of factors, we get totally different results.\n\t * <ol><li>Some browsers get an <code>XDomainRequest</code> when loading cross-domain.</li>\n\t *      <li>XMLHttpRequest are created when available.</li>\n\t *      <li>ActiveX.XMLHTTP objects are used in older IE browsers.</li>\n\t *      <li>Text requests override the mime type if possible</li>\n\t *      <li>Origin headers are sent for crossdomain requests in some browsers.</li>\n\t *      <li>Binary loads set the response type to \"arraybuffer\"</li></ol>\n\t * @method _createXHR\n\t * @param {Object} item The requested item that is being loaded.\n\t * @return {Boolean} If an XHR request or equivalent was successfully created.\n\t * @private\n\t */\n\tp._createXHR = function (item) {\n\t\t// Check for cross-domain loads. We can't fully support them, but we can try.\n\t\tvar crossdomain = createjs.RequestUtils.isCrossDomain(item);\n\t\tvar headers = {};\n\n\t\t// Create the request. Fallback to whatever support we have.\n\t\tvar req = null;\n\t\tif (window.XMLHttpRequest) {\n\t\t\treq = new XMLHttpRequest();\n\t\t\t// This is 8 or 9, so use XDomainRequest instead.\n\t\t\tif (crossdomain && req.withCredentials === undefined && window.XDomainRequest) {\n\t\t\t\treq = new XDomainRequest();\n\t\t\t}\n\t\t} else { // Old IE versions use a different approach\n\t\t\tfor (var i = 0, l = s.ACTIVEX_VERSIONS.length; i < l; i++) {\n\t\t\t\tvar axVersion = s.ACTIVEX_VERSIONS[i];\n\t\t\t\ttry {\n\t\t\t\t\treq = new ActiveXObject(axVersion);\n\t\t\t\t\tbreak;\n\t\t\t\t} catch (e) {\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (req == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Default to utf-8 for Text requests.\n\t\tif (item.mimeType == null && createjs.RequestUtils.isText(item.type)) {\n\t\t\titem.mimeType = \"text/plain; charset=utf-8\";\n\t\t}\n\n\t\t// IE9 doesn't support overrideMimeType(), so we need to check for it.\n\t\tif (item.mimeType && req.overrideMimeType) {\n\t\t\treq.overrideMimeType(item.mimeType);\n\t\t}\n\n\t\t// Determine the XHR level\n\t\tthis._xhrLevel = (typeof req.responseType === \"string\") ? 2 : 1;\n\n\t\tvar src = null;\n\t\tif (item.method == createjs.AbstractLoader.GET) {\n\t\t\tsrc = createjs.RequestUtils.buildPath(item.src, item.values);\n\t\t} else {\n\t\t\tsrc = item.src;\n\t\t}\n\n\t\t// Open the request.  Set cross-domain flags if it is supported (XHR level 1 only)\n\t\treq.open(item.method || createjs.AbstractLoader.GET, src, true);\n\n\t\tif (crossdomain && req instanceof XMLHttpRequest && this._xhrLevel == 1) {\n\t\t\theaders[\"Origin\"] = location.origin;\n\t\t}\n\n\t\t// To send data we need to set the Content-type header)\n\t\tif (item.values && item.method == createjs.AbstractLoader.POST) {\n\t\t\theaders[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n\t\t}\n\n\t\tif (!crossdomain && !headers[\"X-Requested-With\"]) {\n\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t}\n\n\t\tif (item.headers) {\n\t\t\tfor (var n in item.headers) {\n\t\t\t\theaders[n] = item.headers[n];\n\t\t\t}\n\t\t}\n\n\t\tfor (n in headers) {\n\t\t\treq.setRequestHeader(n, headers[n])\n\t\t}\n\n\t\tif (req instanceof XMLHttpRequest && item.withCredentials !== undefined) {\n\t\t\treq.withCredentials = item.withCredentials;\n\t\t}\n\n\t\tthis._request = req;\n\n\t\treturn true;\n\t};\n\n\t/**\n\t * A request has completed (or failed or canceled), and needs to be disposed.\n\t * @method _clean\n\t * @private\n\t */\n\tp._clean = function () {\n\t\tclearTimeout(this._loadTimeout);\n\n\t\tif (this._request.removeEventListener != null) {\n\t\t\tthis._request.removeEventListener(\"loadstart\", this._handleLoadStartProxy);\n\t\t\tthis._request.removeEventListener(\"progress\", this._handleProgressProxy);\n\t\t\tthis._request.removeEventListener(\"abort\", this._handleAbortProxy);\n\t\t\tthis._request.removeEventListener(\"error\", this._handleErrorProxy);\n\t\t\tthis._request.removeEventListener(\"timeout\", this._handleTimeoutProxy);\n\t\t\tthis._request.removeEventListener(\"load\", this._handleLoadProxy);\n\t\t\tthis._request.removeEventListener(\"readystatechange\", this._handleReadyStateChangeProxy);\n\t\t} else {\n\t\t\tthis._request.onloadstart = null;\n\t\t\tthis._request.onprogress = null;\n\t\t\tthis._request.onabort = null;\n\t\t\tthis._request.onerror = null;\n\t\t\tthis._request.ontimeout = null;\n\t\t\tthis._request.onload = null;\n\t\t\tthis._request.onreadystatechange = null;\n\t\t}\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[PreloadJS XHRRequest]\";\n\t};\n\n\tcreatejs.XHRRequest = createjs.promote(XHRRequest, \"AbstractRequest\");\n\n}());\n\n//##############################################################################\n// LoadQueue.js\n//##############################################################################\n\n/*\n TODO: WINDOWS ISSUES\n * No error for HTML audio in IE 678\n * SVG no failure error in IE 67 (maybe 8) TAGS AND XHR\n * No script complete handler in IE 67 TAGS (XHR is fine)\n * No XML/JSON in IE6 TAGS\n * Need to hide loading SVG in Opera TAGS\n * No CSS onload/readystatechange in Safari or Android TAGS (requires rule checking)\n * SVG no load or failure in Opera XHR\n * Reported issues with IE7/8\n */\n\n(function () {\n\t\"use strict\";\n\n// constructor\n\t/**\n\t * The LoadQueue class is the main API for preloading content. LoadQueue is a load manager, which can preload either\n\t * a single file, or queue of files.\n\t *\n\t * <b>Creating a Queue</b><br />\n\t * To use LoadQueue, create a LoadQueue instance. If you want to force tag loading where possible, set the preferXHR\n\t * argument to false.\n\t *\n\t *      var queue = new createjs.LoadQueue(true);\n\t *\n\t * <b>Listening for Events</b><br />\n\t * Add any listeners you want to the queue. Since PreloadJS 0.3.0, the {{#crossLink \"EventDispatcher\"}}{{/crossLink}}\n\t * lets you add as many listeners as you want for events. You can subscribe to the following events:<ul>\n\t *     <li>{{#crossLink \"AbstractLoader/complete:event\"}}{{/crossLink}}: fired when a queue completes loading all\n\t *     files</li>\n\t *     <li>{{#crossLink \"AbstractLoader/error:event\"}}{{/crossLink}}: fired when the queue encounters an error with\n\t *     any file.</li>\n\t *     <li>{{#crossLink \"AbstractLoader/progress:event\"}}{{/crossLink}}: Progress for the entire queue has\n\t *     changed.</li>\n\t *     <li>{{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}}: A single file has completed loading.</li>\n\t *     <li>{{#crossLink \"LoadQueue/fileprogress:event\"}}{{/crossLink}}: Progress for a single file has changes. Note\n\t *     that only files loaded with XHR (or possibly by plugins) will fire progress events other than 0 or 100%.</li>\n\t * </ul>\n\t *\n\t *      queue.on(\"fileload\", handleFileLoad, this);\n\t *      queue.on(\"complete\", handleComplete, this);\n\t *\n\t * <b>Adding files and manifests</b><br />\n\t * Add files you want to load using {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}} or add multiple files at a\n\t * time using a list or a manifest definition using {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}. Files are\n\t * appended to the end of the active queue, so you can use these methods as many times as you like, whenever you\n\t * like.\n\t *\n\t *      queue.loadFile(\"filePath/file.jpg\");\n\t *      queue.loadFile({id:\"image\", src:\"filePath/file.jpg\"});\n\t *      queue.loadManifest([\"filePath/file.jpg\", {id:\"image\", src:\"filePath/file.jpg\"}]);\n\t *\n\t *      // Use an external manifest\n\t *      queue.loadManifest(\"path/to/manifest.json\");\n\t *      queue.loadManifest({src:\"manifest.json\", type:\"manifest\"});\n\t *\n\t * If you pass `false` as the `loadNow` parameter, the queue will not kick of the load of the files, but it will not\n\t * stop if it has already been started. Call the {{#crossLink \"AbstractLoader/load\"}}{{/crossLink}} method to begin\n\t * a paused queue. Note that a paused queue will automatically resume when new files are added to it with a\n\t * `loadNow` argument of `true`.\n\t *\n\t *      queue.load();\n\t *\n\t * <b>File Types</b><br />\n\t * The file type of a manifest item is auto-determined by the file extension. The pattern matching in PreloadJS\n\t * should handle the majority of standard file and url formats, and works with common file extensions. If you have\n\t * either a non-standard file extension, or are serving the file using a proxy script, then you can pass in a\n\t * <code>type</code> property with any manifest item.\n\t *\n\t *      queue.loadFile({src:\"path/to/myFile.mp3x\", type:createjs.AbstractLoader.SOUND});\n\t *\n\t *      // Note that PreloadJS will not read a file extension from the query string\n\t *      queue.loadFile({src:\"http://server.com/proxy?file=image.jpg\", type:createjs.AbstractLoader.IMAGE});\n\t *\n\t * Supported types are defined on the {{#crossLink \"AbstractLoader\"}}{{/crossLink}} class, and include:\n\t * <ul>\n\t *     <li>{{#crossLink \"AbstractLoader/BINARY:property\"}}{{/crossLink}}: Raw binary data via XHR</li>\n\t *     <li>{{#crossLink \"AbstractLoader/CSS:property\"}}{{/crossLink}}: CSS files</li>\n\t *     <li>{{#crossLink \"AbstractLoader/IMAGE:property\"}}{{/crossLink}}: Common image formats</li>\n\t *     <li>{{#crossLink \"AbstractLoader/JAVASCRIPT:property\"}}{{/crossLink}}: JavaScript files</li>\n\t *     <li>{{#crossLink \"AbstractLoader/JSON:property\"}}{{/crossLink}}: JSON data</li>\n\t *     <li>{{#crossLink \"AbstractLoader/JSONP:property\"}}{{/crossLink}}: JSON files cross-domain</li>\n\t *     <li>{{#crossLink \"AbstractLoader/MANIFEST:property\"}}{{/crossLink}}: A list of files to load in JSON format, see\n\t *     {{#crossLink \"AbstractLoader/loadManifest\"}}{{/crossLink}}</li>\n\t *     <li>{{#crossLink \"AbstractLoader/SOUND:property\"}}{{/crossLink}}: Audio file formats</li>\n\t *     <li>{{#crossLink \"AbstractLoader/SPRITESHEET:property\"}}{{/crossLink}}: JSON SpriteSheet definitions. This\n\t *     will also load sub-images, and provide a {{#crossLink \"SpriteSheet\"}}{{/crossLink}} instance.</li>\n\t *     <li>{{#crossLink \"AbstractLoader/SVG:property\"}}{{/crossLink}}: SVG files</li>\n\t *     <li>{{#crossLink \"AbstractLoader/TEXT:property\"}}{{/crossLink}}: Text files - XHR only</li>\n     *     <li>{{#crossLink \"AbstractLoader/VIDEO:property\"}}{{/crossLink}}: Video objects</li>\n\t *     <li>{{#crossLink \"AbstractLoader/XML:property\"}}{{/crossLink}}: XML data</li>\n\t * </ul>\n\t *\n\t * <em>Note: Loader types used to be defined on LoadQueue, but have been moved to AbstractLoader for better\n\t * portability of loader classes, which can be used individually now. The properties on LoadQueue still exist, but\n\t * are deprecated.</em>\n\t *\n\t * <b>Handling Results</b><br />\n\t * When a file is finished downloading, a {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}} event is\n\t * dispatched. In an example above, there is an event listener snippet for fileload. Loaded files are usually a\n\t * formatted object that can be used immediately, including:\n\t * <ul>\n\t *     <li>Binary: The binary loaded result</li>\n\t *     <li>CSS: A &lt;link /&gt; tag</li>\n\t *     <li>Image: An &lt;img /&gt; tag</li>\n\t *     <li>JavaScript: A &lt;script /&gt; tag</li>\n\t *     <li>JSON/JSONP: A formatted JavaScript Object</li>\n\t *     <li>Manifest: A JavaScript object.\n\t *     <li>Sound: An &lt;audio /&gt; tag</a>\n\t *     <li>SpriteSheet: A {{#crossLink \"SpriteSheet\"}}{{/crossLink}} instance, containing loaded images.\n\t *     <li>SVG: An &lt;object /&gt; tag</li>\n\t *     <li>Text: Raw text</li>\n     *     <li>Video: A Video DOM node</li>\n\t *     <li>XML: An XML DOM node</li>\n\t * </ul>\n\t *\n\t *      function handleFileLoad(event) {\n\t *          var item = event.item; // A reference to the item that was passed in to the LoadQueue\n\t *          var type = item.type;\n\t *\n\t *          // Add any images to the page body.\n\t *          if (type == createjs.LoadQueue.IMAGE) {\n\t *              document.body.appendChild(event.result);\n\t *          }\n\t *      }\n\t *\n\t * At any time after the file has been loaded (usually after the queue has completed), any result can be looked up\n\t * via its \"id\" using {{#crossLink \"LoadQueue/getResult\"}}{{/crossLink}}. If no id was provided, then the\n\t * \"src\" or file path can be used instead, including the `path` defined by a manifest, but <strong>not including</strong>\n\t * a base path defined on the LoadQueue. It is recommended to always pass an id if you want to look up content.\n\t *\n\t *      var image = queue.getResult(\"image\");\n\t *      document.body.appendChild(image);\n\t *\n\t * Raw loaded content can be accessed using the <code>rawResult</code> property of the {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}}\n\t * event, or can be looked up using {{#crossLink \"LoadQueue/getResult\"}}{{/crossLink}}, passing `true` as the 2nd\n\t * argument. This is only applicable for content that has been parsed for the browser, specifically: JavaScript,\n\t * CSS, XML, SVG, and JSON objects, or anything loaded with XHR.\n\t *\n\t *      var image = queue.getResult(\"image\", true); // load the binary image data loaded with XHR.\n\t *\n\t * <b>Plugins</b><br />\n\t * LoadQueue has a simple plugin architecture to help process and preload content. For example, to preload audio,\n\t * make sure to install the <a href=\"http://soundjs.com\">SoundJS</a> Sound class, which will help load HTML audio,\n\t * Flash audio, and WebAudio files. This should be installed <strong>before</strong> loading any audio files.\n\t *\n\t *      queue.installPlugin(createjs.Sound);\n\t *\n\t * <h4>Known Browser Issues</h4>\n\t * <ul>\n\t *     <li>Browsers without audio support can not load audio files.</li>\n\t *     <li>Safari on Mac OS X can only play HTML audio if QuickTime is installed</li>\n\t *     <li>HTML Audio tags will only download until their <code>canPlayThrough</code> event is fired. Browsers other\n\t *     than Chrome will continue to download in the background.</li>\n\t *     <li>When loading scripts using tags, they are automatically added to the document.</li>\n\t *     <li>Scripts loaded via XHR may not be properly inspectable with browser tools.</li>\n\t *     <li>IE6 and IE7 (and some other browsers) may not be able to load XML, Text, or JSON, since they require\n\t *     XHR to work.</li>\n\t *     <li>Content loaded via tags will not show progress, and will continue to download in the background when\n\t *     canceled, although no events will be dispatched.</li>\n\t * </ul>\n\t *\n\t * @class LoadQueue\n\t * @param {Boolean} [preferXHR=true] Determines whether the preload instance will favor loading with XHR (XML HTTP\n\t * Requests), or HTML tags. When this is `false`, the queue will use tag loading when possible, and fall back on XHR\n\t * when necessary.\n\t * @param {String} [basePath=\"\"] A path that will be prepended on to the source parameter of all items in the queue\n\t * before they are loaded.  Sources beginning with a protocol such as `http://` or a relative path such as `../`\n\t * will not receive a base path.\n\t * @param {String|Boolean} [crossOrigin=\"\"] An optional flag to support images loaded from a CORS-enabled server. To\n\t * use it, set this value to `true`, which will default the crossOrigin property on images to \"Anonymous\". Any\n\t * string value will be passed through, but only \"\" and \"Anonymous\" are recommended. <strong>Note: The crossOrigin\n\t * parameter is deprecated. Use LoadItem.crossOrigin instead</strong>\n\t *\n\t * @constructor\n\t * @extends AbstractLoader\n\t */\n\tfunction LoadQueue (preferXHR, basePath, crossOrigin) {\n\t\tthis.AbstractLoader_constructor();\n\n\t\t/**\n\t\t * An array of the plugins registered using {{#crossLink \"LoadQueue/installPlugin\"}}{{/crossLink}}.\n\t\t * @property _plugins\n\t\t * @type {Array}\n\t\t * @private\n\t\t * @since 0.6.1\n\t\t */\n\t\tthis._plugins = [];\n\n\t\t/**\n\t\t * An object hash of callbacks that are fired for each file type before the file is loaded, giving plugins the\n\t\t * ability to override properties of the load. Please see the {{#crossLink \"LoadQueue/installPlugin\"}}{{/crossLink}}\n\t\t * method for more information.\n\t\t * @property _typeCallbacks\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._typeCallbacks = {};\n\n\t\t/**\n\t\t * An object hash of callbacks that are fired for each file extension before the file is loaded, giving plugins the\n\t\t * ability to override properties of the load. Please see the {{#crossLink \"LoadQueue/installPlugin\"}}{{/crossLink}}\n\t\t * method for more information.\n\t\t * @property _extensionCallbacks\n\t\t * @type {null}\n\t\t * @private\n\t\t */\n\t\tthis._extensionCallbacks = {};\n\n\t\t/**\n\t\t * The next preload queue to process when this one is complete. If an error is thrown in the current queue, and\n\t\t * {{#crossLink \"LoadQueue/stopOnError:property\"}}{{/crossLink}} is `true`, the next queue will not be processed.\n\t\t * @property next\n\t\t * @type {LoadQueue}\n\t\t * @default null\n\t\t */\n\t\tthis.next = null;\n\n\t\t/**\n\t\t * Ensure loaded scripts \"complete\" in the order they are specified. Loaded scripts are added to the document head\n\t\t * once they are loaded. Scripts loaded via tags will load one-at-a-time when this property is `true`, whereas\n\t\t * scripts loaded using XHR can load in any order, but will \"finish\" and be added to the document in the order\n\t\t * specified.\n\t\t *\n\t\t * Any items can be set to load in order by setting the {{#crossLink \"maintainOrder:property\"}}{{/crossLink}}\n\t\t * property on the load item, or by ensuring that only one connection can be open at a time using\n\t\t * {{#crossLink \"LoadQueue/setMaxConnections\"}}{{/crossLink}}. Note that when the `maintainScriptOrder` property\n\t\t * is set to `true`, scripts items are automatically set to `maintainOrder=true`, and changing the\n\t\t * `maintainScriptOrder` to `false` during a load will not change items already in a queue.\n\t\t *\n\t\t * <h4>Example</h4>\n\t\t *\n\t\t *      var queue = new createjs.LoadQueue();\n\t\t *      queue.setMaxConnections(3); // Set a higher number to load multiple items at once\n\t\t *      queue.maintainScriptOrder = true; // Ensure scripts are loaded in order\n\t\t *      queue.loadManifest([\n\t\t *          \"script1.js\",\n\t\t *          \"script2.js\",\n\t\t *          \"image.png\", // Load any time\n\t\t *          {src: \"image2.png\", maintainOrder: true} // Will wait for script2.js\n\t\t *          \"image3.png\",\n\t\t *          \"script3.js\" // Will wait for image2.png before loading (or completing when loading with XHR)\n\t\t *      ]);\n\t\t *\n\t\t * @property maintainScriptOrder\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.maintainScriptOrder = true;\n\n\t\t/**\n\t\t * Determines if the LoadQueue will stop processing the current queue when an error is encountered.\n\t\t * @property stopOnError\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.stopOnError = false;\n\n\t\t/**\n\t\t * The number of maximum open connections that a loadQueue tries to maintain. Please see\n\t\t * {{#crossLink \"LoadQueue/setMaxConnections\"}}{{/crossLink}} for more information.\n\t\t * @property _maxConnections\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t * @private\n\t\t */\n\t\tthis._maxConnections = 1;\n\n\t\t/**\n\t\t * An internal list of all the default Loaders that are included with PreloadJS. Before an item is loaded, the\n\t\t * available loader list is iterated, in the order they are included, and as soon as a loader indicates it can\n\t\t * handle the content, it will be selected. The default loader, ({{#crossLink \"TextLoader\"}}{{/crossLink}} is\n\t\t * last in the list, so it will be used if no other match is found. Typically, loaders will match based on the\n\t\t * {{#crossLink \"LoadItem/type\"}}{{/crossLink}}, which is automatically determined using the file extension of\n\t\t * the {{#crossLink \"LoadItem/src:property\"}}{{/crossLink}}.\n\t\t *\n\t\t * Loaders can be removed from PreloadJS by simply not including them.\n\t\t *\n\t\t * Custom loaders installed using {{#crossLink \"registerLoader\"}}{{/crossLink}} will be prepended to this list\n\t\t * so that they are checked first.\n\t\t * @property _availableLoaders\n\t\t * @type {Array}\n\t\t * @private\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._availableLoaders = [\n\t\t\tcreatejs.ImageLoader,\n\t\t\tcreatejs.JavaScriptLoader,\n\t\t\tcreatejs.CSSLoader,\n\t\t\tcreatejs.JSONLoader,\n\t\t\tcreatejs.JSONPLoader,\n\t\t\tcreatejs.SoundLoader,\n\t\t\tcreatejs.ManifestLoader,\n\t\t\tcreatejs.SpriteSheetLoader,\n\t\t\tcreatejs.XMLLoader,\n\t\t\tcreatejs.SVGLoader,\n\t\t\tcreatejs.BinaryLoader,\n\t\t\tcreatejs.VideoLoader,\n\t\t\tcreatejs.TextLoader\n\t\t];\n\n\t\t/**\n\t\t * The number of built in loaders, so they can't be removed by {{#crossLink \"unregisterLoader\"}}{{/crossLink}.\n\t\t\t\t * @property _defaultLoaderLength\n\t\t * @type {Number}\n\t\t * @private\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._defaultLoaderLength = this._availableLoaders.length;\n\n\t\tthis.init(preferXHR, basePath, crossOrigin);\n\t}\n\n\tvar p = createjs.extend(LoadQueue, createjs.AbstractLoader);\n\tvar s = LoadQueue;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\t/**\n\t * An internal initialization method, which is used for initial set up, but also to reset the LoadQueue.\n\t * @method init\n\t * @param preferXHR\n\t * @param basePath\n\t * @param crossOrigin\n\t * @private\n\t */\n\tp.init = function (preferXHR, basePath, crossOrigin) {\n\n\t\t// public properties\n\t\t/**\n\t\t * @property useXHR\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t * @deprecated Use preferXHR instead.\n\t\t */\n\t\tthis.useXHR = true;\n\n\t\t/**\n\t\t * Try and use XMLHttpRequest (XHR) when possible. Note that LoadQueue will default to tag loading or XHR\n\t\t * loading depending on the requirements for a media type. For example, HTML audio can not be loaded with XHR,\n\t\t * and plain text can not be loaded with tags, so it will default the the correct type instead of using the\n\t\t * user-defined type.\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis.preferXHR = true; //TODO: Get/Set\n\t\tthis._preferXHR = true;\n\t\tthis.setPreferXHR(preferXHR);\n\n\t\t// protected properties\n\t\t/**\n\t\t * Whether the queue is currently paused or not.\n\t\t * @property _paused\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tthis._paused = false;\n\n\t\t/**\n\t\t * A path that will be prepended on to the item's {{#crossLink \"LoadItem/src:property\"}}{{/crossLink}}. The\n\t\t * `_basePath` property will only be used if an item's source is relative, and does not include a protocol such\n\t\t * as `http://`, or a relative path such as `../`.\n\t\t * @property _basePath\n\t\t * @type {String}\n\t\t * @private\n\t\t * @since 0.3.1\n\t\t */\n\t\tthis._basePath = basePath;\n\n\t\t/**\n\t\t * An optional flag to set on images that are loaded using PreloadJS, which enables CORS support. Images loaded\n\t\t * cross-domain by servers that support CORS require the crossOrigin flag to be loaded and interacted with by\n\t\t * a canvas. When loading locally, or with a server with no CORS support, this flag can cause other security issues,\n\t\t * so it is recommended to only set it if you are sure the server supports it. Currently, supported values are \"\"\n\t\t * and \"Anonymous\".\n\t\t * @property _crossOrigin\n\t\t * @type {String}\n\t\t * @default \"\"\n\t\t * @private\n\t\t * @since 0.4.1\n\t\t */\n\t\tthis._crossOrigin = crossOrigin;\n\n\t\t/**\n\t\t * Determines if the loadStart event was dispatched already. This event is only fired one time, when the first\n\t\t * file is requested.\n\t\t * @property _loadStartWasDispatched\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @private\n\t\t */\n\t\tthis._loadStartWasDispatched = false;\n\n\t\t/**\n\t\t * Determines if there is currently a script loading. This helps ensure that only a single script loads at once when\n\t\t * using a script tag to do preloading.\n\t\t * @property _currentlyLoadingScript\n\t\t * @type {Boolean}\n\t\t * @private\n\t\t */\n\t\tthis._currentlyLoadingScript = null;\n\n\t\t/**\n\t\t * An array containing the currently downloading files.\n\t\t * @property _currentLoads\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._currentLoads = [];\n\n\t\t/**\n\t\t * An array containing the queued items that have not yet started downloading.\n\t\t * @property _loadQueue\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._loadQueue = [];\n\n\t\t/**\n\t\t * An array containing downloads that have not completed, so that the LoadQueue can be properly reset.\n\t\t * @property _loadQueueBackup\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._loadQueueBackup = [];\n\n\t\t/**\n\t\t * An object hash of items that have finished downloading, indexed by the {{#crossLink \"LoadItem\"}}{{/crossLink}}\n\t\t * id.\n\t\t * @property _loadItemsById\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._loadItemsById = {};\n\n\t\t/**\n\t\t * An object hash of items that have finished downloading, indexed by {{#crossLink \"LoadItem\"}}{{/crossLink}}\n\t\t * source.\n\t\t * @property _loadItemsBySrc\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._loadItemsBySrc = {};\n\n\t\t/**\n\t\t * An object hash of loaded items, indexed by the ID of the {{#crossLink \"LoadItem\"}}{{/crossLink}}.\n\t\t * @property _loadedResults\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._loadedResults = {};\n\n\t\t/**\n\t\t * An object hash of un-parsed loaded items, indexed by the ID of the {{#crossLink \"LoadItem\"}}{{/crossLink}}.\n\t\t * @property _loadedRawResults\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._loadedRawResults = {};\n\n\t\t/**\n\t\t * The number of items that have been requested. This helps manage an overall progress without knowing how large\n\t\t * the files are before they are downloaded. This does not include items inside of loaders such as the\n\t\t * {{#crossLink \"ManifestLoader\"}}{{/crossLink}}.\n\t\t * @property _numItems\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @private\n\t\t */\n\t\tthis._numItems = 0;\n\n\t\t/**\n\t\t * The number of items that have completed loaded. This helps manage an overall progress without knowing how large\n\t\t * the files are before they are downloaded.\n\t\t * @property _numItemsLoaded\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @private\n\t\t */\n\t\tthis._numItemsLoaded = 0;\n\n\t\t/**\n\t\t * A list of scripts in the order they were requested. This helps ensure that scripts are \"completed\" in the right\n\t\t * order.\n\t\t * @property _scriptOrder\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._scriptOrder = [];\n\n\t\t/**\n\t\t * A list of scripts that have been loaded. Items are added to this list as <code>null</code> when they are\n\t\t * requested, contain the loaded item if it has completed, but not been dispatched to the user, and <code>true</true>\n\t\t * once they are complete and have been dispatched.\n\t\t * @property _loadedScripts\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._loadedScripts = [];\n\n\t\t/**\n\t\t * The last progress amount. This is used to suppress duplicate progress events.\n\t\t * @property _lastProgress\n\t\t * @type {Number}\n\t\t * @private\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._lastProgress = NaN;\n\n\t};\n\n// static properties\n\t/**\n\t * The time in milliseconds to assume a load has failed. An {{#crossLink \"AbstractLoader/error:event\"}}{{/crossLink}}\n\t * event is dispatched if the timeout is reached before any data is received.\n\t * @property loadTimeout\n\t * @type {Number}\n\t * @default 8000\n\t * @static\n\t * @since 0.4.1\n\t * @deprecated In favour of {{#crossLink \"LoadItem/LOAD_TIMEOUT_DEFAULT:property}}{{/crossLink}} property.\n\t */\n\ts.loadTimeout = 8000;\n\n\t/**\n\t * The time in milliseconds to assume a load has failed.\n\t * @property LOAD_TIMEOUT\n\t * @type {Number}\n\t * @default 0\n\t * @deprecated in favor of the {{#crossLink \"LoadQueue/loadTimeout:property\"}}{{/crossLink}} property.\n\t */\n\ts.LOAD_TIMEOUT = 0;\n\n// Preload Types\n\t/**\n\t * @property BINARY\n\t * @type {String}\n\t * @default binary\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/BINARY:property\"}}{{/crossLink}} instead.\n\t */\n\ts.BINARY = createjs.AbstractLoader.BINARY;\n\n\t/**\n\t * @property CSS\n\t * @type {String}\n\t * @default css\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/CSS:property\"}}{{/crossLink}} instead.\n\t */\n\ts.CSS = createjs.AbstractLoader.CSS;\n\n\t/**\n\t * @property IMAGE\n\t * @type {String}\n\t * @default image\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/CSS:property\"}}{{/crossLink}} instead.\n\t */\n\ts.IMAGE = createjs.AbstractLoader.IMAGE;\n\n\t/**\n\t * @property JAVASCRIPT\n\t * @type {String}\n\t * @default javascript\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/JAVASCRIPT:property\"}}{{/crossLink}} instead.\n\t */\n\ts.JAVASCRIPT = createjs.AbstractLoader.JAVASCRIPT;\n\n\t/**\n\t * @property JSON\n\t * @type {String}\n\t * @default json\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/JSON:property\"}}{{/crossLink}} instead.\n\t */\n\ts.JSON = createjs.AbstractLoader.JSON;\n\n\t/**\n\t * @property JSONP\n\t * @type {String}\n\t * @default jsonp\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/JSONP:property\"}}{{/crossLink}} instead.\n\t */\n\ts.JSONP = createjs.AbstractLoader.JSONP;\n\n\t/**\n\t * @property MANIFEST\n\t * @type {String}\n\t * @default manifest\n\t * @static\n\t * @since 0.4.1\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/MANIFEST:property\"}}{{/crossLink}} instead.\n\t */\n\ts.MANIFEST = createjs.AbstractLoader.MANIFEST;\n\n\t/**\n\t * @property SOUND\n\t * @type {String}\n\t * @default sound\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/JAVASCRIPT:property\"}}{{/crossLink}} instead.\n\t */\n\ts.SOUND = createjs.AbstractLoader.SOUND;\n\n\t/**\n\t * @property VIDEO\n\t * @type {String}\n\t * @default video\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/JAVASCRIPT:property\"}}{{/crossLink}} instead.\n\t */\n\ts.VIDEO = createjs.AbstractLoader.VIDEO;\n\n\t/**\n\t * @property SVG\n\t * @type {String}\n\t * @default svg\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/SVG:property\"}}{{/crossLink}} instead.\n\t */\n\ts.SVG = createjs.AbstractLoader.SVG;\n\n\t/**\n\t * @property TEXT\n\t * @type {String}\n\t * @default text\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/TEXT:property\"}}{{/crossLink}} instead.\n\t */\n\ts.TEXT = createjs.AbstractLoader.TEXT;\n\n\t/**\n\t * @property XML\n\t * @type {String}\n\t * @default xml\n\t * @static\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/XML:property\"}}{{/crossLink}} instead.\n\t */\n\ts.XML = createjs.AbstractLoader.XML;\n\n\t/**\n\t * @property POST\n\t * @type {string}\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/POST:property\"}}{{/crossLink}} instead.\n\t */\n\ts.POST = createjs.AbstractLoader.POST;\n\n\t/**\n\t * @property GET\n\t * @type {string}\n\t * @deprecated Use the AbstractLoader {{#crossLink \"AbstractLoader/GET:property\"}}{{/crossLink}} instead.\n\t */\n\ts.GET = createjs.AbstractLoader.GET;\n\n// events\n\t/**\n\t * This event is fired when an individual file has loaded, and been processed.\n\t * @event fileload\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {Object} item The file item which was specified in the {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}}\n\t * or {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}} call. If only a string path or tag was specified, the\n\t * object will contain that value as a `src` property.\n\t * @param {Object} result The HTML tag or parsed result of the loaded item.\n\t * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted\n\t * to a usable object.\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * This {{#crossLink \"ProgressEvent\"}}{{/crossLink}} that is fired when an an individual file's progress changes.\n\t * @event fileprogress\n\t * @since 0.3.0\n\t */\n\n\t/**\n\t * This event is fired when an individual file starts to load.\n\t * @event filestart\n\t * @param {Object} The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {Object} item The file item which was specified in the {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}}\n\t * or {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}} call. If only a string path or tag was specified, the\n\t * object will contain that value as a property.\n\t */\n\n\t/**\n\t * Although it extends {{#crossLink \"AbstractLoader\"}}{{/crossLink}}, the `initialize` event is never fired from\n\t * a LoadQueue instance.\n\t * @event initialize\n\t * @private\n\t */\n\n// public methods\n\t/**\n\t * Register a custom loaders class. New loaders are given precedence over loaders added earlier and default loaders.\n\t * It is recommended that loaders extend {{#crossLink \"AbstractLoader\"}}{{/crossLink}}. Loaders can only be added\n\t * once, and will be prepended to the list of available loaders.\n\t * @method registerLoader\n\t * @param {Function|AbstractLoader} loader The AbstractLoader class to add.\n\t * @since 0.6.0\n\t */\n\tp.registerLoader = function (loader) {\n\t\tif (!loader || !loader.canLoadItem) {\n\t\t\tthrow new Error(\"loader is of an incorrect type.\");\n\t\t} else if (this._availableLoaders.indexOf(loader) != -1) {\n\t\t\tthrow new Error(\"loader already exists.\"); //LM: Maybe just silently fail here\n\t\t}\n\n\t\tthis._availableLoaders.unshift(loader);\n\t};\n\n\t/**\n\t * Remove a custom loader added using {{#crossLink \"registerLoader\"}}{{/crossLink}}. Only custom loaders can be\n\t * unregistered, the default loaders will always be available.\n\t * @method unregisterLoader\n\t * @param {Function|AbstractLoader} loader The AbstractLoader class to remove\n\t */\n\tp.unregisterLoader = function (loader) {\n\t\tvar idx = this._availableLoaders.indexOf(loader);\n\t\tif (idx != -1 && idx < this._defaultLoaderLength - 1) {\n\t\t\tthis._availableLoaders.splice(idx, 1);\n\t\t}\n\t};\n\n\t/**\n\t * @method setUseXHR\n\t * @param {Boolean} value The new useXHR value to set.\n\t * @return {Boolean} The new useXHR value. If XHR is not supported by the browser, this will return false, even if\n\t * the provided value argument was true.\n\t * @since 0.3.0\n\t * @deprecated use the {{#crossLink \"LoadQueue/preferXHR:property\"}}{{/crossLink}} property, or the\n\t * {{#crossLink \"LoadQueue/setUseXHR\"}}{{/crossLink}} method instead.\n\t */\n\tp.setUseXHR = function (value) {\n\t\treturn this.setPreferXHR(value);\n\t};\n\n\t/**\n\t * Change the {{#crossLink \"preferXHR:property\"}}{{/crossLink}} value. Note that if this is set to `true`, it may\n\t * fail, or be ignored depending on the browser's capabilities and the load type.\n\t * @method setPreferXHR\n\t * @param {Boolean} value\n\t * @returns {Boolean} The value of {{#crossLink \"preferXHR\"}}{{/crossLink}} that was successfully set.\n\t * @since 0.6.0\n\t */\n\tp.setPreferXHR = function (value) {\n\t\t// Determine if we can use XHR. XHR defaults to TRUE, but the browser may not support it.\n\t\t//TODO: Should we be checking for the other XHR types? Might have to do a try/catch on the different types similar to createXHR.\n\t\tthis.preferXHR = (value != false && window.XMLHttpRequest != null);\n\t\treturn this.preferXHR;\n\t};\n\n\t/**\n\t * Stops all queued and loading items, and clears the queue. This also removes all internal references to loaded\n\t * content, and allows the queue to be used again.\n\t * @method removeAll\n\t * @since 0.3.0\n\t */\n\tp.removeAll = function () {\n\t\tthis.remove();\n\t};\n\n\t/**\n\t * Stops an item from being loaded, and removes it from the queue. If nothing is passed, all items are removed.\n\t * This also removes internal references to loaded item(s).\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      queue.loadManifest([\n\t *          {src:\"test.png\", id:\"png\"},\n\t *          {src:\"test.jpg\", id:\"jpg\"},\n\t *          {src:\"test.mp3\", id:\"mp3\"}\n\t *      ]);\n\t *      queue.remove(\"png\"); // Single item by ID\n\t *      queue.remove(\"png\", \"test.jpg\"); // Items as arguments. Mixed id and src.\n\t *      queue.remove([\"test.png\", \"jpg\"]); // Items in an Array. Mixed id and src.\n\t *\n\t * @method remove\n\t * @param {String | Array} idsOrUrls* The id or ids to remove from this queue. You can pass an item, an array of\n\t * items, or multiple items as arguments.\n\t * @since 0.3.0\n\t */\n\tp.remove = function (idsOrUrls) {\n\t\tvar args = null;\n\n\t\tif (idsOrUrls && !Array.isArray(idsOrUrls)) {\n\t\t\targs = [idsOrUrls];\n\t\t} else if (idsOrUrls) {\n\t\t\targs = idsOrUrls;\n\t\t} else if (arguments.length > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar itemsWereRemoved = false;\n\n\t\t// Destroy everything\n\t\tif (!args) {\n\t\t\tthis.close();\n\t\t\tfor (var n in this._loadItemsById) {\n\t\t\t\tthis._disposeItem(this._loadItemsById[n]);\n\t\t\t}\n\t\t\tthis.init(this.preferXHR, this._basePath);\n\n\t\t\t// Remove specific items\n\t\t} else {\n\t\t\twhile (args.length) {\n\t\t\t\tvar item = args.pop();\n\t\t\t\tvar r = this.getResult(item);\n\n\t\t\t\t//Remove from the main load Queue\n\t\t\t\tfor (i = this._loadQueue.length - 1; i >= 0; i--) {\n\t\t\t\t\tloadItem = this._loadQueue[i].getItem();\n\t\t\t\t\tif (loadItem.id == item || loadItem.src == item) {\n\t\t\t\t\t\tthis._loadQueue.splice(i, 1)[0].cancel();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//Remove from the backup queue\n\t\t\t\tfor (i = this._loadQueueBackup.length - 1; i >= 0; i--) {\n\t\t\t\t\tloadItem = this._loadQueueBackup[i].getItem();\n\t\t\t\t\tif (loadItem.id == item || loadItem.src == item) {\n\t\t\t\t\t\tthis._loadQueueBackup.splice(i, 1)[0].cancel();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (r) {\n\t\t\t\t\tthis._disposeItem(this.getItem(item));\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i = this._currentLoads.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tvar loadItem = this._currentLoads[i].getItem();\n\t\t\t\t\t\tif (loadItem.id == item || loadItem.src == item) {\n\t\t\t\t\t\t\tthis._currentLoads.splice(i, 1)[0].cancel();\n\t\t\t\t\t\t\titemsWereRemoved = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If this was called during a load, try to load the next item.\n\t\t\tif (itemsWereRemoved) {\n\t\t\t\tthis._loadNext();\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Stops all open loads, destroys any loaded items, and resets the queue, so all items can\n\t * be reloaded again by calling {{#crossLink \"AbstractLoader/load\"}}{{/crossLink}}. Items are not removed from the\n\t * queue. To remove items use the {{#crossLink \"LoadQueue/remove\"}}{{/crossLink}} or\n\t * {{#crossLink \"LoadQueue/removeAll\"}}{{/crossLink}} method.\n\t * @method reset\n\t * @since 0.3.0\n\t */\n\tp.reset = function () {\n\t\tthis.close();\n\t\tfor (var n in this._loadItemsById) {\n\t\t\tthis._disposeItem(this._loadItemsById[n]);\n\t\t}\n\n\t\t//Reset the queue to its start state\n\t\tvar a = [];\n\t\tfor (var i = 0, l = this._loadQueueBackup.length; i < l; i++) {\n\t\t\ta.push(this._loadQueueBackup[i].getItem());\n\t\t}\n\n\t\tthis.loadManifest(a, false);\n\t};\n\n\t/**\n\t * Register a plugin. Plugins can map to load types (sound, image, etc), or specific extensions (png, mp3, etc).\n\t * Currently, only one plugin can exist per type/extension.\n\t *\n\t * When a plugin is installed, a <code>getPreloadHandlers()</code> method will be called on it. For more information\n\t * on this method, check out the {{#crossLink \"SamplePlugin/getPreloadHandlers\"}}{{/crossLink}} method in the\n\t * {{#crossLink \"SamplePlugin\"}}{{/crossLink}} class.\n\t *\n\t * Before a file is loaded, a matching plugin has an opportunity to modify the load. If a `callback` is returned\n\t * from the {{#crossLink \"SamplePlugin/getPreloadHandlers\"}}{{/crossLink}} method, it will be invoked first, and its\n\t * result may cancel or modify the item. The callback method can also return a `completeHandler` to be fired when\n\t * the file is loaded, or a `tag` object, which will manage the actual download. For more information on these\n\t * methods, check out the {{#crossLink \"SamplePlugin/preloadHandler\"}}{{/crossLink}} and {{#crossLink \"SamplePlugin/fileLoadHandler\"}}{{/crossLink}}\n\t * methods on the {{#crossLink \"SamplePlugin\"}}{{/crossLink}}.\n\t *\n\t * @method installPlugin\n\t * @param {Function} plugin The plugin class to install.\n\t */\n\tp.installPlugin = function (plugin) {\n\t\tif (plugin == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (plugin.getPreloadHandlers != null) {\n\t\t\tthis._plugins.push(plugin);\n\t\t\tvar map = plugin.getPreloadHandlers();\n\t\t\tmap.scope = plugin;\n\n\t\t\tif (map.types != null) {\n\t\t\t\tfor (var i = 0, l = map.types.length; i < l; i++) {\n\t\t\t\t\tthis._typeCallbacks[map.types[i]] = map;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (map.extensions != null) {\n\t\t\t\tfor (i = 0, l = map.extensions.length; i < l; i++) {\n\t\t\t\t\tthis._extensionCallbacks[map.extensions[i]] = map;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Set the maximum number of concurrent connections. Note that browsers and servers may have a built-in maximum\n\t * number of open connections, so any additional connections may remain in a pending state until the browser\n\t * opens the connection. When loading scripts using tags, and when {{#crossLink \"LoadQueue/maintainScriptOrder:property\"}}{{/crossLink}}\n\t * is `true`, only one script is loaded at a time due to browser limitations.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var queue = new createjs.LoadQueue();\n\t *      queue.setMaxConnections(10); // Allow 10 concurrent loads\n\t *\n\t * @method setMaxConnections\n\t * @param {Number} value The number of concurrent loads to allow. By default, only a single connection per LoadQueue\n\t * is open at any time.\n\t */\n\tp.setMaxConnections = function (value) {\n\t\tthis._maxConnections = value;\n\t\tif (!this._paused && this._loadQueue.length > 0) {\n\t\t\tthis._loadNext();\n\t\t}\n\t};\n\n\t/**\n\t * Load a single file. To add multiple files at once, use the {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}\n\t * method.\n\t *\n\t * Files are always appended to the current queue, so this method can be used multiple times to add files.\n\t * To clear the queue first, use the {{#crossLink \"AbstractLoader/close\"}}{{/crossLink}} method.\n\t * @method loadFile\n\t * @param {LoadItem|Object|String} file The file object or path to load. A file can be either\n\t * <ul>\n\t *     <li>A {{#crossLink \"LoadItem\"}}{{/crossLink}} instance</li>\n\t *     <li>An object containing properties defined by {{#crossLink \"LoadItem\"}}{{/crossLink}}</li>\n\t *     <li>OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink \"LoadItem\"}}{{/crossLink}}\n\t *     in the background.</li>\n\t * </ul>\n\t * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default\n\t * value is true. If the queue is paused using {{#crossLink \"LoadQueue/setPaused\"}}{{/crossLink}}, and the value is\n\t * `true`, the queue will resume automatically.\n\t * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the\n\t * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink \"AbstractLoader/MANIFEST:property\"}}{{/crossLink}},\n\t * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>\n\t * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue\n\t * constructor, or a `path` property in a manifest definition.\n\t */\n\tp.loadFile = function (file, loadNow, basePath) {\n\t\tif (file == null) {\n\t\t\tvar event = new createjs.ErrorEvent(\"PRELOAD_NO_FILE\");\n\t\t\tthis._sendError(event);\n\t\t\treturn;\n\t\t}\n\t\tthis._addItem(file, null, basePath);\n\n\t\tif (loadNow !== false) {\n\t\t\tthis.setPaused(false);\n\t\t} else {\n\t\t\tthis.setPaused(true);\n\t\t}\n\t};\n\n\t/**\n\t * Load an array of files. To load a single file, use the {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}} method.\n\t * The files in the manifest are requested in the same order, but may complete in a different order if the max\n\t * connections are set above 1 using {{#crossLink \"LoadQueue/setMaxConnections\"}}{{/crossLink}}. Scripts will load\n\t * in the right order as long as {{#crossLink \"LoadQueue/maintainScriptOrder\"}}{{/crossLink}} is true (which is\n\t * default).\n\t *\n\t * Files are always appended to the current queue, so this method can be used multiple times to add files.\n\t * To clear the queue first, use the {{#crossLink \"AbstractLoader/close\"}}{{/crossLink}} method.\n\t * @method loadManifest\n\t * @param {Array|String|Object} manifest An list of files to load. The loadManifest call supports four types of\n\t * manifests:\n\t * <ol>\n\t *     <li>A string path, which points to a manifest file, which is a JSON file that contains a \"manifest\" property,\n\t *     which defines the list of files to load, and can optionally contain a \"path\" property, which will be\n\t *     prepended to each file in the list.</li>\n\t *     <li>An object which defines a \"src\", which is a JSON or JSONP file. A \"callback\" can be defined for JSONP\n\t *     file. The JSON/JSONP file should contain a \"manifest\" property, which defines the list of files to load,\n\t *     and can optionally contain a \"path\" property, which will be prepended to each file in the list.</li>\n\t *     <li>An object which contains a \"manifest\" property, which defines the list of files to load, and can\n\t *     optionally contain a \"path\" property, which will be prepended to each file in the list.</li>\n\t *     <li>An Array of files to load.</li>\n\t * </ol>\n\t *\n\t * Each \"file\" in a manifest can be either:\n\t * <ul>\n\t *     <li>A {{#crossLink \"LoadItem\"}}{{/crossLink}} instance</li>\n\t *     <li>An object containing properties defined by {{#crossLink \"LoadItem\"}}{{/crossLink}}</li>\n\t *     <li>OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink \"LoadItem\"}}{{/crossLink}}\n\t *     in the background.</li>\n\t * </ul>\n\t *\n\t * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default\n\t * value is true. If the queue is paused using {{#crossLink \"LoadQueue/setPaused\"}}{{/crossLink}} and this value is\n\t * `true`, the queue will resume automatically.\n\t * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the\n\t * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink \"LoadQueue/MANIFEST:property\"}}{{/crossLink}},\n\t * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>\n\t * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue\n\t * constructor, or a `path` property in a manifest definition.\n\t */\n\tp.loadManifest = function (manifest, loadNow, basePath) {\n\t\tvar fileList = null;\n\t\tvar path = null;\n\n\t\t// Array-based list of items\n\t\tif (Array.isArray(manifest)) {\n\t\t\tif (manifest.length == 0) {\n\t\t\t\tvar event = new createjs.ErrorEvent(\"PRELOAD_MANIFEST_EMPTY\");\n\t\t\t\tthis._sendError(event);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfileList = manifest;\n\n\t\t\t// String-based. Only file manifests can be specified this way. Any other types will cause an error when loaded.\n\t\t} else if (typeof(manifest) === \"string\") {\n\t\t\tfileList = [\n\t\t\t\t{\n\t\t\t\t\tsrc: manifest,\n\t\t\t\t\ttype: s.MANIFEST\n\t\t\t\t}\n\t\t\t];\n\n\t\t} else if (typeof(manifest) == \"object\") {\n\n\t\t\t// An object that defines a manifest path\n\t\t\tif (manifest.src !== undefined) {\n\t\t\t\tif (manifest.type == null) {\n\t\t\t\t\tmanifest.type = s.MANIFEST;\n\t\t\t\t} else if (manifest.type != s.MANIFEST) {\n\t\t\t\t\tvar event = new createjs.ErrorEvent(\"PRELOAD_MANIFEST_TYPE\");\n\t\t\t\t\tthis._sendError(event);\n\t\t\t\t}\n\t\t\t\tfileList = [manifest];\n\n\t\t\t\t// An object that defines a manifest\n\t\t\t} else if (manifest.manifest !== undefined) {\n\t\t\t\tfileList = manifest.manifest;\n\t\t\t\tpath = manifest.path;\n\t\t\t}\n\n\t\t\t// Unsupported. This will throw an error.\n\t\t} else {\n\t\t\tvar event = new createjs.ErrorEvent(\"PRELOAD_MANIFEST_NULL\");\n\t\t\tthis._sendError(event);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var i = 0, l = fileList.length; i < l; i++) {\n\t\t\tthis._addItem(fileList[i], path, basePath);\n\t\t}\n\n\t\tif (loadNow !== false) {\n\t\t\tthis.setPaused(false);\n\t\t} else {\n\t\t\tthis.setPaused(true);\n\t\t}\n\n\t};\n\n\t/**\n\t * Start a LoadQueue that was created, but not automatically started.\n\t * @method load\n\t */\n\tp.load = function () {\n\t\tthis.setPaused(false);\n\t};\n\n\t/**\n\t * Look up a {{#crossLink \"LoadItem\"}}{{/crossLink}} using either the \"id\" or \"src\" that was specified when loading it. Note that if no \"id\" was\n\t * supplied with the load item, the ID will be the \"src\", including a `path` property defined by a manifest. The\n\t * `basePath` will not be part of the ID.\n\t * @method getItem\n\t * @param {String} value The <code>id</code> or <code>src</code> of the load item.\n\t * @return {Object} The load item that was initially requested using {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}}\n\t * or {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}. This object is also returned via the {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}}\n\t * event as the `item` parameter.\n\t */\n\tp.getItem = function (value) {\n\t\treturn this._loadItemsById[value] || this._loadItemsBySrc[value];\n\t};\n\n\t/**\n\t * Look up a loaded result using either the \"id\" or \"src\" that was specified when loading it. Note that if no \"id\"\n\t * was supplied with the load item, the ID will be the \"src\", including a `path` property defined by a manifest. The\n\t * `basePath` will not be part of the ID.\n\t * @method getResult\n\t * @param {String} value The <code>id</code> or <code>src</code> of the load item.\n\t * @param {Boolean} [rawResult=false] Return a raw result instead of a formatted result. This applies to content\n\t * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be\n\t * returned instead.\n\t * @return {Object} A result object containing the content that was loaded, such as:\n\t * <ul>\n\t *      <li>An image tag (&lt;image /&gt;) for images</li>\n\t *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts are automatically added to the HTML\n\t *      DOM.</li>\n\t *      <li>A style tag for CSS (&lt;style /&gt; or &lt;link &gt;)</li>\n\t *      <li>Raw text for TEXT</li>\n\t *      <li>A formatted JavaScript object defined by JSON</li>\n\t *      <li>An XML document</li>\n\t *      <li>A binary arraybuffer loaded by XHR</li>\n\t *      <li>An audio tag (&lt;audio &gt;) for HTML audio. Note that it is recommended to use SoundJS APIs to play\n\t *      loaded audio. Specifically, audio loaded by Flash and WebAudio will return a loader object using this method\n\t *      which can not be used to play audio back.</li>\n\t * </ul>\n\t * This object is also returned via the {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}} event as the 'item`\n\t * parameter. Note that if a raw result is requested, but not found, the result will be returned instead.\n\t */\n\tp.getResult = function (value, rawResult) {\n\t\tvar item = this._loadItemsById[value] || this._loadItemsBySrc[value];\n\t\tif (item == null) {\n\t\t\treturn null;\n\t\t}\n\t\tvar id = item.id;\n\t\tif (rawResult && this._loadedRawResults[id]) {\n\t\t\treturn this._loadedRawResults[id];\n\t\t}\n\t\treturn this._loadedResults[id];\n\t};\n\n\t/**\n\t * Generate an list of items loaded by this queue.\n\t * @method getItems\n\t * @param {Boolean} loaded Determines if only items that have been loaded should be returned. If false, in-progress\n\t * and failed load items will also be included.\n\t * @returns {Array} A list of objects that have been loaded. Each item includes the {{#crossLink \"LoadItem\"}}{{/crossLink}},\n\t * result, and rawResult.\n\t * @since 0.6.0\n\t */\n\tp.getItems = function (loaded) {\n\t\tvar arr = [];\n\t\tfor (var n in this._loadItemsById) {\n\t\t\tvar item = this._loadItemsById[n];\n\t\t\tvar result = this.getResult(n);\n\t\t\tif (loaded === true && result == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tarr.push({\n\t\t\t\titem: item,\n\t\t\t\tresult: result,\n\t\t\t\trawResult: this.getResult(n, true)\n\t\t\t});\n\t\t}\n\t\treturn arr;\n\t};\n\n\t/**\n\t * Pause or resume the current load. Active loads will not be cancelled, but the next items in the queue will not\n\t * be processed when active loads complete. LoadQueues are not paused by default.\n\t *\n\t * Note that if new items are added to the queue using {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}} or\n\t * {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}, a paused queue will be resumed, unless the `loadNow`\n\t * argument is `false`.\n\t * @method setPaused\n\t * @param {Boolean} value Whether the queue should be paused or not.\n\t */\n\tp.setPaused = function (value) {\n\t\tthis._paused = value;\n\t\tif (!this._paused) {\n\t\t\tthis._loadNext();\n\t\t}\n\t};\n\n\t/**\n\t * Close the active queue. Closing a queue completely empties the queue, and prevents any remaining items from\n\t * starting to download. Note that currently any active loads will remain open, and events may be processed.\n\t *\n\t * To stop and restart a queue, use the {{#crossLink \"LoadQueue/setPaused\"}}{{/crossLink}} method instead.\n\t * @method close\n\t */\n\tp.close = function () {\n\t\twhile (this._currentLoads.length) {\n\t\t\tthis._currentLoads.pop().cancel();\n\t\t}\n\t\tthis._scriptOrder.length = 0;\n\t\tthis._loadedScripts.length = 0;\n\t\tthis.loadStartWasDispatched = false;\n\t\tthis._itemCount = 0;\n\t\tthis._lastProgress = NaN;\n\t};\n\n// protected methods\n\t/**\n\t * Add an item to the queue. Items are formatted into a usable object containing all the properties necessary to\n\t * load the content. The load queue is populated with the loader instance that handles preloading, and not the load\n\t * item that was passed in by the user. To look up the load item by id or src, use the {{#crossLink \"LoadQueue.getItem\"}}{{/crossLink}}\n\t * method.\n\t * @method _addItem\n\t * @param {String|Object} value The item to add to the queue.\n\t * @param {String} [path] An optional path prepended to the `src`. The path will only be prepended if the src is\n\t * relative, and does not start with a protocol such as `http://`, or a path like `../`. If the LoadQueue was\n\t * provided a {{#crossLink \"_basePath\"}}{{/crossLink}}, then it will optionally be prepended after.\n\t * @param {String} [basePath] <strong>Deprecated</strong>An optional basePath passed into a {{#crossLink \"LoadQueue/loadManifest\"}}{{/crossLink}}\n\t * or {{#crossLink \"LoadQueue/loadFile\"}}{{/crossLink}} call. This parameter will be removed in a future tagged\n\t * version.\n\t * @private\n\t */\n\tp._addItem = function (value, path, basePath) {\n\t\tvar item = this._createLoadItem(value, path, basePath); // basePath and manifest path are added to the src.\n\t\tif (item == null) {\n\t\t\treturn;\n\t\t} // Sometimes plugins or types should be skipped.\n\t\tvar loader = this._createLoader(item);\n\t\tif (loader != null) {\n\t\t\tif (\"plugins\" in loader) {\n\t\t\t\tloader.plugins = this._plugins;\n\t\t\t}\n\t\t\titem._loader = loader;\n\t\t\tthis._loadQueue.push(loader);\n\t\t\tthis._loadQueueBackup.push(loader);\n\n\t\t\tthis._numItems++;\n\t\t\tthis._updateProgress();\n\n\t\t\t// Only worry about script order when using XHR to load scripts. Tags are only loading one at a time.\n\t\t\tif ((this.maintainScriptOrder\n\t\t\t\t\t&& item.type == createjs.LoadQueue.JAVASCRIPT\n\t\t\t\t\t\t//&& loader instanceof createjs.XHRLoader //NOTE: Have to track all JS files this way\n\t\t\t\t\t)\n\t\t\t\t\t|| item.maintainOrder === true) {\n\t\t\t\tthis._scriptOrder.push(item);\n\t\t\t\tthis._loadedScripts.push(null);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Create a refined {{#crossLink \"LoadItem\"}}{{/crossLink}}, which contains all the required properties. The type of\n\t * item is determined by browser support, requirements based on the file type, and developer settings. For example,\n\t * XHR is only used for file types that support it in new browsers.\n\t *\n\t * Before the item is returned, any plugins registered to handle the type or extension will be fired, which may\n\t * alter the load item.\n\t * @method _createLoadItem\n\t * @param {String | Object | HTMLAudioElement | HTMLImageElement} value The item that needs to be preloaded.\n\t * @param {String} [path] A path to prepend to the item's source. Sources beginning with http:// or similar will\n\t * not receive a path. Since PreloadJS 0.4.1, the src will be modified to include the `path` and {{#crossLink \"LoadQueue/_basePath:property\"}}{{/crossLink}}\n\t * when it is added.\n\t * @param {String} [basePath] <strong>Deprectated</strong> A base path to prepend to the items source in addition to\n\t * the path argument.\n\t * @return {Object} The loader instance that will be used.\n\t * @private\n\t */\n\tp._createLoadItem = function (value, path, basePath) {\n\t\tvar item = createjs.LoadItem.create(value);\n\t\tif (item == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar bp = \"\"; // Store the generated basePath\n\t\tvar useBasePath = basePath || this._basePath;\n\n\t\tif (item.src instanceof Object) {\n\t\t\tif (!item.type) {\n\t\t\t\treturn null;\n\t\t\t} // the the src is an object, type is required to pass off to plugin\n\t\t\tif (path) {\n\t\t\t\tbp = path;\n\t\t\t\tvar pathMatch = createjs.RequestUtils.parseURI(path);\n\t\t\t\t// Also append basePath\n\t\t\t\tif (useBasePath != null && !pathMatch.absolute && !pathMatch.relative) {\n\t\t\t\t\tbp = useBasePath + bp;\n\t\t\t\t}\n\t\t\t} else if (useBasePath != null) {\n\t\t\t\tbp = useBasePath;\n\t\t\t}\n\t\t} else {\n\t\t\t// Determine Extension, etc.\n\t\t\tvar match = createjs.RequestUtils.parseURI(item.src);\n\t\t\tif (match.extension) {\n\t\t\t\titem.ext = match.extension;\n\t\t\t}\n\t\t\tif (item.type == null) {\n\t\t\t\titem.type = createjs.RequestUtils.getTypeByExtension(item.ext);\n\t\t\t}\n\n\t\t\t// Inject path & basePath\n\t\t\tvar autoId = item.src;\n\t\t\tif (!match.absolute && !match.relative) {\n\t\t\t\tif (path) {\n\t\t\t\t\tbp = path;\n\t\t\t\t\tvar pathMatch = createjs.RequestUtils.parseURI(path);\n\t\t\t\t\tautoId = path + autoId;\n\t\t\t\t\t// Also append basePath\n\t\t\t\t\tif (useBasePath != null && !pathMatch.absolute && !pathMatch.relative) {\n\t\t\t\t\t\tbp = useBasePath + bp;\n\t\t\t\t\t}\n\t\t\t\t} else if (useBasePath != null) {\n\t\t\t\t\tbp = useBasePath;\n\t\t\t\t}\n\t\t\t}\n\t\t\titem.src = bp + item.src;\n\t\t}\n\t\titem.path = bp;\n\n\t\t// If there's no id, set one now.\n\t\tif (item.id === undefined || item.id === null || item.id === \"\") {\n\t\t\titem.id = autoId;\n\t\t}\n\n\t\t// Give plugins a chance to modify the loadItem:\n\t\tvar customHandler = this._typeCallbacks[item.type] || this._extensionCallbacks[item.ext];\n\t\tif (customHandler) {\n\t\t\t// Plugins are now passed both the full source, as well as a combined path+basePath (appropriately)\n\t\t\tvar result = customHandler.callback.call(customHandler.scope, item, this);\n\n\t\t\t// The plugin will handle the load, or has canceled it. Ignore it.\n\t\t\tif (result === false) {\n\t\t\t\treturn null;\n\n\t\t\t\t// Load as normal:\n\t\t\t} else if (result === true) {\n\t\t\t\t// Do Nothing\n\n\t\t\t\t// Result is a loader class:\n\t\t\t} else if (result != null) {\n\t\t\t\titem._loader = result;\n\t\t\t}\n\n\t\t\t// Update the extension in case the type changed:\n\t\t\tmatch = createjs.RequestUtils.parseURI(item.src);\n\t\t\tif (match.extension != null) {\n\t\t\t\titem.ext = match.extension;\n\t\t\t}\n\t\t}\n\n\t\t// Store the item for lookup. This also helps clean-up later.\n\t\tthis._loadItemsById[item.id] = item;\n\t\tthis._loadItemsBySrc[item.src] = item;\n\n\t\tif (item.crossOrigin == null) {\n\t\t\titem.crossOrigin = this._crossOrigin;\n\t\t}\n\n\t\treturn item;\n\t};\n\n\t/**\n\t * Create a loader for a load item.\n\t * @method _createLoader\n\t * @param {Object} item A formatted load item that can be used to generate a loader.\n\t * @return {AbstractLoader} A loader that can be used to load content.\n\t * @private\n\t */\n\tp._createLoader = function (item) {\n\t\tif (item._loader != null) { // A plugin already specified a loader\n\t\t\treturn item._loader;\n\t\t}\n\n\t\t// Initially, try and use the provided/supported XHR mode:\n\t\tvar preferXHR = this.preferXHR;\n\n\t\tfor (var i = 0; i < this._availableLoaders.length; i++) {\n\t\t\tvar loader = this._availableLoaders[i];\n\t\t\tif (loader && loader.canLoadItem(item)) {\n\t\t\t\treturn new loader(item, preferXHR);\n\t\t\t}\n\t\t}\n\n\t\t// TODO: Log error (requires createjs.log)\n\t\treturn null;\n\t};\n\n\t/**\n\t * Load the next item in the queue. If the queue is empty (all items have been loaded), then the complete event\n\t * is processed. The queue will \"fill up\" any empty slots, up to the max connection specified using\n\t * {{#crossLink \"LoadQueue.setMaxConnections\"}}{{/crossLink}} method. The only exception is scripts that are loaded\n\t * using tags, which have to be loaded one at a time to maintain load order.\n\t * @method _loadNext\n\t * @private\n\t */\n\tp._loadNext = function () {\n\t\tif (this._paused) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Only dispatch loadstart event when the first file is loaded.\n\t\tif (!this._loadStartWasDispatched) {\n\t\t\tthis._sendLoadStart();\n\t\t\tthis._loadStartWasDispatched = true;\n\t\t}\n\n\t\t// The queue has completed.\n\t\tif (this._numItems == this._numItemsLoaded) {\n\t\t\tthis.loaded = true;\n\t\t\tthis._sendComplete();\n\n\t\t\t// Load the next queue, if it has been defined.\n\t\t\tif (this.next && this.next.load) {\n\t\t\t\tthis.next.load();\n\t\t\t}\n\t\t} else {\n\t\t\tthis.loaded = false;\n\t\t}\n\n\t\t// Must iterate forwards to load in the right order.\n\t\tfor (var i = 0; i < this._loadQueue.length; i++) {\n\t\t\tif (this._currentLoads.length >= this._maxConnections) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar loader = this._loadQueue[i];\n\n\t\t\t// Determine if we should be only loading one tag-script at a time:\n\t\t\t// Note: maintainOrder items don't do anything here because we can hold onto their loaded value\n\t\t\tif (!this._canStartLoad(loader)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._loadQueue.splice(i, 1);\n\t\t\ti--;\n\t\t\tthis._loadItem(loader);\n\t\t}\n\t};\n\n\t/**\n\t * Begin loading an item. Event listeners are not added to the loaders until the load starts.\n\t * @method _loadItem\n\t * @param {AbstractLoader} loader The loader instance to start. Currently, this will be an XHRLoader or TagLoader.\n\t * @private\n\t */\n\tp._loadItem = function (loader) {\n\t\tloader.on(\"fileload\", this._handleFileLoad, this);\n\t\tloader.on(\"progress\", this._handleProgress, this);\n\t\tloader.on(\"complete\", this._handleFileComplete, this);\n\t\tloader.on(\"error\", this._handleError, this);\n\t\tloader.on(\"fileerror\", this._handleFileError, this);\n\t\tthis._currentLoads.push(loader);\n\t\tthis._sendFileStart(loader.getItem());\n\t\tloader.load();\n\t};\n\n\t/**\n\t * The callback that is fired when a loader loads a file. This enables loaders like {{#crossLink \"ManifestLoader\"}}{{/crossLink}}\n\t * to maintain internal queues, but for this queue to dispatch the {{#crossLink \"fileload:event\"}}{{/crossLink}}\n\t * events.\n\t * @param {Event} event The {{#crossLink \"AbstractLoader/fileload:event\"}}{{/crossLink}} event from the loader.\n\t * @private\n\t * @since 0.6.0\n\t */\n\tp._handleFileLoad = function (event) {\n\t\tevent.target = null;\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * The callback that is fired when a loader encounters an error from an internal file load operation. This enables\n\t * loaders like M\n\t * @param event\n\t * @private\n\t */\n\tp._handleFileError = function (event) {\n\t\tvar newEvent = new createjs.ErrorEvent(\"FILE_LOAD_ERROR\", null, event.item);\n\t\tthis._sendError(newEvent);\n\t};\n\n\t/**\n\t * The callback that is fired when a loader encounters an error. The queue will continue loading unless {{#crossLink \"LoadQueue/stopOnError:property\"}}{{/crossLink}}\n\t * is set to `true`.\n\t * @method _handleError\n\t * @param {ErrorEvent} event The error event, containing relevant error information.\n\t * @private\n\t */\n\tp._handleError = function (event) {\n\t\tvar loader = event.target;\n\t\tthis._numItemsLoaded++;\n\n\t\tthis._finishOrderedItem(loader, true);\n\t\tthis._updateProgress();\n\n\t\tvar newEvent = new createjs.ErrorEvent(\"FILE_LOAD_ERROR\", null, loader.getItem());\n\t\t// TODO: Propagate actual error message.\n\n\t\tthis._sendError(newEvent);\n\n\t\tif (!this.stopOnError) {\n\t\t\tthis._removeLoadItem(loader);\n\t\t\tthis._cleanLoadItem(loader);\n\t\t\tthis._loadNext();\n\t\t} else {\n\t\t\tthis.setPaused(true);\n\t\t}\n\t};\n\n\t/**\n\t * An item has finished loading. We can assume that it is totally loaded, has been parsed for immediate use, and\n\t * is available as the \"result\" property on the load item. The raw text result for a parsed item (such as JSON, XML,\n\t * CSS, JavaScript, etc) is available as the \"rawResult\" property, and can also be looked up using {{#crossLink \"LoadQueue/getResult\"}}{{/crossLink}}.\n\t * @method _handleFileComplete\n\t * @param {Event} event The event object from the loader.\n\t * @private\n\t */\n\tp._handleFileComplete = function (event) {\n\t\tvar loader = event.target;\n\t\tvar item = loader.getItem();\n\n\t\tvar result = loader.getResult();\n\t\tthis._loadedResults[item.id] = result;\n\t\tvar rawResult = loader.getResult(true);\n\t\tif (rawResult != null && rawResult !== result) {\n\t\t\tthis._loadedRawResults[item.id] = rawResult;\n\t\t}\n\n\t\tthis._saveLoadedItems(loader);\n\n\t\t// Remove the load item\n\t\tthis._removeLoadItem(loader);\n\n\t\tif (!this._finishOrderedItem(loader)) {\n\t\t\t// The item was NOT managed, so process it now\n\t\t\tthis._processFinishedLoad(item, loader);\n\t\t}\n\n\t\t// Clean up the load item\n\t\tthis._cleanLoadItem(loader);\n\t};\n\n\t/**\n\t * Some loaders might load additional content, other than the item they were passed (such as {{#crossLink \"ManifestLoader\"}}{{/crossLink}}).\n\t * Any items exposed by the loader using {{#crossLink \"AbstractLoader/getLoadItems\"}}{{/crossLink}} are added to the\n\t * LoadQueue's look-ups, including {{#crossLink \"getItem\"}}{{/crossLink}} and {{#crossLink \"getResult\"}}{{/crossLink}}\n\t * methods.\n\t * @method _saveLoadedItems\n\t * @param {AbstractLoader} loader\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._saveLoadedItems = function (loader) {\n\t\t// TODO: Not sure how to handle this. Would be nice to expose the items.\n\t\t// Loaders may load sub-items. This adds them to this queue\n\t\tvar list = loader.getLoadedItems();\n\t\tif (list === null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tvar item = list[i].item;\n\n\t\t\t// Store item lookups\n\t\t\tthis._loadItemsBySrc[item.src] = item;\n\t\t\tthis._loadItemsById[item.id] = item;\n\n\t\t\t// Store loaded content\n\t\t\tthis._loadedResults[item.id] = list[i].result;\n\t\t\tthis._loadedRawResults[item.id] = list[i].rawResult;\n\t\t}\n\t};\n\n\t/**\n\t * Flag an item as finished. If the item's order is being managed, then ensure that it is allowed to finish, and if\n\t * so, trigger prior items to trigger as well.\n\t * @method _finishOrderedItem\n\t * @param {AbstractLoader} loader\n\t * @param {Boolean} loadFailed\n\t * @return {Boolean} If the item's order is being managed. This allows the caller to take an alternate\n\t * behaviour if it is.\n\t * @private\n\t */\n\tp._finishOrderedItem = function (loader, loadFailed) {\n\t\tvar item = loader.getItem();\n\n\t\tif ((this.maintainScriptOrder && item.type == createjs.LoadQueue.JAVASCRIPT)\n\t\t\t\t|| item.maintainOrder) {\n\n\t\t\t//TODO: Evaluate removal of the _currentlyLoadingScript\n\t\t\tif (loader instanceof createjs.JavaScriptLoader) {\n\t\t\t\tthis._currentlyLoadingScript = false;\n\t\t\t}\n\n\t\t\tvar index = createjs.indexOf(this._scriptOrder, item);\n\t\t\tif (index == -1) {\n\t\t\t\treturn false;\n\t\t\t} // This loader no longer exists\n\t\t\tthis._loadedScripts[index] = (loadFailed === true) ? true : item;\n\n\t\t\tthis._checkScriptLoadOrder();\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t};\n\n\t/**\n\t * Ensure the scripts load and dispatch in the correct order. When using XHR, scripts are stored in an array in the\n\t * order they were added, but with a \"null\" value. When they are completed, the value is set to the load item,\n\t * and then when they are processed and dispatched, the value is set to `true`. This method simply\n\t * iterates the array, and ensures that any loaded items that are not preceded by a `null` value are\n\t * dispatched.\n\t * @method _checkScriptLoadOrder\n\t * @private\n\t */\n\tp._checkScriptLoadOrder = function () {\n\t\tvar l = this._loadedScripts.length;\n\n\t\tfor (var i = 0; i < l; i++) {\n\t\t\tvar item = this._loadedScripts[i];\n\t\t\tif (item === null) {\n\t\t\t\tbreak;\n\t\t\t} // This is still loading. Do not process further.\n\t\t\tif (item === true) {\n\t\t\t\tcontinue;\n\t\t\t} // This has completed, and been processed. Move on.\n\n\t\t\tvar loadItem = this._loadedResults[item.id];\n\t\t\tif (item.type == createjs.LoadQueue.JAVASCRIPT) {\n\t\t\t\t// Append script tags to the head automatically.\n\t\t\t\tcreatejs.DomUtils.appendToHead(loadItem);\n\t\t\t}\n\n\t\t\tvar loader = item._loader;\n\t\t\tthis._processFinishedLoad(item, loader);\n\t\t\tthis._loadedScripts[i] = true;\n\t\t}\n\t};\n\n\t/**\n\t * A file has completed loading, and the LoadQueue can move on. This triggers the complete event, and kick-starts\n\t * the next item.\n\t * @method _processFinishedLoad\n\t * @param {LoadItem|Object} item\n\t * @param {AbstractLoader} loader\n\t * @protected\n\t */\n\tp._processFinishedLoad = function (item, loader) {\n\t\tthis._numItemsLoaded++;\n\n\t\t// Since LoadQueue needs maintain order, we can't append scripts in the loader.\n\t\t// So we do it here instead. Or in _checkScriptLoadOrder();\n\t\tif (!this.maintainScriptOrder && item.type == createjs.LoadQueue.JAVASCRIPT) {\n\t\t\tvar tag = loader.getTag();\n\t\t\tcreatejs.DomUtils.appendToHead(tag);\n\t\t}\n\n\t\tthis._updateProgress();\n\t\tthis._sendFileComplete(item, loader);\n\t\tthis._loadNext();\n\t};\n\n\t/**\n\t * Ensure items with `maintainOrder=true` that are before the specified item have loaded. This only applies to\n\t * JavaScript items that are being loaded with a TagLoader, since they have to be loaded and completed <strong>before</strong>\n\t * the script can even be started, since it exist in the DOM while loading.\n\t * @method _canStartLoad\n\t * @param {AbstractLoader} loader The loader for the item\n\t * @return {Boolean} Whether the item can start a load or not.\n\t * @private\n\t */\n\tp._canStartLoad = function (loader) {\n\t\tif (!this.maintainScriptOrder || loader.preferXHR) {\n\t\t\treturn true;\n\t\t}\n\t\tvar item = loader.getItem();\n\t\tif (item.type != createjs.LoadQueue.JAVASCRIPT) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this._currentlyLoadingScript) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar index = this._scriptOrder.indexOf(item);\n\t\tvar i = 0;\n\t\twhile (i < index) {\n\t\t\tvar checkItem = this._loadedScripts[i];\n\t\t\tif (checkItem == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tthis._currentlyLoadingScript = true;\n\t\treturn true;\n\t};\n\n\t/**\n\t * A load item is completed or was canceled, and needs to be removed from the LoadQueue.\n\t * @method _removeLoadItem\n\t * @param {AbstractLoader} loader A loader instance to remove.\n\t * @private\n\t */\n\tp._removeLoadItem = function (loader) {\n\t\tvar l = this._currentLoads.length;\n\t\tfor (var i = 0; i < l; i++) {\n\t\t\tif (this._currentLoads[i] == loader) {\n\t\t\t\tthis._currentLoads.splice(i, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Remove unneeded references from a loader.\n\t *\n\t * @param loader\n\t * @private\n\t */\n\tp._cleanLoadItem = function(loader) {\n\t\tvar item = loader.getItem();\n\t\tif (item) {\n\t\t\tdelete item._loader;\n\t\t}\n\t}\n\n\t/**\n\t * An item has dispatched progress. Propagate that progress, and update the LoadQueue's overall progress.\n\t * @method _handleProgress\n\t * @param {ProgressEvent} event The progress event from the item.\n\t * @private\n\t */\n\tp._handleProgress = function (event) {\n\t\tvar loader = event.target;\n\t\tthis._sendFileProgress(loader.getItem(), loader.progress);\n\t\tthis._updateProgress();\n\t};\n\n\t/**\n\t * Overall progress has changed, so determine the new progress amount and dispatch it. This changes any time an\n\t * item dispatches progress or completes. Note that since we don't always know the actual filesize of items before\n\t * they are loaded. In this case, we define a \"slot\" for each item (1 item in 10 would get 10%), and then append\n\t * loaded progress on top of the already-loaded items.\n\t *\n\t * For example, if 5/10 items have loaded, and item 6 is 20% loaded, the total progress would be:\n\t * <ul>\n\t *      <li>5/10 of the items in the queue (50%)</li>\n\t *      <li>plus 20% of item 6's slot (2%)</li>\n\t *      <li>equals 52%</li>\n\t * </ul>\n\t * @method _updateProgress\n\t * @private\n\t */\n\tp._updateProgress = function () {\n\t\tvar loaded = this._numItemsLoaded / this._numItems; // Fully Loaded Progress\n\t\tvar remaining = this._numItems - this._numItemsLoaded;\n\t\tif (remaining > 0) {\n\t\t\tvar chunk = 0;\n\t\t\tfor (var i = 0, l = this._currentLoads.length; i < l; i++) {\n\t\t\t\tchunk += this._currentLoads[i].progress;\n\t\t\t}\n\t\t\tloaded += (chunk / remaining) * (remaining / this._numItems);\n\t\t}\n\n\t\tif (this._lastProgress != loaded) {\n\t\t\tthis._sendProgress(loaded);\n\t\t\tthis._lastProgress = loaded;\n\t\t}\n\t};\n\n\t/**\n\t * Clean out item results, to free them from memory. Mainly, the loaded item and results are cleared from internal\n\t * hashes.\n\t * @method _disposeItem\n\t * @param {LoadItem|Object} item The item that was passed in for preloading.\n\t * @private\n\t */\n\tp._disposeItem = function (item) {\n\t\tdelete this._loadedResults[item.id];\n\t\tdelete this._loadedRawResults[item.id];\n\t\tdelete this._loadItemsById[item.id];\n\t\tdelete this._loadItemsBySrc[item.src];\n\t};\n\n\t/**\n\t * Dispatch a \"fileprogress\" {{#crossLink \"Event\"}}{{/crossLink}}. Please see the LoadQueue {{#crossLink \"LoadQueue/fileprogress:event\"}}{{/crossLink}}\n\t * event for details on the event payload.\n\t * @method _sendFileProgress\n\t * @param {LoadItem|Object} item The item that is being loaded.\n\t * @param {Number} progress The amount the item has been loaded (between 0 and 1).\n\t * @protected\n\t */\n\tp._sendFileProgress = function (item, progress) {\n\t\tif (this._isCanceled() || this._paused) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this.hasEventListener(\"fileprogress\")) {\n\t\t\treturn;\n\t\t}\n\n\t\t//LM: Rework ProgressEvent to support this?\n\t\tvar event = new createjs.Event(\"fileprogress\");\n\t\tevent.progress = progress;\n\t\tevent.loaded = progress;\n\t\tevent.total = 1;\n\t\tevent.item = item;\n\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Dispatch a fileload {{#crossLink \"Event\"}}{{/crossLink}}. Please see the {{#crossLink \"LoadQueue/fileload:event\"}}{{/crossLink}} event for\n\t * details on the event payload.\n\t * @method _sendFileComplete\n\t * @param {LoadItemObject} item The item that is being loaded.\n\t * @param {AbstractLoader} loader\n\t * @protected\n\t */\n\tp._sendFileComplete = function (item, loader) {\n\t\tif (this._isCanceled() || this._paused) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar event = new createjs.Event(\"fileload\");\n\t\tevent.loader = loader;\n\t\tevent.item = item;\n\t\tevent.result = this._loadedResults[item.id];\n\t\tevent.rawResult = this._loadedRawResults[item.id];\n\n\t\t// This calls a handler specified on the actual load item. Currently, the SoundJS plugin uses this.\n\t\tif (item.completeHandler) {\n\t\t\titem.completeHandler(event);\n\t\t}\n\n\t\tthis.hasEventListener(\"fileload\") && this.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Dispatch a filestart {{#crossLink \"Event\"}}{{/crossLink}} immediately before a file starts to load. Please see\n\t * the {{#crossLink \"LoadQueue/filestart:event\"}}{{/crossLink}} event for details on the event payload.\n\t * @method _sendFileStart\n\t * @param {LoadItem|Object} item The item that is being loaded.\n\t * @protected\n\t */\n\tp._sendFileStart = function (item) {\n\t\tvar event = new createjs.Event(\"filestart\");\n\t\tevent.item = item;\n\t\tthis.hasEventListener(\"filestart\") && this.dispatchEvent(event);\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[PreloadJS LoadQueue]\";\n\t};\n\n\tcreatejs.LoadQueue = createjs.promote(LoadQueue, \"AbstractLoader\");\n}());\n\n//##############################################################################\n// TextLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for Text files.\n\t * @class TextLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction TextLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.TEXT);\n\t};\n\n\tvar p = createjs.extend(TextLoader, createjs.AbstractLoader);\n\tvar s = TextLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader loads items that are of type {{#crossLink \"AbstractLoader/TEXT:property\"}}{{/crossLink}},\n\t * but is also the default loader if a file type can not be determined.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.TEXT;\n\t};\n\n\tcreatejs.TextLoader = createjs.promote(TextLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// BinaryLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for binary files. This is useful for loading web audio, or content that requires an ArrayBuffer.\n\t * @class BinaryLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction BinaryLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.BINARY);\n\t\tthis.on(\"initialize\", this._updateXHR, this);\n\t};\n\n\tvar p = createjs.extend(BinaryLoader, createjs.AbstractLoader);\n\tvar s = BinaryLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/BINARY:property\"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.BINARY;\n\t};\n\n\t// private methods\n\t/**\n\t * Before the item loads, set the response type to \"arraybuffer\"\n\t * @property _updateXHR\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._updateXHR = function (event) {\n\t\tevent.loader.setResponseType(\"arraybuffer\");\n\t};\n\n\tcreatejs.BinaryLoader = createjs.promote(BinaryLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// CSSLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for CSS files.\n\t * @class CSSLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction CSSLoader(loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.CSS);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = \"href\";\n\n\t\tif (preferXHR) {\n\t\t\tthis._tag = document.createElement(\"style\");\n\t\t} else {\n\t\t\tthis._tag = document.createElement(\"link\");\n\t\t}\n\n\t\tthis._tag.rel = \"stylesheet\";\n\t\tthis._tag.type = \"text/css\";\n\t};\n\n\tvar p = createjs.extend(CSSLoader, createjs.AbstractLoader);\n\tvar s = CSSLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/CSS:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.CSS;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for CSS files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLLinkElement|HTMLStyleElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\tif (this._preferXHR) {\n\t\t\tvar tag = loader.getTag();\n\n\t\t\tif (tag.styleSheet) { // IE\n\t\t\t\ttag.styleSheet.cssText = loader.getResult(true);\n\t\t\t} else {\n\t\t\t\tvar textNode = document.createTextNode(loader.getResult(true));\n\t\t\t\ttag.appendChild(textNode);\n\t\t\t}\n\t\t} else {\n\t\t\ttag = this._tag;\n\t\t}\n\n\t\tcreatejs.DomUtils.appendToHead(tag);\n\n\t\treturn tag;\n\t};\n\n\tcreatejs.CSSLoader = createjs.promote(CSSLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// ImageLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for image files.\n\t * @class ImageLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction ImageLoader (loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.IMAGE);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = \"src\";\n\n\t\t// Check if the preload item is already a tag.\n\t\tif (createjs.RequestUtils.isImageTag(loadItem)) {\n\t\t\tthis._tag = loadItem;\n\t\t} else if (createjs.RequestUtils.isImageTag(loadItem.src)) {\n\t\t\tthis._tag = loadItem.src;\n\t\t} else if (createjs.RequestUtils.isImageTag(loadItem.tag)) {\n\t\t\tthis._tag = loadItem.tag;\n\t\t}\n\n\t\tif (this._tag != null) {\n\t\t\tthis._preferXHR = false;\n\t\t} else {\n\t\t\tthis._tag = document.createElement(\"img\");\n\t\t}\n\n\t\tthis.on(\"initialize\", this._updateXHR, this);\n\t};\n\n\tvar p = createjs.extend(ImageLoader, createjs.AbstractLoader);\n\tvar s = ImageLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/IMAGE:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.IMAGE;\n\t};\n\n\t// public methods\n\tp.load = function () {\n\t\tif (this._tag.src != \"\" && this._tag.complete) {\n\t\t\tthis._sendComplete();\n\t\t\treturn;\n\t\t}\n\n\t\tvar crossOrigin = this._item.crossOrigin;\n\t\tif (crossOrigin == true) { crossOrigin = \"Anonymous\"; }\n\t\tif (crossOrigin != null && !createjs.RequestUtils.isLocal(this._item.src)) {\n\t\t\tthis._tag.crossOrigin = crossOrigin;\n\t\t}\n\n\t\tthis.AbstractLoader_load();\n\t};\n\n\t// protected methods\n\t/**\n\t * Before the item loads, set its mimeType and responseType.\n\t * @property _updateXHR\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._updateXHR = function (event) {\n\t\tevent.loader.mimeType = 'text/plain; charset=x-user-defined-binary';\n\n\t\t// Only exists for XHR\n\t\tif (event.loader.setResponseType) {\n\t\t\tevent.loader.setResponseType(\"blob\");\n\t\t}\n\t};\n\n\t/**\n\t * The result formatter for Image files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLImageElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\treturn this._formatImage;\n\t};\n\n\t/**\n\t * The asynchronous image formatter function. This is required because images have\n\t * a short delay before they are ready.\n\t * @method _formatImage\n\t * @param {Function} successCallback The method to call when the result has finished formatting\n\t * @param {Function} errorCallback The method to call if an error occurs during formatting\n\t * @private\n\t */\n\tp._formatImage = function (successCallback, errorCallback) {\n\t\tvar tag = this._tag;\n\t\tvar URL = window.URL || window.webkitURL;\n\n\t\tif (!this._preferXHR) {\n\t\t\t//document.body.removeChild(tag);\n\t\t} else if (URL) {\n\t\t\tvar objURL = URL.createObjectURL(this.getResult(true));\n\t\t\ttag.src = objURL;\n\n\t\t\ttag.addEventListener(\"load\", this._cleanUpURL, false);\n\t\t\ttag.addEventListener(\"error\", this._cleanUpURL, false);\n\t\t} else {\n\t\t\ttag.src = this._item.src;\n\t\t}\n\n\t\tif (tag.complete) {\n\t\t\tsuccessCallback(tag);\n\t\t} else {\n            tag.onload = createjs.proxy(function() {\n                successCallback(this._tag);\n            }, this);\n\n            tag.onerror = createjs.proxy(function() {\n                errorCallback(_this._tag);\n            }, this);\n\t\t}\n\t};\n\n\t/**\n\t * Clean up the ObjectURL, the tag is done with it. Note that this function is run\n\t * as an event listener without a proxy/closure, as it doesn't require it - so do not\n\t * include any functionality that requires scope without changing it.\n\t * @method _cleanUpURL\n\t * @param event\n\t * @private\n\t */\n\tp._cleanUpURL = function (event) {\n\t\tvar URL = window.URL || window.webkitURL;\n\t\tURL.revokeObjectURL(event.target.src);\n\t};\n\n\tcreatejs.ImageLoader = createjs.promote(ImageLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// JavaScriptLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for JavaScript files.\n\t * @class JavaScriptLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction JavaScriptLoader(loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.JAVASCRIPT);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = \"src\";\n\t\tthis.setTag(document.createElement(\"script\"));\n\t};\n\n\tvar p = createjs.extend(JavaScriptLoader, createjs.AbstractLoader);\n\tvar s = JavaScriptLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/JAVASCRIPT:property\"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.JAVASCRIPT;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for JavaScript files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLLinkElement|HTMLStyleElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\tvar tag = loader.getTag();\n\t\tif (this._preferXHR) {\n\t\t\ttag.text = loader.getResult(true);\n\t\t}\n\t\treturn tag;\n\t};\n\n\tcreatejs.JavaScriptLoader = createjs.promote(JavaScriptLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// JSONLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for JSON files. To load JSON cross-domain, use JSONP and the {{#crossLink \"JSONPLoader\"}}{{/crossLink}}\n\t * instead. To load JSON-formatted manifests, use {{#crossLink \"ManifestLoader\"}}{{/crossLink}}, and to\n\t * load EaselJS SpriteSheets, use {{#crossLink \"SpriteSheetLoader\"}}{{/crossLink}}.\n\t * @class JSONLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction JSONLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.JSON);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\t};\n\n\tvar p = createjs.extend(JSONLoader, createjs.AbstractLoader);\n\tvar s = JSONLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/JSON:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.JSON;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for JSON files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {HTMLLinkElement|HTMLStyleElement}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\tvar json = null;\n\t\ttry {\n\t\t\tjson = createjs.DataUtils.parseJSON(loader.getResult(true));\n\t\t} catch (e) {\n\t\t\tvar event = new createjs.ErrorEvent(\"JSON_FORMAT\", null, e);\n\t\t\tthis._sendError(event);\n\t\t\treturn e;\n\t\t}\n\n\t\treturn json;\n\t};\n\n\tcreatejs.JSONLoader = createjs.promote(JSONLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// JSONPLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for JSONP files, which are JSON-formatted text files, wrapped in a callback. To load regular JSON\n\t * without a callback use the {{#crossLink \"JSONLoader\"}}{{/crossLink}} instead. To load JSON-formatted manifests,\n\t * use {{#crossLink \"ManifestLoader\"}}{{/crossLink}}, and to load EaselJS SpriteSheets, use\n\t * {{#crossLink \"SpriteSheetLoader\"}}{{/crossLink}}.\n\t *\n\t * JSONP is a format that provides a solution for loading JSON files cross-domain <em>without</em> requiring CORS.\n\t * JSONP files are loaded as JavaScript, and the \"callback\" is executed once they are loaded. The callback in the\n\t * JSONP must match the callback passed to the loadItem.\n\t *\n\t * <h4>Example JSONP</h4>\n\t *\n\t * \t\tcallbackName({\n\t * \t\t\t\"name\": \"value\",\n\t *\t \t\t\"num\": 3,\n\t *\t\t\t\"obj\": { \"bool\":true }\n\t * \t\t});\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \t\tvar loadItem = {id:\"json\", type:\"jsonp\", src:\"http://server.com/text.json\", callback:\"callbackName\"}\n\t * \t\tvar queue = new createjs.LoadQueue();\n\t * \t\tqueue.on(\"complete\", handleComplete);\n\t * \t\tqueue.loadItem(loadItem);\n\t *\n\t * \t\tfunction handleComplete(event) }\n\t * \t\t\tvar json = queue.getResult(\"json\");\n\t * \t\t\tconsole.log(json.obj.bool); // true\n\t * \t\t}\n\t *\n\t * Note that JSONP files loaded concurrently require a <em>unique</em> callback. To ensure JSONP files are loaded\n\t * in order, either use the {{#crossLink \"LoadQueue/setMaxConnections\"}}{{/crossLink}} method (set to 1),\n\t * or set {{#crossLink \"LoadItem/maintainOrder:property\"}}{{/crossLink}} on items with the same callback.\n\t *\n\t * @class JSONPLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction JSONPLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, false, createjs.AbstractLoader.JSONP);\n\t\tthis.setTag(document.createElement(\"script\"));\n\t\tthis.getTag().type = \"text/javascript\";\n\t};\n\n\tvar p = createjs.extend(JSONPLoader, createjs.AbstractLoader);\n\tvar s = JSONPLoader;\n\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/JSONP:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.JSONP;\n\t};\n\n\t// public methods\n\tp.cancel = function () {\n\t\tthis.AbstractLoader_cancel();\n\t\tthis._dispose();\n\t};\n\n\t/**\n\t * Loads the JSONp file.  Because of the unique loading needs of JSONp\n\t * we don't use the AbstractLoader.load() method.\n\t *\n\t * @method load\n\t *\n\t */\n\tp.load = function () {\n\t\tif (this._item.callback == null) {\n\t\t\tthrow new Error('callback is required for loading JSONP requests.');\n\t\t}\n\n\t\t// TODO: Look into creating our own iFrame to handle the load\n\t\t// In the first attempt, FF did not get the result\n\t\t//   result instanceof Object did not work either\n\t\t//   so we would need to clone the result.\n\t\tif (window[this._item.callback] != null) {\n\t\t\tthrow new Error(\n\t\t\t\t\"JSONP callback '\" +\n\t\t\t\tthis._item.callback +\n\t\t\t\t\"' already exists on window. You need to specify a different callback or re-name the current one.\");\n\t\t}\n\n\t\twindow[this._item.callback] = createjs.proxy(this._handleLoad, this);\n\t\twindow.document.body.appendChild(this._tag);\n\n\t\tthis._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);\n\n\t\t// Load the tag\n\t\tthis._tag.src = this._item.src;\n\t};\n\n\t// private methods\n\t/**\n\t * Handle the JSONP callback, which is a public method defined on `window`.\n\t * @method _handleLoad\n\t * @param {Object} data The formatted JSON data.\n\t * @private\n\t */\n\tp._handleLoad = function (data) {\n\t\tthis._result = this._rawResult = data;\n\t\tthis._sendComplete();\n\n\t\tthis._dispose();\n\t};\n\n\t/**\n\t * The tag request has not loaded within the time specfied in loadTimeout.\n\t * @method _handleError\n\t * @param {Object} event The XHR error event.\n\t * @private\n\t */\n\tp._handleTimeout = function () {\n\t\tthis._dispose();\n\t\tthis.dispatchEvent(new createjs.ErrorEvent(\"timeout\"));\n\t};\n\n\t/**\n\t * Clean up the JSONP load. This clears out the callback and script tag that this loader creates.\n\t * @method _dispose\n\t * @private\n\t */\n\tp._dispose = function () {\n\t\twindow.document.body.removeChild(this._tag);\n\t\tdelete window[this._item.callback];\n\n\t\tclearTimeout(this._loadTimeout);\n\t};\n\n\tcreatejs.JSONPLoader = createjs.promote(JSONPLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// ManifestLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for JSON manifests. Items inside the manifest are loaded before the loader completes. To load manifests\n\t * using JSONP, specify a {{#crossLink \"LoadItem/callback:property\"}}{{/crossLink}} as part of the\n\t * {{#crossLink \"LoadItem\"}}{{/crossLink}}.\n\t *\n\t * The list of files in the manifest must be defined on the top-level JSON object in a `manifest` property. This\n\t * example shows a sample manifest definition, as well as how to to include a sub-manifest.\n\t *\n\t * \t\t{\n\t * \t\t\t\"path\": \"assets/\",\n\t *\t \t    \"manifest\": [\n\t *\t\t\t\t\"image.png\",\n\t *\t\t\t\t{\"src\": \"image2.png\", \"id\":\"image2\"},\n\t *\t\t\t\t{\"src\": \"sub-manifest.json\", \"type\":\"manifest\", \"callback\":\"jsonCallback\"}\n\t *\t \t    ]\n\t *\t \t}\n\t *\n\t * When a ManifestLoader has completed loading, the parent loader (usually a {{#crossLink \"LoadQueue\"}}{{/crossLink}},\n\t * but could also be another ManifestLoader) will inherit all the loaded items, so you can access them directly.\n\t *\n\t * Note that the {{#crossLink \"JSONLoader\"}}{{/crossLink}} and {{#crossLink \"JSONPLoader\"}}{{/crossLink}} are\n\t * higher priority loaders, so manifests <strong>must</strong> set the {{#crossLink \"LoadItem\"}}{{/crossLink}}\n\t * {{#crossLink \"LoadItem/type:property\"}}{{/crossLink}} property to {{#crossLink \"AbstractLoader/MANIFEST:property\"}}{{/crossLink}}.\n\t * @class ManifestLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction ManifestLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, null, createjs.AbstractLoader.MANIFEST);\n\n\t// Public Properties\n\t\t/**\n\t\t * An array of the plugins registered using {{#crossLink \"LoadQueue/installPlugin\"}}{{/crossLink}},\n\t\t * used to pass plugins to new LoadQueues that may be created.\n\t\t * @property _plugins\n\t\t * @type {Array}\n\t\t * @private\n\t\t * @since 0.6.1\n\t\t */\n\t\tthis.plugins = null;\n\n\n\t// Protected Properties\n\t\t/**\n\t\t * An internal {{#crossLink \"LoadQueue\"}}{{/crossLink}} that loads the contents of the manifest.\n\t\t * @property _manifestQueue\n\t\t * @type {LoadQueue}\n\t\t * @private\n\t\t */\n\t\tthis._manifestQueue = null;\n\t};\n\n\tvar p = createjs.extend(ManifestLoader, createjs.AbstractLoader);\n\tvar s = ManifestLoader;\n\n\t// static properties\n\t/**\n\t * The amount of progress that the manifest itself takes up.\n\t * @property MANIFEST_PROGRESS\n\t * @type {number}\n\t * @default 0.25 (25%)\n\t * @private\n\t * @static\n\t */\n\ts.MANIFEST_PROGRESS = 0.25;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/MANIFEST:property\"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.MANIFEST;\n\t};\n\n\t// public methods\n\tp.load = function () {\n\t\tthis.AbstractLoader_load();\n\t};\n\n\t// protected methods\n\tp._createRequest = function() {\n\t\tvar callback = this._item.callback;\n\t\tif (callback != null) {\n\t\t\tthis._request = new createjs.JSONPLoader(this._item);\n\t\t} else {\n\t\t\tthis._request = new createjs.JSONLoader(this._item);\n\t\t}\n\t};\n\n\tp.handleEvent = function (event) {\n\t\tswitch (event.type) {\n\t\t\tcase \"complete\":\n\t\t\t\tthis._rawResult = event.target.getResult(true);\n\t\t\t\tthis._result = event.target.getResult();\n\t\t\t\tthis._sendProgress(s.MANIFEST_PROGRESS);\n\t\t\t\tthis._loadManifest(this._result);\n\t\t\t\treturn;\n\t\t\tcase \"progress\":\n\t\t\t\tevent.loaded *= s.MANIFEST_PROGRESS;\n\t\t\t\tthis.progress = event.loaded / event.total;\n\t\t\t\tif (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }\n\t\t\t\tthis._sendProgress(event);\n\t\t\t\treturn;\n\t\t}\n\t\tthis.AbstractLoader_handleEvent(event);\n\t};\n\n\tp.destroy = function() {\n\t\tthis.AbstractLoader_destroy();\n\t\tthis._manifestQueue.close();\n\t};\n\n\t/**\n\t * Create and load the manifest items once the actual manifest has been loaded.\n\t * @method _loadManifest\n\t * @param {Object} json\n\t * @private\n\t */\n\tp._loadManifest = function (json) {\n\t\tif (json && json.manifest) {\n\t\t\tvar queue = this._manifestQueue = new createjs.LoadQueue();\n\t\t\tqueue.on(\"fileload\", this._handleManifestFileLoad, this);\n\t\t\tqueue.on(\"progress\", this._handleManifestProgress, this);\n\t\t\tqueue.on(\"complete\", this._handleManifestComplete, this, true);\n\t\t\tqueue.on(\"error\", this._handleManifestError, this, true);\n\t\t\tfor(var i = 0, l = this.plugins.length; i < l; i++) {\t// conserve order of plugins\n\t\t\t\tqueue.installPlugin(this.plugins[i]);\n\t\t\t}\n\t\t\tqueue.loadManifest(json);\n\t\t} else {\n\t\t\tthis._sendComplete();\n\t\t}\n\t};\n\n\t/**\n\t * An item from the {{#crossLink \"_manifestQueue:property\"}}{{/crossLink}} has completed.\n\t * @method _handleManifestFileLoad\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._handleManifestFileLoad = function (event) {\n\t\tevent.target = null;\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * The manifest has completed loading. This triggers the {{#crossLink \"AbstractLoader/complete:event\"}}{{/crossLink}}\n\t * {{#crossLink \"Event\"}}{{/crossLink}} from the ManifestLoader.\n\t * @method _handleManifestComplete\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._handleManifestComplete = function (event) {\n\t\tthis._loadedItems = this._manifestQueue.getItems(true);\n\t\tthis._sendComplete();\n\t};\n\n\t/**\n\t * The manifest has reported progress.\n\t * @method _handleManifestProgress\n\t * @param {ProgressEvent} event\n\t * @private\n\t */\n\tp._handleManifestProgress = function (event) {\n\t\tthis.progress = event.progress * (1 - s.MANIFEST_PROGRESS) + s.MANIFEST_PROGRESS;\n\t\tthis._sendProgress(this.progress);\n\t};\n\n\t/**\n\t * The manifest has reported an error with one of the files.\n\t * @method _handleManifestError\n\t * @param {ErrorEvent} event\n\t * @private\n\t */\n\tp._handleManifestError = function (event) {\n\t\tvar newEvent = new createjs.Event(\"fileerror\");\n\t\tnewEvent.item = event.data;\n\t\tthis.dispatchEvent(newEvent);\n\t};\n\n\tcreatejs.ManifestLoader = createjs.promote(ManifestLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// SoundLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for HTML audio files. PreloadJS can not load WebAudio files, as a WebAudio context is required, which\n\t * should be created by either a library playing the sound (such as <a href=\"http://soundjs.com\">SoundJS</a>, or an\n\t * external framework that handles audio playback. To load content that can be played by WebAudio, use the\n\t * {{#crossLink \"BinaryLoader\"}}{{/crossLink}}, and handle the audio context decoding manually.\n\t * @class SoundLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractMediaLoader\n\t * @constructor\n\t */\n\tfunction SoundLoader(loadItem, preferXHR) {\n\t\tthis.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SOUND);\n\n\t\t// protected properties\n\t\tif (createjs.RequestUtils.isAudioTag(loadItem)) {\n\t\t\tthis._tag = loadItem;\n\t\t} else if (createjs.RequestUtils.isAudioTag(loadItem.src)) {\n\t\t\tthis._tag = loadItem;\n\t\t} else if (createjs.RequestUtils.isAudioTag(loadItem.tag)) {\n\t\t\tthis._tag = createjs.RequestUtils.isAudioTag(loadItem) ? loadItem : loadItem.src;\n\t\t}\n\n\t\tif (this._tag != null) {\n\t\t\tthis._preferXHR = false;\n\t\t}\n\t};\n\n\tvar p = createjs.extend(SoundLoader, createjs.AbstractMediaLoader);\n\tvar s = SoundLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/SOUND:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.SOUND;\n\t};\n\n\t// protected methods\n\tp._createTag = function (src) {\n\t\tvar tag = document.createElement(\"audio\");\n\t\ttag.autoplay = false;\n\t\ttag.preload = \"none\";\n\n\t\t//LM: Firefox fails when this the preload=\"none\" for other tags, but it needs to be \"none\" to ensure PreloadJS works.\n\t\ttag.src = src;\n\t\treturn tag;\n\t};\n\n\tcreatejs.SoundLoader = createjs.promote(SoundLoader, \"AbstractMediaLoader\");\n\n}());\n\n//##############################################################################\n// VideoLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for video files.\n\t * @class VideoLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractMediaLoader\n\t * @constructor\n\t */\n\tfunction VideoLoader(loadItem, preferXHR) {\n\t\tthis.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.VIDEO);\n\n\t\tif (createjs.RequestUtils.isVideoTag(loadItem) || createjs.RequestUtils.isVideoTag(loadItem.src)) {\n\t\t\tthis.setTag(createjs.RequestUtils.isVideoTag(loadItem)?loadItem:loadItem.src);\n\n\t\t\t// We can't use XHR for a tag that's passed in.\n\t\t\tthis._preferXHR = false;\n\t\t} else {\n\t\t\tthis.setTag(this._createTag());\n\t\t}\n\t};\n\n\tvar p = createjs.extend(VideoLoader, createjs.AbstractMediaLoader);\n\tvar s = VideoLoader;\n\n\t/**\n\t * Create a new video tag\n\t *\n\t * @returns {HTMLElement}\n\t * @private\n\t */\n\tp._createTag = function () {\n\t\treturn document.createElement(\"video\");\n\t};\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/VIDEO:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.VIDEO;\n\t};\n\n\tcreatejs.VideoLoader = createjs.promote(VideoLoader, \"AbstractMediaLoader\");\n\n}());\n\n//##############################################################################\n// SpriteSheetLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for EaselJS SpriteSheets. Images inside the spritesheet definition are loaded before the loader\n\t * completes. To load SpriteSheets using JSONP, specify a {{#crossLink \"LoadItem/callback:property\"}}{{/crossLink}}\n\t * as part of the {{#crossLink \"LoadItem\"}}{{/crossLink}}. Note that the {{#crossLink \"JSONLoader\"}}{{/crossLink}}\n\t * and {{#crossLink \"JSONPLoader\"}}{{/crossLink}} are higher priority loaders, so SpriteSheets <strong>must</strong>\n\t * set the {{#crossLink \"LoadItem\"}}{{/crossLink}} {{#crossLink \"LoadItem/type:property\"}}{{/crossLink}} property\n\t * to {{#crossLink \"AbstractLoader/SPRITESHEET:property\"}}{{/crossLink}}.\n\t *\n\t * The {{#crossLink \"LoadItem\"}}{{/crossLink}} {{#crossLink \"LoadItem/crossOrigin:property\"}}{{/crossLink}} as well\n\t * as the {{#crossLink \"LoadQueue's\"}}{{/crossLink}} `basePath` argument and {{#crossLink \"LoadQueue/_preferXHR\"}}{{/crossLink}}\n\t * property supplied to the {{#crossLink \"LoadQueue\"}}{{/crossLink}} are passed on to the sub-manifest that loads\n\t * the SpriteSheet images.\n\t *\n\t * Note that the SpriteSheet JSON does not respect the {{#crossLink \"LoadQueue/_preferXHR:property\"}}{{/crossLink}}\n\t * property, which should instead be determined by the presence of a {{#crossLink \"LoadItem/callback:property\"}}{{/crossLink}}\n\t * property on the SpriteSheet load item. This is because the JSON loaded will have a different format depending on\n\t * if it is loaded as JSON, so just changing `preferXHR` is not enough to change how it is loaded.\n\t * @class SpriteSheetLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction SpriteSheetLoader(loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SPRITESHEET);\n\n\t\t// protected properties\n\t\t/**\n\t\t * An internal queue which loads the SpriteSheet's images.\n\t\t * @method _manifestQueue\n\t\t * @type {LoadQueue}\n\t\t * @private\n\t\t */\n\t\tthis._manifestQueue = null;\n\t}\n\n\tvar p = createjs.extend(SpriteSheetLoader, createjs.AbstractLoader);\n\tvar s = SpriteSheetLoader;\n\n\t// static properties\n\t/**\n\t * The amount of progress that the manifest itself takes up.\n\t * @property SPRITESHEET_PROGRESS\n\t * @type {number}\n\t * @default 0.25 (25%)\n\t * @private\n\t * @static\n\t */\n\ts.SPRITESHEET_PROGRESS = 0.25;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/SPRITESHEET:property\"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.SPRITESHEET;\n\t};\n\n\t// public methods\n\tp.destroy = function() {\n\t\tthis.AbstractLoader_destroy;\n\t\tthis._manifestQueue.close();\n\t};\n\n\t// protected methods\n\tp._createRequest = function() {\n\t\tvar callback = this._item.callback;\n\t\tif (callback != null) {\n\t\t\tthis._request = new createjs.JSONPLoader(this._item);\n\t\t} else {\n\t\t\tthis._request = new createjs.JSONLoader(this._item);\n\t\t}\n\t};\n\n\tp.handleEvent = function (event) {\n\t\tswitch (event.type) {\n\t\t\tcase \"complete\":\n\t\t\t\tthis._rawResult = event.target.getResult(true);\n\t\t\t\tthis._result = event.target.getResult();\n\t\t\t\tthis._sendProgress(s.SPRITESHEET_PROGRESS);\n\t\t\t\tthis._loadManifest(this._result);\n\t\t\t\treturn;\n\t\t\tcase \"progress\":\n\t\t\t\tevent.loaded *= s.SPRITESHEET_PROGRESS;\n\t\t\t\tthis.progress = event.loaded / event.total;\n\t\t\t\tif (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }\n\t\t\t\tthis._sendProgress(event);\n\t\t\t\treturn;\n\t\t}\n\t\tthis.AbstractLoader_handleEvent(event);\n\t};\n\n\t/**\n\t * Create and load the images once the SpriteSheet JSON has been loaded.\n\t * @method _loadManifest\n\t * @param {Object} json\n\t * @private\n\t */\n\tp._loadManifest = function (json) {\n\t\tif (json && json.images) {\n\t\t\tvar queue = this._manifestQueue = new createjs.LoadQueue(this._preferXHR, this._item.path, this._item.crossOrigin);\n\t\t\tqueue.on(\"complete\", this._handleManifestComplete, this, true);\n\t\t\tqueue.on(\"fileload\", this._handleManifestFileLoad, this);\n\t\t\tqueue.on(\"progress\", this._handleManifestProgress, this);\n\t\t\tqueue.on(\"error\", this._handleManifestError, this, true);\n\t\t\tqueue.loadManifest(json.images);\n\t\t}\n\t};\n\n\t/**\n\t * An item from the {{#crossLink \"_manifestQueue:property\"}}{{/crossLink}} has completed.\n\t * @method _handleManifestFileLoad\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._handleManifestFileLoad = function (event) {\n\t\tvar image = event.result;\n\t\tif (image != null) {\n\t\t\tvar images = this.getResult().images;\n\t\t\tvar pos = images.indexOf(event.item.src);\n\t\t\timages[pos] = image;\n\t\t}\n\t};\n\n\t/**\n\t * The images have completed loading. This triggers the {{#crossLink \"AbstractLoader/complete:event\"}}{{/crossLink}}\n\t * {{#crossLink \"Event\"}}{{/crossLink}} from the SpriteSheetLoader.\n\t * @method _handleManifestComplete\n\t * @param {Event} event\n\t * @private\n\t */\n\tp._handleManifestComplete = function (event) {\n\t\tthis._result = new createjs.SpriteSheet(this._result);\n\t\tthis._loadedItems = this._manifestQueue.getItems(true);\n\t\tthis._sendComplete();\n\t};\n\n\t/**\n\t * The images {{#crossLink \"LoadQueue\"}}{{/crossLink}} has reported progress.\n\t * @method _handleManifestProgress\n\t * @param {ProgressEvent} event\n\t * @private\n\t */\n\tp._handleManifestProgress = function (event) {\n\t\tthis.progress = event.progress * (1 - s.SPRITESHEET_PROGRESS) + s.SPRITESHEET_PROGRESS;\n\t\tthis._sendProgress(this.progress);\n\t};\n\n\t/**\n\t * An image has reported an error.\n\t * @method _handleManifestError\n\t * @param {ErrorEvent} event\n\t * @private\n\t */\n\tp._handleManifestError = function (event) {\n\t\tvar newEvent = new createjs.Event(\"fileerror\");\n\t\tnewEvent.item = event.data;\n\t\tthis.dispatchEvent(newEvent);\n\t};\n\n\tcreatejs.SpriteSheetLoader = createjs.promote(SpriteSheetLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// SVGLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for SVG files.\n\t * @class SVGLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @param {Boolean} preferXHR\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction SVGLoader(loadItem, preferXHR) {\n\t\tthis.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SVG);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\n\t\t// protected properties\n\t\tthis._tagSrcAttribute = \"data\";\n\n\t\tif (preferXHR) {\n\t\t\tthis.setTag(document.createElement(\"svg\"));\n\t\t} else {\n\t\t\tthis.setTag(document.createElement(\"object\"));\n\t\t\tthis.getTag().type = \"image/svg+xml\";\n\t\t}\n\t};\n\n\tvar p = createjs.extend(SVGLoader, createjs.AbstractLoader);\n\tvar s = SVGLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/SVG:property\"}}{{/crossLink}}\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.SVG;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for SVG files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {Object}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\t// mime should be image/svg+xml, but Opera requires text/xml\n\t\tvar xml = createjs.DataUtils.parseXML(loader.getResult(true), \"text/xml\");\n\t\tvar tag = loader.getTag();\n\n\t\tif (!this._preferXHR && document.body.contains(tag)) {\n\t\t\tdocument.body.removeChild(tag);\n\t\t}\n\n\t\tif (xml.documentElement != null) {\n\t\t\ttag.appendChild(xml.documentElement);\n\t\t\ttag.style.visibility = \"visible\";\n\t\t\treturn tag;\n\t\t} else { // For browsers that don't support SVG, just give them the XML. (IE 9-8)\n\t\t\treturn xml;\n\t\t}\n\t};\n\n\tcreatejs.SVGLoader = createjs.promote(SVGLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// XMLLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t// constructor\n\t/**\n\t * A loader for CSS files.\n\t * @class XMLLoader\n\t * @param {LoadItem|Object} loadItem\n\t * @extends AbstractLoader\n\t * @constructor\n\t */\n\tfunction XMLLoader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.XML);\n\n\t\t// public properties\n\t\tthis.resultFormatter = this._formatResult;\n\t};\n\n\tvar p = createjs.extend(XMLLoader, createjs.AbstractLoader);\n\tvar s = XMLLoader;\n\n\t// static methods\n\t/**\n\t * Determines if the loader can load a specific item. This loader can only load items that are of type\n\t * {{#crossLink \"AbstractLoader/XML:property\"}}{{/crossLink}}.\n\t * @method canLoadItem\n\t * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.\n\t * @returns {Boolean} Whether the loader can load the item.\n\t * @static\n\t */\n\ts.canLoadItem = function (item) {\n\t\treturn item.type == createjs.AbstractLoader.XML;\n\t};\n\n\t// protected methods\n\t/**\n\t * The result formatter for XML files.\n\t * @method _formatResult\n\t * @param {AbstractLoader} loader\n\t * @returns {XMLDocument}\n\t * @private\n\t */\n\tp._formatResult = function (loader) {\n\t\treturn createjs.DataUtils.parseXML(loader.getResult(true), \"text/xml\");\n\t};\n\n\tcreatejs.XMLLoader = createjs.promote(XMLLoader, \"AbstractLoader\");\n\n}());\n\n//##############################################################################\n// version.js\n//##############################################################################\n\n(function () {\n\n\t/**\n\t * Static class holding library specific information such as the version and buildDate of the library.\n\t * The SoundJS class has been renamed {{#crossLink \"Sound\"}}{{/crossLink}}.  Please see {{#crossLink \"Sound\"}}{{/crossLink}}\n\t * for information on using sound.\n\t * @class SoundJS\n\t **/\n\tvar s = createjs.SoundJS = createjs.SoundJS || {};\n\n\t/**\n\t * The version string for this release.\n\t * @property version\n\t * @type String\n\t * @static\n\t **/\n\ts.version = /*=version*/\"0.6.2\"; // injected by build process\n\n\t/**\n\t * The build date for this release in UTC format.\n\t * @property buildDate\n\t * @type String\n\t * @static\n\t **/\n\ts.buildDate = /*=date*/\"Thu, 26 Nov 2015 20:44:31 GMT\"; // injected by build process\n\n})();\n\n//##############################################################################\n// IndexOf.js\n//##############################################################################\n\n/**\n * @class Utility Methods\n */\n\n/**\n * Finds the first occurrence of a specified value searchElement in the passed in array, and returns the index of\n * that value.  Returns -1 if value is not found.\n *\n *      var i = createjs.indexOf(myArray, myElementToFind);\n *\n * @method indexOf\n * @param {Array} array Array to search for searchElement\n * @param searchElement Element to find in array.\n * @return {Number} The first index of searchElement in array.\n */\ncreatejs.indexOf = function (array, searchElement){\n\t\"use strict\";\n\n\tfor (var i = 0,l=array.length; i < l; i++) {\n\t\tif (searchElement === array[i]) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\n//##############################################################################\n// Proxy.js\n//##############################################################################\n\n/**\n * Various utilities that the CreateJS Suite uses. Utilities are created as separate files, and will be available on the\n * createjs namespace directly.\n *\n * <h4>Example</h4>\n *\n *      myObject.addEventListener(\"change\", createjs.proxy(myMethod, scope));\n *\n * @class Utility Methods\n * @main Utility Methods\n */\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * A function proxy for methods. By default, JavaScript methods do not maintain scope, so passing a method as a\n\t * callback will result in the method getting called in the scope of the caller. Using a proxy ensures that the\n\t * method gets called in the correct scope.\n\t *\n\t * Additional arguments can be passed that will be applied to the function when it is called.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      myObject.addEventListener(\"event\", createjs.proxy(myHandler, this, arg1, arg2));\n\t *\n\t *      function myHandler(arg1, arg2) {\n\t *           // This gets called when myObject.myCallback is executed.\n\t *      }\n\t *\n\t * @method proxy\n\t * @param {Function} method The function to call\n\t * @param {Object} scope The scope to call the method name on\n\t * @param {mixed} [arg] * Arguments that are appended to the callback for additional params.\n\t * @public\n\t * @static\n\t */\n\tcreatejs.proxy = function (method, scope) {\n\t\tvar aArgs = Array.prototype.slice.call(arguments, 2);\n\t\treturn function () {\n\t\t\treturn method.apply(scope, Array.prototype.slice.call(arguments, 0).concat(aArgs));\n\t\t};\n\t}\n\n}());\n\n//##############################################################################\n// BrowserDetect.js\n//##############################################################################\n\n/**\n * @class Utility Methods\n */\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * An object that determines the current browser, version, operating system, and other environment\n\t * variables via user agent string.\n\t *\n\t * Used for audio because feature detection is unable to detect the many limitations of mobile devices.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      if (createjs.BrowserDetect.isIOS) { // do stuff }\n\t *\n\t * @property BrowserDetect\n\t * @type {Object}\n\t * @param {Boolean} isFirefox True if our browser is Firefox.\n\t * @param {Boolean} isOpera True if our browser is opera.\n\t * @param {Boolean} isChrome True if our browser is Chrome.  Note that Chrome for Android returns true, but is a\n\t * completely different browser with different abilities.\n\t * @param {Boolean} isIOS True if our browser is safari for iOS devices (iPad, iPhone, and iPod).\n\t * @param {Boolean} isAndroid True if our browser is Android.\n\t * @param {Boolean} isBlackberry True if our browser is Blackberry.\n\t * @constructor\n\t * @static\n\t */\n\tfunction BrowserDetect() {\n\t\tthrow \"BrowserDetect cannot be instantiated\";\n\t};\n\n\tvar agent = BrowserDetect.agent = window.navigator.userAgent;\n\tBrowserDetect.isWindowPhone = (agent.indexOf(\"IEMobile\") > -1) || (agent.indexOf(\"Windows Phone\") > -1);\n\tBrowserDetect.isFirefox = (agent.indexOf(\"Firefox\") > -1);\n\tBrowserDetect.isOpera = (window.opera != null);\n\tBrowserDetect.isChrome = (agent.indexOf(\"Chrome\") > -1);  // NOTE that Chrome on Android returns true but is a completely different browser with different abilities\n\tBrowserDetect.isIOS = (agent.indexOf(\"iPod\") > -1 || agent.indexOf(\"iPhone\") > -1 || agent.indexOf(\"iPad\") > -1) && !BrowserDetect.isWindowPhone;\n\tBrowserDetect.isAndroid = (agent.indexOf(\"Android\") > -1) && !BrowserDetect.isWindowPhone;\n\tBrowserDetect.isBlackberry = (agent.indexOf(\"Blackberry\") > -1);\n\n\tcreatejs.BrowserDetect = BrowserDetect;\n\n}());\n\n//##############################################################################\n// AudioSprite.js\n//##############################################################################\n\n//  NOTE this is \"Class\" is purely to document audioSprite Setup and usage.\n\n\n/**\n * <strong>Note: AudioSprite is not a class, but its usage is easily lost in the documentation, so it has been called\n * out here for quick reference.</strong>\n *\n * Audio sprites are much like CSS sprites or image sprite sheets: multiple audio assets grouped into a single file.\n * Audio sprites work around limitations in certain browsers, where only a single sound can be loaded and played at a\n * time. We recommend at least 300ms of silence between audio clips to deal with HTML audio tag inaccuracy, and to prevent\n * accidentally playing bits of the neighbouring clips.\n *\n * <strong>Benefits of Audio Sprites:</strong>\n * <ul>\n *     <li>More robust support for older browsers and devices that only allow a single audio instance, such as iOS 5.</li>\n *     <li>They provide a work around for the Internet Explorer 9 audio tag limit, which restricts how many different\n *     sounds that could be loaded at once.</li>\n *     <li>Faster loading by only requiring a single network request for several sounds, especially on mobile devices\n * where the network round trip for each file can add significant latency.</li>\n * </ul>\n *\n * <strong>Drawbacks of Audio Sprites</strong>\n * <ul>\n *     <li>No guarantee of smooth looping when using HTML or Flash audio. If you have a track that needs to loop\n * \t\tsmoothly and you are supporting non-web audio browsers, do not use audio sprites for that sound if you can avoid\n * \t\tit.</li>\n *     <li>No guarantee that HTML audio will play back immediately, especially the first time. In some browsers\n *     (Chrome!), HTML audio will only load enough to play through at the current download speed â€“ so we rely on the\n *     `canplaythrough` event to determine if the audio is loaded. Since audio sprites must jump ahead to play specific\n *     sounds, the audio may not yet have downloaded fully.</li>\n *     <li>Audio sprites share the same core source, so if you have a sprite with 5 sounds and are limited to 2\n * \t\tconcurrently playing instances, you can only play 2 of the sounds at the same time.</li>\n * </ul>\n *\n * <h4>Example</h4>\n *\n *\t\tcreatejs.Sound.initializeDefaultPlugins();\n *\t\tvar assetsPath = \"./assets/\";\n *\t\tvar sounds = [{\n *\t\t\tsrc:\"MyAudioSprite.ogg\", data: {\n *\t\t\t\taudioSprite: [\n *\t\t\t\t\t{id:\"sound1\", startTime:0, duration:500},\n *\t\t\t\t\t{id:\"sound2\", startTime:1000, duration:400},\n *\t\t\t\t\t{id:\"sound3\", startTime:1700, duration: 1000}\n *\t\t\t\t]}\n *\t\t\t}\n *\t\t];\n *\t\tcreatejs.Sound.alternateExtensions = [\"mp3\"];\n *\t\tcreatejs.Sound.on(\"fileload\", loadSound);\n *\t\tcreatejs.Sound.registerSounds(sounds, assetsPath);\n *\t\t// after load is complete\n *\t\tcreatejs.Sound.play(\"sound2\");\n *\n * You can also create audio sprites on the fly by setting the startTime and duration when creating an new AbstractSoundInstance.\n *\n * \t\tcreatejs.Sound.play(\"MyAudioSprite\", {startTime: 1000, duration: 400});\n *\n * The excellent CreateJS community has created a tool to create audio sprites, available at\n * <a href=\"https://github.com/tonistiigi/audiosprite\" target=\"_blank\">https://github.com/tonistiigi/audiosprite</a>,\n * as well as a <a href=\"http://jsfiddle.net/bharat_battu/g8fFP/12/\" target=\"_blank\">jsfiddle</a> to convert the output\n * to SoundJS format.\n *\n * @class AudioSprite\n * @since 0.6.0\n */\n\n//##############################################################################\n// PlayPropsConfig.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\t/**\n\t * A class to store the optional play properties passed in {{#crossLink \"Sound/play\"}}{{/crossLink}} and\n\t * {{#crossLink \"AbstractSoundInstance/play\"}}{{/crossLink}} calls.\n\t *\n\t * Optional Play Properties Include:\n\t * <ul>\n\t * <li>interrupt - How to interrupt any currently playing instances of audio with the same source,\n\t * if the maximum number of instances of the sound are already playing. Values are defined as <code>INTERRUPT_TYPE</code>\n\t * constants on the Sound class, with the default defined by {{#crossLink \"Sound/defaultInterruptBehavior:property\"}}{{/crossLink}}.</li>\n\t * <li>delay - The amount of time to delay the start of audio playback, in milliseconds.</li>\n\t * <li>offset - The offset from the start of the audio to begin playback, in milliseconds.</li>\n\t * <li>loop - How many times the audio loops when it reaches the end of playback. The default is 0 (no\n\t * loops), and -1 can be used for infinite playback.</li>\n\t * <li>volume - The volume of the sound, between 0 and 1. Note that the master volume is applied\n\t * against the individual volume.</li>\n\t * <li>pan - The left-right pan of the sound (if supported), between -1 (left) and 1 (right).</li>\n\t * <li>startTime - To create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.</li>\n\t * <li>duration - To create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.</li>\n\t * </ul>\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \tvar ppc = new createjs.PlayPropsConfig().set({interrupt: createjs.Sound.INTERRUPT_ANY, loop: -1, volume: 0.5})\n\t * \tcreatejs.Sound.play(\"mySound\", ppc);\n\t * \tmySoundInstance.play(ppc);\n\t *\n\t * @class PlayPropsConfig\n\t * @constructor\n\t * @since 0.6.1\n\t */\n\t// TODO think of a better name for this class\n\tvar PlayPropsConfig = function () {\n// Public Properties\n\t\t/**\n\t\t * How to interrupt any currently playing instances of audio with the same source,\n\t\t * if the maximum number of instances of the sound are already playing. Values are defined as\n\t\t * <code>INTERRUPT_TYPE</code> constants on the Sound class, with the default defined by\n\t\t * {{#crossLink \"Sound/defaultInterruptBehavior:property\"}}{{/crossLink}}.\n\t\t * @property interrupt\n\t\t * @type {string}\n\t\t * @default null\n\t\t */\n\t\tthis.interrupt = null;\n\n\t\t/**\n\t\t * The amount of time to delay the start of audio playback, in milliseconds.\n\t\t * @property delay\n\t\t * @type {Number}\n\t\t * @default null\n\t\t */\n\t\tthis.delay = null;\n\n\t\t/**\n\t\t * The offset from the start of the audio to begin playback, in milliseconds.\n\t\t * @property offset\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.offset = null;\n\n\t\t/**\n\t\t * How many times the audio loops when it reaches the end of playback. The default is 0 (no\n\t\t * loops), and -1 can be used for infinite playback.\n\t\t * @property loop\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.loop = null;\n\n\t\t/**\n\t\t * The volume of the sound, between 0 and 1. Note that the master volume is applied\n\t\t * against the individual volume.\n\t\t * @property volume\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.volume = null;\n\n\t\t/**\n\t\t * The left-right pan of the sound (if supported), between -1 (left) and 1 (right).\n\t\t * @property pan\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.pan = null;\n\n\t\t/**\n\t\t * Used to create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.\n\t\t * @property startTime\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.startTime = null;\n\n\t\t/**\n\t\t * Used to create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.\n\t\t * @property duration\n\t\t * @type {number}\n\t\t * @default null\n\t\t */\n\t\tthis.duration = null;\n\t};\n\tvar p = PlayPropsConfig.prototype = {};\n\tvar s = PlayPropsConfig;\n\n\n// Static Methods\n\t/**\n\t * Creates a PlayPropsConfig from another PlayPropsConfig or an Object.\n\t *\n\t * @method create\n\t * @param {PlayPropsConfig|Object} value The play properties\n\t * @returns {PlayPropsConfig}\n\t * @static\n\t */\n\ts.create = function (value) {\n\t\tif (value instanceof s || value instanceof Object) {\n\t\t\tvar ppc = new createjs.PlayPropsConfig();\n\t\t\tppc.set(value);\n\t\t\treturn ppc;\n\t\t} else {\n\t\t\tthrow new Error(\"Type not recognized.\");\n\t\t}\n\t};\n\n// Public Methods\n\t/**\n\t * Provides a chainable shortcut method for setting a number of properties on the instance.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var PlayPropsConfig = new createjs.PlayPropsConfig().set({loop:-1, volume:0.7});\n\t *\n\t * @method set\n\t * @param {Object} props A generic object containing properties to copy to the PlayPropsConfig instance.\n\t * @return {PlayPropsConfig} Returns the instance the method is called on (useful for chaining calls.)\n\t*/\n\tp.set = function(props) {\n\t\tfor (var n in props) { this[n] = props[n]; }\n\t\treturn this;\n\t};\n\n\tp.toString = function() {\n\t\treturn \"[PlayPropsConfig]\";\n\t};\n\n\tcreatejs.PlayPropsConfig = s;\n\n}());\n\n//##############################################################################\n// Sound.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * The Sound class is the public API for creating sounds, controlling the overall sound levels, and managing plugins.\n\t * All Sound APIs on this class are static.\n\t *\n\t * <b>Registering and Preloading</b><br />\n\t * Before you can play a sound, it <b>must</b> be registered. You can do this with {{#crossLink \"Sound/registerSound\"}}{{/crossLink}},\n\t * or register multiple sounds using {{#crossLink \"Sound/registerSounds\"}}{{/crossLink}}. If you don't register a\n\t * sound prior to attempting to play it using {{#crossLink \"Sound/play\"}}{{/crossLink}} or create it using {{#crossLink \"Sound/createInstance\"}}{{/crossLink}},\n\t * the sound source will be automatically registered but playback will fail as the source will not be ready. If you use\n\t * <a href=\"http://preloadjs.com\" target=\"_blank\">PreloadJS</a>, registration is handled for you when the sound is\n\t * preloaded. It is recommended to preload sounds either internally using the register functions or externally using\n\t * PreloadJS so they are ready when you want to use them.\n\t *\n\t * <b>Playback</b><br />\n\t * To play a sound once it's been registered and preloaded, use the {{#crossLink \"Sound/play\"}}{{/crossLink}} method.\n\t * This method returns a {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} which can be paused, resumed, muted, etc.\n\t * Please see the {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} documentation for more on the instance control APIs.\n\t *\n\t * <b>Plugins</b><br />\n\t * By default, the {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}} or the {{#crossLink \"HTMLAudioPlugin\"}}{{/crossLink}}\n\t * are used (when available), although developers can change plugin priority or add new plugins (such as the\n\t * provided {{#crossLink \"FlashAudioPlugin\"}}{{/crossLink}}). Please see the {{#crossLink \"Sound\"}}{{/crossLink}} API\n\t * methods for more on the playback and plugin APIs. To install plugins, or specify a different plugin order, see\n\t * {{#crossLink \"Sound/installPlugins\"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.FlashAudioPlugin.swfPath = \"../src/soundjs/flashaudio\";\n\t *      createjs.Sound.registerPlugins([createjs.WebAudioPlugin, createjs.FlashAudioPlugin]);\n\t *      createjs.Sound.alternateExtensions = [\"mp3\"];\n\t *      createjs.Sound.on(\"fileload\", this.loadHandler, this);\n\t *      createjs.Sound.registerSound(\"path/to/mySound.ogg\", \"sound\");\n\t *      function loadHandler(event) {\n     *          // This is fired for each sound that is registered.\n     *          var instance = createjs.Sound.play(\"sound\");  // play using id.  Could also use full source path or event.src.\n     *          instance.on(\"complete\", this.handleComplete, this);\n     *          instance.volume = 0.5;\n\t *      }\n\t *\n\t * The maximum number of concurrently playing instances of the same sound can be specified in the \"data\" argument\n\t * of {{#crossLink \"Sound/registerSound\"}}{{/crossLink}}.  Note that if not specified, the active plugin will apply\n\t * a default limit.  Currently HTMLAudioPlugin sets a default limit of 2, while WebAudioPlugin and FlashAudioPlugin set a\n\t * default limit of 100.\n\t *\n\t *      createjs.Sound.registerSound(\"sound.mp3\", \"soundId\", 4);\n\t *\n\t * Sound can be used as a plugin with PreloadJS to help preload audio properly. Audio preloaded with PreloadJS is\n\t * automatically registered with the Sound class. When audio is not preloaded, Sound will do an automatic internal\n\t * load. As a result, it may fail to play the first time play is called if the audio is not finished loading. Use\n\t * the {{#crossLink \"Sound/fileload:event\"}}{{/crossLink}} event to determine when a sound has finished internally\n\t * preloading. It is recommended that all audio is preloaded before it is played.\n\t *\n\t *      var queue = new createjs.LoadQueue();\n\t *\t\tqueue.installPlugin(createjs.Sound);\n\t *\n\t * <b>Audio Sprites</b><br />\n\t * SoundJS has added support for {{#crossLink \"AudioSprite\"}}{{/crossLink}}, available as of version 0.6.0.\n\t * For those unfamiliar with audio sprites, they are much like CSS sprites or sprite sheets: multiple audio assets\n\t * grouped into a single file.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *\t\tvar assetsPath = \"./assets/\";\n\t *\t\tvar sounds = [{\n\t *\t\t\tsrc:\"MyAudioSprite.ogg\", data: {\n\t *\t\t\t\taudioSprite: [\n\t *\t\t\t\t\t{id:\"sound1\", startTime:0, duration:500},\n\t *\t\t\t\t\t{id:\"sound2\", startTime:1000, duration:400},\n\t *\t\t\t\t\t{id:\"sound3\", startTime:1700, duration: 1000}\n\t *\t\t\t\t]}\n \t *\t\t\t}\n\t *\t\t];\n\t *\t\tcreatejs.Sound.alternateExtensions = [\"mp3\"];\n\t *\t\tcreatejs.Sound.on(\"fileload\", loadSound);\n\t *\t\tcreatejs.Sound.registerSounds(sounds, assetsPath);\n\t *\t\t// after load is complete\n\t *\t\tcreatejs.Sound.play(\"sound2\");\n\t *\n\t * <b>Mobile Playback</b><br />\n\t * Devices running iOS require the WebAudio context to be \"unlocked\" by playing at least one sound inside of a user-\n\t * initiated event (such as touch/click). Earlier versions of SoundJS included a \"MobileSafe\" sample, but this is no\n\t * longer necessary as of SoundJS 0.6.2.\n\t * <ul>\n\t *     <li>\n\t *         In SoundJS 0.4.1 and above, you can either initialize plugins or use the {{#crossLink \"WebAudioPlugin/playEmptySound\"}}{{/crossLink}}\n\t *         method in the call stack of a user input event to manually unlock the audio context.\n\t *     </li>\n\t *     <li>\n\t *         In SoundJS 0.6.2 and above, SoundJS will automatically listen for the first document-level \"mousedown\"\n\t *         and \"touchend\" event, and unlock WebAudio. This will continue to check these events until the WebAudio\n\t *         context becomes \"unlocked\" (changes from \"suspended\" to \"running\")\n\t *     </li>\n\t *     <li>\n\t *         Both the \"mousedown\" and \"touchend\" events can be used to unlock audio in iOS9+, the \"touchstart\" event\n\t *         will work in iOS8 and below. The \"touchend\" event will only work in iOS9 when the gesture is interpreted\n\t *         as a \"click\", so if the user long-presses the button, it will no longer work.\n\t *     </li>\n\t *     <li>\n\t *         When using the <a href=\"http://www.createjs.com/docs/easeljs/classes/Touch.html\">EaselJS Touch class</a>,\n\t *         the \"mousedown\" event will not fire when a canvas is clicked, since MouseEvents are prevented, to ensure\n\t *         only touch events fire. To get around this, you can either rely on \"touchend\", or:\n\t *         <ol>\n\t *             <li>Set the `allowDefault` property on the Touch class constructor to `true` (defaults to `false`).</li>\n\t *             <li>Set the `preventSelection` property on the EaselJS `Stage` to `false`.</li>\n\t *         </ol>\n\t *         These settings may change how your application behaves, and are not recommended.\n\t *     </li>\n\t * </ul>\n\t *\n\t * <b>Loading Alternate Paths and Extension-less Files</b><br />\n\t * SoundJS supports loading alternate paths and extension-less files by passing an object instead of a string for\n\t * the `src` property, which is a hash using the format `{extension:\"path\", extension2:\"path2\"}`. These labels are\n\t * how SoundJS determines if the browser will support the sound. This also enables multiple formats to live in\n\t * different folders, or on CDNs, which often has completely different filenames for each file.\n\t *\n\t * Priority is determined by the property order (first property is tried first).  This is supported by both internal loading\n\t * and loading with PreloadJS.\n\t *\n\t * <em>Note: an id is required for playback.</em>\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *\t\tvar sounds = {path:\"./audioPath/\",\n\t * \t\t\t\tmanifest: [\n\t *\t\t\t\t{id: \"cool\", src: {mp3:\"mp3/awesome.mp3\", ogg:\"noExtensionOggFile\"}}\n\t *\t\t]};\n\t *\n\t *\t\tcreatejs.Sound.alternateExtensions = [\"mp3\"];\n\t *\t\tcreatejs.Sound.addEventListener(\"fileload\", handleLoad);\n\t *\t\tcreatejs.Sound.registerSounds(sounds);\n\t *\n\t * <h3>Known Browser and OS issues</h3>\n\t * <b>IE 9 HTML Audio limitations</b><br />\n\t * <ul><li>There is a delay in applying volume changes to tags that occurs once playback is started. So if you have\n\t * muted all sounds, they will all play during this delay until the mute applies internally. This happens regardless of\n\t * when or how you apply the volume change, as the tag seems to need to play to apply it.</li>\n     * <li>MP3 encoding will not always work for audio tags, particularly in Internet Explorer. We've found default\n\t * encoding with 64kbps works.</li>\n\t * <li>Occasionally very short samples will get cut off.</li>\n\t * <li>There is a limit to how many audio tags you can load and play at once, which appears to be determined by\n\t * hardware and browser settings.  See {{#crossLink \"HTMLAudioPlugin.MAX_INSTANCES\"}}{{/crossLink}} for a safe\n\t * estimate.</li></ul>\n\t *\n\t * <b>Firefox 25 Web Audio limitations</b>\n\t * <ul><li>mp3 audio files do not load properly on all windows machines, reported\n\t * <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=929969\" target=\"_blank\">here</a>. </br>\n\t * For this reason it is recommended to pass another FF supported type (ie ogg) first until this bug is resolved, if\n\t * possible.</li></ul>\n\n\t * <b>Safari limitations</b><br />\n\t * <ul><li>Safari requires Quicktime to be installed for audio playback.</li></ul>\n\t *\n\t * <b>iOS 6 Web Audio limitations</b><br />\n\t * <ul><li>Sound is initially locked, and must be unlocked via a user-initiated event. Please see the section on\n\t * Mobile Playback above.</li>\n\t * <li>A bug exists that will distort un-cached web audio when a video element is present in the DOM that has audio\n\t * at a different sampleRate.</li>\n\t * </ul>\n\t *\n\t * <b>Android HTML Audio limitations</b><br />\n\t * <ul><li>We have no control over audio volume. Only the user can set volume on their device.</li>\n\t * <li>We can only play audio inside a user event (touch/click).  This currently means you cannot loop sound or use\n\t * a delay.</li></ul>\n\t *\n\t * <b>Web Audio and PreloadJS</b><br />\n\t * <ul><li>Web Audio must be loaded through XHR, therefore when used with PreloadJS, tag loading is not possible.\n\t * This means that tag loading can not be used to avoid cross domain issues.</li><ul>\n\t *\n\t * @class Sound\n\t * @static\n\t * @uses EventDispatcher\n\t */\n\tfunction Sound() {\n\t\tthrow \"Sound cannot be instantiated\";\n\t}\n\n\tvar s = Sound;\n\n\n// Static Properties\n\t/**\n\t * The interrupt value to interrupt any currently playing instance with the same source, if the maximum number of\n\t * instances of the sound are already playing.\n\t * @property INTERRUPT_ANY\n\t * @type {String}\n\t * @default any\n\t * @static\n\t */\n\ts.INTERRUPT_ANY = \"any\";\n\n\t/**\n\t * The interrupt value to interrupt the earliest currently playing instance with the same source that progressed the\n\t * least distance in the audio track, if the maximum number of instances of the sound are already playing.\n\t * @property INTERRUPT_EARLY\n\t * @type {String}\n\t * @default early\n\t * @static\n\t */\n\ts.INTERRUPT_EARLY = \"early\";\n\n\t/**\n\t * The interrupt value to interrupt the currently playing instance with the same source that progressed the most\n\t * distance in the audio track, if the maximum number of instances of the sound are already playing.\n\t * @property INTERRUPT_LATE\n\t * @type {String}\n\t * @default late\n\t * @static\n\t */\n\ts.INTERRUPT_LATE = \"late\";\n\n\t/**\n\t * The interrupt value to not interrupt any currently playing instances with the same source, if the maximum number of\n\t * instances of the sound are already playing.\n\t * @property INTERRUPT_NONE\n\t * @type {String}\n\t * @default none\n\t * @static\n\t */\n\ts.INTERRUPT_NONE = \"none\";\n\n\t/**\n\t * Defines the playState of an instance that is still initializing.\n\t * @property PLAY_INITED\n\t * @type {String}\n\t * @default playInited\n\t * @static\n\t */\n\ts.PLAY_INITED = \"playInited\";\n\n\t/**\n\t * Defines the playState of an instance that is currently playing or paused.\n\t * @property PLAY_SUCCEEDED\n\t * @type {String}\n\t * @default playSucceeded\n\t * @static\n\t */\n\ts.PLAY_SUCCEEDED = \"playSucceeded\";\n\n\t/**\n\t * Defines the playState of an instance that was interrupted by another instance.\n\t * @property PLAY_INTERRUPTED\n\t * @type {String}\n\t * @default playInterrupted\n\t * @static\n\t */\n\ts.PLAY_INTERRUPTED = \"playInterrupted\";\n\n\t/**\n\t * Defines the playState of an instance that completed playback.\n\t * @property PLAY_FINISHED\n\t * @type {String}\n\t * @default playFinished\n\t * @static\n\t */\n\ts.PLAY_FINISHED = \"playFinished\";\n\n\t/**\n\t * Defines the playState of an instance that failed to play. This is usually caused by a lack of available channels\n\t * when the interrupt mode was \"INTERRUPT_NONE\", the playback stalled, or the sound could not be found.\n\t * @property PLAY_FAILED\n\t * @type {String}\n\t * @default playFailed\n\t * @static\n\t */\n\ts.PLAY_FAILED = \"playFailed\";\n\n\t/**\n\t * A list of the default supported extensions that Sound will <i>try</i> to play. Plugins will check if the browser\n\t * can play these types, so modifying this list before a plugin is initialized will allow the plugins to try to\n\t * support additional media types.\n\t *\n\t * NOTE this does not currently work for {{#crossLink \"FlashAudioPlugin\"}}{{/crossLink}}.\n\t *\n\t * More details on file formats can be found at <a href=\"http://en.wikipedia.org/wiki/Audio_file_format\" target=\"_blank\">http://en.wikipedia.org/wiki/Audio_file_format</a>.<br />\n\t * A very detailed list of file formats can be found at <a href=\"http://www.fileinfo.com/filetypes/audio\" target=\"_blank\">http://www.fileinfo.com/filetypes/audio</a>.\n\t * @property SUPPORTED_EXTENSIONS\n\t * @type {Array[String]}\n\t * @default [\"mp3\", \"ogg\", \"opus\", \"mpeg\", \"wav\", \"m4a\", \"mp4\", \"aiff\", \"wma\", \"mid\"]\n\t * @since 0.4.0\n\t * @static\n\t */\n\ts.SUPPORTED_EXTENSIONS = [\"mp3\", \"ogg\", \"opus\", \"mpeg\", \"wav\", \"m4a\", \"mp4\", \"aiff\", \"wma\", \"mid\"];\n\n\t/**\n\t * Some extensions use another type of extension support to play (one of them is a codex).  This allows you to map\n\t * that support so plugins can accurately determine if an extension is supported.  Adding to this list can help\n\t * plugins determine more accurately if an extension is supported.\n\t *\n \t * A useful list of extensions for each format can be found at <a href=\"http://html5doctor.com/html5-audio-the-state-of-play/\" target=\"_blank\">http://html5doctor.com/html5-audio-the-state-of-play/</a>.\n\t * @property EXTENSION_MAP\n\t * @type {Object}\n\t * @since 0.4.0\n\t * @default {m4a:\"mp4\"}\n\t * @static\n\t */\n\ts.EXTENSION_MAP = {\n\t\tm4a:\"mp4\"\n\t};\n\n\t/**\n\t * The RegExp pattern used to parse file URIs. This supports simple file names, as well as full domain URIs with\n\t * query strings. The resulting match is: protocol:$1 domain:$2 path:$3 file:$4 extension:$5 query:$6.\n\t * @property FILE_PATTERN\n\t * @type {RegExp}\n\t * @static\n\t * @protected\n\t */\n\ts.FILE_PATTERN = /^(?:(\\w+:)\\/{2}(\\w+(?:\\.\\w+)*\\/?))?([/.]*?(?:[^?]+)?\\/)?((?:[^/?]+)\\.(\\w+))(?:\\?(\\S+)?)?$/;\n\n\n// Class Public properties\n\t/**\n\t * Determines the default behavior for interrupting other currently playing instances with the same source, if the\n\t * maximum number of instances of the sound are already playing.  Currently the default is {{#crossLink \"Sound/INTERRUPT_NONE:property\"}}{{/crossLink}}\n\t * but this can be set and will change playback behavior accordingly.  This is only used when {{#crossLink \"Sound/play\"}}{{/crossLink}}\n\t * is called without passing a value for interrupt.\n\t * @property defaultInterruptBehavior\n\t * @type {String}\n\t * @default Sound.INTERRUPT_NONE, or \"none\"\n\t * @static\n\t * @since 0.4.0\n\t */\n\ts.defaultInterruptBehavior = s.INTERRUPT_NONE;  // OJR does s.INTERRUPT_ANY make more sense as default?  Needs game dev testing to see which case makes more sense.\n\n\t/**\n\t * An array of extensions to attempt to use when loading sound, if the default is unsupported by the active plugin.\n\t * These are applied in order, so if you try to Load Thunder.ogg in a browser that does not support ogg, and your\n\t * extensions array is [\"mp3\", \"m4a\", \"wav\"] it will check mp3 support, then m4a, then wav. The audio files need\n\t * to exist in the same location, as only the extension is altered.\n\t *\n\t * Note that regardless of which file is loaded, you can call {{#crossLink \"Sound/createInstance\"}}{{/crossLink}}\n\t * and {{#crossLink \"Sound/play\"}}{{/crossLink}} using the same id or full source path passed for loading.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *\tvar sounds = [\n\t *\t\t{src:\"myPath/mySound.ogg\", id:\"example\"},\n\t *\t];\n\t *\tcreatejs.Sound.alternateExtensions = [\"mp3\"]; // now if ogg is not supported, SoundJS will try asset0.mp3\n\t *\tcreatejs.Sound.on(\"fileload\", handleLoad); // call handleLoad when each sound loads\n\t *\tcreatejs.Sound.registerSounds(sounds, assetPath);\n\t *\t// ...\n\t *\tcreatejs.Sound.play(\"myPath/mySound.ogg\"); // works regardless of what extension is supported.  Note calling with ID is a better approach\n\t *\n\t * @property alternateExtensions\n\t * @type {Array}\n\t * @since 0.5.2\n\t * @static\n\t */\n\ts.alternateExtensions = [];\n\n\t/**\n\t * The currently active plugin. If this is null, then no plugin could be initialized. If no plugin was specified,\n\t * Sound attempts to apply the default plugins: {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}}, followed by\n\t * {{#crossLink \"HTMLAudioPlugin\"}}{{/crossLink}}.\n\t * @property activePlugin\n\t * @type {Object}\n\t * @static\n\t */\n    s.activePlugin = null;\n\n\n// class getter / setter properties\n\t/**\n\t * Set the master volume of Sound. The master volume is multiplied against each sound's individual volume.  For\n\t * example, if master volume is 0.5 and a sound's volume is 0.5, the resulting volume is 0.25. To set individual\n\t * sound volume, use AbstractSoundInstance {{#crossLink \"AbstractSoundInstance/volume:property\"}}{{/crossLink}} instead.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     createjs.Sound.volume = 0.5;\n\t *\n\t *\n\t * @property volume\n\t * @type {Number}\n\t * @default 1\n\t * @since 0.6.1\n\t */\n\ts._masterVolume = 1;\n\tObject.defineProperty(s, \"volume\", {\n\t\tget: function () {return this._masterVolume;},\n\t\tset: function (value) {\n\t\t\t\tif (Number(value) == null) {return false;}\n\t\t\t\tvalue = Math.max(0, Math.min(1, value));\n\t\t\t\ts._masterVolume = value;\n\t\t\t\tif (!this.activePlugin || !this.activePlugin.setVolume || !this.activePlugin.setVolume(value)) {\n\t\t\t\t\tvar instances = this._instances;\n\t\t\t\t\tfor (var i = 0, l = instances.length; i < l; i++) {\n\t\t\t\t\t\tinstances[i].setMasterVolume(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t});\n\n\t/**\n\t * Mute/Unmute all audio. Note that muted audio still plays at 0 volume. This global mute value is maintained\n\t * separately and when set will override, but not change the mute property of individual instances. To mute an individual\n\t * instance, use AbstractSoundInstance {{#crossLink \"AbstractSoundInstance/muted:property\"}}{{/crossLink}} instead.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     createjs.Sound.muted = true;\n\t *\n\t *\n\t * @property muted\n\t * @type {Boolean}\n\t * @default false\n\t * @since 0.6.1\n\t */\n\ts._masterMute = false;\n\t// OJR references to the methods were not working, so the code had to be duplicated here\n\tObject.defineProperty(s, \"muted\", {\n\t\tget: function () {return this._masterMute;},\n\t\tset: function (value) {\n\t\t\t\tif (value == null) {return false;}\n\n\t\t\t\tthis._masterMute = value;\n\t\t\t\tif (!this.activePlugin || !this.activePlugin.setMute || !this.activePlugin.setMute(value)) {\n\t\t\t\t\tvar instances = this._instances;\n\t\t\t\t\tfor (var i = 0, l = instances.length; i < l; i++) {\n\t\t\t\t\t\tinstances[i].setMasterMute(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t});\n\n\t/**\n\t * Get the active plugins capabilities, which help determine if a plugin can be used in the current environment,\n\t * or if the plugin supports a specific feature. Capabilities include:\n\t * <ul>\n\t *     <li><b>panning:</b> If the plugin can pan audio from left to right</li>\n\t *     <li><b>volume;</b> If the plugin can control audio volume.</li>\n\t *     <li><b>tracks:</b> The maximum number of audio tracks that can be played back at a time. This will be -1\n\t *     if there is no known limit.</li>\n\t * <br />An entry for each file type in {{#crossLink \"Sound/SUPPORTED_EXTENSIONS:property\"}}{{/crossLink}}:\n\t *     <li><b>mp3:</b> If MP3 audio is supported.</li>\n\t *     <li><b>ogg:</b> If OGG audio is supported.</li>\n\t *     <li><b>wav:</b> If WAV audio is supported.</li>\n\t *     <li><b>mpeg:</b> If MPEG audio is supported.</li>\n\t *     <li><b>m4a:</b> If M4A audio is supported.</li>\n\t *     <li><b>mp4:</b> If MP4 audio is supported.</li>\n\t *     <li><b>aiff:</b> If aiff audio is supported.</li>\n\t *     <li><b>wma:</b> If wma audio is supported.</li>\n\t *     <li><b>mid:</b> If mid audio is supported.</li>\n\t * </ul>\n\t *\n\t * You can get a specific capability of the active plugin using standard object notation\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var mp3 = createjs.Sound.capabilities.mp3;\n\t *\n\t * Note this property is read only.\n\t *\n\t * @property capabilities\n\t * @type {Object}\n\t * @static\n\t * @readOnly\n\t * @since 0.6.1\n\t */\n\tObject.defineProperty(s, \"capabilities\", {\n\t\tget: function () {\n\t\t\t\t\tif (s.activePlugin == null) {return null;}\n\t\t\t\t\treturn s.activePlugin._capabilities;\n\t\t\t\t},\n\t\tset: function (value) { return false;}\n\t});\n\n\n// Class Private properties\n\t/**\n\t * Determines if the plugins have been registered. If false, the first call to play() will instantiate the default\n\t * plugins ({{#crossLink \"WebAudioPlugin\"}}{{/crossLink}}, followed by {{#crossLink \"HTMLAudioPlugin\"}}{{/crossLink}}).\n\t * If plugins have been registered, but none are applicable, then sound playback will fail.\n\t * @property _pluginsRegistered\n\t * @type {Boolean}\n\t * @default false\n\t * @static\n\t * @protected\n\t */\n\ts._pluginsRegistered = false;\n\n\t/**\n\t * Used internally to assign unique IDs to each AbstractSoundInstance.\n\t * @property _lastID\n\t * @type {Number}\n\t * @static\n\t * @protected\n\t */\n\ts._lastID = 0;\n\n\t/**\n\t * An array containing all currently playing instances. This allows Sound to control the volume, mute, and playback of\n\t * all instances when using static APIs like {{#crossLink \"Sound/stop\"}}{{/crossLink}} and {{#crossLink \"Sound/setVolume\"}}{{/crossLink}}.\n\t * When an instance has finished playback, it gets removed via the {{#crossLink \"Sound/finishedPlaying\"}}{{/crossLink}}\n\t * method. If the user replays an instance, it gets added back in via the {{#crossLink \"Sound/_beginPlaying\"}}{{/crossLink}}\n\t * method.\n\t * @property _instances\n\t * @type {Array}\n\t * @protected\n\t * @static\n\t */\n\ts._instances = [];\n\n\t/**\n\t * An object hash storing objects with sound sources, startTime, and duration via there corresponding ID.\n\t * @property _idHash\n\t * @type {Object}\n\t * @protected\n\t * @static\n\t */\n\ts._idHash = {};\n\n\t/**\n\t * An object hash that stores preloading sound sources via the parsed source that is passed to the plugin.  Contains the\n\t * source, id, and data that was passed in by the user.  Parsed sources can contain multiple instances of source, id,\n\t * and data.\n\t * @property _preloadHash\n\t * @type {Object}\n\t * @protected\n\t * @static\n\t */\n\ts._preloadHash = {};\n\n\t/**\n\t * An object hash storing {{#crossLink \"PlayPropsConfig\"}}{{/crossLink}} via the parsed source that is passed as defaultPlayProps in\n\t * {{#crossLink \"Sound/registerSound\"}}{{/crossLink}} and {{#crossLink \"Sound/registerSounds\"}}{{/crossLink}}.\n\t * @property _defaultPlayPropsHash\n\t * @type {Object}\n\t * @protected\n\t * @static\n\t * @since 0.6.1\n\t */\n\ts._defaultPlayPropsHash = {};\n\n\n// EventDispatcher methods:\n\ts.addEventListener = null;\n\ts.removeEventListener = null;\n\ts.removeAllEventListeners = null;\n\ts.dispatchEvent = null;\n\ts.hasEventListener = null;\n\ts._listeners = null;\n\n\tcreatejs.EventDispatcher.initialize(s); // inject EventDispatcher methods.\n\n\n// Events\n\t/**\n\t * This event is fired when a file finishes loading internally. This event is fired for each loaded sound,\n\t * so any handler methods should look up the <code>event.src</code> to handle a particular sound.\n\t * @event fileload\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {String} src The source of the sound that was loaded.\n\t * @param {String} [id] The id passed in when the sound was registered. If one was not provided, it will be null.\n\t * @param {Number|Object} [data] Any additional data associated with the item. If not provided, it will be undefined.\n\t * @since 0.4.1\n\t */\n\n\t/**\n\t * This event is fired when a file fails loading internally. This event is fired for each loaded sound,\n\t * so any handler methods should look up the <code>event.src</code> to handle a particular sound.\n\t * @event fileerror\n\t * @param {Object} target The object that dispatched the event.\n\t * @param {String} type The event type.\n\t * @param {String} src The source of the sound that was loaded.\n\t * @param {String} [id] The id passed in when the sound was registered. If one was not provided, it will be null.\n\t * @param {Number|Object} [data] Any additional data associated with the item. If not provided, it will be undefined.\n\t * @since 0.6.0\n\t */\n\n\n// Class Public Methods\n\t/**\n\t * Get the preload rules to allow Sound to be used as a plugin by <a href=\"http://preloadjs.com\" target=\"_blank\">PreloadJS</a>.\n\t * Any load calls that have the matching type or extension will fire the callback method, and use the resulting\n\t * object, which is potentially modified by Sound. This helps when determining the correct path, as well as\n\t * registering the audio instance(s) with Sound. This method should not be called, except by PreloadJS.\n\t * @method getPreloadHandlers\n\t * @return {Object} An object containing:\n\t * <ul><li>callback: A preload callback that is fired when a file is added to PreloadJS, which provides\n\t *      Sound a mechanism to modify the load parameters, select the correct file format, register the sound, etc.</li>\n\t *      <li>types: A list of file types that are supported by Sound (currently supports \"sound\").</li>\n\t *      <li>extensions: A list of file extensions that are supported by Sound (see {{#crossLink \"Sound/SUPPORTED_EXTENSIONS:property\"}}{{/crossLink}}).</li></ul>\n\t * @static\n\t * @protected\n\t */\n\ts.getPreloadHandlers = function () {\n\t\treturn {\n\t\t\tcallback:createjs.proxy(s.initLoad, s),\n\t\t\ttypes:[\"sound\"],\n\t\t\textensions:s.SUPPORTED_EXTENSIONS\n\t\t};\n\t};\n\n\t/**\n\t * Used to dispatch fileload events from internal loading.\n\t * @method _handleLoadComplete\n\t * @param event A loader event.\n\t * @protected\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts._handleLoadComplete = function(event) {\n\t\tvar src = event.target.getItem().src;\n\t\tif (!s._preloadHash[src]) {return;}\n\n\t\tfor (var i = 0, l = s._preloadHash[src].length; i < l; i++) {\n\t\t\tvar item = s._preloadHash[src][i];\n\t\t\ts._preloadHash[src][i] = true;\n\n\t\t\tif (!s.hasEventListener(\"fileload\")) { continue; }\n\n\t\t\tvar event = new createjs.Event(\"fileload\");\n\t\t\tevent.src = item.src;\n\t\t\tevent.id = item.id;\n\t\t\tevent.data = item.data;\n\t\t\tevent.sprite = item.sprite;\n\n\t\t\ts.dispatchEvent(event);\n\t\t}\n\t};\n\n\t/**\n\t * Used to dispatch error events from internal preloading.\n\t * @param event\n\t * @protected\n\t * @since 0.6.0\n\t * @static\n\t */\n\ts._handleLoadError = function(event) {\n\t\tvar src = event.target.getItem().src;\n\t\tif (!s._preloadHash[src]) {return;}\n\n\t\tfor (var i = 0, l = s._preloadHash[src].length; i < l; i++) {\n\t\t\tvar item = s._preloadHash[src][i];\n\t\t\ts._preloadHash[src][i] = false;\n\n\t\t\tif (!s.hasEventListener(\"fileerror\")) { continue; }\n\n\t\t\tvar event = new createjs.Event(\"fileerror\");\n\t\t\tevent.src = item.src;\n\t\t\tevent.id = item.id;\n\t\t\tevent.data = item.data;\n\t\t\tevent.sprite = item.sprite;\n\n\t\t\ts.dispatchEvent(event);\n\t\t}\n\t};\n\n\t/**\n\t * Used by {{#crossLink \"Sound/registerPlugins\"}}{{/crossLink}} to register a Sound plugin.\n\t *\n\t * @method _registerPlugin\n\t * @param {Object} plugin The plugin class to install.\n\t * @return {Boolean} Whether the plugin was successfully initialized.\n\t * @static\n\t * @private\n\t */\n\ts._registerPlugin = function (plugin) {\n\t\t// Note: Each plugin is passed in as a class reference, but we store the activePlugin as an instance\n\t\tif (plugin.isSupported()) {\n\t\t\ts.activePlugin = new plugin();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Register a list of Sound plugins, in order of precedence. To register a single plugin, pass a single element in the array.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.FlashAudioPlugin.swfPath = \"../src/soundjs/flashaudio/\";\n\t *      createjs.Sound.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin, createjs.FlashAudioPlugin]);\n\t *\n\t * @method registerPlugins\n\t * @param {Array} plugins An array of plugins classes to install.\n\t * @return {Boolean} Whether a plugin was successfully initialized.\n\t * @static\n\t */\n\ts.registerPlugins = function (plugins) {\n\t\ts._pluginsRegistered = true;\n\t\tfor (var i = 0, l = plugins.length; i < l; i++) {\n\t\t\tif (s._registerPlugin(plugins[i])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Initialize the default plugins. This method is automatically called when any audio is played or registered before\n\t * the user has manually registered plugins, and enables Sound to work without manual plugin setup. Currently, the\n\t * default plugins are {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}} followed by {{#crossLink \"HTMLAudioPlugin\"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \tif (!createjs.initializeDefaultPlugins()) { return; }\n\t *\n\t * @method initializeDefaultPlugins\n\t * @returns {Boolean} True if a plugin was initialized, false otherwise.\n\t * @since 0.4.0\n\t * @static\n\t */\n\ts.initializeDefaultPlugins = function () {\n\t\tif (s.activePlugin != null) {return true;}\n\t\tif (s._pluginsRegistered) {return false;}\n\t\tif (s.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin])) {return true;}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Determines if Sound has been initialized, and a plugin has been activated.\n\t *\n\t * <h4>Example</h4>\n\t * This example sets up a Flash fallback, but only if there is no plugin specified yet.\n\t *\n\t * \tif (!createjs.Sound.isReady()) {\n\t *\t\tcreatejs.FlashAudioPlugin.swfPath = \"../src/soundjs/flashaudio/\";\n\t * \t\tcreatejs.Sound.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin, createjs.FlashAudioPlugin]);\n\t *\t}\n\t *\n\t * @method isReady\n\t * @return {Boolean} If Sound has initialized a plugin.\n\t * @static\n\t */\n\ts.isReady = function () {\n\t\treturn (s.activePlugin != null);\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink \"Sound/capabilities:property\"}}{{/crossLink}} instead.\n\t *\n\t * @method getCapabilities\n\t * @return {Object} An object containing the capabilities of the active plugin.\n\t * @static\n\t * @deprecated\n\t */\n\ts.getCapabilities = function () {\n\t\tif (s.activePlugin == null) {return null;}\n\t\treturn s.activePlugin._capabilities;\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink \"Sound/capabilities:property\"}}{{/crossLink}} instead.\n\t *\n\t * @method getCapability\n\t * @param {String} key The capability to retrieve\n\t * @return {Number|Boolean} The value of the capability.\n\t * @static\n\t * @see getCapabilities\n\t * @deprecated\n\t */\n\ts.getCapability = function (key) {\n\t\tif (s.activePlugin == null) {return null;}\n\t\treturn s.activePlugin._capabilities[key];\n\t};\n\n\t/**\n\t * Process manifest items from <a href=\"http://preloadjs.com\" target=\"_blank\">PreloadJS</a>. This method is intended\n\t * for usage by a plugin, and not for direct interaction.\n\t * @method initLoad\n\t * @param {Object} src The object to load.\n\t * @return {Object|AbstractLoader} An instance of AbstractLoader.\n\t * @protected\n\t * @static\n\t */\n\ts.initLoad = function (loadItem) {\n\t\treturn s._registerSound(loadItem);\n\t};\n\n\t/**\n\t * Internal method for loading sounds.  This should not be called directly.\n\t *\n\t * @method _registerSound\n\t * @param {Object} src The object to load, containing src property and optionally containing id and data.\n\t * @return {Object} An object with the modified values that were passed in, which defines the sound.\n\t * Returns false if the source cannot be parsed or no plugins can be initialized.\n\t * Returns true if the source is already loaded.\n\t * @static\n\t * @private\n\t * @since 0.6.0\n\t */\n\n\ts._registerSound = function (loadItem) {\n\t\tif (!s.initializeDefaultPlugins()) {return false;}\n\n\t\tvar details;\n\t\tif (loadItem.src instanceof Object) {\n\t\t\tdetails = s._parseSrc(loadItem.src);\n\t\t\tdetails.src = loadItem.path + details.src;\n\t\t} else {\n\t\t\tdetails = s._parsePath(loadItem.src);\n\t\t}\n\t\tif (details == null) {return false;}\n\t\tloadItem.src = details.src;\n\t\tloadItem.type = \"sound\";\n\n\t\tvar data = loadItem.data;\n\t\tvar numChannels = null;\n\t\tif (data != null) {\n\t\t\tif (!isNaN(data.channels)) {\n\t\t\t\tnumChannels = parseInt(data.channels);\n\t\t\t} else if (!isNaN(data)) {\n\t\t\t\tnumChannels = parseInt(data);\n\t\t\t}\n\n\t\t\tif(data.audioSprite) {\n\t\t\t\tvar sp;\n\t\t\t\tfor(var i = data.audioSprite.length; i--; ) {\n\t\t\t\t\tsp = data.audioSprite[i];\n\t\t\t\t\ts._idHash[sp.id] = {src: loadItem.src, startTime: parseInt(sp.startTime), duration: parseInt(sp.duration)};\n\n\t\t\t\t\tif (sp.defaultPlayProps) {\n\t\t\t\t\t\ts._defaultPlayPropsHash[sp.id] = createjs.PlayPropsConfig.create(sp.defaultPlayProps);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (loadItem.id != null) {s._idHash[loadItem.id] = {src: loadItem.src}};\n\t\tvar loader = s.activePlugin.register(loadItem);\n\n\t\tSoundChannel.create(loadItem.src, numChannels);\n\n\t\t// return the number of instances to the user.  This will also be returned in the load event.\n\t\tif (data == null || !isNaN(data)) {\n\t\t\tloadItem.data = numChannels || SoundChannel.maxPerChannel();\n\t\t} else {\n\t\t\tloadItem.data.channels = numChannels || SoundChannel.maxPerChannel();\n\t\t}\n\n\t\tif (loader.type) {loadItem.type = loader.type;}\n\n\t\tif (loadItem.defaultPlayProps) {\n\t\t\ts._defaultPlayPropsHash[loadItem.src] = createjs.PlayPropsConfig.create(loadItem.defaultPlayProps);\n\t\t}\n\t\treturn loader;\n\t};\n\n\t/**\n\t * Register an audio file for loading and future playback in Sound. This is automatically called when using\n\t * <a href=\"http://preloadjs.com\" target=\"_blank\">PreloadJS</a>.  It is recommended to register all sounds that\n\t * need to be played back in order to properly prepare and preload them. Sound does internal preloading when required.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Sound.alternateExtensions = [\"mp3\"];\n\t *      createjs.Sound.on(\"fileload\", handleLoad); // add an event listener for when load is completed\n\t *      createjs.Sound.registerSound(\"myAudioPath/mySound.ogg\", \"myID\", 3);\n\t *      createjs.Sound.registerSound({ogg:\"path1/mySound.ogg\", mp3:\"path2/mySoundNoExtension\"}, \"myID\", 3);\n\t *\n\t *\n\t * @method registerSound\n\t * @param {String | Object} src The source or an Object with a \"src\" property or an Object with multiple extension labeled src properties.\n\t * @param {String} [id] An id specified by the user to play the sound later.  Note id is required for when src is multiple extension labeled src properties.\n\t * @param {Number | Object} [data] Data associated with the item. Sound uses the data parameter as the number of\n\t * channels for an audio instance, however a \"channels\" property can be appended to the data object if it is used\n\t * for other information. The audio channels will set a default based on plugin if no value is found.\n\t * Sound also uses the data property to hold an {{#crossLink \"AudioSprite\"}}{{/crossLink}} array of objects in the following format {id, startTime, duration}.<br/>\n\t *   id used to play the sound later, in the same manner as a sound src with an id.<br/>\n\t *   startTime is the initial offset to start playback and loop from, in milliseconds.<br/>\n\t *   duration is the amount of time to play the clip for, in milliseconds.<br/>\n\t * This allows Sound to support audio sprites that are played back by id.\n\t * @param {string} basePath Set a path that will be prepended to src for loading.\n\t * @param {Object | PlayPropsConfig} defaultPlayProps Optional Playback properties that will be set as the defaults on any new AbstractSoundInstance.\n\t * See {{#crossLink \"PlayPropsConfig\"}}{{/crossLink}} for options.\n\t * @return {Object} An object with the modified values that were passed in, which defines the sound.\n\t * Returns false if the source cannot be parsed or no plugins can be initialized.\n\t * Returns true if the source is already loaded.\n\t * @static\n\t * @since 0.4.0\n\t */\n\ts.registerSound = function (src, id, data, basePath, defaultPlayProps) {\n\t\tvar loadItem = {src: src, id: id, data:data, defaultPlayProps:defaultPlayProps};\n\t\tif (src instanceof Object && src.src) {\n\t\t\tbasePath = id;\n\t\t\tloadItem = src;\n\t\t}\n\t\tloadItem = createjs.LoadItem.create(loadItem);\n\t\tloadItem.path = basePath;\n\n\t\tif (basePath != null && !(loadItem.src instanceof Object)) {loadItem.src = basePath + src;}\n\n\t\tvar loader = s._registerSound(loadItem);\n\t\tif(!loader) {return false;}\n\n\t\tif (!s._preloadHash[loadItem.src]) { s._preloadHash[loadItem.src] = [];}\n\t\ts._preloadHash[loadItem.src].push(loadItem);\n\t\tif (s._preloadHash[loadItem.src].length == 1) {\n\t\t\t// OJR note this will disallow reloading a sound if loading fails or the source changes\n\t\t\tloader.on(\"complete\", createjs.proxy(this._handleLoadComplete, this));\n\t\t\tloader.on(\"error\", createjs.proxy(this._handleLoadError, this));\n\t\t\ts.activePlugin.preload(loader);\n\t\t} else {\n\t\t\tif (s._preloadHash[loadItem.src][0] == true) {return true;}\n\t\t}\n\n\t\treturn loadItem;\n\t};\n\n\t/**\n\t * Register an array of audio files for loading and future playback in Sound. It is recommended to register all\n\t * sounds that need to be played back in order to properly prepare and preload them. Sound does internal preloading\n\t * when required.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \t\tvar assetPath = \"./myAudioPath/\";\n\t *      var sounds = [\n\t *          {src:\"asset0.ogg\", id:\"example\"},\n\t *          {src:\"asset1.ogg\", id:\"1\", data:6},\n\t *          {src:\"asset2.mp3\", id:\"works\"}\n\t *          {src:{mp3:\"path1/asset3.mp3\", ogg:\"path2/asset3NoExtension}, id:\"better\"}\n\t *      ];\n\t *      createjs.Sound.alternateExtensions = [\"mp3\"];\t// if the passed extension is not supported, try this extension\n\t *      createjs.Sound.on(\"fileload\", handleLoad); // call handleLoad when each sound loads\n\t *      createjs.Sound.registerSounds(sounds, assetPath);\n\t *\n\t * @method registerSounds\n\t * @param {Array} sounds An array of objects to load. Objects are expected to be in the format needed for\n\t * {{#crossLink \"Sound/registerSound\"}}{{/crossLink}}: <code>{src:srcURI, id:ID, data:Data}</code>\n\t * with \"id\" and \"data\" being optional.\n\t * You can also pass an object with path and manifest properties, where path is a basePath and manifest is an array of objects to load.\n\t * Note id is required if src is an object with extension labeled src properties.\n\t * @param {string} basePath Set a path that will be prepended to each src when loading.  When creating, playing, or removing\n\t * audio that was loaded with a basePath by src, the basePath must be included.\n\t * @return {Object} An array of objects with the modified values that were passed in, which defines each sound.\n\t * Like registerSound, it will return false for any values when the source cannot be parsed or if no plugins can be initialized.\n\t * Also, it will return true for any values when the source is already loaded.\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.registerSounds = function (sounds, basePath) {\n\t\tvar returnValues = [];\n\t\tif (sounds.path) {\n\t\t\tif (!basePath) {\n\t\t\t\tbasePath = sounds.path;\n\t\t\t} else {\n\t\t\t\tbasePath = basePath + sounds.path;\n\t\t\t}\n\t\t\tsounds = sounds.manifest;\n\t\t\t// TODO document this feature\n\t\t}\n\t\tfor (var i = 0, l = sounds.length; i < l; i++) {\n\t\t\treturnValues[i] = createjs.Sound.registerSound(sounds[i].src, sounds[i].id, sounds[i].data, basePath, sounds[i].defaultPlayProps);\n\t\t}\n\t\treturn returnValues;\n\t};\n\n\t/**\n\t * Remove a sound that has been registered with {{#crossLink \"Sound/registerSound\"}}{{/crossLink}} or\n\t * {{#crossLink \"Sound/registerSounds\"}}{{/crossLink}}.\n\t * <br />Note this will stop playback on active instances playing this sound before deleting them.\n\t * <br />Note if you passed in a basePath, you need to pass it or prepend it to the src here.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Sound.removeSound(\"myID\");\n\t *      createjs.Sound.removeSound(\"myAudioBasePath/mySound.ogg\");\n\t *      createjs.Sound.removeSound(\"myPath/myOtherSound.mp3\", \"myBasePath/\");\n\t *      createjs.Sound.removeSound({mp3:\"musicNoExtension\", ogg:\"music.ogg\"}, \"myBasePath/\");\n\t *\n\t * @method removeSound\n\t * @param {String | Object} src The src or ID of the audio, or an Object with a \"src\" property, or an Object with multiple extension labeled src properties.\n\t * @param {string} basePath Set a path that will be prepended to each src when removing.\n\t * @return {Boolean} True if sound is successfully removed.\n\t * @static\n\t * @since 0.4.1\n\t */\n\ts.removeSound = function(src, basePath) {\n\t\tif (s.activePlugin == null) {return false;}\n\n\t\tif (src instanceof Object && src.src) {src = src.src;}\n\n\t\tvar details;\n\t\tif (src instanceof Object) {\n\t\t\tdetails = s._parseSrc(src);\n\t\t} else {\n\t\t\tsrc = s._getSrcById(src).src;\n\t\t\tdetails = s._parsePath(src);\n\t\t}\n\t\tif (details == null) {return false;}\n\t\tsrc = details.src;\n\t\tif (basePath != null) {src = basePath + src;}\n\n\t\tfor(var prop in s._idHash){\n\t\t\tif(s._idHash[prop].src == src) {\n\t\t\t\tdelete(s._idHash[prop]);\n\t\t\t}\n\t\t}\n\n\t\t// clear from SoundChannel, which also stops and deletes all instances\n\t\tSoundChannel.removeSrc(src);\n\n\t\tdelete(s._preloadHash[src]);\n\n\t\ts.activePlugin.removeSound(src);\n\n\t\treturn true;\n\t};\n\n\t/**\n\t * Remove an array of audio files that have been registered with {{#crossLink \"Sound/registerSound\"}}{{/crossLink}} or\n\t * {{#crossLink \"Sound/registerSounds\"}}{{/crossLink}}.\n\t * <br />Note this will stop playback on active instances playing this audio before deleting them.\n\t * <br />Note if you passed in a basePath, you need to pass it or prepend it to the src here.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t * \t\tassetPath = \"./myPath/\";\n\t *      var sounds = [\n\t *          {src:\"asset0.ogg\", id:\"example\"},\n\t *          {src:\"asset1.ogg\", id:\"1\", data:6},\n\t *          {src:\"asset2.mp3\", id:\"works\"}\n\t *      ];\n\t *      createjs.Sound.removeSounds(sounds, assetPath);\n\t *\n\t * @method removeSounds\n\t * @param {Array} sounds An array of objects to remove. Objects are expected to be in the format needed for\n\t * {{#crossLink \"Sound/removeSound\"}}{{/crossLink}}: <code>{srcOrID:srcURIorID}</code>.\n\t * You can also pass an object with path and manifest properties, where path is a basePath and manifest is an array of objects to remove.\n\t * @param {string} basePath Set a path that will be prepended to each src when removing.\n\t * @return {Object} An array of Boolean values representing if the sounds with the same array index were\n\t * successfully removed.\n\t * @static\n\t * @since 0.4.1\n\t */\n\ts.removeSounds = function (sounds, basePath) {\n\t\tvar returnValues = [];\n\t\tif (sounds.path) {\n\t\t\tif (!basePath) {\n\t\t\t\tbasePath = sounds.path;\n\t\t\t} else {\n\t\t\t\tbasePath = basePath + sounds.path;\n\t\t\t}\n\t\t\tsounds = sounds.manifest;\n\t\t}\n\t\tfor (var i = 0, l = sounds.length; i < l; i++) {\n\t\t\treturnValues[i] = createjs.Sound.removeSound(sounds[i].src, basePath);\n\t\t}\n\t\treturn returnValues;\n\t};\n\n\t/**\n\t * Remove all sounds that have been registered with {{#crossLink \"Sound/registerSound\"}}{{/crossLink}} or\n\t * {{#crossLink \"Sound/registerSounds\"}}{{/crossLink}}.\n\t * <br />Note this will stop playback on all active sound instances before deleting them.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     createjs.Sound.removeAllSounds();\n\t *\n\t * @method removeAllSounds\n\t * @static\n\t * @since 0.4.1\n\t */\n\ts.removeAllSounds = function() {\n\t\ts._idHash = {};\n\t\ts._preloadHash = {};\n\t\tSoundChannel.removeAll();\n\t\tif (s.activePlugin) {s.activePlugin.removeAllSounds();}\n\t};\n\n\t/**\n\t * Check if a source has been loaded by internal preloaders. This is necessary to ensure that sounds that are\n\t * not completed preloading will not kick off a new internal preload if they are played.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     var mySound = \"assetPath/asset0.ogg\";\n\t *     if(createjs.Sound.loadComplete(mySound) {\n\t *         createjs.Sound.play(mySound);\n\t *     }\n\t *\n\t * @method loadComplete\n\t * @param {String} src The src or id that is being loaded.\n\t * @return {Boolean} If the src is already loaded.\n\t * @since 0.4.0\n\t * @static\n\t */\n\ts.loadComplete = function (src) {\n\t\tif (!s.isReady()) { return false; }\n\t\tvar details = s._parsePath(src);\n\t\tif (details) {\n\t\t\tsrc = s._getSrcById(details.src).src;\n\t\t} else {\n\t\t\tsrc = s._getSrcById(src).src;\n\t\t}\n\t\tif(s._preloadHash[src] == undefined) {return false;}\n\t\treturn (s._preloadHash[src][0] == true);  // src only loads once, so if it's true for the first it's true for all\n\t};\n\n\t/**\n\t * Parse the path of a sound. Alternate extensions will be attempted in order if the\n\t * current extension is not supported\n\t * @method _parsePath\n\t * @param {String} value The path to an audio source.\n\t * @return {Object} A formatted object that can be registered with the {{#crossLink \"Sound/activePlugin:property\"}}{{/crossLink}}\n\t * and returned to a preloader like <a href=\"http://preloadjs.com\" target=\"_blank\">PreloadJS</a>.\n\t * @protected\n\t * @static\n\t */\n\ts._parsePath = function (value) {\n\t\tif (typeof(value) != \"string\") {value = value.toString();}\n\n\t\tvar match = value.match(s.FILE_PATTERN);\n\t\tif (match == null) {return false;}\n\n\t\tvar name = match[4];\n\t\tvar ext = match[5];\n\t\tvar c = s.capabilities;\n\t\tvar i = 0;\n\t\twhile (!c[ext]) {\n\t\t\text = s.alternateExtensions[i++];\n\t\t\tif (i > s.alternateExtensions.length) { return null;}\t// no extensions are supported\n\t\t}\n\t\tvalue = value.replace(\".\"+match[5], \".\"+ext);\n\n\t\tvar ret = {name:name, src:value, extension:ext};\n\t\treturn ret;\n\t};\n\n\t/**\n\t * Parse the path of a sound based on properties of src matching with supported extensions.\n\t * Returns false if none of the properties are supported\n\t * @method _parseSrc\n\t * @param {Object} value The paths to an audio source, indexed by extension type.\n\t * @return {Object} A formatted object that can be registered with the {{#crossLink \"Sound/activePlugin:property\"}}{{/crossLink}}\n\t * and returned to a preloader like <a href=\"http://preloadjs.com\" target=\"_blank\">PreloadJS</a>.\n\t * @protected\n\t * @static\n\t */\n\ts._parseSrc = function (value) {\n\t\tvar ret = {name:undefined, src:undefined, extension:undefined};\n\t\tvar c = s.capabilities;\n\n\t\tfor (var prop in value) {\n\t\t  if(value.hasOwnProperty(prop) && c[prop]) {\n\t\t\t\tret.src = value[prop];\n\t\t\t\tret.extension = prop;\n\t\t\t\tbreak;\n\t\t  }\n\t\t}\n\t\tif (!ret.src) {return false;}\t// no matches\n\n\t\tvar i = ret.src.lastIndexOf(\"/\");\n\t\tif (i != -1) {\n\t\t\tret.name = ret.src.slice(i+1);\n\t\t} else {\n\t\t\tret.name = ret.src;\n\t\t}\n\n\t\treturn ret;\n\t};\n\n\t/* ---------------\n\t Static API.\n\t --------------- */\n\t/**\n\t * Play a sound and get a {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} to control. If the sound fails to play, a\n\t * AbstractSoundInstance will still be returned, and have a playState of {{#crossLink \"Sound/PLAY_FAILED:property\"}}{{/crossLink}}.\n\t * Note that even on sounds with failed playback, you may still be able to call AbstractSoundInstance {{#crossLink \"AbstractSoundInstance/play\"}}{{/crossLink}},\n\t * since the failure could be due to lack of available channels. If the src does not have a supported extension or\n\t * if there is no available plugin, a default AbstractSoundInstance will be returned which will not play any audio, but will not generate errors.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      createjs.Sound.on(\"fileload\", handleLoad);\n\t *      createjs.Sound.registerSound(\"myAudioPath/mySound.mp3\", \"myID\", 3);\n\t *      function handleLoad(event) {\n\t *      \tcreatejs.Sound.play(\"myID\");\n\t *      \t// store off AbstractSoundInstance for controlling\n\t *      \tvar myInstance = createjs.Sound.play(\"myID\", {interrupt: createjs.Sound.INTERRUPT_ANY, loop:-1});\n\t *      }\n\t *\n\t * NOTE to create an audio sprite that has not already been registered, both startTime and duration need to be set.\n\t * This is only when creating a new audio sprite, not when playing using the id of an already registered audio sprite.\n\t *\n\t * <b>Parameters Deprecated</b><br />\n\t * The parameters for this method are deprecated in favor of a single parameter that is an Object or {{#crossLink \"PlayPropsConfig\"}}{{/crossLink}}.\n\t *\n\t * @method play\n\t * @param {String} src The src or ID of the audio.\n\t * @param {String | Object} [interrupt=\"none\"|options] <b>This parameter will be renamed playProps in the next release.</b><br />\n\t * This parameter can be an instance of {{#crossLink \"PlayPropsConfig\"}}{{/crossLink}} or an Object that contains any or all optional properties by name,\n\t * including: interrupt, delay, offset, loop, volume, pan, startTime, and duration (see the above code sample).\n\t * <br /><strong>OR</strong><br />\n\t * <b>Deprecated</b> How to interrupt any currently playing instances of audio with the same source,\n\t * if the maximum number of instances of the sound are already playing. Values are defined as <code>INTERRUPT_TYPE</code>\n\t * constants on the Sound class, with the default defined by {{#crossLink \"Sound/defaultInterruptBehavior:property\"}}{{/crossLink}}.\n\t * @param {Number} [delay=0] <b>Deprecated</b> The amount of time to delay the start of audio playback, in milliseconds.\n\t * @param {Number} [offset=0] <b>Deprecated</b> The offset from the start of the audio to begin playback, in milliseconds.\n\t * @param {Number} [loop=0] <b>Deprecated</b> How many times the audio loops when it reaches the end of playback. The default is 0 (no\n\t * loops), and -1 can be used for infinite playback.\n\t * @param {Number} [volume=1] <b>Deprecated</b> The volume of the sound, between 0 and 1. Note that the master volume is applied\n\t * against the individual volume.\n\t * @param {Number} [pan=0] <b>Deprecated</b> The left-right pan of the sound (if supported), between -1 (left) and 1 (right).\n\t * @param {Number} [startTime=null] <b>Deprecated</b> To create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.\n\t * @param {Number} [duration=null] <b>Deprecated</b> To create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.\n\t * @return {AbstractSoundInstance} A {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} that can be controlled after it is created.\n\t * @static\n\t */\n\ts.play = function (src, interrupt, delay, offset, loop, volume, pan, startTime, duration) {\n\t\tvar playProps;\n\t\tif (interrupt instanceof Object || interrupt instanceof createjs.PlayPropsConfig) {\n\t\t\tplayProps = createjs.PlayPropsConfig.create(interrupt);\n\t\t} else {\n\t\t\tplayProps = createjs.PlayPropsConfig.create({interrupt:interrupt, delay:delay, offset:offset, loop:loop, volume:volume, pan:pan, startTime:startTime, duration:duration});\n\t\t}\n\t\tvar instance = s.createInstance(src, playProps.startTime, playProps.duration);\n\t\tvar ok = s._playInstance(instance, playProps);\n\t\tif (!ok) {instance._playFailed();}\n\t\treturn instance;\n\t};\n\n\t/**\n\t * Creates a {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} using the passed in src. If the src does not have a\n\t * supported extension or if there is no available plugin, a default AbstractSoundInstance will be returned that can be\n\t * called safely but does nothing.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var myInstance = null;\n\t *      createjs.Sound.on(\"fileload\", handleLoad);\n\t *      createjs.Sound.registerSound(\"myAudioPath/mySound.mp3\", \"myID\", 3);\n\t *      function handleLoad(event) {\n\t *      \tmyInstance = createjs.Sound.createInstance(\"myID\");\n\t *      \t// alternately we could call the following\n\t *      \tmyInstance = createjs.Sound.createInstance(\"myAudioPath/mySound.mp3\");\n\t *      }\n\t *\n\t * NOTE to create an audio sprite that has not already been registered, both startTime and duration need to be set.\n\t * This is only when creating a new audio sprite, not when playing using the id of an already registered audio sprite.\n\t *\n\t * @method createInstance\n\t * @param {String} src The src or ID of the audio.\n\t * @param {Number} [startTime=null] To create an audio sprite (with duration), the initial offset to start playback and loop from, in milliseconds.\n\t * @param {Number} [duration=null] To create an audio sprite (with startTime), the amount of time to play the clip for, in milliseconds.\n\t * @return {AbstractSoundInstance} A {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} that can be controlled after it is created.\n\t * Unsupported extensions will return the default AbstractSoundInstance.\n\t * @since 0.4.0\n\t * @static\n\t */\n\ts.createInstance = function (src, startTime, duration) {\n\t\tif (!s.initializeDefaultPlugins()) {return new createjs.DefaultSoundInstance(src, startTime, duration);}\n\n\t\tvar defaultPlayProps = s._defaultPlayPropsHash[src];\t// for audio sprites, which create and store defaults by id\n\t\tsrc = s._getSrcById(src);\n\n\t\tvar details = s._parsePath(src.src);\n\n\t\tvar instance = null;\n\t\tif (details != null && details.src != null) {\n\t\t\tSoundChannel.create(details.src);\n\t\t\tif (startTime == null) {startTime = src.startTime;}\n\t\t\tinstance = s.activePlugin.create(details.src, startTime, duration || src.duration);\n\n\t\t\tdefaultPlayProps = defaultPlayProps || s._defaultPlayPropsHash[details.src];\n\t\t\tif(defaultPlayProps) {\n\t\t\t\tinstance.applyPlayProps(defaultPlayProps);\n\t\t\t}\n\t\t} else {\n\t\t\tinstance = new createjs.DefaultSoundInstance(src, startTime, duration);\n\t\t}\n\n\t\tinstance.uniqueId = s._lastID++;\n\n\t\treturn instance;\n\t};\n\n\t/**\n\t * Stop all audio (global stop). Stopped audio is reset, and not paused. To play audio that has been stopped,\n\t * call AbstractSoundInstance {{#crossLink \"AbstractSoundInstance/play\"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     createjs.Sound.stop();\n\t *\n\t * @method stop\n\t * @static\n\t */\n\ts.stop = function () {\n\t\tvar instances = this._instances;\n\t\tfor (var i = instances.length; i--; ) {\n\t\t\tinstances[i].stop();  // NOTE stop removes instance from this._instances\n\t\t}\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink \"Sound/volume:property\"}}{{/crossLink}} instead.\n\t *\n\t * @method setVolume\n\t * @param {Number} value The master volume value. The acceptable range is 0-1.\n\t * @static\n\t * @deprecated\n\t */\n\ts.setVolume = function (value) {\n\t\tif (Number(value) == null) {return false;}\n\t\tvalue = Math.max(0, Math.min(1, value));\n\t\ts._masterVolume = value;\n\t\tif (!this.activePlugin || !this.activePlugin.setVolume || !this.activePlugin.setVolume(value)) {\n\t\t\tvar instances = this._instances;\n\t\t\tfor (var i = 0, l = instances.length; i < l; i++) {\n\t\t\t\tinstances[i].setMasterVolume(value);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink \"Sound/volume:property\"}}{{/crossLink}} instead.\n\t *\n\t * @method getVolume\n\t * @return {Number} The master volume, in a range of 0-1.\n\t * @static\n\t * @deprecated\n\t */\n\ts.getVolume = function () {\n\t\treturn this._masterVolume;\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink \"Sound/muted:property\"}}{{/crossLink}} instead.\n\t *\n\t * @method setMute\n\t * @param {Boolean} value Whether the audio should be muted or not.\n\t * @return {Boolean} If the mute was set.\n\t * @static\n\t * @since 0.4.0\n\t * @deprecated\n\t */\n\ts.setMute = function (value) {\n\t\tif (value == null) {return false;}\n\n\t\tthis._masterMute = value;\n\t\tif (!this.activePlugin || !this.activePlugin.setMute || !this.activePlugin.setMute(value)) {\n\t\t\tvar instances = this._instances;\n\t\t\tfor (var i = 0, l = instances.length; i < l; i++) {\n\t\t\t\tinstances[i].setMasterMute(value);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t * Deprecated, please use {{#crossLink \"Sound/muted:property\"}}{{/crossLink}} instead.\n\t *\n\t * @method getMute\n\t * @return {Boolean} The mute value of Sound.\n\t * @static\n\t * @since 0.4.0\n\t * @deprecated\n\t */\n\ts.getMute = function () {\n\t\treturn this._masterMute;\n\t};\n\n\t/**\n\t * Set the default playback properties for all new SoundInstances of the passed in src or ID.\n\t * See {{#crossLink \"PlayPropsConfig\"}}{{/crossLink}} for available properties.\n\t *\n\t * @method setDefaultPlayProps\n\t * @param {String} src The src or ID used to register the audio.\n\t * @param {Object | PlayPropsConfig} playProps The playback properties you would like to set.\n\t * @since 0.6.1\n\t */\n\ts.setDefaultPlayProps = function(src, playProps) {\n\t\tsrc = s._getSrcById(src);\n\t\ts._defaultPlayPropsHash[s._parsePath(src.src).src] = createjs.PlayPropsConfig.create(playProps);\n\t};\n\n\t/**\n\t * Get the default playback properties for the passed in src or ID.  These properties are applied to all\n\t * new SoundInstances.  Returns null if default does not exist.\n\t *\n\t * @method getDefaultPlayProps\n\t * @param {String} src The src or ID used to register the audio.\n\t * @returns {PlayPropsConfig} returns an existing PlayPropsConfig or null if one does not exist\n\t * @since 0.6.1\n\t */\n\ts.getDefaultPlayProps = function(src) {\n\t\tsrc = s._getSrcById(src);\n\t\treturn s._defaultPlayPropsHash[s._parsePath(src.src).src];\n\t};\n\n\n\t/* ---------------\n\t Internal methods\n\t --------------- */\n\t/**\n\t * Play an instance. This is called by the static API, as well as from plugins. This allows the core class to\n\t * control delays.\n\t * @method _playInstance\n\t * @param {AbstractSoundInstance} instance The {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} to start playing.\n\t * @param {PlayPropsConfig} playProps A PlayPropsConfig object.\n\t * @return {Boolean} If the sound can start playing. Sounds that fail immediately will return false. Sounds that\n\t * have a delay will return true, but may still fail to play.\n\t * @protected\n\t * @static\n\t */\n\ts._playInstance = function (instance, playProps) {\n\t\tvar defaultPlayProps = s._defaultPlayPropsHash[instance.src] || {};\n\t\tif (playProps.interrupt == null) {playProps.interrupt = defaultPlayProps.interrupt || s.defaultInterruptBehavior};\n\t\tif (playProps.delay == null) {playProps.delay = defaultPlayProps.delay || 0;}\n\t\tif (playProps.offset == null) {playProps.offset = instance.getPosition();}\n\t\tif (playProps.loop == null) {playProps.loop = instance.loop;}\n\t\tif (playProps.volume == null) {playProps.volume = instance.volume;}\n\t\tif (playProps.pan == null) {playProps.pan = instance.pan;}\n\n\t\tif (playProps.delay == 0) {\n\t\t\tvar ok = s._beginPlaying(instance, playProps);\n\t\t\tif (!ok) {return false;}\n\t\t} else {\n\t\t\t//Note that we can't pass arguments to proxy OR setTimeout (IE only), so just wrap the function call.\n\t\t\t// OJR WebAudio may want to handle this differently, so it might make sense to move this functionality into the plugins in the future\n\t\t\tvar delayTimeoutId = setTimeout(function () {\n\t\t\t\ts._beginPlaying(instance, playProps);\n\t\t\t}, playProps.delay);\n\t\t\tinstance.delayTimeoutId = delayTimeoutId;\n\t\t}\n\n\t\tthis._instances.push(instance);\n\n\t\treturn true;\n\t};\n\n\t/**\n\t * Begin playback. This is called immediately or after delay by {{#crossLink \"Sound/playInstance\"}}{{/crossLink}}.\n\t * @method _beginPlaying\n\t * @param {AbstractSoundInstance} instance A {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} to begin playback.\n\t * @param {PlayPropsConfig} playProps A PlayPropsConfig object.\n\t * @return {Boolean} If the sound can start playing. If there are no available channels, or the instance fails to\n\t * start, this will return false.\n\t * @protected\n\t * @static\n\t */\n\ts._beginPlaying = function (instance, playProps) {\n\t\tif (!SoundChannel.add(instance, playProps.interrupt)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar result = instance._beginPlaying(playProps);\n\t\tif (!result) {\n\t\t\tvar index = createjs.indexOf(this._instances, instance);\n\t\t\tif (index > -1) {this._instances.splice(index, 1);}\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t * Get the source of a sound via the ID passed in with a register call. If no ID is found the value is returned\n\t * instead.\n\t * @method _getSrcById\n\t * @param {String} value The ID the sound was registered with.\n\t * @return {String} The source of the sound if it has been registered with this ID or the value that was passed in.\n\t * @protected\n\t * @static\n\t */\n\ts._getSrcById = function (value) {\n\t\treturn s._idHash[value] || {src: value};\n\t};\n\n\t/**\n\t * A sound has completed playback, been interrupted, failed, or been stopped. This method removes the instance from\n\t * Sound management. It will be added again, if the sound re-plays. Note that this method is called from the\n\t * instances themselves.\n\t * @method _playFinished\n\t * @param {AbstractSoundInstance} instance The instance that finished playback.\n\t * @protected\n\t * @static\n\t */\n\ts._playFinished = function (instance) {\n\t\tSoundChannel.remove(instance);\n\t\tvar index = createjs.indexOf(this._instances, instance);\n\t\tif (index > -1) {this._instances.splice(index, 1);}\t// OJR this will always be > -1, there is no way for an instance to exist without being added to this._instances\n\t};\n\n\tcreatejs.Sound = Sound;\n\n\t/**\n\t * An internal class that manages the number of active {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} instances for\n\t * each sound type. This method is only used internally by the {{#crossLink \"Sound\"}}{{/crossLink}} class.\n\t *\n\t * The number of sounds is artificially limited by Sound in order to prevent over-saturation of a\n\t * single sound, as well as to stay within hardware limitations, although the latter may disappear with better\n\t * browser support.\n\t *\n\t * When a sound is played, this class ensures that there is an available instance, or interrupts an appropriate\n\t * sound that is already playing.\n\t * #class SoundChannel\n\t * @param {String} src The source of the instances\n\t * @param {Number} [max=1] The number of instances allowed\n\t * @constructor\n\t * @protected\n\t */\n\tfunction SoundChannel(src, max) {\n\t\tthis.init(src, max);\n\t}\n\n\t/* ------------\n\t Static API\n\t ------------ */\n\t/**\n\t * A hash of channel instances indexed by source.\n\t * #property channels\n\t * @type {Object}\n\t * @static\n\t */\n\tSoundChannel.channels = {};\n\n\t/**\n\t * Create a sound channel. Note that if the sound channel already exists, this will fail.\n\t * #method create\n\t * @param {String} src The source for the channel\n\t * @param {Number} max The maximum amount this channel holds. The default is {{#crossLink \"SoundChannel.maxDefault\"}}{{/crossLink}}.\n\t * @return {Boolean} If the channels were created.\n\t * @static\n\t */\n\tSoundChannel.create = function (src, max) {\n\t\tvar channel = SoundChannel.get(src);\n\t\tif (channel == null) {\n\t\t\tSoundChannel.channels[src] = new SoundChannel(src, max);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\t/**\n\t * Delete a sound channel, stop and delete all related instances. Note that if the sound channel does not exist, this will fail.\n\t * #method remove\n\t * @param {String} src The source for the channel\n\t * @return {Boolean} If the channels were deleted.\n\t * @static\n\t */\n\tSoundChannel.removeSrc = function (src) {\n\t\tvar channel = SoundChannel.get(src);\n\t\tif (channel == null) {return false;}\n\t\tchannel._removeAll();\t// this stops and removes all active instances\n\t\tdelete(SoundChannel.channels[src]);\n\t\treturn true;\n\t};\n\t/**\n\t * Delete all sound channels, stop and delete all related instances.\n\t * #method removeAll\n\t * @static\n\t */\n\tSoundChannel.removeAll = function () {\n\t\tfor(var channel in SoundChannel.channels) {\n\t\t\tSoundChannel.channels[channel]._removeAll();\t// this stops and removes all active instances\n\t\t}\n\t\tSoundChannel.channels = {};\n\t};\n\t/**\n\t * Add an instance to a sound channel.\n\t * #method add\n\t * @param {AbstractSoundInstance} instance The instance to add to the channel\n\t * @param {String} interrupt The interrupt value to use. Please see the {{#crossLink \"Sound/play\"}}{{/crossLink}}\n\t * for details on interrupt modes.\n\t * @return {Boolean} The success of the method call. If the channel is full, it will return false.\n\t * @static\n\t */\n\tSoundChannel.add = function (instance, interrupt) {\n\t\tvar channel = SoundChannel.get(instance.src);\n\t\tif (channel == null) {return false;}\n\t\treturn channel._add(instance, interrupt);\n\t};\n\t/**\n\t * Remove an instance from the channel.\n\t * #method remove\n\t * @param {AbstractSoundInstance} instance The instance to remove from the channel\n\t * @return The success of the method call. If there is no channel, it will return false.\n\t * @static\n\t */\n\tSoundChannel.remove = function (instance) {\n\t\tvar channel = SoundChannel.get(instance.src);\n\t\tif (channel == null) {return false;}\n\t\tchannel._remove(instance);\n\t\treturn true;\n\t};\n\t/**\n\t * Get the maximum number of sounds you can have in a channel.\n\t * #method maxPerChannel\n\t * @return {Number} The maximum number of sounds you can have in a channel.\n\t */\n\tSoundChannel.maxPerChannel = function () {\n\t\treturn p.maxDefault;\n\t};\n\t/**\n\t * Get a channel instance by its src.\n\t * #method get\n\t * @param {String} src The src to use to look up the channel\n\t * @static\n\t */\n\tSoundChannel.get = function (src) {\n\t\treturn SoundChannel.channels[src];\n\t};\n\n\tvar p = SoundChannel.prototype;\n\tp.constructor = SoundChannel;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n\t/**\n\t * The source of the channel.\n\t * #property src\n\t * @type {String}\n\t */\n\tp.src = null;\n\n\t/**\n\t * The maximum number of instances in this channel.  -1 indicates no limit\n\t * #property max\n\t * @type {Number}\n\t */\n\tp.max = null;\n\n\t/**\n\t * The default value to set for max, if it isn't passed in.  Also used if -1 is passed.\n\t * #property maxDefault\n\t * @type {Number}\n\t * @default 100\n\t * @since 0.4.0\n\t */\n\tp.maxDefault = 100;\n\n\t/**\n\t * The current number of active instances.\n\t * #property length\n\t * @type {Number}\n\t */\n\tp.length = 0;\n\n\t/**\n\t * Initialize the channel.\n\t * #method init\n\t * @param {String} src The source of the channel\n\t * @param {Number} max The maximum number of instances in the channel\n\t * @protected\n\t */\n\tp.init = function (src, max) {\n\t\tthis.src = src;\n\t\tthis.max = max || this.maxDefault;\n\t\tif (this.max == -1) {this.max = this.maxDefault;}\n\t\tthis._instances = [];\n\t};\n\n\t/**\n\t * Get an instance by index.\n\t * #method get\n\t * @param {Number} index The index to return.\n\t * @return {AbstractSoundInstance} The AbstractSoundInstance at a specific instance.\n\t */\n\tp._get = function (index) {\n\t\treturn this._instances[index];\n\t};\n\n\t/**\n\t * Add a new instance to the channel.\n\t * #method add\n\t * @param {AbstractSoundInstance} instance The instance to add.\n\t * @return {Boolean} The success of the method call. If the channel is full, it will return false.\n\t */\n\tp._add = function (instance, interrupt) {\n\t\tif (!this._getSlot(interrupt, instance)) {return false;}\n\t\tthis._instances.push(instance);\n\t\tthis.length++;\n\t\treturn true;\n\t};\n\n\t/**\n\t * Remove an instance from the channel, either when it has finished playing, or it has been interrupted.\n\t * #method remove\n\t * @param {AbstractSoundInstance} instance The instance to remove\n\t * @return {Boolean} The success of the remove call. If the instance is not found in this channel, it will\n\t * return false.\n\t */\n\tp._remove = function (instance) {\n\t\tvar index = createjs.indexOf(this._instances, instance);\n\t\tif (index == -1) {return false;}\n\t\tthis._instances.splice(index, 1);\n\t\tthis.length--;\n\t\treturn true;\n\t};\n\n\t/**\n\t * Stop playback and remove all instances from the channel.  Usually in response to a delete call.\n\t * #method removeAll\n\t */\n\tp._removeAll = function () {\n\t\t// Note that stop() removes the item from the list\n\t\tfor (var i=this.length-1; i>=0; i--) {\n\t\t\tthis._instances[i].stop();\n\t\t}\n\t};\n\n\t/**\n\t * Get an available slot depending on interrupt value and if slots are available.\n\t * #method getSlot\n\t * @param {String} interrupt The interrupt value to use.\n\t * @param {AbstractSoundInstance} instance The sound instance that will go in the channel if successful.\n\t * @return {Boolean} Determines if there is an available slot. Depending on the interrupt mode, if there are no slots,\n\t * an existing AbstractSoundInstance may be interrupted. If there are no slots, this method returns false.\n\t */\n\tp._getSlot = function (interrupt, instance) {\n\t\tvar target, replacement;\n\n\t\tif (interrupt != Sound.INTERRUPT_NONE) {\n\t\t\t// First replacement candidate\n\t\t\treplacement = this._get(0);\n\t\t\tif (replacement == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0, l = this.max; i < l; i++) {\n\t\t\ttarget = this._get(i);\n\n\t\t\t// Available Space\n\t\t\tif (target == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Audio is complete or not playing\n\t\t\tif (target.playState == Sound.PLAY_FINISHED ||\n\t\t\t\ttarget.playState == Sound.PLAY_INTERRUPTED ||\n\t\t\t\ttarget.playState == Sound.PLAY_FAILED) {\n\t\t\t\treplacement = target;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (interrupt == Sound.INTERRUPT_NONE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Audio is a better candidate than the current target, according to playhead\n\t\t\tif ((interrupt == Sound.INTERRUPT_EARLY && target.getPosition() < replacement.getPosition()) ||\n\t\t\t\t(interrupt == Sound.INTERRUPT_LATE && target.getPosition() > replacement.getPosition())) {\n\t\t\t\t\treplacement = target;\n\t\t\t}\n\t\t}\n\n\t\tif (replacement != null) {\n\t\t\treplacement._interrupt();\n\t\t\tthis._remove(replacement);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[Sound SoundChannel]\";\n\t};\n\t// do not add SoundChannel to namespace\n\n}());\n\n//##############################################################################\n// AbstractSoundInstance.js\n//##############################################################################\n\n/**\n * A AbstractSoundInstance is created when any calls to the Sound API method {{#crossLink \"Sound/play\"}}{{/crossLink}} or\n * {{#crossLink \"Sound/createInstance\"}}{{/crossLink}} are made. The AbstractSoundInstance is returned by the active plugin\n * for control by the user.\n *\n * <h4>Example</h4>\n *\n *      var myInstance = createjs.Sound.play(\"myAssetPath/mySrcFile.mp3\");\n *\n * A number of additional parameters provide a quick way to determine how a sound is played. Please see the Sound\n * API method {{#crossLink \"Sound/play\"}}{{/crossLink}} for a list of arguments.\n *\n * Once a AbstractSoundInstance is created, a reference can be stored that can be used to control the audio directly through\n * the AbstractSoundInstance. If the reference is not stored, the AbstractSoundInstance will play out its audio (and any loops), and\n * is then de-referenced from the {{#crossLink \"Sound\"}}{{/crossLink}} class so that it can be cleaned up. If audio\n * playback has completed, a simple call to the {{#crossLink \"AbstractSoundInstance/play\"}}{{/crossLink}} instance method\n * will rebuild the references the Sound class need to control it.\n *\n *      var myInstance = createjs.Sound.play(\"myAssetPath/mySrcFile.mp3\", {loop:2});\n *      myInstance.on(\"loop\", handleLoop);\n *      function handleLoop(event) {\n *          myInstance.volume = myInstance.volume * 0.5;\n *      }\n *\n * Events are dispatched from the instance to notify when the sound has completed, looped, or when playback fails\n *\n *      var myInstance = createjs.Sound.play(\"myAssetPath/mySrcFile.mp3\");\n *      myInstance.on(\"complete\", handleComplete);\n *      myInstance.on(\"loop\", handleLoop);\n *      myInstance.on(\"failed\", handleFailed);\n *\n *\n * @class AbstractSoundInstance\n * @param {String} src The path to and file name of the sound.\n * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\n * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\n * @param {Object} playbackResource Any resource needed by plugin to support audio playback.\n * @extends EventDispatcher\n * @constructor\n */\n\n(function () {\n\t\"use strict\";\n\n\n// Constructor:\n\tvar AbstractSoundInstance = function (src, startTime, duration, playbackResource) {\n\t\tthis.EventDispatcher_constructor();\n\n\n\t// public properties:\n\t\t/**\n\t\t * The source of the sound.\n\t\t * @property src\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.src = src;\n\n\t\t/**\n\t\t * The unique ID of the instance. This is set by {{#crossLink \"Sound\"}}{{/crossLink}}.\n\t\t * @property uniqueId\n\t\t * @type {String} | Number\n\t\t * @default -1\n\t\t */\n\t\tthis.uniqueId = -1;\n\n\t\t/**\n\t\t * The play state of the sound. Play states are defined as constants on {{#crossLink \"Sound\"}}{{/crossLink}}.\n\t\t * @property playState\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.playState = null;\n\n\t\t/**\n\t\t * A Timeout created by {{#crossLink \"Sound\"}}{{/crossLink}} when this AbstractSoundInstance is played with a delay.\n\t\t * This allows AbstractSoundInstance to remove the delay if stop, pause, or cleanup are called before playback begins.\n\t\t * @property delayTimeoutId\n\t\t * @type {timeoutVariable}\n\t\t * @default null\n\t\t * @protected\n\t\t * @since 0.4.0\n\t\t */\n\t\tthis.delayTimeoutId = null;\n\t\t// TODO consider moving delay into AbstractSoundInstance so it can be handled by plugins\n\n\n\t// private properties\n\t// Getter / Setter Properties\n\t\t// OJR TODO find original reason that we didn't use defined functions.  I think it was performance related\n\t\t/**\n\t\t * The volume of the sound, between 0 and 1.\n\t\t *\n\t\t * The actual output volume of a sound can be calculated using:\n\t\t * <code>myInstance.volume * createjs.Sound.getVolume();</code>\n\t\t *\n\t\t * @property volume\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis._volume =  1;\n\t\tObject.defineProperty(this, \"volume\", {\n\t\t\tget: this.getVolume,\n\t\t\tset: this.setVolume\n\t\t});\n\n\t\t/**\n\t\t * The pan of the sound, between -1 (left) and 1 (right). Note that pan is not supported by HTML Audio.\n\t\t *\n\t\t * <br />Note in WebAudioPlugin this only gives us the \"x\" value of what is actually 3D audio.\n\t\t *\n\t\t * @property pan\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis._pan =  0;\n\t\tObject.defineProperty(this, \"pan\", {\n\t\t\tget: this.getPan,\n\t\t\tset: this.setPan\n\t\t});\n\n\t\t/**\n\t\t * Audio sprite property used to determine the starting offset.\n\t\t * @property startTime\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @since 0.6.1\n\t\t */\n\t\tthis._startTime = Math.max(0, startTime || 0);\n\t\tObject.defineProperty(this, \"startTime\", {\n\t\t\tget: this.getStartTime,\n\t\t\tset: this.setStartTime\n\t\t});\n\n\t\t/**\n\t\t * Sets or gets the length of the audio clip, value is in milliseconds.\n\t\t *\n\t\t * @property duration\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._duration = Math.max(0, duration || 0);\n\t\tObject.defineProperty(this, \"duration\", {\n\t\t\tget: this.getDuration,\n\t\t\tset: this.setDuration\n\t\t});\n\n\t\t/**\n\t\t * Object that holds plugin specific resource need for audio playback.\n\t\t * This is set internally by the plugin.  For example, WebAudioPlugin will set an array buffer,\n\t\t * HTMLAudioPlugin will set a tag, FlashAudioPlugin will set a flash reference.\n\t\t *\n\t\t * @property playbackResource\n\t\t * @type {Object}\n\t\t * @default null\n\t\t */\n\t\tthis._playbackResource = null;\n\t\tObject.defineProperty(this, \"playbackResource\", {\n\t\t\tget: this.getPlaybackResource,\n\t\t\tset: this.setPlaybackResource\n\t\t});\n\t\tif(playbackResource !== false && playbackResource !== true) { this.setPlaybackResource(playbackResource); }\n\n\t\t/**\n\t\t * The position of the playhead in milliseconds. This can be set while a sound is playing, paused, or stopped.\n\t\t *\n\t\t * @property position\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._position = 0;\n\t\tObject.defineProperty(this, \"position\", {\n\t\t\tget: this.getPosition,\n\t\t\tset: this.setPosition\n\t\t});\n\n\t\t/**\n\t\t * The number of play loops remaining. Negative values will loop infinitely.\n\t\t *\n\t\t * @property loop\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @public\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._loop = 0;\n\t\tObject.defineProperty(this, \"loop\", {\n\t\t\tget: this.getLoop,\n\t\t\tset: this.setLoop\n\t\t});\n\n\t\t/**\n\t\t * Mutes or unmutes the current audio instance.\n\t\t *\n\t\t * @property muted\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @since 0.6.0\n\t\t */\n\t\tthis._muted = false;\n\t\tObject.defineProperty(this, \"muted\", {\n\t\t\tget: this.getMuted,\n\t\t\tset: this.setMuted\n\t\t});\n\n\t\t/**\n\t\t * Pauses or resumes the current audio instance.\n\t\t *\n\t\t * @property paused\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis._paused = false;\n\t\tObject.defineProperty(this, \"paused\", {\n\t\t\tget: this.getPaused,\n\t\t\tset: this.setPaused\n\t\t});\n\n\n\t// Events\n\t\t/**\n\t\t * The event that is fired when playback has started successfully.\n\t\t * @event succeeded\n\t\t * @param {Object} target The object that dispatched the event.\n\t\t * @param {String} type The event type.\n\t\t * @since 0.4.0\n\t\t */\n\n\t\t/**\n\t\t * The event that is fired when playback is interrupted. This happens when another sound with the same\n\t\t * src property is played using an interrupt value that causes this instance to stop playing.\n\t\t * @event interrupted\n\t\t * @param {Object} target The object that dispatched the event.\n\t\t * @param {String} type The event type.\n\t\t * @since 0.4.0\n\t\t */\n\n\t\t/**\n\t\t * The event that is fired when playback has failed. This happens when there are too many channels with the same\n\t\t * src property already playing (and the interrupt value doesn't cause an interrupt of another instance), or\n\t\t * the sound could not be played, perhaps due to a 404 error.\n\t\t * @event failed\n\t\t * @param {Object} target The object that dispatched the event.\n\t\t * @param {String} type The event type.\n\t\t * @since 0.4.0\n\t\t */\n\n\t\t/**\n\t\t * The event that is fired when a sound has completed playing but has loops remaining.\n\t\t * @event loop\n\t\t * @param {Object} target The object that dispatched the event.\n\t\t * @param {String} type The event type.\n\t\t * @since 0.4.0\n\t\t */\n\n\t\t/**\n\t\t * The event that is fired when playback completes. This means that the sound has finished playing in its\n\t\t * entirety, including its loop iterations.\n\t\t * @event complete\n\t\t * @param {Object} target The object that dispatched the event.\n\t\t * @param {String} type The event type.\n\t\t * @since 0.4.0\n\t\t */\n\t};\n\n\tvar p = createjs.extend(AbstractSoundInstance, createjs.EventDispatcher);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// Public Methods:\n\t/**\n\t * Play an instance. This method is intended to be called on SoundInstances that already exist (created\n\t * with the Sound API {{#crossLink \"Sound/createInstance\"}}{{/crossLink}} or {{#crossLink \"Sound/play\"}}{{/crossLink}}).\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      var myInstance = createjs.Sound.createInstance(mySrc);\n\t *      myInstance.play({interrupt:createjs.Sound.INTERRUPT_ANY, loop:2, pan:0.5});\n\t *\n\t * Note that if this sound is already playing, this call will still set the passed in parameters.\n\n\t * <b>Parameters Deprecated</b><br />\n\t * The parameters for this method are deprecated in favor of a single parameter that is an Object or {{#crossLink \"PlayPropsConfig\"}}{{/crossLink}}.\n\t *\n\t * @method play\n\t * @param {String | Object} [interrupt=\"none\"|options] <b>This parameter will be renamed playProps in the next release.</b><br />\n\t * This parameter can be an instance of {{#crossLink \"PlayPropsConfig\"}}{{/crossLink}} or an Object that contains any or all optional properties by name,\n\t * including: interrupt, delay, offset, loop, volume, pan, startTime, and duration (see the above code sample).\n\t * <br /><strong>OR</strong><br />\n\t * <b>Deprecated</b> How to interrupt any currently playing instances of audio with the same source,\n\t * if the maximum number of instances of the sound are already playing. Values are defined as <code>INTERRUPT_TYPE</code>\n\t * constants on the Sound class, with the default defined by {{#crossLink \"Sound/defaultInterruptBehavior:property\"}}{{/crossLink}}.\n\t * @param {Number} [delay=0] <b>Deprecated</b> The amount of time to delay the start of audio playback, in milliseconds.\n\t * @param {Number} [offset=0] <b>Deprecated</b> The offset from the start of the audio to begin playback, in milliseconds.\n\t * @param {Number} [loop=0] <b>Deprecated</b> How many times the audio loops when it reaches the end of playback. The default is 0 (no\n\t * loops), and -1 can be used for infinite playback.\n\t * @param {Number} [volume=1] <b>Deprecated</b> The volume of the sound, between 0 and 1. Note that the master volume is applied\n\t * against the individual volume.\n\t * @param {Number} [pan=0] <b>Deprecated</b> The left-right pan of the sound (if supported), between -1 (left) and 1 (right).\n\t * Note that pan is not supported for HTML Audio.\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t */\n\tp.play = function (interrupt, delay, offset, loop, volume, pan) {\n\t\tvar playProps;\n\t\tif (interrupt instanceof Object || interrupt instanceof createjs.PlayPropsConfig) {\n\t\t\tplayProps = createjs.PlayPropsConfig.create(interrupt);\n\t\t} else {\n\t\t\tplayProps = createjs.PlayPropsConfig.create({interrupt:interrupt, delay:delay, offset:offset, loop:loop, volume:volume, pan:pan});\n\t\t}\n\n\t\tif (this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis.applyPlayProps(playProps);\n\t\t\tif (this._paused) {\tthis.setPaused(false); }\n\t\t\treturn;\n\t\t}\n\t\tthis._cleanUp();\n\t\tcreatejs.Sound._playInstance(this, playProps);\t// make this an event dispatch??\n\t\treturn this;\n\t};\n\n\t/**\n\t * Stop playback of the instance. Stopped sounds will reset their position to 0, and calls to {{#crossLink \"AbstractSoundInstance/resume\"}}{{/crossLink}}\n\t * will fail. To start playback again, call {{#crossLink \"AbstractSoundInstance/play\"}}{{/crossLink}}.\n     *\n     * If you don't want to lose your position use yourSoundInstance.paused = true instead. {{#crossLink \"AbstractSoundInstance/paused\"}}{{/crossLink}}.\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     myInstance.stop();\n\t *\n\t * @method stop\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t */\n\tp.stop = function () {\n\t\tthis._position = 0;\n\t\tthis._paused = false;\n\t\tthis._handleStop();\n\t\tthis._cleanUp();\n\t\tthis.playState = createjs.Sound.PLAY_FINISHED;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Remove all external references and resources from AbstractSoundInstance.  Note this is irreversible and AbstractSoundInstance will no longer work\n\t * @method destroy\n\t * @since 0.6.0\n\t */\n\tp.destroy = function() {\n\t\tthis._cleanUp();\n\t\tthis.src = null;\n\t\tthis.playbackResource = null;\n\n\t\tthis.removeAllEventListeners();\n\t};\n\n\t/**\n\t * Takes an PlayPropsConfig or Object with the same properties and sets them on this instance.\n\t * @method applyPlayProps\n\t * @param {PlayPropsConfig | Object} playProps A PlayPropsConfig or object containing the same properties.\n\t * @since 0.6.1\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t */\n\tp.applyPlayProps = function(playProps) {\n\t\tif (playProps.offset != null) { this.setPosition(playProps.offset) }\n\t\tif (playProps.loop != null) { this.setLoop(playProps.loop); }\n\t\tif (playProps.volume != null) { this.setVolume(playProps.volume); }\n\t\tif (playProps.pan != null) { this.setPan(playProps.pan); }\n\t\tif (playProps.startTime != null) {\n\t\t\tthis.setStartTime(playProps.startTime);\n\t\t\tthis.setDuration(playProps.duration);\n\t\t}\n\t\treturn this;\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[AbstractSoundInstance]\";\n\t};\n\n// get/set methods that allow support for IE8\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/paused:property\"}}{{/crossLink}} directly as a property,\n\t *\n\t * @deprecated\n\t * @method getPaused\n\t * @returns {boolean} If the instance is currently paused\n\t * @since 0.6.0\n\t */\n\tp.getPaused = function() {\n\t\treturn this._paused;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/paused:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setPaused\n\t * @param {boolean} value\n\t * @since 0.6.0\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t */\n\tp.setPaused = function (value) {\n\t\tif ((value !== true && value !== false) || this._paused == value) {return;}\n\t\tif (value == true && this.playState != createjs.Sound.PLAY_SUCCEEDED) {return;}\n\t\tthis._paused = value;\n\t\tif(value) {\n\t\t\tthis._pause();\n\t\t} else {\n\t\t\tthis._resume();\n\t\t}\n\t\tclearTimeout(this.delayTimeoutId);\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/volume:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setVolume\n\t * @param {Number} value The volume to set, between 0 and 1.\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t */\n\tp.setVolume = function (value) {\n\t\tif (value == this._volume) { return this; }\n\t\tthis._volume = Math.max(0, Math.min(1, value));\n\t\tif (!this._muted) {\n\t\t\tthis._updateVolume();\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/volume:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getVolume\n\t * @return {Number} The current volume of the sound instance.\n\t */\n\tp.getVolume = function () {\n\t\treturn this._volume;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/muted:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setMuted\n\t * @param {Boolean} value If the sound should be muted.\n\t * @return {AbstractSoundInstance} A reference to itself, intended for chaining calls.\n\t * @since 0.6.0\n\t */\n\tp.setMuted = function (value) {\n\t\tif (value !== true && value !== false) {return;}\n\t\tthis._muted = value;\n\t\tthis._updateVolume();\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/muted:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getMuted\n\t * @return {Boolean} If the sound is muted.\n\t * @since 0.6.0\n\t */\n\tp.getMuted = function () {\n\t\treturn this._muted;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/pan:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setPan\n\t * @param {Number} value The pan value, between -1 (left) and 1 (right).\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n\t */\n\tp.setPan = function (value) {\n\t\tif(value == this._pan) { return this; }\n\t\tthis._pan = Math.max(-1, Math.min(1, value));\n\t\tthis._updatePan();\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/pan:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getPan\n\t * @return {Number} The value of the pan, between -1 (left) and 1 (right).\n\t */\n\tp.getPan = function () {\n\t\treturn this._pan;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/position:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getPosition\n\t * @return {Number} The position of the playhead in the sound, in milliseconds.\n\t */\n\tp.getPosition = function () {\n\t\tif (!this._paused && this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis._position = this._calculateCurrentPosition();\n\t\t}\n\t\treturn this._position;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/position:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setPosition\n\t * @param {Number} value The position to place the playhead, in milliseconds.\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n\t */\n\tp.setPosition = function (value) {\n\t\tthis._position = Math.max(0, value);\n\t\tif (this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis._updatePosition();\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/startTime:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getStartTime\n\t * @return {Number} The startTime of the sound instance in milliseconds.\n\t */\n\tp.getStartTime = function () {\n\t\treturn this._startTime;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/startTime:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setStartTime\n\t * @param {number} value The new startTime time in milli seconds.\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n\t */\n\tp.setStartTime = function (value) {\n\t\tif (value == this._startTime) { return this; }\n\t\tthis._startTime = Math.max(0, value || 0);\n\t\tthis._updateStartTime();\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/duration:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getDuration\n\t * @return {Number} The duration of the sound instance in milliseconds.\n\t */\n\tp.getDuration = function () {\n\t\treturn this._duration;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/duration:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setDuration\n\t * @param {number} value The new duration time in milli seconds.\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n\t * @since 0.6.0\n\t */\n\tp.setDuration = function (value) {\n\t\tif (value == this._duration) { return this; }\n\t\tthis._duration = Math.max(0, value || 0);\n\t\tthis._updateDuration();\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/playbackResource:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setPlayback\n\t * @param {Object} value The new playback resource.\n\t * @return {AbstractSoundInstance} Returns reference to itself for chaining calls\n\t * @since 0.6.0\n\t **/\n\tp.setPlaybackResource = function (value) {\n\t\tthis._playbackResource = value;\n\t\tif (this._duration == 0) { this._setDurationFromSource(); }\n\t\treturn this;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/playbackResource:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method setPlayback\n\t * @param {Object} value The new playback resource.\n\t * @return {Object} playback resource used for playing audio\n\t * @since 0.6.0\n\t **/\n\tp.getPlaybackResource = function () {\n\t\treturn this._playbackResource;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/loop:property\"}}{{/crossLink}} directly as a property\n\t *\n\t * @deprecated\n\t * @method getLoop\n\t * @return {number}\n\t * @since 0.6.0\n\t **/\n\tp.getLoop = function () {\n\t\treturn this._loop;\n\t};\n\n\t/**\n\t * DEPRECATED, please use {{#crossLink \"AbstractSoundInstance/loop:property\"}}{{/crossLink}} directly as a property,\n\t *\n\t * @deprecated\n\t * @method setLoop\n\t * @param {number} value The number of times to loop after play.\n\t * @since 0.6.0\n\t */\n\tp.setLoop = function (value) {\n\t\tif(this._playbackResource != null) {\n\t\t\t// remove looping\n\t\t\tif (this._loop != 0 && value == 0) {\n\t\t\t\tthis._removeLooping(value);\n\t\t\t}\n\t\t\t// add looping\n\t\t\telse if (this._loop == 0 && value != 0) {\n\t\t\t\tthis._addLooping(value);\n\t\t\t}\n\t\t}\n\t\tthis._loop = value;\n\t};\n\n\n// Private Methods:\n\t/**\n\t * A helper method that dispatches all events for AbstractSoundInstance.\n\t * @method _sendEvent\n\t * @param {String} type The event type\n\t * @protected\n\t */\n\tp._sendEvent = function (type) {\n\t\tvar event = new createjs.Event(type);\n\t\tthis.dispatchEvent(event);\n\t};\n\n\t/**\n\t * Clean up the instance. Remove references and clean up any additional properties such as timers.\n\t * @method _cleanUp\n\t * @protected\n\t */\n\tp._cleanUp = function () {\n\t\tclearTimeout(this.delayTimeoutId); // clear timeout that plays delayed sound\n\t\tthis._handleCleanUp();\n\t\tthis._paused = false;\n\n\t\tcreatejs.Sound._playFinished(this);\t// TODO change to an event\n\t};\n\n\t/**\n\t * The sound has been interrupted.\n\t * @method _interrupt\n\t * @protected\n\t */\n\tp._interrupt = function () {\n\t\tthis._cleanUp();\n\t\tthis.playState = createjs.Sound.PLAY_INTERRUPTED;\n\t\tthis._sendEvent(\"interrupted\");\n\t};\n\n\t/**\n\t * Called by the Sound class when the audio is ready to play (delay has completed). Starts sound playing if the\n\t * src is loaded, otherwise playback will fail.\n\t * @method _beginPlaying\n\t * @param {PlayPropsConfig} playProps A PlayPropsConfig object.\n\t * @return {Boolean} If playback succeeded.\n\t * @protected\n\t */\n\t// OJR FlashAudioSoundInstance overwrites\n\tp._beginPlaying = function (playProps) {\n\t\tthis.setPosition(playProps.offset);\n\t\tthis.setLoop(playProps.loop);\n\t\tthis.setVolume(playProps.volume);\n\t\tthis.setPan(playProps.pan);\n\t\tif (playProps.startTime != null) {\n\t\t\tthis.setStartTime(playProps.startTime);\n\t\t\tthis.setDuration(playProps.duration);\n\t\t}\n\n\t\tif (this._playbackResource != null && this._position < this._duration) {\n\t\t\tthis._paused = false;\n\t\t\tthis._handleSoundReady();\n\t\t\tthis.playState = createjs.Sound.PLAY_SUCCEEDED;\n\t\t\tthis._sendEvent(\"succeeded\");\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis._playFailed();\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Play has failed, which can happen for a variety of reasons.\n\t * Cleans up instance and dispatches failed event\n\t * @method _playFailed\n\t * @private\n\t */\n\tp._playFailed = function () {\n\t\tthis._cleanUp();\n\t\tthis.playState = createjs.Sound.PLAY_FAILED;\n\t\tthis._sendEvent(\"failed\");\n\t};\n\n\t/**\n\t * Audio has finished playing. Manually loop it if required.\n\t * @method _handleSoundComplete\n\t * @param event\n\t * @protected\n\t */\n\tp._handleSoundComplete = function (event) {\n\t\tthis._position = 0;  // have to set this as it can be set by pause during playback\n\n\t\tif (this._loop != 0) {\n\t\t\tthis._loop--;  // NOTE this introduces a theoretical limit on loops = float max size x 2 - 1\n\t\t\tthis._handleLoop();\n\t\t\tthis._sendEvent(\"loop\");\n\t\t\treturn;\n\t\t}\n\n\t\tthis._cleanUp();\n\t\tthis.playState = createjs.Sound.PLAY_FINISHED;\n\t\tthis._sendEvent(\"complete\");\n\t};\n\n// Plugin specific code\n\t/**\n\t * Handles starting playback when the sound is ready for playing.\n\t * @method _handleSoundReady\n\t * @protected\n \t */\n\tp._handleSoundReady = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function used to update the volume based on the instance volume, master volume, instance mute value,\n\t * and master mute value.\n\t * @method _updateVolume\n\t * @protected\n\t */\n\tp._updateVolume = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function used to update the pan\n\t * @method _updatePan\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._updatePan = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function used to update the startTime of the audio.\n\t * @method _updateStartTime\n\t * @protected\n\t * @since 0.6.1\n\t */\n\tp._updateStartTime = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function used to update the duration of the audio.\n\t * @method _updateDuration\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._updateDuration = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function used to get the duration of the audio from the source we'll be playing.\n\t * @method _updateDuration\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._setDurationFromSource = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function that calculates the current position of the playhead and sets this._position to that value\n\t * @method _calculateCurrentPosition\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._calculateCurrentPosition = function () {\n\t\t// plugin specific code that sets this.position\n\t};\n\n\t/**\n\t * Internal function used to update the position of the playhead.\n\t * @method _updatePosition\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._updatePosition = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when looping is removed during playback.\n\t * @method _removeLooping\n\t * @param {number} value The number of times to loop after play.\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._removeLooping = function (value) {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when looping is added during playback.\n\t * @method _addLooping\n\t * @param {number} value The number of times to loop after play.\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._addLooping = function (value) {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when pausing playback\n\t * @method _pause\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._pause = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when resuming playback\n\t * @method _resume\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._resume = function () {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when stopping playback\n\t * @method _handleStop\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._handleStop = function() {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when AbstractSoundInstance is being cleaned up\n\t * @method _handleCleanUp\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._handleCleanUp = function() {\n\t\t// plugin specific code\n\t};\n\n\t/**\n\t * Internal function called when AbstractSoundInstance has played to end and is looping\n\t * @method _handleLoop\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._handleLoop = function () {\n\t\t// plugin specific code\n\t};\n\n\tcreatejs.AbstractSoundInstance = createjs.promote(AbstractSoundInstance, \"EventDispatcher\");\n\tcreatejs.DefaultSoundInstance = createjs.AbstractSoundInstance;\t// used when no plugin is supported\n}());\n\n//##############################################################################\n// AbstractPlugin.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\n// constructor:\n \t/**\n\t * A default plugin class used as a base for all other plugins.\n\t * @class AbstractPlugin\n\t * @constructor\n\t * @since 0.6.0\n\t */\n\n\tvar AbstractPlugin = function () {\n\t// private properties:\n\t\t/**\n\t\t * The capabilities of the plugin.\n\t\t * method and is used internally.\n\t\t * @property _capabilities\n\t\t * @type {Object}\n\t\t * @default null\n\t\t * @protected\n\t\t * @static\n\t\t */\n\t\tthis._capabilities = null;\n\n\t\t/**\n\t\t * Object hash indexed by the source URI of all created loaders, used to properly destroy them if sources are removed.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._loaders = {};\n\n\t\t/**\n\t\t * Object hash indexed by the source URI of each file to indicate if an audio source has begun loading,\n\t\t * is currently loading, or has completed loading.  Can be used to store non boolean data after loading\n\t\t * is complete (for example arrayBuffers for web audio).\n\t\t * @property _audioSources\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._audioSources = {};\n\n\t\t/**\n\t\t * Object hash indexed by the source URI of all created SoundInstances, updates the playbackResource if it loads after they are created,\n\t\t * and properly destroy them if sources are removed\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._soundInstances = {};\n\n\t\t/**\n\t\t * The internal master volume value of the plugin.\n\t\t * @property _volume\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t * @protected\n\t\t */\n\t\tthis._volume = 1;\n\n\t\t/**\n\t\t * A reference to a loader class used by a plugin that must be set.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._loaderClass;\n\n\t\t/**\n\t\t * A reference to an AbstractSoundInstance class used by a plugin that must be set.\n\t\t * @type {Object}\n\t\t * @protected;\n\t\t */\n\t\tthis._soundInstanceClass;\n\t};\n\tvar p = AbstractPlugin.prototype;\n\n\t/**\n\t * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n\t * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n\t * for details.\n\t *\n\t * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n\t *\n\t * @method initialize\n\t * @protected\n\t * @deprecated\n\t */\n\t// p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n// Static Properties:\n// NOTE THESE PROPERTIES NEED TO BE ADDED TO EACH PLUGIN\n\t/**\n\t * The capabilities of the plugin. This is generated via the _generateCapabilities method and is used internally.\n\t * @property _capabilities\n\t * @type {Object}\n\t * @default null\n\t * @protected\n\t * @static\n\t */\n\tAbstractPlugin._capabilities = null;\n\n\t/**\n\t * Determine if the plugin can be used in the current browser/OS.\n\t * @method isSupported\n\t * @return {Boolean} If the plugin can be initialized.\n\t * @static\n\t */\n\tAbstractPlugin.isSupported = function () {\n\t\treturn true;\n\t};\n\n\n// public methods:\n\t/**\n\t * Pre-register a sound for preloading and setup. This is called by {{#crossLink \"Sound\"}}{{/crossLink}}.\n\t * Note all plugins provide a <code>Loader</code> instance, which <a href=\"http://preloadjs.com\" target=\"_blank\">PreloadJS</a>\n\t * can use to assist with preloading.\n\t * @method register\n\t * @param {String} loadItem An Object containing the source of the audio\n\t * Note that not every plugin will manage this value.\n\t * @return {Object} A result object, containing a \"tag\" for preloading purposes.\n\t */\n\tp.register = function (loadItem) {\n\t\tvar loader = this._loaders[loadItem.src];\n\t\tif(loader && !loader.canceled) {return this._loaders[loadItem.src];}\t// already loading/loaded this, so don't load twice\n\t\t// OJR potential issue that we won't be firing loaded event, might need to trigger if this is already loaded?\n\t\tthis._audioSources[loadItem.src] = true;\n\t\tthis._soundInstances[loadItem.src] = [];\n\t\tloader = new this._loaderClass(loadItem);\n\t\tloader.on(\"complete\", this._handlePreloadComplete, this);\n\t\tthis._loaders[loadItem.src] = loader;\n\t\treturn loader;\n\t};\n\n\t// note sound calls register before calling preload\n\t/**\n\t * Internally preload a sound.\n\t * @method preload\n\t * @param {Loader} loader The sound URI to load.\n\t */\n\tp.preload = function (loader) {\n\t\tloader.on(\"error\", this._handlePreloadError, this);\n\t\tloader.load();\n\t};\n\n\t/**\n\t * Checks if preloading has started for a specific source. If the source is found, we can assume it is loading,\n\t * or has already finished loading.\n\t * @method isPreloadStarted\n\t * @param {String} src The sound URI to check.\n\t * @return {Boolean}\n\t */\n\tp.isPreloadStarted = function (src) {\n\t\treturn (this._audioSources[src] != null);\n\t};\n\n\t/**\n\t * Checks if preloading has finished for a specific source.\n\t * @method isPreloadComplete\n\t * @param {String} src The sound URI to load.\n\t * @return {Boolean}\n\t */\n\tp.isPreloadComplete = function (src) {\n\t\treturn (!(this._audioSources[src] == null || this._audioSources[src] == true));\n\t};\n\n\t/**\n\t * Remove a sound added using {{#crossLink \"WebAudioPlugin/register\"}}{{/crossLink}}. Note this does not cancel a preload.\n\t * @method removeSound\n\t * @param {String} src The sound URI to unload.\n\t */\n\tp.removeSound = function (src) {\n\t\tif (!this._soundInstances[src]) { return; }\n\t\tfor (var i = this._soundInstances[src].length; i--; ) {\n\t\t\tvar item = this._soundInstances[src][i];\n\t\t\titem.destroy();\n\t\t}\n\t\tdelete(this._soundInstances[src]);\n\t\tdelete(this._audioSources[src]);\n\t\tif(this._loaders[src]) { this._loaders[src].destroy(); }\n\t\tdelete(this._loaders[src]);\n\t};\n\n\t/**\n\t * Remove all sounds added using {{#crossLink \"WebAudioPlugin/register\"}}{{/crossLink}}. Note this does not cancel a preload.\n\t * @method removeAllSounds\n\t * @param {String} src The sound URI to unload.\n\t */\n\tp.removeAllSounds = function () {\n\t\tfor(var key in this._audioSources) {\n\t\t\tthis.removeSound(key);\n\t\t}\n\t};\n\n\t/**\n\t * Create a sound instance. If the sound has not been preloaded, it is internally preloaded here.\n\t * @method create\n\t * @param {String} src The sound source to use.\n\t * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\n\t * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\n\t * @return {AbstractSoundInstance} A sound instance for playback and control.\n\t */\n\tp.create = function (src, startTime, duration) {\n\t\tif (!this.isPreloadStarted(src)) {\n\t\t\tthis.preload(this.register(src));\n\t\t}\n\t\tvar si = new this._soundInstanceClass(src, startTime, duration, this._audioSources[src]);\n\t\tthis._soundInstances[src].push(si);\n\t\treturn si;\n\t};\n\n\t// if a plugin does not support volume and mute, it should set these to null\n\t/**\n\t * Set the master volume of the plugin, which affects all SoundInstances.\n\t * @method setVolume\n\t * @param {Number} value The volume to set, between 0 and 1.\n\t * @return {Boolean} If the plugin processes the setVolume call (true). The Sound class will affect all the\n\t * instances manually otherwise.\n\t */\n\tp.setVolume = function (value) {\n\t\tthis._volume = value;\n\t\tthis._updateVolume();\n\t\treturn true;\n\t};\n\n\t/**\n\t * Get the master volume of the plugin, which affects all SoundInstances.\n\t * @method getVolume\n\t * @return {Number} The volume level, between 0 and 1.\n\t */\n\tp.getVolume = function () {\n\t\treturn this._volume;\n\t};\n\n\t/**\n\t * Mute all sounds via the plugin.\n\t * @method setMute\n\t * @param {Boolean} value If all sound should be muted or not. Note that plugin-level muting just looks up\n\t * the mute value of Sound {{#crossLink \"Sound/getMute\"}}{{/crossLink}}, so this property is not used here.\n\t * @return {Boolean} If the mute call succeeds.\n\t */\n\tp.setMute = function (value) {\n\t\tthis._updateVolume();\n\t\treturn true;\n\t};\n\n\t// plugins should overwrite this method\n\tp.toString = function () {\n\t\treturn \"[AbstractPlugin]\";\n\t};\n\n\n// private methods:\n\t/**\n\t * Handles internal preload completion.\n\t * @method _handlePreloadComplete\n\t * @protected\n\t */\n\tp._handlePreloadComplete = function (event) {\n\t\tvar src = event.target.getItem().src;\n\t\tthis._audioSources[src] = event.result;\n\t\tfor (var i = 0, l = this._soundInstances[src].length; i < l; i++) {\n\t\t\tvar item = this._soundInstances[src][i];\n\t\t\titem.setPlaybackResource(this._audioSources[src]);\n\t\t\t// ToDo consider adding play call here if playstate == playfailed\n\t\t}\n\t};\n\n\t/**\n\t * Handles internal preload erros\n\t * @method _handlePreloadError\n\t * @param event\n\t * @protected\n\t */\n\tp._handlePreloadError = function(event) {\n\t\t//delete(this._audioSources[src]);\n\t};\n\n\t/**\n\t * Set the gain value for master audio. Should not be called externally.\n\t * @method _updateVolume\n\t * @protected\n\t */\n\tp._updateVolume = function () {\n\t\t// Plugin Specific code\n\t};\n\n\tcreatejs.AbstractPlugin = AbstractPlugin;\n}());\n\n//##############################################################################\n// WebAudioLoader.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * Loader provides a mechanism to preload Web Audio content via PreloadJS or internally. Instances are returned to\n\t * the preloader, and the load method is called when the asset needs to be requested.\n\t *\n\t * @class WebAudioLoader\n\t * @param {String} loadItem The item to be loaded\n\t * @extends XHRRequest\n\t * @protected\n\t */\n\tfunction Loader(loadItem) {\n\t\tthis.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.SOUND);\n\n\t};\n\tvar p = createjs.extend(Loader, createjs.AbstractLoader);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n\t/**\n\t * web audio context required for decoding audio\n\t * @property context\n\t * @type {AudioContext}\n\t * @static\n\t */\n\tLoader.context = null;\n\n\n// public methods\n\tp.toString = function () {\n\t\treturn \"[WebAudioLoader]\";\n\t};\n\n\n// private methods\n\tp._createRequest = function() {\n\t\tthis._request = new createjs.XHRRequest(this._item, false);\n\t\tthis._request.setResponseType(\"arraybuffer\");\n\t};\n\n\tp._sendComplete = function (event) {\n\t\t// OJR we leave this wrapped in Loader because we need to reference src and the handler only receives a single argument, the decodedAudio\n\t\tLoader.context.decodeAudioData(this._rawResult,\n\t         createjs.proxy(this._handleAudioDecoded, this),\n\t         createjs.proxy(this._sendError, this));\n\t};\n\n\n\t/**\n\t* The audio has been decoded.\n\t* @method handleAudioDecoded\n\t* @param decoded\n\t* @protected\n\t*/\n\tp._handleAudioDecoded = function (decodedAudio) {\n\t\tthis._result = decodedAudio;\n\t\tthis.AbstractLoader__sendComplete();\n\t};\n\n\tcreatejs.WebAudioLoader = createjs.promote(Loader, \"AbstractLoader\");\n}());\n\n//##############################################################################\n// WebAudioSoundInstance.js\n//##############################################################################\n\n/**\n * WebAudioSoundInstance extends the base api of {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} and is used by\n * {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}}.\n *\n * WebAudioSoundInstance exposes audioNodes for advanced users.\n *\n * @param {String} src The path to and file name of the sound.\n * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\n * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\n * @param {Object} playbackResource Any resource needed by plugin to support audio playback.\n * @class WebAudioSoundInstance\n * @extends AbstractSoundInstance\n * @constructor\n */\n(function () {\n\t\"use strict\";\n\n\tfunction WebAudioSoundInstance(src, startTime, duration, playbackResource) {\n\t\tthis.AbstractSoundInstance_constructor(src, startTime, duration, playbackResource);\n\n\n// public properties\n\t\t/**\n\t\t * NOTE this is only intended for use by advanced users.\n\t\t * <br />GainNode for controlling <code>WebAudioSoundInstance</code> volume. Connected to the {{#crossLink \"WebAudioSoundInstance/destinationNode:property\"}}{{/crossLink}}.\n\t\t * @property gainNode\n\t\t * @type {AudioGainNode}\n\t\t * @since 0.4.0\n\t\t *\n\t\t */\n\t\tthis.gainNode = s.context.createGain();\n\n\t\t/**\n\t\t * NOTE this is only intended for use by advanced users.\n\t\t * <br />A panNode allowing left and right audio channel panning only. Connected to WebAudioSoundInstance {{#crossLink \"WebAudioSoundInstance/gainNode:property\"}}{{/crossLink}}.\n\t\t * @property panNode\n\t\t * @type {AudioPannerNode}\n\t\t * @since 0.4.0\n\t\t */\n\t\tthis.panNode = s.context.createPanner();\n\t\tthis.panNode.panningModel = s._panningModel;\n\t\tthis.panNode.connect(this.gainNode);\n\t\tthis._updatePan();\n\n\t\t/**\n\t\t * NOTE this is only intended for use by advanced users.\n\t\t * <br />sourceNode is the audio source. Connected to WebAudioSoundInstance {{#crossLink \"WebAudioSoundInstance/panNode:property\"}}{{/crossLink}}.\n\t\t * @property sourceNode\n\t\t * @type {AudioNode}\n\t\t * @since 0.4.0\n\t\t *\n\t\t */\n\t\tthis.sourceNode = null;\n\n\n// private properties\n\t\t/**\n\t\t * Timeout that is created internally to handle sound playing to completion.\n\t\t * Stored so we can remove it when stop, pause, or cleanup are called\n\t\t * @property _soundCompleteTimeout\n\t\t * @type {timeoutVariable}\n\t\t * @default null\n\t\t * @protected\n\t\t * @since 0.4.0\n\t\t */\n\t\tthis._soundCompleteTimeout = null;\n\n\t\t/**\n\t\t * NOTE this is only intended for use by very advanced users.\n\t\t * _sourceNodeNext is the audio source for the next loop, inserted in a look ahead approach to allow for smooth\n\t\t * looping. Connected to {{#crossLink \"WebAudioSoundInstance/gainNode:property\"}}{{/crossLink}}.\n\t\t * @property _sourceNodeNext\n\t\t * @type {AudioNode}\n\t\t * @default null\n\t\t * @protected\n\t\t * @since 0.4.1\n\t\t *\n\t\t */\n\t\tthis._sourceNodeNext = null;\n\n\t\t/**\n\t\t * Time audio started playback, in seconds. Used to handle set position, get position, and resuming from paused.\n\t\t * @property _playbackStartTime\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @protected\n\t\t * @since 0.4.0\n\t\t */\n\t\tthis._playbackStartTime = 0;\n\n\t\t// Proxies, make removing listeners easier.\n\t\tthis._endedHandler = createjs.proxy(this._handleSoundComplete, this);\n\t};\n\tvar p = createjs.extend(WebAudioSoundInstance, createjs.AbstractSoundInstance);\n\tvar s = WebAudioSoundInstance;\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n\t/**\n\t * Note this is only intended for use by advanced users.\n\t * <br />Audio context used to create nodes.  This is and needs to be the same context used by {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}}.\n  \t * @property context\n\t * @type {AudioContext}\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.context = null;\n\n\t/**\n\t * Note this is only intended for use by advanced users.\n\t * <br />The scratch buffer that will be assigned to the buffer property of a source node on close.  \n\t * This is and should be the same scratch buffer referenced by {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}}.\n  \t * @property _scratchBuffer\n\t * @type {AudioBufferSourceNode}\n\t * @static\n\t */\n\ts._scratchBuffer = null;\n\n\t/**\n\t * Note this is only intended for use by advanced users.\n\t * <br /> Audio node from WebAudioPlugin that sequences to <code>context.destination</code>\n\t * @property destinationNode\n\t * @type {AudioNode}\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts.destinationNode = null;\n\n\t/**\n\t * Value to set panning model to equal power for WebAudioSoundInstance.  Can be \"equalpower\" or 0 depending on browser implementation.\n\t * @property _panningModel\n\t * @type {Number / String}\n\t * @protected\n\t * @static\n\t * @since 0.6.0\n\t */\n\ts._panningModel = \"equalpower\";\n\n\n// Public methods\n\tp.destroy = function() {\n\t\tthis.AbstractSoundInstance_destroy();\n\n\t\tthis.panNode.disconnect(0);\n\t\tthis.panNode = null;\n\t\tthis.gainNode.disconnect(0);\n\t\tthis.gainNode = null;\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[WebAudioSoundInstance]\";\n\t};\n\n\n// Private Methods\n\tp._updatePan = function() {\n\t\tthis.panNode.setPosition(this._pan, 0, -0.5);\n\t\t// z need to be -0.5 otherwise the sound only plays in left, right, or center\n\t};\n\n\tp._removeLooping = function(value) {\n\t\tthis._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\n\t};\n\n\tp._addLooping = function(value) {\n\t\tif (this.playState != createjs.Sound.PLAY_SUCCEEDED) { return; }\n\t\tthis._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0);\n\t};\n\n\tp._setDurationFromSource = function () {\n\t\tthis._duration = this.playbackResource.duration * 1000;\n\t};\n\n\tp._handleCleanUp = function () {\n\t\tif (this.sourceNode && this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis.sourceNode = this._cleanUpAudioNode(this.sourceNode);\n\t\t\tthis._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\n\t\t}\n\n\t\tif (this.gainNode.numberOfOutputs != 0) {this.gainNode.disconnect(0);}\n\t\t// OJR there appears to be a bug that this doesn't always work in webkit (Chrome and Safari). According to the documentation, this should work.\n\n\t\tclearTimeout(this._soundCompleteTimeout);\n\n\t\tthis._playbackStartTime = 0;\t// This is used by getPosition\n\t};\n\n\t/**\n\t * Turn off and disconnect an audioNode, then set reference to null to release it for garbage collection\n\t * @method _cleanUpAudioNode\n\t * @param audioNode\n\t * @return {audioNode}\n\t * @protected\n\t * @since 0.4.1\n\t */\n\tp._cleanUpAudioNode = function(audioNode) {\n\t\tif(audioNode) {\n\t\t\taudioNode.stop(0);\n\t\t\taudioNode.disconnect(0);\n\t\t\t// necessary to prevent leak on iOS Safari 7-9. will throw in almost all other\n\t\t\t// browser implementations.\n\t\t\ttry { audioNode.buffer = s._scratchBuffer; } catch(e) {}\n\t\t\taudioNode = null;\n\t\t}\n\t\treturn audioNode;\n\t};\n\n\tp._handleSoundReady = function (event) {\n\t\tthis.gainNode.connect(s.destinationNode);  // this line can cause a memory leak.  Nodes need to be disconnected from the audioDestination or any sequence that leads to it.\n\n\t\tvar dur = this._duration * 0.001;\n\t\tvar pos = this._position * 0.001;\n\t\tif (pos > dur) {pos = dur;}\n\t\tthis.sourceNode = this._createAndPlayAudioNode((s.context.currentTime - dur), pos);\n\t\tthis._playbackStartTime = this.sourceNode.startTime - pos;\n\n\t\tthis._soundCompleteTimeout = setTimeout(this._endedHandler, (dur - pos) * 1000);\n\n\t\tif(this._loop != 0) {\n\t\t\tthis._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0);\n\t\t}\n\t};\n\n\t/**\n\t * Creates an audio node using the current src and context, connects it to the gain node, and starts playback.\n\t * @method _createAndPlayAudioNode\n\t * @param {Number} startTime The time to add this to the web audio context, in seconds.\n\t * @param {Number} offset The amount of time into the src audio to start playback, in seconds.\n\t * @return {audioNode}\n\t * @protected\n\t * @since 0.4.1\n\t */\n\tp._createAndPlayAudioNode = function(startTime, offset) {\n\t\tvar audioNode = s.context.createBufferSource();\n\t\taudioNode.buffer = this.playbackResource;\n\t\taudioNode.connect(this.panNode);\n\t\tvar dur = this._duration * 0.001;\n\t\taudioNode.startTime = startTime + dur;\n\t\taudioNode.start(audioNode.startTime, offset+(this._startTime*0.001), dur - offset);\n\t\treturn audioNode;\n\t};\n\n\tp._pause = function () {\n\t\tthis._position = (s.context.currentTime - this._playbackStartTime) * 1000;  // * 1000 to give milliseconds, lets us restart at same point\n\t\tthis.sourceNode = this._cleanUpAudioNode(this.sourceNode);\n\t\tthis._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\n\n\t\tif (this.gainNode.numberOfOutputs != 0) {this.gainNode.disconnect(0);}\n\n\t\tclearTimeout(this._soundCompleteTimeout);\n\t};\n\n\tp._resume = function () {\n\t\tthis._handleSoundReady();\n\t};\n\n\t/*\n\tp._handleStop = function () {\n\t\t// web audio does not need to do anything extra\n\t};\n\t*/\n\n\tp._updateVolume = function () {\n\t\tvar newVolume = this._muted ? 0 : this._volume;\n\t  \tif (newVolume != this.gainNode.gain.value) {\n\t\t  this.gainNode.gain.value = newVolume;\n  \t\t}\n\t};\n\n\tp._calculateCurrentPosition = function () {\n\t\treturn ((s.context.currentTime - this._playbackStartTime) * 1000); // pos in seconds * 1000 to give milliseconds\n\t};\n\n\tp._updatePosition = function () {\n\t\tthis.sourceNode = this._cleanUpAudioNode(this.sourceNode);\n\t\tthis._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext);\n\t\tclearTimeout(this._soundCompleteTimeout);\n\n\t\tif (!this._paused) {this._handleSoundReady();}\n\t};\n\n\t// OJR we are using a look ahead approach to ensure smooth looping.\n\t// We add _sourceNodeNext to the audio context so that it starts playing even if this callback is delayed.\n\t// This technique is described here:  http://www.html5rocks.com/en/tutorials/audio/scheduling/\n\t// NOTE the cost of this is that our audio loop may not always match the loop event timing precisely.\n\tp._handleLoop = function () {\n\t\tthis._cleanUpAudioNode(this.sourceNode);\n\t\tthis.sourceNode = this._sourceNodeNext;\n\t\tthis._playbackStartTime = this.sourceNode.startTime;\n\t\tthis._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0);\n\t\tthis._soundCompleteTimeout = setTimeout(this._endedHandler, this._duration);\n\t};\n\n\tp._updateDuration = function () {\n\t\tif(this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis._pause();\n\t\t\tthis._resume();\n\t\t}\n\t};\n\n\tcreatejs.WebAudioSoundInstance = createjs.promote(WebAudioSoundInstance, \"AbstractSoundInstance\");\n}());\n\n//##############################################################################\n// WebAudioPlugin.js\n//##############################################################################\n\n(function () {\n\n\t\"use strict\";\n\n\t/**\n\t * Play sounds using Web Audio in the browser. The WebAudioPlugin is currently the default plugin, and will be used\n\t * anywhere that it is supported. To change plugin priority, check out the Sound API\n\t * {{#crossLink \"Sound/registerPlugins\"}}{{/crossLink}} method.\n\n\t * <h4>Known Browser and OS issues for Web Audio</h4>\n\t * <b>Firefox 25</b>\n\t * <li>\n\t *     mp3 audio files do not load properly on all windows machines, reported <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=929969\" target=\"_blank\">here</a>.\n\t *     <br />For this reason it is recommended to pass another FireFox-supported type (i.e. ogg) as the default\n\t *     extension, until this bug is resolved\n\t * </li>\n\t *\n\t * <b>Webkit (Chrome and Safari)</b>\n\t * <li>\n\t *     AudioNode.disconnect does not always seem to work.  This can cause the file size to grow over time if you\n\t * \t   are playing a lot of audio files.\n\t * </li>\n\t *\n\t * <b>iOS 6 limitations</b>\n\t * <ul>\n\t *     <li>\n\t *         Sound is initially muted and will only unmute through play being called inside a user initiated event\n\t *         (touch/click). Please read the mobile playback notes in the the {{#crossLink \"Sound\"}}{{/crossLink}}\n\t *         class for a full overview of the limitations, and how to get around them.\n\t *     </li>\n\t *\t   <li>\n\t *\t       A bug exists that will distort un-cached audio when a video element is present in the DOM. You can avoid\n\t *\t       this bug by ensuring the audio and video audio share the same sample rate.\n\t *\t   </li>\n\t * </ul>\n\t * @class WebAudioPlugin\n\t * @extends AbstractPlugin\n\t * @constructor\n\t * @since 0.4.0\n\t */\n\tfunction WebAudioPlugin() {\n\t\tthis.AbstractPlugin_constructor();\n\n\n// Private Properties\n\t\t/**\n\t\t * Value to set panning model to equal power for WebAudioSoundInstance.  Can be \"equalpower\" or 0 depending on browser implementation.\n\t\t * @property _panningModel\n\t\t * @type {Number / String}\n\t\t * @protected\n\t\t */\n\t\tthis._panningModel = s._panningModel;;\n\n\t\t/**\n\t\t * The web audio context, which WebAudio uses to play audio. All nodes that interact with the WebAudioPlugin\n\t\t * need to be created within this context.\n\t\t * @property context\n\t\t * @type {AudioContext}\n\t\t */\n\t\tthis.context = s.context;\n\n\t\t/**\n\t\t * A DynamicsCompressorNode, which is used to improve sound quality and prevent audio distortion.\n\t\t * It is connected to <code>context.destination</code>.\n\t\t *\n\t\t * Can be accessed by advanced users through createjs.Sound.activePlugin.dynamicsCompressorNode.\n\t\t * @property dynamicsCompressorNode\n\t\t * @type {AudioNode}\n\t\t */\n\t\tthis.dynamicsCompressorNode = this.context.createDynamicsCompressor();\n\t\tthis.dynamicsCompressorNode.connect(this.context.destination);\n\n\t\t/**\n\t\t * A GainNode for controlling master volume. It is connected to {{#crossLink \"WebAudioPlugin/dynamicsCompressorNode:property\"}}{{/crossLink}}.\n\t\t *\n\t\t * Can be accessed by advanced users through createjs.Sound.activePlugin.gainNode.\n\t\t * @property gainNode\n\t\t * @type {AudioGainNode}\n\t\t */\n\t\tthis.gainNode = this.context.createGain();\n\t\tthis.gainNode.connect(this.dynamicsCompressorNode);\n\t\tcreatejs.WebAudioSoundInstance.destinationNode = this.gainNode;\n\n\t\tthis._capabilities = s._capabilities;\n\n\t\tthis._loaderClass = createjs.WebAudioLoader;\n\t\tthis._soundInstanceClass = createjs.WebAudioSoundInstance;\n\n\t\tthis._addPropsToClasses();\n\t}\n\tvar p = createjs.extend(WebAudioPlugin, createjs.AbstractPlugin);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// Static Properties\n\tvar s = WebAudioPlugin;\n\t/**\n\t * The capabilities of the plugin. This is generated via the {{#crossLink \"WebAudioPlugin/_generateCapabilities:method\"}}{{/crossLink}}\n\t * method and is used internally.\n\t * @property _capabilities\n\t * @type {Object}\n\t * @default null\n\t * @protected\n\t * @static\n\t */\n\ts._capabilities = null;\n\n\t/**\n\t * Value to set panning model to equal power for WebAudioSoundInstance.  Can be \"equalpower\" or 0 depending on browser implementation.\n\t * @property _panningModel\n\t * @type {Number / String}\n\t * @protected\n\t * @static\n\t */\n\ts._panningModel = \"equalpower\";\n\n\t/**\n\t * The web audio context, which WebAudio uses to play audio. All nodes that interact with the WebAudioPlugin\n\t * need to be created within this context.\n\t *\n\t * Advanced users can set this to an existing context, but <b>must</b> do so before they call\n\t * {{#crossLink \"Sound/registerPlugins\"}}{{/crossLink}} or {{#crossLink \"Sound/initializeDefaultPlugins\"}}{{/crossLink}}.\n\t *\n\t * @property context\n\t * @type {AudioContext}\n\t * @static\n\t */\n\ts.context = null;\n\n\t/**\n\t * The scratch buffer that will be assigned to the buffer property of a source node on close.\n\t * Works around an iOS Safari bug: https://github.com/CreateJS/SoundJS/issues/102\n\t *\n\t * Advanced users can set this to an existing source node, but <b>must</b> do so before they call\n\t * {{#crossLink \"Sound/registerPlugins\"}}{{/crossLink}} or {{#crossLink \"Sound/initializeDefaultPlugins\"}}{{/crossLink}}.\n\t *\n\t * @property _scratchBuffer\n\t * @type {AudioBuffer}\n\t * @protected\n\t * @static\n\t */\n\t s._scratchBuffer = null;\n\n\t/**\n\t * Indicated whether audio on iOS has been unlocked, which requires a touchend/mousedown event that plays an\n\t * empty sound.\n\t * @property _unlocked\n\t * @type {boolean}\n\t * @since 0.6.2\n\t * @private\n\t */\n\ts._unlocked = false;\n\n\n// Static Public Methods\n\t/**\n\t * Determine if the plugin can be used in the current browser/OS.\n\t * @method isSupported\n\t * @return {Boolean} If the plugin can be initialized.\n\t * @static\n\t */\n\ts.isSupported = function () {\n\t\t// check if this is some kind of mobile device, Web Audio works with local protocol under PhoneGap and it is unlikely someone is trying to run a local file\n\t\tvar isMobilePhoneGap = createjs.BrowserDetect.isIOS || createjs.BrowserDetect.isAndroid || createjs.BrowserDetect.isBlackberry;\n\t\t// OJR isMobile may be redundant with _isFileXHRSupported available.  Consider removing.\n\t\tif (location.protocol == \"file:\" && !isMobilePhoneGap && !this._isFileXHRSupported()) { return false; }  // Web Audio requires XHR, which is not usually available locally\n\t\ts._generateCapabilities();\n\t\tif (s.context == null) {return false;}\n\t\treturn true;\n\t};\n\n\t/**\n\t * Plays an empty sound in the web audio context.  This is used to enable web audio on iOS devices, as they\n\t * require the first sound to be played inside of a user initiated event (touch/click).  This is called when\n\t * {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}} is initialized (by Sound {{#crossLink \"Sound/initializeDefaultPlugins\"}}{{/crossLink}}\n\t * for example).\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *     function handleTouch(event) {\n\t *         createjs.WebAudioPlugin.playEmptySound();\n\t *     }\n\t *\n\t * @method playEmptySound\n\t * @static\n\t * @since 0.4.1\n\t */\n\ts.playEmptySound = function() {\n\t\tif (s.context == null) {return;}\n\t\tvar source = s.context.createBufferSource();\n\t\tsource.buffer = s._scratchBuffer;\n\t\tsource.connect(s.context.destination);\n\t\tsource.start(0, 0, 0);\n\t};\n\n\n// Static Private Methods\n\t/**\n\t * Determine if XHR is supported, which is necessary for web audio.\n\t * @method _isFileXHRSupported\n\t * @return {Boolean} If XHR is supported.\n\t * @since 0.4.2\n\t * @protected\n\t * @static\n\t */\n\ts._isFileXHRSupported = function() {\n\t\t// it's much easier to detect when something goes wrong, so let's start optimistically\n\t\tvar supported = true;\n\n\t\tvar xhr = new XMLHttpRequest();\n\t\ttry {\n\t\t\txhr.open(\"GET\", \"WebAudioPluginTest.fail\", false); // loading non-existant file triggers 404 only if it could load (synchronous call)\n\t\t} catch (error) {\n\t\t\t// catch errors in cases where the onerror is passed by\n\t\t\tsupported = false;\n\t\t\treturn supported;\n\t\t}\n\t\txhr.onerror = function() { supported = false; }; // cause irrelevant\n\t\t// with security turned off, we can get empty success results, which is actually a failed read (status code 0?)\n\t\txhr.onload = function() { supported = this.status == 404 || (this.status == 200 || (this.status == 0 && this.response != \"\")); };\n\t\ttry {\n\t\t\txhr.send();\n\t\t} catch (error) {\n\t\t\t// catch errors in cases where the onerror is passed by\n\t\t\tsupported = false;\n\t\t}\n\n\t\treturn supported;\n\t};\n\n\t/**\n\t * Determine the capabilities of the plugin. Used internally. Please see the Sound API {{#crossLink \"Sound/getCapabilities\"}}{{/crossLink}}\n\t * method for an overview of plugin capabilities.\n\t * @method _generateCapabilities\n\t * @static\n\t * @protected\n\t */\n\ts._generateCapabilities = function () {\n\t\tif (s._capabilities != null) {return;}\n\t\t// Web Audio can be in any formats supported by the audio element, from http://www.w3.org/TR/webaudio/#AudioContext-section\n\t\tvar t = document.createElement(\"audio\");\n\t\tif (t.canPlayType == null) {return null;}\n\n\t\tif (s.context == null) {\n\t\t\tif (window.AudioContext) {\n\t\t\t\ts.context = new AudioContext();\n\t\t\t} else if (window.webkitAudioContext) {\n\t\t\t\ts.context = new webkitAudioContext();\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tif (s._scratchBuffer == null) {\n\t\t\ts._scratchBuffer = s.context.createBuffer(1, 1, 22050);\n\t\t}\n\n\t\ts._compatibilitySetUp();\n\n\t\t// Listen for document level clicks to unlock WebAudio on iOS. See the _unlock method.\n\t\tif (\"ontouchstart\" in window && s.context.state != \"running\") {\n\t\t\ts._unlock(); // When played inside of a touch event, this will enable audio on iOS immediately.\n\t\t\tdocument.addEventListener(\"mousedown\", s._unlock, true);\n\t\t\tdocument.addEventListener(\"touchend\", s._unlock, true);\n\t\t}\n\n\n\t\ts._capabilities = {\n\t\t\tpanning:true,\n\t\t\tvolume:true,\n\t\t\ttracks:-1\n\t\t};\n\n\t\t// determine which extensions our browser supports for this plugin by iterating through Sound.SUPPORTED_EXTENSIONS\n\t\tvar supportedExtensions = createjs.Sound.SUPPORTED_EXTENSIONS;\n\t\tvar extensionMap = createjs.Sound.EXTENSION_MAP;\n\t\tfor (var i = 0, l = supportedExtensions.length; i < l; i++) {\n\t\t\tvar ext = supportedExtensions[i];\n\t\t\tvar playType = extensionMap[ext] || ext;\n\t\t\ts._capabilities[ext] = (t.canPlayType(\"audio/\" + ext) != \"no\" && t.canPlayType(\"audio/\" + ext) != \"\") || (t.canPlayType(\"audio/\" + playType) != \"no\" && t.canPlayType(\"audio/\" + playType) != \"\");\n\t\t}  // OJR another way to do this might be canPlayType:\"m4a\", codex: mp4\n\n\t\t// 0=no output, 1=mono, 2=stereo, 4=surround, 6=5.1 surround.\n\t\t// See http://www.w3.org/TR/webaudio/#AudioChannelSplitter for more details on channels.\n\t\tif (s.context.destination.numberOfChannels < 2) {\n\t\t\ts._capabilities.panning = false;\n\t\t}\n\t};\n\n\t/**\n\t * Set up compatibility if only deprecated web audio calls are supported.\n\t * See http://www.w3.org/TR/webaudio/#DeprecationNotes\n\t * Needed so we can support new browsers that don't support deprecated calls (Firefox) as well as old browsers that\n\t * don't support new calls.\n\t *\n\t * @method _compatibilitySetUp\n\t * @static\n\t * @protected\n\t * @since 0.4.2\n\t */\n\ts._compatibilitySetUp = function() {\n\t\ts._panningModel = \"equalpower\";\n\t\t//assume that if one new call is supported, they all are\n\t\tif (s.context.createGain) { return; }\n\n\t\t// simple name change, functionality the same\n\t\ts.context.createGain = s.context.createGainNode;\n\n\t\t// source node, add to prototype\n\t\tvar audioNode = s.context.createBufferSource();\n\t\taudioNode.__proto__.start = audioNode.__proto__.noteGrainOn;\t// note that noteGrainOn requires all 3 parameters\n\t\taudioNode.__proto__.stop = audioNode.__proto__.noteOff;\n\n\t\t// panningModel\n\t\ts._panningModel = 0;\n\t};\n\n\t/**\n\t * Try to unlock audio on iOS. This is triggered from either WebAudio plugin setup (which will work if inside of\n\t * a `mousedown` or `touchend` event stack), or the first document touchend/mousedown event. If it fails (touchend\n\t * will fail if the user presses for too long, indicating a scroll event instead of a click event.\n\t *\n\t * Note that earlier versions of iOS supported `touchstart` for this, but iOS9 removed this functionality. Adding\n\t * a `touchstart` event to support older platforms may preclude a `mousedown` even from getting fired on iOS9, so we\n\t * stick with `mousedown` and `touchend`.\n\t * @method _unlock\n\t * @since 0.6.2\n\t * @private\n\t */\n\ts._unlock = function() {\n\t\tif (s._unlocked) { return; }\n\t\ts.playEmptySound();\n\t\tif (s.context.state == \"running\") {\n\t\t\tdocument.removeEventListener(\"mousedown\", s._unlock, true);\n\t\t\tdocument.removeEventListener(\"touchend\", s._unlock, true);\n\t\t\ts._unlocked = true;\n\t\t}\n\t};\n\n\n// Public Methods\n\tp.toString = function () {\n\t\treturn \"[WebAudioPlugin]\";\n\t};\n\n\n// Private Methods\n\t/**\n\t * Set up needed properties on supported classes WebAudioSoundInstance and WebAudioLoader.\n\t * @method _addPropsToClasses\n\t * @static\n\t * @protected\n\t * @since 0.6.0\n\t */\n\tp._addPropsToClasses = function() {\n\t\tvar c = this._soundInstanceClass;\n\t\tc.context = this.context;\n\t\tc._scratchBuffer = s._scratchBuffer;\n\t\tc.destinationNode = this.gainNode;\n\t\tc._panningModel = this._panningModel;\n\n\t\tthis._loaderClass.context = this.context;\n\t};\n\n\n\t/**\n\t * Set the gain value for master audio. Should not be called externally.\n\t * @method _updateVolume\n\t * @protected\n\t */\n\tp._updateVolume = function () {\n\t\tvar newVolume = createjs.Sound._masterMute ? 0 : this._volume;\n\t\tif (newVolume != this.gainNode.gain.value) {\n\t\t\tthis.gainNode.gain.value = newVolume;\n\t\t}\n\t};\n\n\tcreatejs.WebAudioPlugin = createjs.promote(WebAudioPlugin, \"AbstractPlugin\");\n}());\n\n//##############################################################################\n// HTMLAudioTagPool.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * HTMLAudioTagPool is an object pool for HTMLAudio tag instances.\n\t * @class HTMLAudioTagPool\n\t * @param {String} src The source of the channel.\n\t * @protected\n\t */\n\tfunction HTMLAudioTagPool() {\n\t\t\tthrow \"HTMLAudioTagPool cannot be instantiated\";\n\t}\n\n\tvar s = HTMLAudioTagPool;\n\n// Static Properties\n\t/**\n\t * A hash lookup of each base audio tag, indexed by the audio source.\n\t * @property _tags\n\t * @type {{}}\n\t * @static\n\t * @protected\n\t */\n\ts._tags = {};\n\n\t/**\n\t * An object pool for html audio tags\n\t * @property _tagPool\n\t * @type {TagPool}\n\t * @static\n\t * @protected\n\t */\n\ts._tagPool = new TagPool();\n\n\t/**\n\t * A hash lookup of if a base audio tag is available, indexed by the audio source\n\t * @property _tagsUsed\n\t * @type {{}}\n\t * @protected\n\t * @static\n\t */\n\ts._tagUsed = {};\n\n// Static Methods\n\t/**\n\t  * Get an audio tag with the given source.\n\t  * @method get\n\t  * @param {String} src The source file used by the audio tag.\n\t  * @static\n\t  */\n\t s.get = function (src) {\n\t\tvar t = s._tags[src];\n\t\tif (t == null) {\n\t\t\t// create new base tag\n\t\t\tt = s._tags[src] = s._tagPool.get();\n\t\t\tt.src = src;\n\t\t} else {\n\t\t\t// get base or pool\n\t\t\tif (s._tagUsed[src]) {\n\t\t\t\tt = s._tagPool.get();\n\t\t\t\tt.src = src;\n\t\t\t} else {\n\t\t\t\ts._tagUsed[src] = true;\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t };\n\n\t /**\n\t  * Return an audio tag to the pool.\n\t  * @method set\n\t  * @param {String} src The source file used by the audio tag.\n\t  * @param {HTMLElement} tag Audio tag to set.\n\t  * @static\n\t  */\n\t s.set = function (src, tag) {\n\t\t // check if this is base, if yes set boolean if not return to pool\n\t\t if(tag == s._tags[src]) {\n\t\t\t s._tagUsed[src] = false;\n\t\t } else {\n\t\t\t s._tagPool.set(tag);\n\t\t }\n\t };\n\n\t/**\n\t * Delete stored tag reference and return them to pool. Note that if the tag reference does not exist, this will fail.\n\t * @method remove\n\t * @param {String} src The source for the tag\n\t * @return {Boolean} If the TagPool was deleted.\n\t * @static\n\t */\n\ts.remove = function (src) {\n\t\tvar tag = s._tags[src];\n\t\tif (tag == null) {return false;}\n\t\ts._tagPool.set(tag);\n\t\tdelete(s._tags[src]);\n\t\tdelete(s._tagUsed[src]);\n\t\treturn true;\n\t};\n\n\t/**\n\t * Gets the duration of the src audio in milliseconds\n\t * @method getDuration\n\t * @param {String} src The source file used by the audio tag.\n\t * @return {Number} Duration of src in milliseconds\n\t * @static\n\t */\n\ts.getDuration= function (src) {\n\t\tvar t = s._tags[src];\n\t\tif (t == null || !t.duration) {return 0;}\t// OJR duration is NaN if loading has not completed\n\t\treturn t.duration * 1000;\n\t};\n\n\tcreatejs.HTMLAudioTagPool = HTMLAudioTagPool;\n\n\n// ************************************************************************************************************\n\t/**\n\t * The TagPool is an object pool for HTMLAudio tag instances.\n\t * #class TagPool\n\t * @param {String} src The source of the channel.\n\t * @protected\n\t */\n\tfunction TagPool(src) {\n\n// Public Properties\n\t\t/**\n\t\t * A list of all available tags in the pool.\n\t\t * #property tags\n\t\t * @type {Array}\n\t\t * @protected\n\t\t */\n\t\tthis._tags = [];\n\t};\n\n\tvar p = TagPool.prototype;\n\tp.constructor = TagPool;\n\n\n// Public Methods\n\t/**\n\t * Get an HTMLAudioElement for immediate playback. This takes it out of the pool.\n\t * #method get\n\t * @return {HTMLAudioElement} An HTML audio tag.\n\t */\n\tp.get = function () {\n\t\tvar tag;\n\t\tif (this._tags.length == 0) {\n\t\t\ttag = this._createTag();\n\t\t} else {\n\t\t\ttag = this._tags.pop();\n\t\t}\n\t\tif (tag.parentNode == null) {document.body.appendChild(tag);}\n\t\treturn tag;\n\t};\n\n\t/**\n\t * Put an HTMLAudioElement back in the pool for use.\n\t * #method set\n\t * @param {HTMLAudioElement} tag HTML audio tag\n\t */\n\tp.set = function (tag) {\n\t\t// OJR this first step seems unnecessary\n\t\tvar index = createjs.indexOf(this._tags, tag);\n\t\tif (index == -1) {\n\t\t\tthis._tags.src = null;\n\t\t\tthis._tags.push(tag);\n\t\t}\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[TagPool]\";\n\t};\n\n\n// Private Methods\n\t/**\n\t * Create an HTML audio tag.\n\t * #method _createTag\n\t * @param {String} src The source file to set for the audio tag.\n\t * @return {HTMLElement} Returns an HTML audio tag.\n\t * @protected\n\t */\n\tp._createTag = function () {\n\t\tvar tag = document.createElement(\"audio\");\n\t\ttag.autoplay = false;\n\t\ttag.preload = \"none\";\n\t\t//LM: Firefox fails when this the preload=\"none\" for other tags, but it needs to be \"none\" to ensure PreloadJS works.\n\t\treturn tag;\n\t};\n\n}());\n\n//##############################################################################\n// HTMLAudioSoundInstance.js\n//##############################################################################\n\n(function () {\n\t\"use strict\";\n\n\t/**\n\t * HTMLAudioSoundInstance extends the base api of {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} and is used by\n\t * {{#crossLink \"HTMLAudioPlugin\"}}{{/crossLink}}.\n\t *\n\t * @param {String} src The path to and file name of the sound.\n\t * @param {Number} startTime Audio sprite property used to apply an offset, in milliseconds.\n\t * @param {Number} duration Audio sprite property used to set the time the clip plays for, in milliseconds.\n\t * @param {Object} playbackResource Any resource needed by plugin to support audio playback.\n\t * @class HTMLAudioSoundInstance\n\t * @extends AbstractSoundInstance\n\t * @constructor\n\t */\n\tfunction HTMLAudioSoundInstance(src, startTime, duration, playbackResource) {\n\t\tthis.AbstractSoundInstance_constructor(src, startTime, duration, playbackResource);\n\n\n// Private Properties\n\t\tthis._audioSpriteStopTime = null;\n\t\tthis._delayTimeoutId = null;\n\n\t\t// Proxies, make removing listeners easier.\n\t\tthis._endedHandler = createjs.proxy(this._handleSoundComplete, this);\n\t\tthis._readyHandler = createjs.proxy(this._handleTagReady, this);\n\t\tthis._stalledHandler = createjs.proxy(this._playFailed, this);\n\t\tthis._audioSpriteEndHandler = createjs.proxy(this._handleAudioSpriteLoop, this);\n\t\tthis._loopHandler = createjs.proxy(this._handleSoundComplete, this);\n\n\t\tif (duration) {\n\t\t\tthis._audioSpriteStopTime = (startTime + duration) * 0.001;\n\t\t} else {\n\t\t\tthis._duration = createjs.HTMLAudioTagPool.getDuration(this.src);\n\t\t}\n\t}\n\tvar p = createjs.extend(HTMLAudioSoundInstance, createjs.AbstractSoundInstance);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// Public Methods\n\t/**\n\t * Called by {{#crossLink \"Sound\"}}{{/crossLink}} when plugin does not handle master volume.\n\t * undoc'd because it is not meant to be used outside of Sound\n\t * #method setMasterVolume\n\t * @param value\n\t */\n\tp.setMasterVolume = function (value) {\n\t\tthis._updateVolume();\n\t};\n\n\t/**\n\t * Called by {{#crossLink \"Sound\"}}{{/crossLink}} when plugin does not handle master mute.\n\t * undoc'd because it is not meant to be used outside of Sound\n\t * #method setMasterMute\n\t * @param value\n\t */\n\tp.setMasterMute = function (isMuted) {\n\t\tthis._updateVolume();\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[HTMLAudioSoundInstance]\";\n\t};\n\n//Private Methods\n\tp._removeLooping = function() {\n\t\tif(this._playbackResource == null) {return;}\n\t\tthis._playbackResource.loop = false;\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t};\n\n\tp._addLooping = function() {\n\t\tif(this._playbackResource == null  || this._audioSpriteStopTime) {return;}\n\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t\tthis._playbackResource.loop = true;\n\t};\n\n\tp._handleCleanUp = function () {\n\t\tvar tag = this._playbackResource;\n\t\tif (tag != null) {\n\t\t\ttag.pause();\n\t\t\ttag.loop = false;\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, false);\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, false);\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t\t\ttag.removeEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);\n\n\t\t\ttry {\n\t\t\t\ttag.currentTime = this._startTime;\n\t\t\t} catch (e) {\n\t\t\t} // Reset Position\n\t\t\tcreatejs.HTMLAudioTagPool.set(this.src, tag);\n\t\t\tthis._playbackResource = null;\n\t\t}\n\t};\n\n\tp._beginPlaying = function (playProps) {\n\t\tthis._playbackResource = createjs.HTMLAudioTagPool.get(this.src);\n\t\treturn this.AbstractSoundInstance__beginPlaying(playProps);\n\t};\n\n\tp._handleSoundReady = function (event) {\n\t\tif (this._playbackResource.readyState !== 4) {\n\t\t\tvar tag = this._playbackResource;\n\t\t\ttag.addEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, false);\n\t\t\ttag.addEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, false);\n\t\t\ttag.preload = \"auto\"; // This is necessary for Firefox, as it won't ever \"load\" until this is set.\n\t\t\ttag.load();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._updateVolume();\n\t\tthis._playbackResource.currentTime = (this._startTime + this._position) * 0.001;\n\t\tif (this._audioSpriteStopTime) {\n\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);\n\t\t} else {\n\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);\n\t\t\tif(this._loop != 0) {\n\t\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t\t\t\tthis._playbackResource.loop = true;\n\t\t\t}\n\t\t}\n\n\t\tthis._playbackResource.play();\n\t};\n\n\t/**\n\t * Used to handle when a tag is not ready for immediate playback when it is returned from the HTMLAudioTagPool.\n\t * @method _handleTagReady\n\t * @param event\n\t * @protected\n\t */\n\tp._handleTagReady = function (event) {\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, false);\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, false);\n\n\t\tthis._handleSoundReady();\n\t};\n\n\tp._pause = function () {\n\t\tthis._playbackResource.pause();\n\t};\n\n\tp._resume = function () {\n\t\tthis._playbackResource.play();\n\t};\n\n\tp._updateVolume = function () {\n\t\tif (this._playbackResource != null) {\n\t\t\tvar newVolume = (this._muted || createjs.Sound._masterMute) ? 0 : this._volume * createjs.Sound._masterVolume;\n\t\t\tif (newVolume != this._playbackResource.volume) {this._playbackResource.volume = newVolume;}\n\t\t}\n\t};\n\n\tp._calculateCurrentPosition = function() {\n\t\treturn (this._playbackResource.currentTime * 1000) - this._startTime;\n\t};\n\n\tp._updatePosition = function() {\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._handleSetPositionSeek, false);\n\t\ttry {\n\t\t\tthis._playbackResource.currentTime = (this._position + this._startTime) * 0.001;\n\t\t} catch (error) { // Out of range\n\t\t\tthis._handleSetPositionSeek(null);\n\t\t}\n\t};\n\n\t/**\n\t * Used to enable setting position, as we need to wait for that seek to be done before we add back our loop handling seek listener\n\t * @method _handleSetPositionSeek\n\t * @param event\n\t * @protected\n\t */\n\tp._handleSetPositionSeek = function(event) {\n\t\tif (this._playbackResource == null) { return; }\n\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._handleSetPositionSeek, false);\n\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t};\n\n\t/**\n\t * Timer used to loop audio sprites.\n\t * NOTE because of the inaccuracies in the timeupdate event (15 - 250ms) and in setting the tag to the desired timed\n\t * (up to 300ms), it is strongly recommended not to loop audio sprites with HTML Audio if smooth looping is desired\n\t *\n\t * @method _handleAudioSpriteLoop\n\t * @param event\n\t * @private\n\t */\n\tp._handleAudioSpriteLoop = function (event) {\n\t\tif(this._playbackResource.currentTime <= this._audioSpriteStopTime) {return;}\n\t\tthis._playbackResource.pause();\n\t\tif(this._loop == 0) {\n\t\t\tthis._handleSoundComplete(null);\n\t\t} else {\n\t\t\tthis._position = 0;\n\t\t\tthis._loop--;\n\t\t\tthis._playbackResource.currentTime = this._startTime * 0.001;\n\t\t\tif(!this._paused) {this._playbackResource.play();}\n\t\t\tthis._sendEvent(\"loop\");\n\t\t}\n\t};\n\n\t// NOTE with this approach audio will loop as reliably as the browser allows\n\t// but we could end up sending the loop event after next loop playback begins\n\tp._handleLoop = function (event) {\n\t\tif(this._loop == 0) {\n\t\t\tthis._playbackResource.loop = false;\n\t\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, false);\n\t\t}\n\t};\n\n\tp._updateStartTime = function () {\n\t\tthis._audioSpriteStopTime = (this._startTime + this._duration) * 0.001;\n\n\t\tif(this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);\n\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);\n\t\t}\n\t};\n\n\tp._updateDuration = function () {\n\t\tthis._audioSpriteStopTime = (this._startTime + this._duration) * 0.001;\n\n\t\tif(this.playState == createjs.Sound.PLAY_SUCCEEDED) {\n\t\t\tthis._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, false);\n\t\t\tthis._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, false);\n\t\t}\n\t};\n\n\tp._setDurationFromSource = function () {\n\t\tthis._duration = createjs.HTMLAudioTagPool.getDuration(this.src);\n\t\tthis._playbackResource = null;\n\t};\n\n\tcreatejs.HTMLAudioSoundInstance = createjs.promote(HTMLAudioSoundInstance, \"AbstractSoundInstance\");\n}());\n\n//##############################################################################\n// HTMLAudioPlugin.js\n//##############################################################################\n\n(function () {\n\n\t\"use strict\";\n\n\t/**\n\t * Play sounds using HTML &lt;audio&gt; tags in the browser. This plugin is the second priority plugin installed\n\t * by default, after the {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}}.  For older browsers that do not support html\n\t * audio, include and install the {{#crossLink \"FlashAudioPlugin\"}}{{/crossLink}}.\n\t *\n\t * <h4>Known Browser and OS issues for HTML Audio</h4>\n\t * <b>All browsers</b><br />\n\t * Testing has shown in all browsers there is a limit to how many audio tag instances you are allowed.  If you exceed\n\t * this limit, you can expect to see unpredictable results. Please use {{#crossLink \"Sound.MAX_INSTANCES\"}}{{/crossLink}} as\n\t * a guide to how many total audio tags you can safely use in all browsers.  This issue is primarily limited to IE9.\n\t *\n     * <b>IE html limitations</b><br />\n     * <ul><li>There is a delay in applying volume changes to tags that occurs once playback is started. So if you have\n     * muted all sounds, they will all play during this delay until the mute applies internally. This happens regardless of\n     * when or how you apply the volume change, as the tag seems to need to play to apply it.</li>\n     * <li>MP3 encoding will not always work for audio tags if it's not default.  We've found default encoding with\n     * 64kbps works.</li>\n\t * <li>Occasionally very short samples will get cut off.</li>\n\t * <li>There is a limit to how many audio tags you can load or play at once, which appears to be determined by\n\t * hardware and browser settings.  See {{#crossLink \"HTMLAudioPlugin.MAX_INSTANCES\"}}{{/crossLink}} for a safe estimate.\n\t * Note that audio sprites can be used as a solution to this issue.</li></ul>\n\t *\n\t * <b>Safari limitations</b><br />\n\t * <ul><li>Safari requires Quicktime to be installed for audio playback.</li></ul>\n\t *\n\t * <b>iOS 6 limitations</b><br />\n\t * <ul><li>can only have one &lt;audio&gt; tag</li>\n\t * \t\t<li>can not preload or autoplay the audio</li>\n\t * \t\t<li>can not cache the audio</li>\n\t * \t\t<li>can not play the audio except inside a user initiated event.</li>\n\t *\t\t<li>Note it is recommended to use {{#crossLink \"WebAudioPlugin\"}}{{/crossLink}} for iOS (6+)</li>\n\t * \t\t<li>audio sprites can be used to mitigate some of these issues and are strongly recommended on iOS</li>\n\t * </ul>\n\t *\n\t * <b>Android Native Browser limitations</b><br />\n\t * <ul><li>We have no control over audio volume. Only the user can set volume on their device.</li>\n\t *      <li>We can only play audio inside a user event (touch/click).  This currently means you cannot loop sound or use a delay.</li></ul>\n\t * <b> Android Chrome 26.0.1410.58 specific limitations</b><br />\n\t * <ul> <li>Can only play 1 sound at a time.</li>\n\t *      <li>Sound is not cached.</li>\n\t *      <li>Sound can only be loaded in a user initiated touch/click event.</li>\n\t *      <li>There is a delay before a sound is played, presumably while the src is loaded.</li>\n\t * </ul>\n\t *\n\t * See {{#crossLink \"Sound\"}}{{/crossLink}} for general notes on known issues.\n\t *\n\t * @class HTMLAudioPlugin\n\t * @extends AbstractPlugin\n\t * @constructor\n\t */\n\tfunction HTMLAudioPlugin() {\n\t\tthis.AbstractPlugin_constructor();\n\n\n\t// Public Properties\n\t\t/**\n\t\t * This is no longer needed as we are now using object pooling for tags.\n\t\t *\n\t\t * <b>NOTE this property only exists as a limitation of HTML audio.</b>\n\t\t * @property defaultNumChannels\n\t\t * @type {Number}\n\t\t * @default 2\n\t\t * @since 0.4.0\n\t\t * @deprecated\n\t\t */\n\t\tthis.defaultNumChannels = 2;\n\n\t\tthis._capabilities = s._capabilities;\n\n\t\tthis._loaderClass = createjs.SoundLoader;\n\t\tthis._soundInstanceClass = createjs.HTMLAudioSoundInstance;\n\t}\n\n\tvar p = createjs.extend(HTMLAudioPlugin, createjs.AbstractPlugin);\n\tvar s = HTMLAudioPlugin;\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\n// Static Properties\n\t/**\n\t * The maximum number of instances that can be loaded or played. This is a browser limitation, primarily limited to IE9.\n\t * The actual number varies from browser to browser (and is largely hardware dependant), but this is a safe estimate.\n\t * Audio sprites work around this limitation.\n\t * @property MAX_INSTANCES\n\t * @type {Number}\n\t * @default 30\n\t * @static\n\t */\n\ts.MAX_INSTANCES = 30;\n\n\t/**\n\t * Event constant for the \"canPlayThrough\" event for cleaner code.\n\t * @property _AUDIO_READY\n\t * @type {String}\n\t * @default canplaythrough\n\t * @static\n\t * @protected\n\t */\n\ts._AUDIO_READY = \"canplaythrough\";\n\n\t/**\n\t * Event constant for the \"ended\" event for cleaner code.\n\t * @property _AUDIO_ENDED\n\t * @type {String}\n\t * @default ended\n\t * @static\n\t * @protected\n\t */\n\ts._AUDIO_ENDED = \"ended\";\n\n\t/**\n\t * Event constant for the \"seeked\" event for cleaner code.  We utilize this event for maintaining loop events.\n\t * @property _AUDIO_SEEKED\n\t * @type {String}\n\t * @default seeked\n\t * @static\n\t * @protected\n\t */\n\ts._AUDIO_SEEKED = \"seeked\";\n\n\t/**\n\t * Event constant for the \"stalled\" event for cleaner code.\n\t * @property _AUDIO_STALLED\n\t * @type {String}\n\t * @default stalled\n\t * @static\n\t * @protected\n\t */\n\ts._AUDIO_STALLED = \"stalled\";\n\n\t/**\n\t * Event constant for the \"timeupdate\" event for cleaner code.  Utilized for looping audio sprites.\n\t * This event callsback ever 15 to 250ms and can be dropped by the browser for performance.\n\t * @property _TIME_UPDATE\n\t * @type {String}\n\t * @default timeupdate\n\t * @static\n\t * @protected\n\t */\n\ts._TIME_UPDATE = \"timeupdate\";\n\n\t/**\n\t * The capabilities of the plugin. This is generated via the {{#crossLink \"HTMLAudioPlugin/_generateCapabilities\"}}{{/crossLink}}\n\t * method. Please see the Sound {{#crossLink \"Sound/getCapabilities\"}}{{/crossLink}} method for an overview of all\n\t * of the available properties.\n\t * @property _capabilities\n\t * @type {Object}\n\t * @protected\n\t * @static\n\t */\n\ts._capabilities = null;\n\n\n// Static Methods\n\t/**\n\t * Determine if the plugin can be used in the current browser/OS. Note that HTML audio is available in most modern\n\t * browsers, but is disabled in iOS because of its limitations.\n\t * @method isSupported\n\t * @return {Boolean} If the plugin can be initialized.\n\t * @static\n\t */\n\ts.isSupported = function () {\n\t\ts._generateCapabilities();\n\t\treturn (s._capabilities != null);\n\t};\n\n\t/**\n\t * Determine the capabilities of the plugin. Used internally. Please see the Sound API {{#crossLink \"Sound/getCapabilities\"}}{{/crossLink}}\n\t * method for an overview of plugin capabilities.\n\t * @method _generateCapabilities\n\t * @static\n\t * @protected\n\t */\n\ts._generateCapabilities = function () {\n\t\tif (s._capabilities != null) {return;}\n\t\tvar t = document.createElement(\"audio\");\n\t\tif (t.canPlayType == null) {return null;}\n\n\t\ts._capabilities = {\n\t\t\tpanning:false,\n\t\t\tvolume:true,\n\t\t\ttracks:-1\n\t\t};\n\n\t\t// determine which extensions our browser supports for this plugin by iterating through Sound.SUPPORTED_EXTENSIONS\n\t\tvar supportedExtensions = createjs.Sound.SUPPORTED_EXTENSIONS;\n\t\tvar extensionMap = createjs.Sound.EXTENSION_MAP;\n\t\tfor (var i = 0, l = supportedExtensions.length; i < l; i++) {\n\t\t\tvar ext = supportedExtensions[i];\n\t\t\tvar playType = extensionMap[ext] || ext;\n\t\t\ts._capabilities[ext] = (t.canPlayType(\"audio/\" + ext) != \"no\" && t.canPlayType(\"audio/\" + ext) != \"\") || (t.canPlayType(\"audio/\" + playType) != \"no\" && t.canPlayType(\"audio/\" + playType) != \"\");\n\t\t}  // OJR another way to do this might be canPlayType:\"m4a\", codex: mp4\n\t};\n\n\n// public methods\n\tp.register = function (loadItem) {\n\t\tvar tag = createjs.HTMLAudioTagPool.get(loadItem.src);\n\t\tvar loader = this.AbstractPlugin_register(loadItem);\n\t\tloader.setTag(tag);\n\n\t\treturn loader;\n\t};\n\n\tp.removeSound = function (src) {\n\t\tthis.AbstractPlugin_removeSound(src);\n\t\tcreatejs.HTMLAudioTagPool.remove(src);\n\t};\n\n\tp.create = function (src, startTime, duration) {\n\t\tvar si = this.AbstractPlugin_create(src, startTime, duration);\n\t\tsi.setPlaybackResource(null);\n\t\treturn si;\n\t};\n\n\tp.toString = function () {\n\t\treturn \"[HTMLAudioPlugin]\";\n\t};\n\n\t// plugin does not support these\n\tp.setVolume = p.getVolume = p.setMute = null;\n\n\n\tcreatejs.HTMLAudioPlugin = createjs.promote(HTMLAudioPlugin, \"AbstractPlugin\");\n}());\n\n//##############################################################################\n// Tween.js\n//##############################################################################\n\n// TODO: possibly add a END actionsMode (only runs actions that == position)?\n// TODO: evaluate a way to decouple paused from tick registration.\n\n\n\n\n(function() {\n\t\"use strict\";\n\n\n// constructor\n\t/**\n\t * A Tween instance tweens properties for a single target. Instance methods can be chained for easy construction and sequencing:\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      target.alpha = 1;\n\t *\t    createjs.Tween.get(target)\n\t *\t         .wait(500)\n\t *\t         .to({alpha:0, visible:false}, 1000)\n\t *\t         .call(handleComplete);\n\t *\t    function handleComplete() {\n\t *\t    \t//Tween complete\n\t *\t    }\n\t *\n\t * Multiple tweens can point to the same instance, however if they affect the same properties there could be unexpected\n\t * behaviour. To stop all tweens on an object, use {{#crossLink \"Tween/removeTweens\"}}{{/crossLink}} or pass `override:true`\n\t * in the props argument.\n\t *\n\t *      createjs.Tween.get(target, {override:true}).to({x:100});\n\t *\n\t * Subscribe to the {{#crossLink \"Tween/change:event\"}}{{/crossLink}} event to get notified when a property of the\n\t * target is changed.\n\t *\n\t *      createjs.Tween.get(target, {override:true}).to({x:100}).addEventListener(\"change\", handleChange);\n\t *      function handleChange(event) {\n\t *          // The tween changed.\n\t *      }\n\t *\n\t * See the Tween {{#crossLink \"Tween/get\"}}{{/crossLink}} method for additional param documentation.\n\t * @class Tween\n\t * @param {Object} target The target object that will have its properties tweened.\n\t * @param {Object} [props] The configuration properties to apply to this tween instance (ex. `{loop:true, paused:true}`.\n\t * All properties default to false. Supported props are:<UL>\n\t *    <LI> loop: sets the loop property on this tween.</LI>\n\t *    <LI> useTicks: uses ticks for all durations instead of milliseconds.</LI>\n\t *    <LI> ignoreGlobalPause: sets the {{#crossLink \"Tween/ignoreGlobalPause:property\"}}{{/crossLink}} property on this tween.</LI>\n\t *    <LI> override: if true, `Tween.removeTweens(target)` will be called to remove any other tweens with the same target.\n\t *    <LI> paused: indicates whether to start the tween paused.</LI>\n\t *    <LI> position: indicates the initial position for this tween.</LI>\n\t *    <LI> onChange: specifies a listener for the \"change\" event.</LI>\n\t * </UL>\n\t * @param {Object} [pluginData] An object containing data for use by installed plugins. See individual\n\t * plugins' documentation for details.\n\t * @extends EventDispatcher\n\t * @constructor\n\t */\n\tfunction Tween(target, props, pluginData) {\n\n\t// public properties:\n\t\t/**\n\t\t * Causes this tween to continue playing when a global pause is active. For example, if TweenJS is using {{#crossLink \"Ticker\"}}{{/crossLink}},\n\t\t * then setting this to true (the default) will cause this tween to be paused when <code>Ticker.setPaused(true)</code>\n\t\t * is called. See the Tween {{#crossLink \"Tween/tick\"}}{{/crossLink}} method for more info. Can be set via the props\n\t\t * parameter.\n\t\t * @property ignoreGlobalPause\n\t\t * @type Boolean\n\t\t * @default false\n\t\t */\n\t\tthis.ignoreGlobalPause = false;\n\t\n\t\t/**\n\t\t * If true, the tween will loop when it reaches the end. Can be set via the props param.\n\t\t * @property loop\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.loop = false;\n\t\n\t\t/**\n\t\t * Specifies the total duration of this tween in milliseconds (or ticks if useTicks is true).\n\t\t * This value is automatically updated as you modify the tween. Changing it directly could result in unexpected\n\t\t * behaviour.\n\t\t * @property duration\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @readonly\n\t\t */\n\t\tthis.duration = 0;\n\t\n\t\t/**\n\t\t * Allows you to specify data that will be used by installed plugins. Each plugin uses this differently, but in general\n\t\t * you specify data by setting it to a property of pluginData with the same name as the plugin class.\n\t\t * @example\n\t\t *\tmyTween.pluginData.PluginClassName = data;\n\t\t * <br/>\n\t\t * Also, most plugins support a property to enable or disable them. This is typically the plugin class name followed by \"_enabled\".<br/>\n\t\t * @example\n\t\t *\tmyTween.pluginData.PluginClassName_enabled = false;<br/>\n\t\t * <br/>\n\t\t * Some plugins also store instance data in this object, usually in a property named _PluginClassName.\n\t\t * See the documentation for individual plugins for more details.\n\t\t * @property pluginData\n\t\t * @type {Object}\n\t\t */\n\t\tthis.pluginData = pluginData || {};\n\t\n\t\t/**\n\t\t * The target of this tween. This is the object on which the tweened properties will be changed. Changing\n\t\t * this property after the tween is created will not have any effect.\n\t\t * @property target\n\t\t * @type {Object}\n\t\t * @readonly\n\t\t */\n\t\tthis.target = target;\n\t\n\t\t/**\n\t\t * The current normalized position of the tween. This will always be a value between 0 and duration.\n\t\t * Changing this property directly will have no effect.\n\t\t * @property position\n\t\t * @type {Object}\n\t\t * @readonly\n\t\t */\n\t\tthis.position = null;\n\t\n\t\t/**\n\t\t * Indicates the tween's current position is within a passive wait.\n\t\t * @property passive\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @readonly\n\t\t **/\n\t\tthis.passive = false;\n\t\n\t// private properties:\t\n\t\t/**\n\t\t * @property _paused\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis._paused = false;\n\t\n\t\t/**\n\t\t * @property _curQueueProps\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._curQueueProps = {};\n\t\n\t\t/**\n\t\t * @property _initQueueProps\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._initQueueProps = {};\n\t\n\t\t/**\n\t\t * @property _steps\n\t\t * @type {Array}\n\t\t * @protected\n\t\t */\n\t\tthis._steps = [];\n\t\n\t\t/**\n\t\t * @property _actions\n\t\t * @type {Array}\n\t\t * @protected\n\t\t */\n\t\tthis._actions = [];\n\t\n\t\t/**\n\t\t * Raw position.\n\t\t * @property _prevPosition\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @protected\n\t\t */\n\t\tthis._prevPosition = 0;\n\t\n\t\t/**\n\t\t * The position within the current step.\n\t\t * @property _stepPosition\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t * @protected\n\t\t */\n\t\tthis._stepPosition = 0; // this is needed by MovieClip.\n\t\n\t\t/**\n\t\t * Normalized position.\n\t\t * @property _prevPos\n\t\t * @type {Number}\n\t\t * @default -1\n\t\t * @protected\n\t\t */\n\t\tthis._prevPos = -1;\n\t\n\t\t/**\n\t\t * @property _target\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._target = target;\n\t\n\t\t/**\n\t\t * @property _useTicks\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis._useTicks = false;\n\t\n\t\t/**\n\t\t * @property _inited\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis._inited = false;\n\t\t\n\t\t/**\n\t\t * Indicates whether the tween is currently registered with Tween.\n\t\t * @property _registered\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis._registered = false;\n\n\n\t\tif (props) {\n\t\t\tthis._useTicks = props.useTicks;\n\t\t\tthis.ignoreGlobalPause = props.ignoreGlobalPause;\n\t\t\tthis.loop = props.loop;\n\t\t\tprops.onChange && this.addEventListener(\"change\", props.onChange);\n\t\t\tif (props.override) { Tween.removeTweens(target); }\n\t\t}\n\t\tif (props&&props.paused) { this._paused=true; }\n\t\telse { createjs.Tween._register(this,true); }\n\t\tif (props&&props.position!=null) { this.setPosition(props.position, Tween.NONE); }\n\n\t};\n\n\tvar p = createjs.extend(Tween, createjs.EventDispatcher);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\t\n\n// static properties\n\t/**\n\t * Constant defining the none actionsMode for use with setPosition.\n\t * @property NONE\n\t * @type Number\n\t * @default 0\n\t * @static\n\t */\n\tTween.NONE = 0;\n\n\t/**\n\t * Constant defining the loop actionsMode for use with setPosition.\n\t * @property LOOP\n\t * @type Number\n\t * @default 1\n\t * @static\n\t */\n\tTween.LOOP = 1;\n\n\t/**\n\t * Constant defining the reverse actionsMode for use with setPosition.\n\t * @property REVERSE\n\t * @type Number\n\t * @default 2\n\t * @static\n\t */\n\tTween.REVERSE = 2;\n\n\t/**\n\t * Constant returned by plugins to tell the tween not to use default assignment.\n\t * @property IGNORE\n\t * @type Object\n\t * @static\n\t */\n\tTween.IGNORE = {};\n\n\t/**\n\t * @property _listeners\n\t * @type Array[Tween]\n\t * @static\n\t * @protected\n\t */\n\tTween._tweens = [];\n\n\t/**\n\t * @property _plugins\n\t * @type Object\n\t * @static\n\t * @protected\n\t */\n\tTween._plugins = {};\n\n\n// static methods\t\n\t/**\n\t * Returns a new tween instance. This is functionally identical to using \"new Tween(...)\", but looks cleaner\n\t * with the chained syntax of TweenJS.\n\t * <h4>Example</h4>\n\t *\n\t *\t\tvar tween = createjs.Tween.get(target);\n\t *\n\t * @method get\n\t * @param {Object} target The target object that will have its properties tweened.\n\t * @param {Object} [props] The configuration properties to apply to this tween instance (ex. `{loop:true, paused:true}`).\n\t * All properties default to `false`. Supported props are:\n\t * <UL>\n\t *    <LI> loop: sets the loop property on this tween.</LI>\n\t *    <LI> useTicks: uses ticks for all durations instead of milliseconds.</LI>\n\t *    <LI> ignoreGlobalPause: sets the {{#crossLink \"Tween/ignoreGlobalPause:property\"}}{{/crossLink}} property on\n\t *    this tween.</LI>\n\t *    <LI> override: if true, `createjs.Tween.removeTweens(target)` will be called to remove any other tweens with\n\t *    the same target.\n\t *    <LI> paused: indicates whether to start the tween paused.</LI>\n\t *    <LI> position: indicates the initial position for this tween.</LI>\n\t *    <LI> onChange: specifies a listener for the {{#crossLink \"Tween/change:event\"}}{{/crossLink}} event.</LI>\n\t * </UL>\n\t * @param {Object} [pluginData] An object containing data for use by installed plugins. See individual plugins'\n\t * documentation for details.\n\t * @param {Boolean} [override=false] If true, any previous tweens on the same target will be removed. This is the\n\t * same as calling `Tween.removeTweens(target)`.\n\t * @return {Tween} A reference to the created tween. Additional chained tweens, method calls, or callbacks can be\n\t * applied to the returned tween instance.\n\t * @static\n\t */\n\tTween.get = function(target, props, pluginData, override) {\n\t\tif (override) { Tween.removeTweens(target); }\n\t\treturn new Tween(target, props, pluginData);\n\t};\n\n\t/**\n\t * Advances all tweens. This typically uses the {{#crossLink \"Ticker\"}}{{/crossLink}} class, but you can call it\n\t * manually if you prefer to use your own \"heartbeat\" implementation.\n\t * @method tick\n\t * @param {Number} delta The change in time in milliseconds since the last tick. Required unless all tweens have\n\t * `useTicks` set to true.\n\t * @param {Boolean} paused Indicates whether a global pause is in effect. Tweens with {{#crossLink \"Tween/ignoreGlobalPause:property\"}}{{/crossLink}}\n\t * will ignore this, but all others will pause if this is `true`.\n\t * @static\n\t */\n\tTween.tick = function(delta, paused) {\n\t\tvar tweens = Tween._tweens.slice(); // to avoid race conditions.\n\t\tfor (var i=tweens.length-1; i>=0; i--) {\n\t\t\tvar tween = tweens[i];\n\t\t\tif ((paused && !tween.ignoreGlobalPause) || tween._paused) { continue; }\n\t\t\ttween.tick(tween._useTicks?1:delta);\n\t\t}\n\t};\n\n\t/**\n\t * Handle events that result from Tween being used as an event handler. This is included to allow Tween to handle\n\t * {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}} events from the createjs {{#crossLink \"Ticker\"}}{{/crossLink}}.\n\t * No other events are handled in Tween.\n\t * @method handleEvent\n\t * @param {Object} event An event object passed in by the {{#crossLink \"EventDispatcher\"}}{{/crossLink}}. Will\n\t * usually be of type \"tick\".\n\t * @private\n\t * @static\n\t * @since 0.4.2\n\t */\n\tTween.handleEvent = function(event) {\n\t\tif (event.type == \"tick\") {\n\t\t\tthis.tick(event.delta, event.paused);\n\t\t}\n\t};\n\n\t/**\n\t * Removes all existing tweens for a target. This is called automatically by new tweens if the `override`\n\t * property is `true`.\n\t * @method removeTweens\n\t * @param {Object} target The target object to remove existing tweens from.\n\t * @static\n\t */\n\tTween.removeTweens = function(target) {\n\t\tif (!target.tweenjs_count) { return; }\n\t\tvar tweens = Tween._tweens;\n\t\tfor (var i=tweens.length-1; i>=0; i--) {\n\t\t\tvar tween = tweens[i];\n\t\t\tif (tween._target == target) {\n\t\t\t\ttween._paused = true;\n\t\t\t\ttweens.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\ttarget.tweenjs_count = 0;\n\t};\n\n\t/**\n\t * Stop and remove all existing tweens.\n\t * @method removeAllTweens\n\t * @static\n\t * @since 0.4.1\n\t */\n\tTween.removeAllTweens = function() {\n\t\tvar tweens = Tween._tweens;\n\t\tfor (var i= 0, l=tweens.length; i<l; i++) {\n\t\t\tvar tween = tweens[i];\n\t\t\ttween._paused = true;\n\t\t\ttween.target&&(tween.target.tweenjs_count = 0);\n\t\t}\n\t\ttweens.length = 0;\n\t};\n\n\t/**\n\t * Indicates whether there are any active tweens (and how many) on the target object (if specified) or in general.\n\t * @method hasActiveTweens\n\t * @param {Object} [target] The target to check for active tweens. If not specified, the return value will indicate\n\t * if there are any active tweens on any target.\n\t * @return {Boolean} If there are active tweens.\n\t * @static\n\t */\n\tTween.hasActiveTweens = function(target) {\n\t\tif (target) { return target.tweenjs_count != null && !!target.tweenjs_count; }\n\t\treturn Tween._tweens && !!Tween._tweens.length;\n\t};\n\n\t/**\n\t * Installs a plugin, which can modify how certain properties are handled when tweened. See the {{#crossLink \"CSSPlugin\"}}{{/crossLink}}\n\t * for an example of how to write TweenJS plugins.\n\t * @method installPlugin\n\t * @static\n\t * @param {Object} plugin The plugin class to install\n\t * @param {Array} properties An array of properties that the plugin will handle.\n\t */\n\tTween.installPlugin = function(plugin, properties) {\n\t\tvar priority = plugin.priority;\n\t\tif (priority == null) { plugin.priority = priority = 0; }\n\t\tfor (var i=0,l=properties.length,p=Tween._plugins;i<l;i++) {\n\t\t\tvar n = properties[i];\n\t\t\tif (!p[n]) { p[n] = [plugin]; }\n\t\t\telse {\n\t\t\t\tvar arr = p[n];\n\t\t\t\tfor (var j=0,jl=arr.length;j<jl;j++) {\n\t\t\t\t\tif (priority < arr[j].priority) { break; }\n\t\t\t\t}\n\t\t\t\tp[n].splice(j,0,plugin);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Registers or unregisters a tween with the ticking system.\n\t * @method _register\n\t * @param {Tween} tween The tween instance to register or unregister.\n\t * @param {Boolean} value If `true`, the tween is registered. If `false` the tween is unregistered.\n\t * @static\n\t * @protected\n\t */\n\tTween._register = function(tween, value) {\n\t\tvar target = tween._target;\n\t\tvar tweens = Tween._tweens;\n\t\tif (value && !tween._registered) {\n\t\t\t// TODO: this approach might fail if a dev is using sealed objects in ES5\n\t\t\tif (target) { target.tweenjs_count = target.tweenjs_count ? target.tweenjs_count+1 : 1; }\n\t\t\ttweens.push(tween);\n\t\t\tif (!Tween._inited && createjs.Ticker) { createjs.Ticker.addEventListener(\"tick\", Tween); Tween._inited = true; }\n\t\t} else if (!value && tween._registered) {\n\t\t\tif (target) { target.tweenjs_count--; }\n\t\t\tvar i = tweens.length;\n\t\t\twhile (i--) {\n\t\t\t\tif (tweens[i] == tween) {\n\t\t\t\t\ttweens.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttween._registered = value;\n\t};\n\n\n// events:\n\t/**\n\t * Called whenever the tween's position changes.\n\t * @event change\n\t * @since 0.4.0\n\t **/\n\t\n\n// public methods:\n\t/**\n\t * Queues a wait (essentially an empty tween).\n\t * <h4>Example</h4>\n\t *\n\t *\t\t//This tween will wait 1s before alpha is faded to 0.\n\t *\t\tcreatejs.Tween.get(target).wait(1000).to({alpha:0}, 1000);\n\t *\n\t * @method wait\n\t * @param {Number} duration The duration of the wait in milliseconds (or in ticks if `useTicks` is true).\n\t * @param {Boolean} [passive] Tween properties will not be updated during a passive wait. This\n\t * is mostly useful for use with {{#crossLink \"Timeline\"}}{{/crossLink}} instances that contain multiple tweens\n\t * affecting the same target at different times.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t **/\n\tp.wait = function(duration, passive) {\n\t\tif (duration == null || duration <= 0) { return this; }\n\t\tvar o = this._cloneProps(this._curQueueProps);\n\t\treturn this._addStep({d:duration, p0:o, e:this._linearEase, p1:o, v:passive});\n\t};\n\n\t/**\n\t * Queues a tween from the current values to the target properties. Set duration to 0 to jump to these value.\n\t * Numeric properties will be tweened from their current value in the tween to the target value. Non-numeric\n\t * properties will be set at the end of the specified duration.\n\t * <h4>Example</h4>\n\t *\n\t *\t\tcreatejs.Tween.get(target).to({alpha:0}, 1000);\n\t *\n\t * @method to\n\t * @param {Object} props An object specifying property target values for this tween (Ex. `{x:300}` would tween the x\n\t * property of the target to 300).\n\t * @param {Number} [duration=0] The duration of the wait in milliseconds (or in ticks if `useTicks` is true).\n\t * @param {Function} [ease=\"linear\"] The easing function to use for this tween. See the {{#crossLink \"Ease\"}}{{/crossLink}}\n\t * class for a list of built-in ease functions.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t */\n\tp.to = function(props, duration, ease) {\n\t\tif (isNaN(duration) || duration < 0) { duration = 0; }\n\t\treturn this._addStep({d:duration||0, p0:this._cloneProps(this._curQueueProps), e:ease, p1:this._cloneProps(this._appendQueueProps(props))});\n\t};\n\n\t/**\n\t * Queues an action to call the specified function.\n\t * <h4>Example</h4>\n\t *\n\t *   \t//would call myFunction() after 1 second.\n\t *   \tmyTween.wait(1000).call(myFunction);\n\t *\n\t * @method call\n\t * @param {Function} callback The function to call.\n\t * @param {Array} [params]. The parameters to call the function with. If this is omitted, then the function\n\t *      will be called with a single param pointing to this tween.\n\t * @param {Object} [scope]. The scope to call the function in. If omitted, it will be called in the target's\n\t *      scope.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t */\n\tp.call = function(callback, params, scope) {\n\t\treturn this._addAction({f:callback, p:params ? params : [this], o:scope ? scope : this._target});\n\t};\n\n\t// TODO: add clarification between this and a 0 duration .to:\n\t/**\n\t * Queues an action to set the specified props on the specified target. If target is null, it will use this tween's\n\t * target.\n\t * <h4>Example</h4>\n\t *\n\t *\t\tmyTween.wait(1000).set({visible:false},foo);\n\t *\n\t * @method set\n\t * @param {Object} props The properties to set (ex. `{visible:false}`).\n\t * @param {Object} [target] The target to set the properties on. If omitted, they will be set on the tween's target.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t */\n\tp.set = function(props, target) {\n\t\treturn this._addAction({f:this._set, o:this, p:[props, target ? target : this._target]});\n\t};\n\n\t/**\n\t * Queues an action to play (unpause) the specified tween. This enables you to sequence multiple tweens.\n\t * <h4>Example</h4>\n\t *\n\t *\t\tmyTween.to({x:100},500).play(otherTween);\n\t *\n\t * @method play\n\t * @param {Tween} tween The tween to play.\n\t * @return {Tween} This tween instance (for chaining calls).\n\t */\n\tp.play = function(tween) {\n\t\tif (!tween) { tween = this; }\n\t\treturn this.call(tween.setPaused, [false], tween);\n\t};\n\n\t/**\n\t * Queues an action to pause the specified tween.\n\t * @method pause\n\t * @param {Tween} tween The tween to pause. If null, it pauses this tween.\n\t * @return {Tween} This tween instance (for chaining calls)\n\t */\n\tp.pause = function(tween) {\n\t\tif (!tween) { tween = this; }\n\t\treturn this.call(tween.setPaused, [true], tween);\n\t};\n\n\t/**\n\t * Advances the tween to a specified position.\n\t * @method setPosition\n\t * @param {Number} value The position to seek to in milliseconds (or ticks if useTicks is true).\n\t * @param {Number} [actionsMode=1] Specifies how actions are handled (ie. call, set, play, pause):\n\t * <ul>\n\t *      <li>{{#crossLink \"Tween/NONE:property\"}}{{/crossLink}} (0) - run no actions.</li>\n\t *      <li>{{#crossLink \"Tween/LOOP:property\"}}{{/crossLink}} (1) - if new position is less than old, then run all\n\t *      actions between old and duration, then all actions between 0 and new.</li>\n\t *      <li>{{#crossLink \"Tween/REVERSE:property\"}}{{/crossLink}} (2) - if new position is less than old, run all\n\t *      actions between them in reverse.</li>\n\t * </ul>\n\t * @return {Boolean} Returns `true` if the tween is complete (ie. the full tween has run & {{#crossLink \"Tween/loop:property\"}}{{/crossLink}}\n\t * is `false`).\n\t */\n\tp.setPosition = function(value, actionsMode) {\n\t\tif (value < 0) { value = 0; }\n\t\tif (actionsMode == null) { actionsMode = 1; }\n\n\t\t// normalize position:\n\t\tvar t = value;\n\t\tvar end = false;\n\t\tif (t >= this.duration) {\n\t\t\tif (this.loop) { t = t%this.duration; }\n\t\t\telse {\n\t\t\t\tt = this.duration;\n\t\t\t\tend = true;\n\t\t\t}\n\t\t}\n\t\tif (t == this._prevPos) { return end; }\n\n\n\t\tvar prevPos = this._prevPos;\n\t\tthis.position = this._prevPos = t; // set this in advance in case an action modifies position.\n\t\tthis._prevPosition = value;\n\n\t\t// handle tweens:\n\t\tif (this._target) {\n\t\t\tif (end) {\n\t\t\t\t// addresses problems with an ending zero length step.\n\t\t\t\tthis._updateTargetProps(null,1);\n\t\t\t} else if (this._steps.length > 0) {\n\t\t\t\t// find our new tween index:\n\t\t\t\tfor (var i=0, l=this._steps.length; i<l; i++) {\n\t\t\t\t\tif (this._steps[i].t > t) { break; }\n\t\t\t\t}\n\t\t\t\tvar step = this._steps[i-1];\n\t\t\t\tthis._updateTargetProps(step,(this._stepPosition = t-step.t)/step.d);\n\t\t\t}\n\t\t}\n\n\t\t// run actions:\n\t\tif (actionsMode != 0 && this._actions.length > 0) {\n\t\t\tif (this._useTicks) {\n\t\t\t\t// only run the actions we landed on.\n\t\t\t\tthis._runActions(t,t);\n\t\t\t} else if (actionsMode == 1 && t<prevPos) {\n\t\t\t\tif (prevPos != this.duration) { this._runActions(prevPos, this.duration); }\n\t\t\t\tthis._runActions(0, t, true);\n\t\t\t} else {\n\t\t\t\tthis._runActions(prevPos, t);\n\t\t\t}\n\t\t}\n\n\t\tif (end) { this.setPaused(true); }\n\n        this.dispatchEvent(\"change\");\n\t\treturn end;\n\t};\n\n\t/**\n\t * Advances this tween by the specified amount of time in milliseconds (or ticks if`useTicks` is `true`).\n\t * This is normally called automatically by the Tween engine (via {{#crossLink \"Tween/tick\"}}{{/crossLink}}), but is\n\t * exposed for advanced uses.\n\t * @method tick\n\t * @param {Number} delta The time to advance in milliseconds (or ticks if `useTicks` is `true`).\n\t */\n\tp.tick = function(delta) {\n\t\tif (this._paused) { return; }\n\t\tthis.setPosition(this._prevPosition+delta);\n\t};\n\n\t/**\n\t * Pauses or plays this tween.\n\t * @method setPaused\n\t * @param {Boolean} [value=true] Indicates whether the tween should be paused (`true`) or played (`false`).\n\t * @return {Tween} This tween instance (for chaining calls)\n\t */\n\tp.setPaused = function(value) {\n\t\tif (this._paused === !!value) { return this; }\n\t\tthis._paused = !!value;\n\t\tTween._register(this, !value);\n\t\treturn this;\n\t};\n\n\t// tiny api (primarily for tool output):\n\tp.w = p.wait;\n\tp.t = p.to;\n\tp.c = p.call;\n\tp.s = p.set;\n\n\t/**\n\t * Returns a string representation of this object.\n\t * @method toString\n\t * @return {String} a string representation of the instance.\n\t */\n\tp.toString = function() {\n\t\treturn \"[Tween]\";\n\t};\n\n\t/**\n\t * @method clone\n\t * @protected\n\t */\n\tp.clone = function() {\n\t\tthrow(\"Tween can not be cloned.\")\n\t};\n\n// private methods:\n\t/**\n\t * @method _updateTargetProps\n\t * @param {Object} step\n\t * @param {Number} ratio\n\t * @protected\n\t */\n\tp._updateTargetProps = function(step, ratio) {\n\t\tvar p0,p1,v,v0,v1,arr;\n\t\tif (!step && ratio == 1) {\n\t\t\t// GDS: when does this run? Just at the very end? Shouldn't.\n\t\t\tthis.passive = false;\n\t\t\tp0 = p1 = this._curQueueProps;\n\t\t} else {\n\t\t\tthis.passive = !!step.v;\n\t\t\tif (this.passive) { return; } // don't update props.\n\t\t\t// apply ease to ratio.\n\t\t\tif (step.e) { ratio = step.e(ratio,0,1,1); }\n\t\t\tp0 = step.p0;\n\t\t\tp1 = step.p1;\n\t\t}\n\n\t\tfor (var n in this._initQueueProps) {\n\t\t\tif ((v0 = p0[n]) == null) { p0[n] = v0 = this._initQueueProps[n]; }\n\t\t\tif ((v1 = p1[n]) == null) { p1[n] = v1 = v0; }\n\t\t\tif (v0 == v1 || ratio == 0 || ratio == 1 || (typeof(v0) != \"number\")) {\n\t\t\t\t// no interpolation - either at start, end, values don't change, or the value is non-numeric.\n\t\t\t\tv = ratio == 1 ? v1 : v0;\n\t\t\t} else {\n\t\t\t\tv = v0+(v1-v0)*ratio;\n\t\t\t}\n\n\t\t\tvar ignore = false;\n\t\t\tif (arr = Tween._plugins[n]) {\n\t\t\t\tfor (var i=0,l=arr.length;i<l;i++) {\n\t\t\t\t\tvar v2 = arr[i].tween(this, n, v, p0, p1, ratio, !!step&&p0==p1, !step);\n\t\t\t\t\tif (v2 == Tween.IGNORE) { ignore = true; }\n\t\t\t\t\telse { v = v2; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ignore) { this._target[n] = v; }\n\t\t}\n\n\t};\n\n\t/**\n\t * @method _runActions\n\t * @param {Number} startPos\n\t * @param {Number} endPos\n\t * @param {Boolean} includeStart\n\t * @protected\n\t */\n\tp._runActions = function(startPos, endPos, includeStart) {\n\t\tvar sPos = startPos;\n\t\tvar ePos = endPos;\n\t\tvar i = -1;\n\t\tvar j = this._actions.length;\n\t\tvar k = 1;\n\t\tif (startPos > endPos) {\n\t\t\t// running backwards, flip everything:\n\t\t\tsPos = endPos;\n\t\t\tePos = startPos;\n\t\t\ti = j;\n\t\t\tj = k = -1;\n\t\t}\n\t\twhile ((i+=k) != j) {\n\t\t\tvar action = this._actions[i];\n\t\t\tvar pos = action.t;\n\t\t\tif (pos == ePos || (pos > sPos && pos < ePos) || (includeStart && pos == startPos) ) {\n\t\t\t\taction.f.apply(action.o, action.p);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method _appendQueueProps\n\t * @param {Object} o\n\t * @protected\n\t */\n\tp._appendQueueProps = function(o) {\n\t\tvar arr,oldValue,i, l, injectProps;\n\t\tfor (var n in o) {\n\t\t\tif (this._initQueueProps[n] === undefined) {\n\t\t\t\toldValue = this._target[n];\n\n\t\t\t\t// init plugins:\n\t\t\t\tif (arr = Tween._plugins[n]) {\n\t\t\t\t\tfor (i=0,l=arr.length;i<l;i++) {\n\t\t\t\t\t\toldValue = arr[i].init(this, n, oldValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._initQueueProps[n] = this._curQueueProps[n] = (oldValue===undefined) ? null : oldValue;\n\t\t\t} else {\n\t\t\t\toldValue = this._curQueueProps[n];\n\t\t\t}\n\t\t}\n\n\t\tfor (var n in o) {\n\t\t\toldValue = this._curQueueProps[n];\n\t\t\tif (arr = Tween._plugins[n]) {\n\t\t\t\tinjectProps = injectProps||{};\n\t\t\t\tfor (i=0, l=arr.length;i<l;i++) {\n\t\t\t\t\t// TODO: remove the check for .step in the next version. It's here for backwards compatibility.\n\t\t\t\t\tif (arr[i].step) { arr[i].step(this, n, oldValue, o[n], injectProps); }\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._curQueueProps[n] = o[n];\n\t\t}\n\t\tif (injectProps) { this._appendQueueProps(injectProps); }\n\t\treturn this._curQueueProps;\n\t};\n\n\t/**\n\t * @method _cloneProps\n\t * @param {Object} props\n\t * @protected\n\t */\n\tp._cloneProps = function(props) {\n\t\tvar o = {};\n\t\tfor (var n in props) {\n\t\t\to[n] = props[n];\n\t\t}\n\t\treturn o;\n\t};\n\n\t/**\n\t * @method _addStep\n\t * @param {Object} o\n\t * @protected\n\t */\n\tp._addStep = function(o) {\n\t\tif (o.d > 0) {\n\t\t\tthis._steps.push(o);\n\t\t\to.t = this.duration;\n\t\t\tthis.duration += o.d;\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method _addAction\n\t * @param {Object} o\n\t * @protected\n\t */\n\tp._addAction = function(o) {\n\t\to.t = this.duration;\n\t\tthis._actions.push(o);\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method _set\n\t * @param {Object} props\n\t * @param {Object} o\n\t * @protected\n\t */\n\tp._set = function(props, o) {\n\t\tfor (var n in props) {\n\t\t\to[n] = props[n];\n\t\t}\n\t};\n\n\tcreatejs.Tween = createjs.promote(Tween, \"EventDispatcher\");\n\n}());\n\n//##############################################################################\n// Timeline.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\t\n\n// constructor\t\n\t/**\n\t * The Timeline class synchronizes multiple tweens and allows them to be controlled as a group. Please note that if a\n\t * timeline is looping, the tweens on it may appear to loop even if the \"loop\" property of the tween is false.\n\t * @class Timeline\n\t * @param {Array} tweens An array of Tweens to add to this timeline. See {{#crossLink \"Timeline/addTween\"}}{{/crossLink}}\n\t * for more info.\n\t * @param {Object} labels An object defining labels for using {{#crossLink \"Timeline/gotoAndPlay\"}}{{/crossLink}}/{{#crossLink \"Timeline/gotoAndStop\"}}{{/crossLink}}.\n\t * See {{#crossLink \"Timeline/setLabels\"}}{{/crossLink}}\n\t * for details.\n\t * @param {Object} props The configuration properties to apply to this tween instance (ex. `{loop:true}`). All properties\n\t * default to false. Supported props are:<UL>\n\t *    <LI> loop: sets the loop property on this tween.</LI>\n\t *    <LI> useTicks: uses ticks for all durations instead of milliseconds.</LI>\n\t *    <LI> ignoreGlobalPause: sets the ignoreGlobalPause property on this tween.</LI>\n\t *    <LI> paused: indicates whether to start the tween paused.</LI>\n\t *    <LI> position: indicates the initial position for this timeline.</LI>\n\t *    <LI> onChange: specifies a listener to add for the {{#crossLink \"Timeline/change:event\"}}{{/crossLink}} event.</LI>\n\t * </UL>\n\t * @extends EventDispatcher\n\t * @constructor\n\t **/\n\tfunction Timeline(tweens, labels, props) {\n\t\tthis.EventDispatcher_constructor();\n\n\t// public properties:\n\t\t/**\n\t\t * Causes this timeline to continue playing when a global pause is active.\n\t\t * @property ignoreGlobalPause\n\t\t * @type Boolean\n\t\t **/\n\t\tthis.ignoreGlobalPause = false;\n\n\t\t/**\n\t\t * The total duration of this timeline in milliseconds (or ticks if `useTicks `is `true`). This value is usually\n\t\t * automatically updated as you modify the timeline. See {{#crossLink \"Timeline/updateDuration\"}}{{/crossLink}}\n\t\t * for more information.\n\t\t * @property duration\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @readonly\n\t\t **/\n\t\tthis.duration = 0;\n\n\t\t/**\n\t\t * If true, the timeline will loop when it reaches the end. Can be set via the props param.\n\t\t * @property loop\n\t\t * @type Boolean\n\t\t **/\n\t\tthis.loop = false;\n\n\t\t/**\n\t\t * The current normalized position of the timeline. This will always be a value between 0 and\n\t\t * {{#crossLink \"Timeline/duration:property\"}}{{/crossLink}}.\n\t\t * Changing this property directly will have no effect.\n\t\t * @property position\n\t\t * @type Object\n\t\t * @readonly\n\t\t **/\n\t\tthis.position = null;\n\n\t\t// private properties:\n\t\t/**\n\t\t * @property _paused\n\t\t * @type Boolean\n\t\t * @protected\n\t\t **/\n\t\tthis._paused = false;\n\n\t\t/**\n\t\t * @property _tweens\n\t\t * @type Array[Tween]\n\t\t * @protected\n\t\t **/\n\t\tthis._tweens = [];\n\n\t\t/**\n\t\t * @property _labels\n\t\t * @type Object\n\t\t * @protected\n\t\t **/\n\t\tthis._labels = null;\n\n\t\t/**\n\t\t * @property _labelList\n\t\t * @type Array[Object]\n\t\t * @protected\n\t\t **/\n\t\tthis._labelList = null;\n\n\t\t/**\n\t\t * @property _prevPosition\n\t\t * @type Number\n\t\t * @default 0\n\t\t * @protected\n\t\t **/\n\t\tthis._prevPosition = 0;\n\n\t\t/**\n\t\t * @property _prevPos\n\t\t * @type Number\n\t\t * @default -1\n\t\t * @protected\n\t\t **/\n\t\tthis._prevPos = -1;\n\n\t\t/**\n\t\t * @property _useTicks\n\t\t * @type Boolean\n\t\t * @default false\n\t\t * @protected\n\t\t **/\n\t\tthis._useTicks = false;\n\t\t\n\t\t/**\n\t\t * Indicates whether the timeline is currently registered with Tween.\n\t\t * @property _registered\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis._registered = false;\n\n\n\t\tif (props) {\n\t\t\tthis._useTicks = props.useTicks;\n\t\t\tthis.loop = props.loop;\n\t\t\tthis.ignoreGlobalPause = props.ignoreGlobalPause;\n\t\t\tprops.onChange&&this.addEventListener(\"change\", props.onChange);\n\t\t}\n\t\tif (tweens) { this.addTween.apply(this, tweens); }\n\t\tthis.setLabels(labels);\n\t\tif (props&&props.paused) { this._paused=true; }\n\t\telse { createjs.Tween._register(this,true); }\n\t\tif (props&&props.position!=null) { this.setPosition(props.position, createjs.Tween.NONE); }\n\t\t\n\t};\n\t\n\tvar p = createjs.extend(Timeline, createjs.EventDispatcher);\n\n\t// TODO: deprecated\n\t// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.\n\n\t\n// events:\n\t/**\n\t * Called whenever the timeline's position changes.\n\t * @event change\n\t * @since 0.5.0\n\t **/\n\n\n// public methods:\n\t/**\n\t * Adds one or more tweens (or timelines) to this timeline. The tweens will be paused (to remove them from the\n\t * normal ticking system) and managed by this timeline. Adding a tween to multiple timelines will result in\n\t * unexpected behaviour.\n\t * @method addTween\n\t * @param {Tween} ...tween The tween(s) to add. Accepts multiple arguments.\n\t * @return {Tween} The first tween that was passed in.\n\t **/\n\tp.addTween = function(tween) {\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tfor (var i=0; i<l; i++) { this.addTween(arguments[i]); }\n\t\t\treturn arguments[0];\n\t\t} else if (l == 0) { return null; }\n\t\tthis.removeTween(tween);\n\t\tthis._tweens.push(tween);\n\t\ttween.setPaused(true);\n\t\ttween._paused = false;\n\t\ttween._useTicks = this._useTicks;\n\t\tif (tween.duration > this.duration) { this.duration = tween.duration; }\n\t\tif (this._prevPos >= 0) { tween.setPosition(this._prevPos, createjs.Tween.NONE); }\n\t\treturn tween;\n\t};\n\n\t/**\n\t * Removes one or more tweens from this timeline.\n\t * @method removeTween\n\t * @param {Tween} ...tween The tween(s) to remove. Accepts multiple arguments.\n\t * @return Boolean Returns `true` if all of the tweens were successfully removed.\n\t **/\n\tp.removeTween = function(tween) {\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tvar good = true;\n\t\t\tfor (var i=0; i<l; i++) { good = good && this.removeTween(arguments[i]); }\n\t\t\treturn good;\n\t\t} else if (l == 0) { return false; }\n\n\t\tvar tweens = this._tweens;\n\t\tvar i = tweens.length;\n\t\twhile (i--) {\n\t\t\tif (tweens[i] == tween) {\n\t\t\t\ttweens.splice(i, 1);\n\t\t\t\tif (tween.duration >= this.duration) { this.updateDuration(); }\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Adds a label that can be used with {{#crossLink \"Timeline/gotoAndPlay\"}}{{/crossLink}}/{{#crossLink \"Timeline/gotoAndStop\"}}{{/crossLink}}.\n\t * @method addLabel\n\t * @param {String} label The label name.\n\t * @param {Number} position The position this label represents.\n\t **/\n\tp.addLabel = function(label, position) {\n\t\tthis._labels[label] = position;\n\t\tvar list = this._labelList;\n\t\tif (list) {\n\t\t\tfor (var i= 0,l=list.length; i<l; i++) { if (position < list[i].position) { break; } }\n\t\t\tlist.splice(i, 0, {label:label, position:position});\n\t\t}\n\t};\n\n\t/**\n\t * Defines labels for use with gotoAndPlay/Stop. Overwrites any previously set labels.\n\t * @method setLabels\n\t * @param {Object} o An object defining labels for using {{#crossLink \"Timeline/gotoAndPlay\"}}{{/crossLink}}/{{#crossLink \"Timeline/gotoAndStop\"}}{{/crossLink}}\n\t * in the form `{labelName:time}` where time is in milliseconds (or ticks if `useTicks` is `true`).\n\t **/\n\tp.setLabels = function(o) {\n\t\tthis._labels = o ?  o : {};\n\t};\n\n\t/**\n\t * Returns a sorted list of the labels defined on this timeline.\n\t * @method getLabels\n\t * @return {Array[Object]} A sorted array of objects with label and position properties.\n\t **/\n\tp.getLabels = function() {\n\t\tvar list = this._labelList;\n\t\tif (!list) {\n\t\t\tlist = this._labelList = [];\n\t\t\tvar labels = this._labels;\n\t\t\tfor (var n in labels) {\n\t\t\t\tlist.push({label:n, position:labels[n]});\n\t\t\t}\n\t\t\tlist.sort(function (a,b) { return a.position- b.position; });\n\t\t}\n\t\treturn list;\n\t};\n\n\t/**\n\t * Returns the name of the label on or immediately before the current position. For example, given a timeline with\n\t * two labels, \"first\" on frame index 4, and \"second\" on frame 8, getCurrentLabel would return:\n\t * <UL>\n\t * \t\t<LI>null if the current position is 2.</LI>\n\t * \t\t<LI>\"first\" if the current position is 4.</LI>\n\t * \t\t<LI>\"first\" if the current position is 7.</LI>\n\t * \t\t<LI>\"second\" if the current position is 15.</LI>\n\t * </UL>\n\t * @method getCurrentLabel\n\t * @return {String} The name of the current label or null if there is no label\n\t **/\n\tp.getCurrentLabel = function() {\n\t\tvar labels = this.getLabels();\n\t\tvar pos = this.position;\n\t\tvar l = labels.length;\n\t\tif (l) {\n\t\t\tfor (var i = 0; i<l; i++) { if (pos < labels[i].position) { break; } }\n\t\t\treturn (i==0) ? null : labels[i-1].label;\n\t\t}\n\t\treturn null;\n\t};\n\n\t/**\n\t * Unpauses this timeline and jumps to the specified position or label.\n\t * @method gotoAndPlay\n\t * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`)\n\t * or label to jump to.\n\t **/\n\tp.gotoAndPlay = function(positionOrLabel) {\n\t\tthis.setPaused(false);\n\t\tthis._goto(positionOrLabel);\n\t};\n\n\t/**\n\t * Pauses this timeline and jumps to the specified position or label.\n\t * @method gotoAndStop\n\t * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`) or label\n\t * to jump to.\n\t **/\n\tp.gotoAndStop = function(positionOrLabel) {\n\t\tthis.setPaused(true);\n\t\tthis._goto(positionOrLabel);\n\t};\n\n\t/**\n\t * Advances the timeline to the specified position.\n\t * @method setPosition\n\t * @param {Number} value The position to seek to in milliseconds (or ticks if `useTicks` is `true`).\n\t * @param {Number} [actionsMode] parameter specifying how actions are handled. See the Tween {{#crossLink \"Tween/setPosition\"}}{{/crossLink}}\n\t * method for more details.\n\t * @return {Boolean} Returns `true` if the timeline is complete (ie. the full timeline has run & {{#crossLink \"Timeline/loop:property\"}}{{/crossLink}}\n\t * is `false`).\n\t **/\n\tp.setPosition = function(value, actionsMode) {\n\t\tvar t = this._calcPosition(value);\n\t\tvar end = !this.loop && value >= this.duration;\n\t\tif (t == this._prevPos) { return end; }\n\t\tthis._prevPosition = value;\n\t\tthis.position = this._prevPos = t; // in case an action changes the current frame.\n\t\tfor (var i=0, l=this._tweens.length; i<l; i++) {\n\t\t\tthis._tweens[i].setPosition(t, actionsMode);\n\t\t\tif (t != this._prevPos) { return false; } // an action changed this timeline's position.\n\t\t}\n\t\tif (end) { this.setPaused(true); }\n\t\tthis.dispatchEvent(\"change\");\n\t\treturn end;\n\t};\n\n\t/**\n\t * Pauses or plays this timeline.\n\t * @method setPaused\n\t * @param {Boolean} value Indicates whether the tween should be paused (`true`) or played (`false`).\n\t **/\n\tp.setPaused = function(value) {\n\t\tthis._paused = !!value; \n\t\tcreatejs.Tween._register(this, !value);\n\t};\n\n\t/**\n\t * Recalculates the duration of the timeline. The duration is automatically updated when tweens are added or removed,\n\t * but this method is useful if you modify a tween after it was added to the timeline.\n\t * @method updateDuration\n\t **/\n\tp.updateDuration = function() {\n\t\tthis.duration = 0;\n\t\tfor (var i=0,l=this._tweens.length; i<l; i++) {\n\t\t\tvar tween = this._tweens[i];\n\t\t\tif (tween.duration > this.duration) { this.duration = tween.duration; }\n\t\t}\n\t};\n\n\t/**\n\t * Advances this timeline by the specified amount of time in milliseconds (or ticks if `useTicks` is `true`).\n\t * This is normally called automatically by the Tween engine (via the {{#crossLink \"Tween/tick:event\"}}{{/crossLink}}\n\t * event), but is exposed for advanced uses.\n\t * @method tick\n\t * @param {Number} delta The time to advance in milliseconds (or ticks if useTicks is true).\n\t **/\n\tp.tick = function(delta) {\n\t\tthis.setPosition(this._prevPosition+delta);\n\t};\n\n\t/**\n\t * If a numeric position is passed, it is returned unchanged. If a string is passed, the position of the\n\t * corresponding frame label will be returned, or `null` if a matching label is not defined.\n\t * @method resolve\n\t * @param {String|Number} positionOrLabel A numeric position value or label string.\n\t **/\n\tp.resolve = function(positionOrLabel) {\n\t\tvar pos = Number(positionOrLabel);\n\t\tif (isNaN(pos)) { pos = this._labels[positionOrLabel]; }\n\t\treturn pos;\n\t};\n\n\t/**\n\t* Returns a string representation of this object.\n\t* @method toString\n\t* @return {String} a string representation of the instance.\n\t**/\n\tp.toString = function() {\n\t\treturn \"[Timeline]\";\n\t};\n\n\t/**\n\t * @method clone\n\t * @protected\n\t **/\n\tp.clone = function() {\n\t\tthrow(\"Timeline can not be cloned.\")\n\t};\n\n// private methods:\n\t/**\n\t * @method _goto\n\t * @param {String | Number} positionOrLabel\n\t * @protected\n\t **/\n\tp._goto = function(positionOrLabel) {\n\t\tvar pos = this.resolve(positionOrLabel);\n\t\tif (pos != null) { this.setPosition(pos); }\n\t};\n\t\n\t/**\n\t * @method _calcPosition\n\t * @param {Number} value\n\t * @return {Number}\n\t * @protected\n\t **/\n\tp._calcPosition = function(value) {\n\t\tif (value < 0) { return 0; }\n\t\tif (value < this.duration) { return value; }\n\t\treturn this.loop ? value%this.duration : this.duration;\n\t};\n\n\tcreatejs.Timeline = createjs.promote(Timeline, \"EventDispatcher\");\n\n}());\n\n//##############################################################################\n// Ease.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * The Ease class provides a collection of easing functions for use with TweenJS. It does not use the standard 4 param\n\t * easing signature. Instead it uses a single param which indicates the current linear ratio (0 to 1) of the tween.\n\t *\n\t * Most methods on Ease can be passed directly as easing functions:\n\t *\n\t *      Tween.get(target).to({x:100}, 500, Ease.linear);\n\t *\n\t * However, methods beginning with \"get\" will return an easing function based on parameter values:\n\t *\n\t *      Tween.get(target).to({y:200}, 500, Ease.getPowIn(2.2));\n\t *\n\t * Please see the <a href=\"http://www.createjs.com/Demos/TweenJS/Tween_SparkTable\">spark table demo</a> for an\n\t * overview of the different ease types on <a href=\"http://tweenjs.com\">TweenJS.com</a>.\n\t *\n\t * <em>Equations derived from work by Robert Penner.</em>\n\t * @class Ease\n\t * @static\n\t **/\n\tfunction Ease() {\n\t\tthrow \"Ease cannot be instantiated.\";\n\t}\n\n\n// static methods and properties\n\t/**\n\t * @method linear\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.linear = function(t) { return t; };\n\n\t/**\n\t * Identical to linear.\n\t * @method none\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.none = Ease.linear;\n\n\t/**\n\t * Mimics the simple -100 to 100 easing in Flash Pro.\n\t * @method get\n\t * @param {Number} amount A value from -1 (ease in) to 1 (ease out) indicating the strength and direction of the ease.\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.get = function(amount) {\n\t\tif (amount < -1) { amount = -1; }\n\t\tif (amount > 1) { amount = 1; }\n\t\treturn function(t) {\n\t\t\tif (amount==0) { return t; }\n\t\t\tif (amount<0) { return t*(t*-amount+1+amount); }\n\t\t\treturn t*((2-t)*amount+(1-amount));\n\t\t};\n\t};\n\n\t/**\n\t * Configurable exponential ease.\n\t * @method getPowIn\n\t * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getPowIn = function(pow) {\n\t\treturn function(t) {\n\t\t\treturn Math.pow(t,pow);\n\t\t};\n\t};\n\n\t/**\n\t * Configurable exponential ease.\n\t * @method getPowOut\n\t * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getPowOut = function(pow) {\n\t\treturn function(t) {\n\t\t\treturn 1-Math.pow(1-t,pow);\n\t\t};\n\t};\n\n\t/**\n\t * Configurable exponential ease.\n\t * @method getPowInOut\n\t * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getPowInOut = function(pow) {\n\t\treturn function(t) {\n\t\t\tif ((t*=2)<1) return 0.5*Math.pow(t,pow);\n\t\t\treturn 1-0.5*Math.abs(Math.pow(2-t,pow));\n\t\t};\n\t};\n\n\t/**\n\t * @method quadIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quadIn = Ease.getPowIn(2);\n\t/**\n\t * @method quadOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quadOut = Ease.getPowOut(2);\n\t/**\n\t * @method quadInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quadInOut = Ease.getPowInOut(2);\n\n\t/**\n\t * @method cubicIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.cubicIn = Ease.getPowIn(3);\n\t/**\n\t * @method cubicOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.cubicOut = Ease.getPowOut(3);\n\t/**\n\t * @method cubicInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.cubicInOut = Ease.getPowInOut(3);\n\n\t/**\n\t * @method quartIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quartIn = Ease.getPowIn(4);\n\t/**\n\t * @method quartOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quartOut = Ease.getPowOut(4);\n\t/**\n\t * @method quartInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quartInOut = Ease.getPowInOut(4);\n\n\t/**\n\t * @method quintIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quintIn = Ease.getPowIn(5);\n\t/**\n\t * @method quintOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quintOut = Ease.getPowOut(5);\n\t/**\n\t * @method quintInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.quintInOut = Ease.getPowInOut(5);\n\n\t/**\n\t * @method sineIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.sineIn = function(t) {\n\t\treturn 1-Math.cos(t*Math.PI/2);\n\t};\n\n\t/**\n\t * @method sineOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.sineOut = function(t) {\n\t\treturn Math.sin(t*Math.PI/2);\n\t};\n\n\t/**\n\t * @method sineInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.sineInOut = function(t) {\n\t\treturn -0.5*(Math.cos(Math.PI*t) - 1);\n\t};\n\n\t/**\n\t * Configurable \"back in\" ease.\n\t * @method getBackIn\n\t * @param {Number} amount The strength of the ease.\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getBackIn = function(amount) {\n\t\treturn function(t) {\n\t\t\treturn t*t*((amount+1)*t-amount);\n\t\t};\n\t};\n\t/**\n\t * @method backIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.backIn = Ease.getBackIn(1.7);\n\n\t/**\n\t * Configurable \"back out\" ease.\n\t * @method getBackOut\n\t * @param {Number} amount The strength of the ease.\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getBackOut = function(amount) {\n\t\treturn function(t) {\n\t\t\treturn (--t*t*((amount+1)*t + amount) + 1);\n\t\t};\n\t};\n\t/**\n\t * @method backOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.backOut = Ease.getBackOut(1.7);\n\n\t/**\n\t * Configurable \"back in out\" ease.\n\t * @method getBackInOut\n\t * @param {Number} amount The strength of the ease.\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getBackInOut = function(amount) {\n\t\tamount*=1.525;\n\t\treturn function(t) {\n\t\t\tif ((t*=2)<1) return 0.5*(t*t*((amount+1)*t-amount));\n\t\t\treturn 0.5*((t-=2)*t*((amount+1)*t+amount)+2);\n\t\t};\n\t};\n\t/**\n\t * @method backInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.backInOut = Ease.getBackInOut(1.7);\n\n\t/**\n\t * @method circIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.circIn = function(t) {\n\t\treturn -(Math.sqrt(1-t*t)- 1);\n\t};\n\n\t/**\n\t * @method circOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.circOut = function(t) {\n\t\treturn Math.sqrt(1-(--t)*t);\n\t};\n\n\t/**\n\t * @method circInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.circInOut = function(t) {\n\t\tif ((t*=2) < 1) return -0.5*(Math.sqrt(1-t*t)-1);\n\t\treturn 0.5*(Math.sqrt(1-(t-=2)*t)+1);\n\t};\n\n\t/**\n\t * @method bounceIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.bounceIn = function(t) {\n\t\treturn 1-Ease.bounceOut(1-t);\n\t};\n\n\t/**\n\t * @method bounceOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.bounceOut = function(t) {\n\t\tif (t < 1/2.75) {\n\t\t\treturn (7.5625*t*t);\n\t\t} else if (t < 2/2.75) {\n\t\t\treturn (7.5625*(t-=1.5/2.75)*t+0.75);\n\t\t} else if (t < 2.5/2.75) {\n\t\t\treturn (7.5625*(t-=2.25/2.75)*t+0.9375);\n\t\t} else {\n\t\t\treturn (7.5625*(t-=2.625/2.75)*t +0.984375);\n\t\t}\n\t};\n\n\t/**\n\t * @method bounceInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.bounceInOut = function(t) {\n\t\tif (t<0.5) return Ease.bounceIn (t*2) * .5;\n\t\treturn Ease.bounceOut(t*2-1)*0.5+0.5;\n\t};\n\n\t/**\n\t * Configurable elastic ease.\n\t * @method getElasticIn\n\t * @param {Number} amplitude\n\t * @param {Number} period\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getElasticIn = function(amplitude,period) {\n\t\tvar pi2 = Math.PI*2;\n\t\treturn function(t) {\n\t\t\tif (t==0 || t==1) return t;\n\t\t\tvar s = period/pi2*Math.asin(1/amplitude);\n\t\t\treturn -(amplitude*Math.pow(2,10*(t-=1))*Math.sin((t-s)*pi2/period));\n\t\t};\n\t};\n\t/**\n\t * @method elasticIn\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.elasticIn = Ease.getElasticIn(1,0.3);\n\n\t/**\n\t * Configurable elastic ease.\n\t * @method getElasticOut\n\t * @param {Number} amplitude\n\t * @param {Number} period\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getElasticOut = function(amplitude,period) {\n\t\tvar pi2 = Math.PI*2;\n\t\treturn function(t) {\n\t\t\tif (t==0 || t==1) return t;\n\t\t\tvar s = period/pi2 * Math.asin(1/amplitude);\n\t\t\treturn (amplitude*Math.pow(2,-10*t)*Math.sin((t-s)*pi2/period )+1);\n\t\t};\n\t};\n\t/**\n\t * @method elasticOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.elasticOut = Ease.getElasticOut(1,0.3);\n\n\t/**\n\t * Configurable elastic ease.\n\t * @method getElasticInOut\n\t * @param {Number} amplitude\n\t * @param {Number} period\n\t * @static\n\t * @return {Function}\n\t **/\n\tEase.getElasticInOut = function(amplitude,period) {\n\t\tvar pi2 = Math.PI*2;\n\t\treturn function(t) {\n\t\t\tvar s = period/pi2 * Math.asin(1/amplitude);\n\t\t\tif ((t*=2)<1) return -0.5*(amplitude*Math.pow(2,10*(t-=1))*Math.sin( (t-s)*pi2/period ));\n\t\t\treturn amplitude*Math.pow(2,-10*(t-=1))*Math.sin((t-s)*pi2/period)*0.5+1;\n\t\t};\n\t};\n\t/**\n\t * @method elasticInOut\n\t * @param {Number} t\n\t * @static\n\t * @return {Number}\n\t **/\n\tEase.elasticInOut = Ease.getElasticInOut(1,0.3*1.5);\n\n\tcreatejs.Ease = Ease;\n\n}());\n\n//##############################################################################\n// MotionGuidePlugin.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * A TweenJS plugin for working with motion guides.\n\t *\n\t * To use, install the plugin after TweenJS has loaded. Next tween the 'guide' property with an object as detailed below.\n\t *\n\t *       createjs.MotionGuidePlugin.install();\n\t *\n\t * <h4>Example</h4>\n\t *\n\t *      // Using a Motion Guide\n\t *\t    createjs.Tween.get(target).to({guide:{ path:[0,0, 0,200,200,200, 200,0,0,0] }},7000);\n\t *\t    // Visualizing the line\n\t *\t    graphics.moveTo(0,0).curveTo(0,200,200,200).curveTo(200,0,0,0);\n\t *\n\t * Each path needs pre-computation to ensure there's fast performance. Because of the pre-computation there's no\n\t * built in support for path changes mid tween. These are the Guide Object's properties:<UL>\n\t *      <LI> path: Required, Array : The x/y points used to draw the path with a moveTo and 1 to n curveTo calls.</LI>\n\t *      <LI> start: Optional, 0-1 : Initial position, default 0 except for when continuing along the same path.</LI>\n\t *      <LI> end: Optional, 0-1 : Final position, default 1 if not specified.</LI>\n\t *      <LI> orient: Optional, string : \"fixed\"/\"auto\"/\"cw\"/\"ccw\"<UL>\n\t *\t\t\t\t<LI>\"fixed\" forces the object to face down the path all movement (relative to start rotation),</LI>\n\t *      \t\t<LI>\"auto\" rotates the object along the path relative to the line.</LI>\n\t *      \t\t<LI>\"cw\"/\"ccw\" force clockwise or counter clockwise rotations including flash like behaviour</LI>\n\t * \t\t</UL></LI>\n\t * </UL>\n\t * Guide objects should not be shared between tweens even if all properties are identical, the library stores\n\t * information on these objects in the background and sharing them can cause unexpected behaviour. Values\n\t * outside 0-1 range of tweens will be a \"best guess\" from the appropriate part of the defined curve.\n\t *\n\t * @class MotionGuidePlugin\n\t * @constructor\n\t **/\n\tfunction MotionGuidePlugin() {\n\t\tthrow(\"MotionGuidePlugin cannot be instantiated.\")\n\t};\n\n\n// static properties:\n\t/**\n\t * @property priority\n\t * @protected\n\t * @static\n\t **/\n\tMotionGuidePlugin.priority = 0; // high priority, should run sooner\n\n\t/**\n\t * @property temporary variable storage\n\t * @private\n\t * @static\n\t */\n\tMotionGuidePlugin._rotOffS;\n\t/**\n\t * @property temporary variable storage\n\t * @private\n\t * @static\n\t */\n\tMotionGuidePlugin._rotOffE;\n\t/**\n\t * @property temporary variable storage\n\t * @private\n\t * @static\n\t */\n\tMotionGuidePlugin._rotNormS;\n\t/**\n\t * @property temporary variable storage\n\t * @private\n\t * @static\n\t */\n\tMotionGuidePlugin._rotNormE;\n\n\n// static methods\n\t/**\n\t * Installs this plugin for use with TweenJS. Call this once after TweenJS is loaded to enable this plugin.\n\t * @method install\n\t * @static\n\t **/\n\tMotionGuidePlugin.install = function() {\n\t\tcreatejs.Tween.installPlugin(MotionGuidePlugin, [\"guide\", \"x\", \"y\", \"rotation\"]);\n\t\treturn createjs.Tween.IGNORE;\n\t};\n\n\t/**\n\t * @method init\n\t * @protected\n\t * @static\n\t **/\n\tMotionGuidePlugin.init = function(tween, prop, value) {\n\t\tvar target = tween.target;\n\t\tif(!target.hasOwnProperty(\"x\")){ target.x = 0; }\n\t\tif(!target.hasOwnProperty(\"y\")){ target.y = 0; }\n\t\tif(!target.hasOwnProperty(\"rotation\")){ target.rotation = 0; }\n\n\t\tif(prop==\"rotation\"){ tween.__needsRot = true; }\n\t\treturn prop==\"guide\"?null:value;\n\t};\n\n\t/**\n\t * @method step\n\t * @protected\n\t * @static\n\t **/\n\tMotionGuidePlugin.step = function(tween, prop, startValue, endValue, injectProps) {\n\t\t// other props\n\t\tif(prop == \"rotation\"){\n\t\t\ttween.__rotGlobalS = startValue;\n\t\t\ttween.__rotGlobalE = endValue;\n\t\t\tMotionGuidePlugin.testRotData(tween, injectProps);\n\t\t}\n\t\tif(prop != \"guide\"){ return endValue; }\n\n\t\t// guide only information - Start -\n\t\tvar temp, data = endValue;\n\t\tif(!data.hasOwnProperty(\"path\")){ data.path = []; }\n\t\tvar path = data.path;\n\t\tif(!data.hasOwnProperty(\"end\")){ data.end = 1; }\n\t\tif(!data.hasOwnProperty(\"start\")){\n\t\t\tdata.start = (startValue&&startValue.hasOwnProperty(\"end\")&&startValue.path===path)?startValue.end:0;\n\t\t}\n\n\t\t// Figure out subline information\n\t\tif(data.hasOwnProperty(\"_segments\") && data._length){ return endValue; }\n\t\tvar l = path.length;\n\t\tvar accuracy = 10;\t\t// Adjust to improve line following precision but sacrifice performance (# of seg)\n\t\tif(l >= 6 && (l-2) % 4 == 0){\t// Enough points && contains correct number per entry ignoring start\n\t\t\tdata._segments = [];\n\t\t\tdata._length = 0;\n\t\t\tfor(var i=2; i<l; i+=4){\n\t\t\t\tvar sx = path[i-2], sy = path[i-1];\n\t\t\t\tvar cx = path[i+0], cy = path[i+1];\n\t\t\t\tvar ex = path[i+2], ey = path[i+3];\n\t\t\t\tvar oldX = sx, oldY = sy;\n\t\t\t\tvar tempX, tempY, total = 0;\n\t\t\t\tvar sublines = [];\n\t\t\t\tfor(var j=1; j<=accuracy; j++){\n\t\t\t\t\tvar t = j/accuracy;\n\t\t\t\t\tvar inv = 1 - t;\n\t\t\t\t\ttempX = inv*inv * sx + 2 * inv * t * cx + t*t * ex;\n\t\t\t\t\ttempY = inv*inv * sy + 2 * inv * t * cy + t*t * ey;\n\t\t\t\t\ttotal += sublines[sublines.push(Math.sqrt((temp=tempX-oldX)*temp + (temp=tempY-oldY)*temp))-1];\n\t\t\t\t\toldX = tempX;\n\t\t\t\t\toldY = tempY;\n\t\t\t\t}\n\t\t\t\tdata._segments.push(total);\n\t\t\t\tdata._segments.push(sublines);\n\t\t\t\tdata._length += total;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow(\"invalid 'path' data, please see documentation for valid paths\");\n\t\t}\n\n\t\t// Setup x/y tweens\n\t\ttemp = data.orient;\n\t\tdata.orient = true;\n\t\tvar o = {};\n\t\tMotionGuidePlugin.calc(data, data.start, o);\n\t\ttween.__rotPathS = Number(o.rotation.toFixed(5));\n\t\tMotionGuidePlugin.calc(data, data.end, o);\n\t\ttween.__rotPathE = Number(o.rotation.toFixed(5));\n\t\tdata.orient = false;\t//here and now we don't know if we need to\n\t\tMotionGuidePlugin.calc(data, data.end, injectProps);\n\t\tdata.orient = temp;\n\n\t\t// Setup rotation properties\n\t\tif(!data.orient){ return endValue; }\n\t\ttween.__guideData = data;\n\t\tMotionGuidePlugin.testRotData(tween, injectProps);\n\t\treturn endValue;\n\t};\n\n\t/**\n\t * @method testRotData\n\t * @protected\n\t * @static\n\t **/\n\tMotionGuidePlugin.testRotData = function(tween, injectProps){\n\n\t\t// no rotation informat? if we need it come back, if we don't use 0 & ensure we have guide data\n\t\tif(tween.__rotGlobalS === undefined || tween.__rotGlobalE === undefined){\n\t\t\tif(tween.__needsRot){ return; }\n\t\t\tif(tween._curQueueProps.rotation !== undefined){\n\t\t\t\ttween.__rotGlobalS = tween.__rotGlobalE = tween._curQueueProps.rotation;\n\t\t\t} else {\n\t\t\t\ttween.__rotGlobalS = tween.__rotGlobalE = injectProps.rotation = tween.target.rotation || 0;\n\t\t\t}\n\t\t}\n\t\tif(tween.__guideData === undefined){ return; }\n\n\t\t// Process rotation properties\n\t\tvar data = tween.__guideData;\n\t\tvar rotGlobalD = tween.__rotGlobalE - tween.__rotGlobalS;\n\t\tvar rotPathD = tween.__rotPathE - tween.__rotPathS;\n\t\tvar rot = rotGlobalD - rotPathD;\n\n\t\tif(data.orient == \"auto\"){\n\t\t\tif(rot > 180){\t\t\trot -= 360; }\n\t\t\telse if(rot < -180){\trot += 360; }\n\n\t\t} else if(data.orient == \"cw\"){\n\t\t\twhile(rot < 0){ rot += 360; }\n\t\t\tif(rot == 0 && rotGlobalD > 0 && rotGlobalD != 180){ rot += 360; }\n\n\t\t} else if(data.orient == \"ccw\"){\n\t\t\trot = rotGlobalD - ((rotPathD > 180)?(360-rotPathD):(rotPathD));\t// sign flipping on path\n\t\t\twhile(rot > 0){ rot -= 360; }\n\t\t\tif(rot == 0 && rotGlobalD < 0 && rotGlobalD != -180){ rot -= 360; }\n\t\t}\n\n\t\tdata.rotDelta = rot;\n\t\tdata.rotOffS = tween.__rotGlobalS - tween.__rotPathS;\n\n\t\t// reset\n\t\ttween.__rotGlobalS = tween.__rotGlobalE = tween.__guideData = tween.__needsRot = undefined;\n\t};\n\n\t/**\n\t * @method tween\n\t * @protected\n\t * @static\n\t **/\n\tMotionGuidePlugin.tween = function(tween, prop, value, startValues, endValues, ratio, wait, end) {\n\t\tvar data = endValues.guide;\n\t\tif(data == undefined || data === startValues.guide){ return value; }\n\t\tif(data.lastRatio != ratio){\n\t\t\t// first time through so calculate what I need to\n\t\t\tvar t = ((data.end-data.start)*(wait?data.end:ratio)+data.start);\n\t\t\tMotionGuidePlugin.calc(data, t, tween.target);\n\t\t\tswitch(data.orient){\n\t\t\t\tcase \"cw\":\t\t// mix in the original rotation\n\t\t\t\tcase \"ccw\":\n\t\t\t\tcase \"auto\": tween.target.rotation += data.rotOffS + data.rotDelta*ratio; break;\n\t\t\t\tcase \"fixed\":\t// follow fixed behaviour to solve potential issues\n\t\t\t\tdefault: tween.target.rotation += data.rotOffS; break;\n\t\t\t}\n\t\t\tdata.lastRatio = ratio;\n\t\t}\n\t\tif(prop == \"rotation\" && ((!data.orient) || data.orient == \"false\")){ return value; }\n\t\treturn tween.target[prop];\n\t};\n\n\t/**\n\t * Determine the appropriate x/y/rotation information about a path for a given ratio along the path.\n\t * Assumes a path object with all optional parameters specified.\n\t * @param data Data object you would pass to the \"guide:\" property in a Tween\n\t * @param ratio 0-1 Distance along path, values outside 0-1 are \"best guess\"\n\t * @param target Object to copy the results onto, will use a new object if not supplied.\n\t * @return {Object} The target object or a new object w/ the tweened properties\n\t * @static\n\t */\n\tMotionGuidePlugin.calc = function(data, ratio, target) {\n\t\tif(data._segments == undefined){ throw(\"Missing critical pre-calculated information, please file a bug\"); }\n\t\tif(target == undefined){ target = {x:0, y:0, rotation:0}; }\n\t\tvar seg = data._segments;\n\t\tvar path = data.path;\n\n\t\t// find segment\n\t\tvar pos = data._length * ratio;\n\t\tvar cap = seg.length - 2;\n\t\tvar n = 0;\n\t\twhile(pos > seg[n] && n < cap){\n\t\t\tpos -= seg[n];\n\t\t\tn+=2;\n\t\t}\n\n\t\t// find subline\n\t\tvar sublines = seg[n+1];\n\t\tvar i = 0;\n\t\tcap = sublines.length-1;\n\t\twhile(pos > sublines[i] && i < cap){\n\t\t\tpos -= sublines[i];\n\t\t\ti++;\n\t\t}\n\t\tvar t = (i/++cap)+(pos/(cap*sublines[i]));\n\n\t\t// find x/y\n\t\tn = (n*2)+2;\n\t\tvar inv = 1 - t;\n\t\ttarget.x = inv*inv * path[n-2] + 2 * inv * t * path[n+0] + t*t * path[n+2];\n\t\ttarget.y = inv*inv * path[n-1] + 2 * inv * t * path[n+1] + t*t * path[n+3];\n\n\t\t// orientation\n\t\tif(data.orient){\n\t\t\ttarget.rotation = 57.2957795 * Math.atan2(\n\t\t\t\t(path[n+1]-path[n-1])*inv + (path[n+3]-path[n+1])*t,\n\t\t\t\t(path[n+0]-path[n-2])*inv + (path[n+2]-path[n+0])*t);\n\t\t}\n\n\t\treturn target;\n\t};\n\n\tcreatejs.MotionGuidePlugin = MotionGuidePlugin;\n\n}());\n\n//##############################################################################\n// version.js\n//##############################################################################\n\n(function() {\n\t\"use strict\";\n\n\t/**\n\t * Static class holding library specific information such as the version and buildDate of\n\t * the library.\n\t * @class TweenJS\n\t **/\n\tvar s = createjs.TweenJS = createjs.TweenJS || {};\n\n\t/**\n\t * The version string for this release.\n\t * @property version\n\t * @type String\n\t * @static\n\t **/\n\ts.version = /*=version*/\"0.6.2\"; // injected by build process\n\n\t/**\n\t * The build date for this release in UTC format.\n\t * @property buildDate\n\t * @type String\n\t * @static\n\t **/\n\ts.buildDate = /*=date*/\"Thu, 26 Nov 2015 20:44:31 GMT\"; // injected by build process\n\n})();\nif(typeof module !== \"undefined\" && typeof module.exports !== \"undefined\") module.exports = this.createjs;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1337)(module), __webpack_require__(71)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM0My5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vY3JlYXRlanMtbW9kdWxlL2NyZWF0ZWpzLmpzP2E5MjEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNyZWF0ZWpzID0gKHRoaXMuY3JlYXRlanMgPSAodGhpcy5jcmVhdGVqcyB8fCB7fSkpO1xuLyohXG4qIENyZWF0ZUpTXG4qIFZpc2l0IGh0dHA6Ly9jcmVhdGVqcy5jb20vIGZvciBkb2N1bWVudGF0aW9uLCB1cGRhdGVzIGFuZCBleGFtcGxlcy5cbipcbiogQ29weXJpZ2h0IChjKSAyMDEwIGdza2lubmVyLmNvbSwgaW5jLlxuKlxuKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4qIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4qIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuKiBjb25kaXRpb25zOlxuKlxuKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbipcbiogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4qIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4qIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4qIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIGV4dGVuZC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuLyoqXG4gKiBAY2xhc3MgVXRpbGl0eSBNZXRob2RzXG4gKi9cblxuLyoqXG4gKiBTZXRzIHVwIHRoZSBwcm90b3R5cGUgY2hhaW4gYW5kIGNvbnN0cnVjdG9yIHByb3BlcnR5IGZvciBhIG5ldyBjbGFzcy5cbiAqXG4gKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgcmlnaHQgYWZ0ZXIgY3JlYXRpbmcgdGhlIGNsYXNzIGNvbnN0cnVjdG9yLlxuICpcbiAqIFx0ZnVuY3Rpb24gTXlTdWJDbGFzcygpIHt9XG4gKiBcdGNyZWF0ZWpzLmV4dGVuZChNeVN1YkNsYXNzLCBNeVN1cGVyQ2xhc3MpO1xuICogXHRNeVN1YkNsYXNzLnByb3RvdHlwZS5kb1NvbWV0aGluZyA9IGZ1bmN0aW9uKCkgeyB9XG4gKlxuICogXHR2YXIgZm9vID0gbmV3IE15U3ViQ2xhc3MoKTtcbiAqIFx0Y29uc29sZS5sb2coZm9vIGluc3RhbmNlb2YgTXlTdXBlckNsYXNzKTsgLy8gdHJ1ZVxuICogXHRjb25zb2xlLmxvZyhmb28ucHJvdG90eXBlLmNvbnN0cnVjdG9yID09PSBNeVN1YkNsYXNzKTsgLy8gdHJ1ZVxuICpcbiAqIEBtZXRob2QgZXh0ZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJjbGFzcyBUaGUgc3ViY2xhc3MuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdXBlcmNsYXNzIFRoZSBzdXBlcmNsYXNzIHRvIGV4dGVuZC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBzdWJjbGFzcydzIG5ldyBwcm90b3R5cGUuXG4gKi9cbmNyZWF0ZWpzLmV4dGVuZCA9IGZ1bmN0aW9uKHN1YmNsYXNzLCBzdXBlcmNsYXNzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGZ1bmN0aW9uIG8oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBzdWJjbGFzczsgfVxuXHRvLnByb3RvdHlwZSA9IHN1cGVyY2xhc3MucHJvdG90eXBlO1xuXHRyZXR1cm4gKHN1YmNsYXNzLnByb3RvdHlwZSA9IG5ldyBvKCkpO1xufTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIHByb21vdGUuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbi8qKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbi8qKlxuICogUHJvbW90ZXMgYW55IG1ldGhvZHMgb24gdGhlIHN1cGVyIGNsYXNzIHRoYXQgd2VyZSBvdmVycmlkZGVuLCBieSBjcmVhdGluZyBhbiBhbGlhcyBpbiB0aGUgZm9ybWF0IGBwcmVmaXhfbWV0aG9kTmFtZWAuXG4gKiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgdGhlIHN1cGVyIGNsYXNzJ3MgbmFtZSBhcyB0aGUgcHJlZml4LlxuICogQW4gYWxpYXMgdG8gdGhlIHN1cGVyIGNsYXNzJ3MgY29uc3RydWN0b3IgaXMgYWx3YXlzIGFkZGVkIGluIHRoZSBmb3JtYXQgYHByZWZpeF9jb25zdHJ1Y3RvcmAuXG4gKiBUaGlzIGFsbG93cyB0aGUgc3ViY2xhc3MgdG8gY2FsbCBzdXBlciBjbGFzcyBtZXRob2RzIHdpdGhvdXQgdXNpbmcgYGZ1bmN0aW9uLmNhbGxgLCBwcm92aWRpbmcgYmV0dGVyIHBlcmZvcm1hbmNlLlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiBgTXlTdWJDbGFzc2AgZXh0ZW5kcyBgTXlTdXBlckNsYXNzYCwgYW5kIGJvdGggZGVmaW5lIGEgYGRyYXdgIG1ldGhvZCwgdGhlbiBjYWxsaW5nIGBwcm9tb3RlKE15U3ViQ2xhc3MsIFwiTXlTdXBlckNsYXNzXCIpYFxuICogd291bGQgYWRkIGEgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAgbWV0aG9kIHRvIE15U3ViQ2xhc3MgYW5kIHByb21vdGUgdGhlIGBkcmF3YCBtZXRob2Qgb24gYE15U3VwZXJDbGFzc2AgdG8gdGhlXG4gKiBwcm90b3R5cGUgb2YgYE15U3ViQ2xhc3NgIGFzIGBNeVN1cGVyQ2xhc3NfZHJhd2AuXG4gKlxuICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHRoZSBjbGFzcydzIHByb3RvdHlwZSBpcyBmdWxseSBkZWZpbmVkLlxuICpcbiAqIFx0ZnVuY3Rpb24gQ2xhc3NBKG5hbWUpIHtcbiAqIFx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuICogXHR9XG4gKiBcdENsYXNzQS5wcm90b3R5cGUuZ3JlZXQgPSBmdW5jdGlvbigpIHtcbiAqIFx0XHRyZXR1cm4gXCJIZWxsbyBcIit0aGlzLm5hbWU7XG4gKiBcdH1cbiAqXG4gKiBcdGZ1bmN0aW9uIENsYXNzQihuYW1lLCBwdW5jdHVhdGlvbikge1xuICogXHRcdHRoaXMuQ2xhc3NBX2NvbnN0cnVjdG9yKG5hbWUpO1xuICogXHRcdHRoaXMucHVuY3R1YXRpb24gPSBwdW5jdHVhdGlvbjtcbiAqIFx0fVxuICogXHRjcmVhdGVqcy5leHRlbmQoQ2xhc3NCLCBDbGFzc0EpO1xuICogXHRDbGFzc0IucHJvdG90eXBlLmdyZWV0ID0gZnVuY3Rpb24oKSB7XG4gKiBcdFx0cmV0dXJuIHRoaXMuQ2xhc3NBX2dyZWV0KCkrdGhpcy5wdW5jdHVhdGlvbjtcbiAqIFx0fVxuICogXHRjcmVhdGVqcy5wcm9tb3RlKENsYXNzQiwgXCJDbGFzc0FcIik7XG4gKlxuICogXHR2YXIgZm9vID0gbmV3IENsYXNzQihcIldvcmxkXCIsIFwiIT8hXCIpO1xuICogXHRjb25zb2xlLmxvZyhmb28uZ3JlZXQoKSk7IC8vIEhlbGxvIFdvcmxkIT8hXG4gKlxuICogQG1ldGhvZCBwcm9tb3RlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJjbGFzcyBUaGUgY2xhc3MgdG8gcHJvbW90ZSBzdXBlciBjbGFzcyBtZXRob2RzIG9uLlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBUaGUgcHJlZml4IHRvIGFkZCB0byB0aGUgcHJvbW90ZWQgbWV0aG9kIG5hbWVzLiBVc3VhbGx5IHRoZSBuYW1lIG9mIHRoZSBzdXBlcmNsYXNzLlxuICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgdGhlIHN1YmNsYXNzLlxuICovXG5jcmVhdGVqcy5wcm9tb3RlID0gZnVuY3Rpb24oc3ViY2xhc3MsIHByZWZpeCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHR2YXIgc3ViUCA9IHN1YmNsYXNzLnByb3RvdHlwZSwgc3VwUCA9IChPYmplY3QuZ2V0UHJvdG90eXBlT2YmJk9iamVjdC5nZXRQcm90b3R5cGVPZihzdWJQKSl8fHN1YlAuX19wcm90b19fO1xuXHRpZiAoc3VwUCkge1xuXHRcdHN1YlBbKHByZWZpeCs9XCJfXCIpICsgXCJjb25zdHJ1Y3RvclwiXSA9IHN1cFAuY29uc3RydWN0b3I7IC8vIGNvbnN0cnVjdG9yIGlzIG5vdCBhbHdheXMgaW5udW1lcmFibGVcblx0XHRmb3IgKHZhciBuIGluIHN1cFApIHtcblx0XHRcdGlmIChzdWJQLmhhc093blByb3BlcnR5KG4pICYmICh0eXBlb2Ygc3VwUFtuXSA9PSBcImZ1bmN0aW9uXCIpKSB7IHN1YlBbcHJlZml4ICsgbl0gPSBzdXBQW25dOyB9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBzdWJjbGFzcztcbn07XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBpbmRleE9mLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4vKipcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqL1xuXG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGEgc3BlY2lmaWVkIHZhbHVlIHNlYXJjaEVsZW1lbnQgaW4gdGhlIHBhc3NlZCBpbiBhcnJheSwgYW5kIHJldHVybnMgdGhlIGluZGV4IG9mXG4gKiB0aGF0IHZhbHVlLiAgUmV0dXJucyAtMSBpZiB2YWx1ZSBpcyBub3QgZm91bmQuXG4gKlxuICogICAgICB2YXIgaSA9IGNyZWF0ZWpzLmluZGV4T2YobXlBcnJheSwgbXlFbGVtZW50VG9GaW5kKTtcbiAqXG4gKiBAbWV0aG9kIGluZGV4T2ZcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIHNlYXJjaCBmb3Igc2VhcmNoRWxlbWVudFxuICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgRWxlbWVudCB0byBmaW5kIGluIGFycmF5LlxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgZmlyc3QgaW5kZXggb2Ygc2VhcmNoRWxlbWVudCBpbiBhcnJheS5cbiAqL1xuY3JlYXRlanMuaW5kZXhPZiA9IGZ1bmN0aW9uIChhcnJheSwgc2VhcmNoRWxlbWVudCl7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGZvciAodmFyIGkgPSAwLGw9YXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0aWYgKHNlYXJjaEVsZW1lbnQgPT09IGFycmF5W2ldKSB7XG5cdFx0XHRyZXR1cm4gaTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIC0xO1xufTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEV2ZW50LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIENvbnRhaW5zIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgc2hhcmVkIGJ5IGFsbCBldmVudHMgZm9yIHVzZSB3aXRoXG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogXG5cdCAqIE5vdGUgdGhhdCBFdmVudCBvYmplY3RzIGFyZSBvZnRlbiByZXVzZWQsIHNvIHlvdSBzaG91bGQgbmV2ZXJcblx0ICogcmVseSBvbiBhbiBldmVudCBvYmplY3QncyBzdGF0ZSBvdXRzaWRlIG9mIHRoZSBjYWxsIHN0YWNrIGl0IHdhcyByZWNlaXZlZCBpbi5cblx0ICogQGNsYXNzIEV2ZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGJ1YmJsZXMgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50IHdpbGwgYnViYmxlIHRocm91Z2ggdGhlIGRpc3BsYXkgbGlzdC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBjYW5jZWxhYmxlIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiB0aGlzIGV2ZW50IGNhbiBiZSBjYW5jZWxsZWQuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIEV2ZW50KHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUpIHtcblx0XHRcblx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSB0eXBlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICoqL1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBvYmplY3QgdGhhdCBnZW5lcmF0ZWQgYW4gZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IHRhcmdldFxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMudGFyZ2V0ID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgdGFyZ2V0IHRoYXQgYSBidWJibGluZyBldmVudCBpcyBiZWluZyBkaXNwYXRjaGVkIGZyb20uIEZvciBub24tYnViYmxpbmcgZXZlbnRzLCB0aGlzIHdpbGxcblx0XHQgKiBhbHdheXMgYmUgdGhlIHNhbWUgYXMgdGFyZ2V0LiBGb3IgZXhhbXBsZSwgaWYgY2hpbGRPYmoucGFyZW50ID0gcGFyZW50T2JqLCBhbmQgYSBidWJibGluZyBldmVudFxuXHRcdCAqIGlzIGdlbmVyYXRlZCBmcm9tIGNoaWxkT2JqLCB0aGVuIGEgbGlzdGVuZXIgb24gcGFyZW50T2JqIHdvdWxkIHJlY2VpdmUgdGhlIGV2ZW50IHdpdGhcblx0XHQgKiB0YXJnZXQ9Y2hpbGRPYmogKHRoZSBvcmlnaW5hbCB0YXJnZXQpIGFuZCBjdXJyZW50VGFyZ2V0PXBhcmVudE9iaiAod2hlcmUgdGhlIGxpc3RlbmVyIHdhcyBhZGRlZCkuXG5cdFx0ICogQHByb3BlcnR5IGN1cnJlbnRUYXJnZXRcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBGb3IgYnViYmxpbmcgZXZlbnRzLCB0aGlzIGluZGljYXRlcyB0aGUgY3VycmVudCBldmVudCBwaGFzZTo8T0w+XG5cdFx0ICogXHQ8TEk+IGNhcHR1cmUgcGhhc2U6IHN0YXJ0aW5nIGZyb20gdGhlIHRvcCBwYXJlbnQgdG8gdGhlIHRhcmdldDwvTEk+XG5cdFx0ICogXHQ8TEk+IGF0IHRhcmdldCBwaGFzZTogY3VycmVudGx5IGJlaW5nIGRpc3BhdGNoZWQgZnJvbSB0aGUgdGFyZ2V0PC9MST5cblx0XHQgKiBcdDxMST4gYnViYmxpbmcgcGhhc2U6IGZyb20gdGhlIHRhcmdldCB0byB0aGUgdG9wIHBhcmVudDwvTEk+XG5cdFx0ICogPC9PTD5cblx0XHQgKiBAcHJvcGVydHkgZXZlbnRQaGFzZVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuZXZlbnRQaGFzZSA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBldmVudCB3aWxsIGJ1YmJsZSB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuXG5cdFx0ICogQHByb3BlcnR5IGJ1YmJsZXNcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuYnViYmxlcyA9ICEhYnViYmxlcztcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9mIHRoaXMgZXZlbnQgY2FuIGJlIGNhbmNlbGxlZCB2aWFcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudC9wcmV2ZW50RGVmYXVsdFwifX17ey9jcm9zc0xpbmt9fS4gVGhpcyBpcyBzZXQgdmlhIHRoZSBFdmVudCBjb25zdHJ1Y3Rvci5cblx0XHQgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5jYW5jZWxhYmxlID0gISFjYW5jZWxhYmxlO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgZXBvY2ggdGltZSBhdCB3aGljaCB0aGlzIGV2ZW50IHdhcyBjcmVhdGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSB0aW1lU3RhbXBcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLnRpbWVTdGFtcCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB7eyNjcm9zc0xpbmsgXCJFdmVudC9wcmV2ZW50RGVmYXVsdFwifX17ey9jcm9zc0xpbmt9fSBoYXMgYmVlbiBjYWxsZWRcblx0XHQgKiBvbiB0aGlzIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBkZWZhdWx0UHJldmVudGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHt7I2Nyb3NzTGluayBcIkV2ZW50L3N0b3BQcm9wYWdhdGlvblwifX17ey9jcm9zc0xpbmt9fSBvclxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50L3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblwifX17ey9jcm9zc0xpbmt9fSBoYXMgYmVlbiBjYWxsZWQgb24gdGhpcyBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgcHJvcGFnYXRpb25TdG9wcGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYge3sjY3Jvc3NMaW5rIFwiRXZlbnQvc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXCJ9fXt7L2Nyb3NzTGlua319IGhhcyBiZWVuIGNhbGxlZFxuXHRcdCAqIG9uIHRoaXMgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IGltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcmVtb3ZlXCJ9fXt7L2Nyb3NzTGlua319IGhhcyBiZWVuIGNhbGxlZCBvbiB0aGlzIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSByZW1vdmVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLnJlbW92ZWQgPSBmYWxzZTtcblx0fVxuXHR2YXIgcCA9IEV2ZW50LnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogU2V0cyB7eyNjcm9zc0xpbmsgXCJFdmVudC9kZWZhdWx0UHJldmVudGVkXCJ9fXt7L2Nyb3NzTGlua319IHRvIHRydWUgaWYgdGhlIGV2ZW50IGlzIGNhbmNlbGFibGUuXG5cdCAqIE1pcnJvcnMgdGhlIERPTSBsZXZlbCAyIGV2ZW50IHN0YW5kYXJkLiBJbiBnZW5lcmFsLCBjYW5jZWxhYmxlIGV2ZW50cyB0aGF0IGhhdmUgYHByZXZlbnREZWZhdWx0KClgIGNhbGxlZCB3aWxsXG5cdCAqIGNhbmNlbCB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudC5cblx0ICogQG1ldGhvZCBwcmV2ZW50RGVmYXVsdFxuXHQgKiovXG5cdHAucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0aGlzLmNhbmNlbGFibGUmJnRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcHJvcGFnYXRpb25TdG9wcGVkXCJ9fXt7L2Nyb3NzTGlua319IHRvIHRydWUuXG5cdCAqIE1pcnJvcnMgdGhlIERPTSBldmVudCBzdGFuZGFyZC5cblx0ICogQG1ldGhvZCBzdG9wUHJvcGFnYXRpb25cblx0ICoqL1xuXHRwLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB7eyNjcm9zc0xpbmsgXCJFdmVudC9wcm9wYWdhdGlvblN0b3BwZWRcIn19e3svY3Jvc3NMaW5rfX0gYW5kXG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50L2ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZFwifX17ey9jcm9zc0xpbmt9fSB0byB0cnVlLlxuXHQgKiBNaXJyb3JzIHRoZSBET00gZXZlbnQgc3RhbmRhcmQuXG5cdCAqIEBtZXRob2Qgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXG5cdCAqKi9cblx0cC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDYXVzZXMgdGhlIGFjdGl2ZSBsaXN0ZW5lciB0byBiZSByZW1vdmVkIHZpYSByZW1vdmVFdmVudExpc3RlbmVyKCk7XG5cdCAqIFxuXHQgKiBcdFx0bXlCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2dCkge1xuXHQgKiBcdFx0XHQvLyBkbyBzdHVmZi4uLlxuXHQgKiBcdFx0XHRldnQucmVtb3ZlKCk7IC8vIHJlbW92ZXMgdGhpcyBsaXN0ZW5lci5cblx0ICogXHRcdH0pO1xuXHQgKiBcblx0ICogQG1ldGhvZCByZW1vdmVcblx0ICoqL1xuXHRwLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucmVtb3ZlZCA9IHRydWU7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBFdmVudCBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtFdmVudH0gYSBjbG9uZSBvZiB0aGUgRXZlbnQgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgRXZlbnQodGhpcy50eXBlLCB0aGlzLmJ1YmJsZXMsIHRoaXMuY2FuY2VsYWJsZSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUHJvdmlkZXMgYSBjaGFpbmFibGUgc2hvcnRjdXQgbWV0aG9kIGZvciBzZXR0aW5nIGEgbnVtYmVyIG9mIHByb3BlcnRpZXMgb24gdGhlIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHNldFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQSBnZW5lcmljIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgdG8gY29weSB0byB0aGUgaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4ge0V2ZW50fSBSZXR1cm5zIHRoZSBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5zZXQgPSBmdW5jdGlvbihwcm9wcykge1xuXHRcdGZvciAodmFyIG4gaW4gcHJvcHMpIHsgdGhpc1tuXSA9IHByb3BzW25dOyB9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltFdmVudCAodHlwZT1cIit0aGlzLnR5cGUrXCIpXVwiO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkV2ZW50ID0gRXZlbnQ7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRXZlbnREaXNwYXRjaGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogRXZlbnREaXNwYXRjaGVyIHByb3ZpZGVzIG1ldGhvZHMgZm9yIG1hbmFnaW5nIHF1ZXVlcyBvZiBldmVudCBsaXN0ZW5lcnMgYW5kIGRpc3BhdGNoaW5nIGV2ZW50cy5cblx0ICpcblx0ICogWW91IGNhbiBlaXRoZXIgZXh0ZW5kIEV2ZW50RGlzcGF0Y2hlciBvciBtaXggaXRzIG1ldGhvZHMgaW50byBhbiBleGlzdGluZyBwcm90b3R5cGUgb3IgaW5zdGFuY2UgYnkgdXNpbmcgdGhlXG5cdCAqIEV2ZW50RGlzcGF0Y2hlciB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvaW5pdGlhbGl6ZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG5cdCAqIFxuXHQgKiBUb2dldGhlciB3aXRoIHRoZSBDcmVhdGVKUyBFdmVudCBjbGFzcywgRXZlbnREaXNwYXRjaGVyIHByb3ZpZGVzIGFuIGV4dGVuZGVkIGV2ZW50IG1vZGVsIHRoYXQgaXMgYmFzZWQgb24gdGhlXG5cdCAqIERPTSBMZXZlbCAyIGV2ZW50IG1vZGVsLCBpbmNsdWRpbmcgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciwgYW5kIGRpc3BhdGNoRXZlbnQuIEl0IHN1cHBvcnRzXG5cdCAqIGJ1YmJsaW5nIC8gY2FwdHVyZSwgcHJldmVudERlZmF1bHQsIHN0b3BQcm9wYWdhdGlvbiwgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uLCBhbmQgaGFuZGxlRXZlbnQuXG5cdCAqIFxuXHQgKiBFdmVudERpc3BhdGNoZXIgYWxzbyBleHBvc2VzIGEge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL29uXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCwgd2hpY2ggbWFrZXMgaXQgZWFzaWVyXG5cdCAqIHRvIGNyZWF0ZSBzY29wZWQgbGlzdGVuZXJzLCBsaXN0ZW5lcnMgdGhhdCBvbmx5IHJ1biBvbmNlLCBhbmQgbGlzdGVuZXJzIHdpdGggYXNzb2NpYXRlZCBhcmJpdHJhcnkgZGF0YS4gVGhlIFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvb2ZmXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCBpcyBtZXJlbHkgYW4gYWxpYXMgdG9cblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL3JlbW92ZUV2ZW50TGlzdGVuZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFxuXHQgKiBBbm90aGVyIGFkZGl0aW9uIHRvIHRoZSBET00gTGV2ZWwgMiBtb2RlbCBpcyB0aGUge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL3JlbW92ZUFsbEV2ZW50TGlzdGVuZXJzXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZCwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbGlzdGVuZXJzIGZvciBhbGwgZXZlbnRzLCBvciBsaXN0ZW5lcnMgZm9yIGEgc3BlY2lmaWMgZXZlbnQuIFRoZSBFdmVudCBvYmplY3QgYWxzbyBcblx0ICogaW5jbHVkZXMgYSB7eyNjcm9zc0xpbmsgXCJFdmVudC9yZW1vdmVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIHdoaWNoIHJlbW92ZXMgdGhlIGFjdGl2ZSBsaXN0ZW5lci5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBBZGQgRXZlbnREaXNwYXRjaGVyIGNhcGFiaWxpdGllcyB0byB0aGUgXCJNeUNsYXNzXCIgY2xhc3MuXG5cdCAqXG5cdCAqICAgICAgRXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUoTXlDbGFzcy5wcm90b3R5cGUpO1xuXHQgKlxuXHQgKiBBZGQgYW4gZXZlbnQgKHNlZSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvYWRkRXZlbnRMaXN0ZW5lclwifX17ey9jcm9zc0xpbmt9fSkuXG5cdCAqXG5cdCAqICAgICAgaW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcihcImV2ZW50TmFtZVwiLCBoYW5kbGVyTWV0aG9kKTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVyTWV0aG9kKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LnRhcmdldCArIFwiIFdhcyBDbGlja2VkXCIpO1xuXHQgKiAgICAgIH1cblx0ICpcblx0ICogPGI+TWFpbnRhaW5pbmcgcHJvcGVyIHNjb3BlPC9iPjxiciAvPlxuXHQgKiBTY29wZSAoaWUuIFwidGhpc1wiKSBjYW4gYmUgYmUgYSBjaGFsbGVuZ2Ugd2l0aCBldmVudHMuIFVzaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvb25cIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kIHRvIHN1YnNjcmliZSB0byBldmVudHMgc2ltcGxpZmllcyB0aGlzLlxuXHQgKlxuXHQgKiAgICAgIGluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihldmVudCkge1xuXHQgKiAgICAgICAgICBjb25zb2xlLmxvZyhpbnN0YW5jZSA9PSB0aGlzKTsgLy8gZmFsc2UsIHNjb3BlIGlzIGFtYmlndW91cy5cblx0ICogICAgICB9KTtcblx0ICogICAgICBcblx0ICogICAgICBpbnN0YW5jZS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKGluc3RhbmNlID09IHRoaXMpOyAvLyB0cnVlLCBcIm9uXCIgdXNlcyBkaXNwYXRjaGVyIHNjb3BlIGJ5IGRlZmF1bHQuXG5cdCAqICAgICAgfSk7XG5cdCAqIFxuXHQgKiBJZiB5b3Ugd2FudCB0byB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpbnN0ZWFkLCB5b3UgbWF5IHdhbnQgdG8gdXNlIGZ1bmN0aW9uLmJpbmQoKSBvciBhIHNpbWlsYXIgcHJveHkgdG8gbWFuYWdlXG5cdCAqIHNjb3BlLlxuXHQgKlxuXHQgKiA8Yj5Ccm93c2VyIHN1cHBvcnQ8L2I+XG5cdCAqIFRoZSBldmVudCBtb2RlbCBpbiBDcmVhdGVKUyBjYW4gYmUgdXNlZCBzZXBhcmF0ZWx5IGZyb20gdGhlIHN1aXRlIGluIGFueSBwcm9qZWN0LCBob3dldmVyIHRoZSBpbmhlcml0YW5jZSBtb2RlbFxuXHQgKiByZXF1aXJlcyBtb2Rlcm4gYnJvd3NlcnMgKElFOSspLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAY2xhc3MgRXZlbnREaXNwYXRjaGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIEV2ZW50RGlzcGF0Y2hlcigpIHtcblx0XG5cdFxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBwcm9wZXJ0eSBfbGlzdGVuZXJzXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2xpc3RlbmVycyA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBwcm9wZXJ0eSBfY2FwdHVyZUxpc3RlbmVyc1xuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqKi9cblx0XHR0aGlzLl9jYXB0dXJlTGlzdGVuZXJzID0gbnVsbDtcblx0fVxuXHR2YXIgcCA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cbi8vIHN0YXRpYyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFN0YXRpYyBpbml0aWFsaXplciB0byBtaXggRXZlbnREaXNwYXRjaGVyIG1ldGhvZHMgaW50byBhIHRhcmdldCBvYmplY3Qgb3IgcHJvdG90eXBlLlxuXHQgKiBcblx0ICogXHRcdEV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplKE15Q2xhc3MucHJvdG90eXBlKTsgLy8gYWRkIHRvIHRoZSBwcm90b3R5cGUgb2YgdGhlIGNsYXNzXG5cdCAqIFx0XHRFdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZShteU9iamVjdCk7IC8vIGFkZCB0byBhIHNwZWNpZmljIGluc3RhbmNlXG5cdCAqIFxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IHRvIGluamVjdCBFdmVudERpc3BhdGNoZXIgbWV0aG9kcyBpbnRvLiBUaGlzIGNhbiBiZSBhbiBpbnN0YW5jZSBvciBhXG5cdCAqIHByb3RvdHlwZS5cblx0ICoqL1xuXHRFdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdHRhcmdldC5hZGRFdmVudExpc3RlbmVyID0gcC5hZGRFdmVudExpc3RlbmVyO1xuXHRcdHRhcmdldC5vbiA9IHAub247XG5cdFx0dGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIgPSB0YXJnZXQub2ZmID0gIHAucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblx0XHR0YXJnZXQucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMgPSBwLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzO1xuXHRcdHRhcmdldC5oYXNFdmVudExpc3RlbmVyID0gcC5oYXNFdmVudExpc3RlbmVyO1xuXHRcdHRhcmdldC5kaXNwYXRjaEV2ZW50ID0gcC5kaXNwYXRjaEV2ZW50O1xuXHRcdHRhcmdldC5fZGlzcGF0Y2hFdmVudCA9IHAuX2Rpc3BhdGNoRXZlbnQ7XG5cdFx0dGFyZ2V0LndpbGxUcmlnZ2VyID0gcC53aWxsVHJpZ2dlcjtcblx0fTtcblx0XG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogQWRkcyB0aGUgc3BlY2lmaWVkIGV2ZW50IGxpc3RlbmVyLiBOb3RlIHRoYXQgYWRkaW5nIG11bHRpcGxlIGxpc3RlbmVycyB0byB0aGUgc2FtZSBmdW5jdGlvbiB3aWxsIHJlc3VsdCBpblxuXHQgKiBtdWx0aXBsZSBjYWxsYmFja3MgZ2V0dGluZyBmaXJlZC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNsaWNrKTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuXHQgKiAgICAgICAgIC8vIENsaWNrIGhhcHBlbmVkLlxuXHQgKiAgICAgIH1cblx0ICpcblx0ICogQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb24gfCBPYmplY3R9IGxpc3RlbmVyIEFuIG9iamVjdCB3aXRoIGEgaGFuZGxlRXZlbnQgbWV0aG9kLCBvciBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlblxuXHQgKiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZV0gRm9yIGV2ZW50cyB0aGF0IGJ1YmJsZSwgaW5kaWNhdGVzIHdoZXRoZXIgdG8gbGlzdGVuIGZvciB0aGUgZXZlbnQgaW4gdGhlIGNhcHR1cmUgb3IgYnViYmxpbmcvdGFyZ2V0IHBoYXNlLlxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbiB8IE9iamVjdH0gUmV0dXJucyB0aGUgbGlzdGVuZXIgZm9yIGNoYWluaW5nIG9yIGFzc2lnbm1lbnQuXG5cdCAqKi9cblx0cC5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcblx0XHR2YXIgbGlzdGVuZXJzO1xuXHRcdGlmICh1c2VDYXB0dXJlKSB7XG5cdFx0XHRsaXN0ZW5lcnMgPSB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVyc3x8e307XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc3x8e307XG5cdFx0fVxuXHRcdHZhciBhcnIgPSBsaXN0ZW5lcnNbdHlwZV07XG5cdFx0aWYgKGFycikgeyB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpOyB9XG5cdFx0YXJyID0gbGlzdGVuZXJzW3R5cGVdOyAvLyByZW1vdmUgbWF5IGhhdmUgZGVsZXRlZCB0aGUgYXJyYXlcblx0XHRpZiAoIWFycikgeyBsaXN0ZW5lcnNbdHlwZV0gPSBbbGlzdGVuZXJdOyAgfVxuXHRcdGVsc2UgeyBhcnIucHVzaChsaXN0ZW5lcik7IH1cblx0XHRyZXR1cm4gbGlzdGVuZXI7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQSBzaG9ydGN1dCBtZXRob2QgZm9yIHVzaW5nIGFkZEV2ZW50TGlzdGVuZXIgdGhhdCBtYWtlcyBpdCBlYXNpZXIgdG8gc3BlY2lmeSBhbiBleGVjdXRpb24gc2NvcGUsIGhhdmUgYSBsaXN0ZW5lclxuXHQgKiBvbmx5IHJ1biBvbmNlLCBhc3NvY2lhdGUgYXJiaXRyYXJ5IGRhdGEgd2l0aCB0aGUgbGlzdGVuZXIsIGFuZCByZW1vdmUgdGhlIGxpc3RlbmVyLlxuXHQgKiBcblx0ICogVGhpcyBtZXRob2Qgd29ya3MgYnkgY3JlYXRpbmcgYW4gYW5vbnltb3VzIHdyYXBwZXIgZnVuY3Rpb24gYW5kIHN1YnNjcmliaW5nIGl0IHdpdGggYWRkRXZlbnRMaXN0ZW5lci5cblx0ICogVGhlIHdyYXBwZXIgZnVuY3Rpb24gaXMgcmV0dXJuZWQgZm9yIHVzZSB3aXRoIGByZW1vdmVFdmVudExpc3RlbmVyYCAob3IgYG9mZmApLlxuXHQgKiBcblx0ICogPGI+SU1QT1JUQU5UOjwvYj4gVG8gcmVtb3ZlIGEgbGlzdGVuZXIgYWRkZWQgd2l0aCBgb25gLCB5b3UgbXVzdCBwYXNzIGluIHRoZSByZXR1cm5lZCB3cmFwcGVyIGZ1bmN0aW9uIGFzIHRoZSBsaXN0ZW5lciwgb3IgdXNlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50L3JlbW92ZVwifX17ey9jcm9zc0xpbmt9fS4gTGlrZXdpc2UsIGVhY2ggdGltZSB5b3UgY2FsbCBgb25gIGEgTkVXIHdyYXBwZXIgZnVuY3Rpb24gaXMgc3Vic2NyaWJlZCwgc28gbXVsdGlwbGUgY2FsbHNcblx0ICogdG8gYG9uYCB3aXRoIHRoZSBzYW1lIHBhcmFtcyB3aWxsIGNyZWF0ZSBtdWx0aXBsZSBsaXN0ZW5lcnMuXG5cdCAqIFxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIFxuXHQgKiBcdFx0dmFyIGxpc3RlbmVyID0gbXlCdG4ub24oXCJjbGlja1wiLCBoYW5kbGVDbGljaywgbnVsbCwgZmFsc2UsIHtjb3VudDozfSk7XG5cdCAqIFx0XHRmdW5jdGlvbiBoYW5kbGVDbGljayhldnQsIGRhdGEpIHtcblx0ICogXHRcdFx0ZGF0YS5jb3VudCAtPSAxO1xuXHQgKiBcdFx0XHRjb25zb2xlLmxvZyh0aGlzID09IG15QnRuKTsgLy8gdHJ1ZSAtIHNjb3BlIGRlZmF1bHRzIHRvIHRoZSBkaXNwYXRjaGVyXG5cdCAqIFx0XHRcdGlmIChkYXRhLmNvdW50ID09IDApIHtcblx0ICogXHRcdFx0XHRhbGVydChcImNsaWNrZWQgMyB0aW1lcyFcIik7XG5cdCAqIFx0XHRcdFx0bXlCdG4ub2ZmKFwiY2xpY2tcIiwgbGlzdGVuZXIpO1xuXHQgKiBcdFx0XHRcdC8vIGFsdGVybmF0ZWx5OiBldnQucmVtb3ZlKCk7XG5cdCAqIFx0XHRcdH1cblx0ICogXHRcdH1cblx0ICogXG5cdCAqIEBtZXRob2Qgb25cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbiB8IE9iamVjdH0gbGlzdGVuZXIgQW4gb2JqZWN0IHdpdGggYSBoYW5kbGVFdmVudCBtZXRob2QsIG9yIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuXG5cdCAqIHRoZSBldmVudCBpcyBkaXNwYXRjaGVkLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSBUaGUgc2NvcGUgdG8gZXhlY3V0ZSB0aGUgbGlzdGVuZXIgaW4uIERlZmF1bHRzIHRvIHRoZSBkaXNwYXRjaGVyL2N1cnJlbnRUYXJnZXQgZm9yIGZ1bmN0aW9uIGxpc3RlbmVycywgYW5kIHRvIHRoZSBsaXN0ZW5lciBpdHNlbGYgZm9yIG9iamVjdCBsaXN0ZW5lcnMgKGllLiB1c2luZyBoYW5kbGVFdmVudCkuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIElmIHRydWUsIHRoZSBsaXN0ZW5lciB3aWxsIHJlbW92ZSBpdHNlbGYgYWZ0ZXIgdGhlIGZpcnN0IHRpbWUgaXQgaXMgdHJpZ2dlcmVkLlxuXHQgKiBAcGFyYW0geyp9IFtkYXRhXSBBcmJpdHJhcnkgZGF0YSB0aGF0IHdpbGwgYmUgaW5jbHVkZWQgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgd2hlbiB0aGUgbGlzdGVuZXIgaXMgY2FsbGVkLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlPWZhbHNlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBhbm9ueW1vdXMgZnVuY3Rpb24gdGhhdCB3YXMgY3JlYXRlZCBhbmQgYXNzaWduZWQgYXMgdGhlIGxpc3RlbmVyLiBUaGlzIGlzIG5lZWRlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyIGxhdGVyIHVzaW5nIC5yZW1vdmVFdmVudExpc3RlbmVyLlxuXHQgKiovXG5cdHAub24gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgc2NvcGUsIG9uY2UsIGRhdGEsIHVzZUNhcHR1cmUpIHtcblx0XHRpZiAobGlzdGVuZXIuaGFuZGxlRXZlbnQpIHtcblx0XHRcdHNjb3BlID0gc2NvcGV8fGxpc3RlbmVyO1xuXHRcdFx0bGlzdGVuZXIgPSBsaXN0ZW5lci5oYW5kbGVFdmVudDtcblx0XHR9XG5cdFx0c2NvcGUgPSBzY29wZXx8dGhpcztcblx0XHRyZXR1cm4gdGhpcy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmN0aW9uKGV2dCkge1xuXHRcdFx0XHRsaXN0ZW5lci5jYWxsKHNjb3BlLCBldnQsIGRhdGEpO1xuXHRcdFx0XHRvbmNlJiZldnQucmVtb3ZlKCk7XG5cdFx0XHR9LCB1c2VDYXB0dXJlKTtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGV2ZW50IGxpc3RlbmVyLlxuXHQgKlxuXHQgKiA8Yj5JbXBvcnRhbnQgTm90ZTo8L2I+IHRoYXQgeW91IG11c3QgcGFzcyB0aGUgZXhhY3QgZnVuY3Rpb24gcmVmZXJlbmNlIHVzZWQgd2hlbiB0aGUgZXZlbnQgd2FzIGFkZGVkLiBJZiBhIHByb3h5XG5cdCAqIGZ1bmN0aW9uLCBvciBmdW5jdGlvbiBjbG9zdXJlIGlzIHVzZWQgYXMgdGhlIGNhbGxiYWNrLCB0aGUgcHJveHkvY2xvc3VyZSByZWZlcmVuY2UgbXVzdCBiZSB1c2VkIC0gYSBuZXcgcHJveHkgb3Jcblx0ICogY2xvc3VyZSB3aWxsIG5vdCB3b3JrLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHJlbW92ZUV2ZW50TGlzdGVuZXJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbiB8IE9iamVjdH0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIG9yIG9iamVjdC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZV0gRm9yIGV2ZW50cyB0aGF0IGJ1YmJsZSwgaW5kaWNhdGVzIHdoZXRoZXIgdG8gbGlzdGVuIGZvciB0aGUgZXZlbnQgaW4gdGhlIGNhcHR1cmUgb3IgYnViYmxpbmcvdGFyZ2V0IHBoYXNlLlxuXHQgKiovXG5cdHAucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG5cdFx0dmFyIGxpc3RlbmVycyA9IHVzZUNhcHR1cmUgPyB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzIDogdGhpcy5fbGlzdGVuZXJzO1xuXHRcdGlmICghbGlzdGVuZXJzKSB7IHJldHVybjsgfVxuXHRcdHZhciBhcnIgPSBsaXN0ZW5lcnNbdHlwZV07XG5cdFx0aWYgKCFhcnIpIHsgcmV0dXJuOyB9XG5cdFx0Zm9yICh2YXIgaT0wLGw9YXJyLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdGlmIChhcnJbaV0gPT0gbGlzdGVuZXIpIHtcblx0XHRcdFx0aWYgKGw9PTEpIHsgZGVsZXRlKGxpc3RlbmVyc1t0eXBlXSk7IH0gLy8gYWxsb3dzIGZvciBmYXN0ZXIgY2hlY2tzLlxuXHRcdFx0XHRlbHNlIHsgYXJyLnNwbGljZShpLDEpOyB9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBBIHNob3J0Y3V0IHRvIHRoZSByZW1vdmVFdmVudExpc3RlbmVyIG1ldGhvZCwgd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFuZCByZXR1cm4gdmFsdWUuIFRoaXMgaXMgYSBjb21wYW5pb24gdG8gdGhlXG5cdCAqIC5vbiBtZXRob2QuXG5cdCAqIFxuXHQgKiA8Yj5JTVBPUlRBTlQ6PC9iPiBUbyByZW1vdmUgYSBsaXN0ZW5lciBhZGRlZCB3aXRoIGBvbmAsIHlvdSBtdXN0IHBhc3MgaW4gdGhlIHJldHVybmVkIHdyYXBwZXIgZnVuY3Rpb24gYXMgdGhlIGxpc3RlbmVyLiBTZWUgXG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9vblwifX17ey9jcm9zc0xpbmt9fSBmb3IgYW4gZXhhbXBsZS5cblx0ICpcblx0ICogQG1ldGhvZCBvZmZcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbiB8IE9iamVjdH0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIG9yIG9iamVjdC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZV0gRm9yIGV2ZW50cyB0aGF0IGJ1YmJsZSwgaW5kaWNhdGVzIHdoZXRoZXIgdG8gbGlzdGVuIGZvciB0aGUgZXZlbnQgaW4gdGhlIGNhcHR1cmUgb3IgYnViYmxpbmcvdGFyZ2V0IHBoYXNlLlxuXHQgKiovXG5cdHAub2ZmID0gcC5yZW1vdmVFdmVudExpc3RlbmVyO1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBzcGVjaWZpZWQgdHlwZSwgb3IgYWxsIGxpc3RlbmVycyBvZiBhbGwgdHlwZXMuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVyc1xuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoKTtcblx0ICpcblx0ICogICAgICAvLyBSZW1vdmUgYWxsIGNsaWNrIGxpc3RlbmVyc1xuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoXCJjbGlja1wiKTtcblx0ICpcblx0ICogQG1ldGhvZCByZW1vdmVBbGxFdmVudExpc3RlbmVyc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3R5cGVdIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuIElmIG9taXR0ZWQsIGFsbCBsaXN0ZW5lcnMgZm9yIGFsbCB0eXBlcyB3aWxsIGJlIHJlbW92ZWQuXG5cdCAqKi9cblx0cC5yZW1vdmVBbGxFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRpZiAoIXR5cGUpIHsgdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA9IG51bGw7IH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICh0aGlzLl9saXN0ZW5lcnMpIHsgZGVsZXRlKHRoaXMuX2xpc3RlbmVyc1t0eXBlXSk7IH1cblx0XHRcdGlmICh0aGlzLl9jYXB0dXJlTGlzdGVuZXJzKSB7IGRlbGV0ZSh0aGlzLl9jYXB0dXJlTGlzdGVuZXJzW3R5cGVdKTsgfVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRGlzcGF0Y2hlcyB0aGUgc3BlY2lmaWVkIGV2ZW50IHRvIGFsbCBsaXN0ZW5lcnMuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICAvLyBVc2UgYSBzdHJpbmcgZXZlbnRcblx0ICogICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKTtcblx0ICpcblx0ICogICAgICAvLyBVc2UgYW4gRXZlbnQgaW5zdGFuY2Vcblx0ICogICAgICB2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJwcm9ncmVzc1wiKTtcblx0ICogICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIGRpc3BhdGNoRXZlbnRcblx0ICogQHBhcmFtIHtPYmplY3QgfCBTdHJpbmcgfCBFdmVudH0gZXZlbnRPYmogQW4gb2JqZWN0IHdpdGggYSBcInR5cGVcIiBwcm9wZXJ0eSwgb3IgYSBzdHJpbmcgdHlwZS5cblx0ICogV2hpbGUgYSBnZW5lcmljIG9iamVjdCB3aWxsIHdvcmssIGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBhIENyZWF0ZUpTIEV2ZW50IGluc3RhbmNlLiBJZiBhIHN0cmluZyBpcyB1c2VkLFxuXHQgKiBkaXNwYXRjaEV2ZW50IHdpbGwgY29uc3RydWN0IGFuIEV2ZW50IGluc3RhbmNlIGlmIG5lY2Vzc2FyeSB3aXRoIHRoZSBzcGVjaWZpZWQgdHlwZS4gVGhpcyBsYXR0ZXIgYXBwcm9hY2ggY2FuXG5cdCAqIGJlIHVzZWQgdG8gYXZvaWQgZXZlbnQgb2JqZWN0IGluc3RhbnRpYXRpb24gZm9yIG5vbi1idWJibGluZyBldmVudHMgdGhhdCBtYXkgbm90IGhhdmUgYW55IGxpc3RlbmVycy5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbYnViYmxlc10gU3BlY2lmaWVzIHRoZSBgYnViYmxlc2AgdmFsdWUgd2hlbiBhIHN0cmluZyB3YXMgcGFzc2VkIHRvIGV2ZW50T2JqLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYW5jZWxhYmxlXSBTcGVjaWZpZXMgdGhlIGBjYW5jZWxhYmxlYCB2YWx1ZSB3aGVuIGEgc3RyaW5nIHdhcyBwYXNzZWQgdG8gZXZlbnRPYmouXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgZmFsc2UgaWYgYHByZXZlbnREZWZhdWx0KClgIHdhcyBjYWxsZWQgb24gYSBjYW5jZWxhYmxlIGV2ZW50LCB0cnVlIG90aGVyd2lzZS5cblx0ICoqL1xuXHRwLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudE9iaiwgYnViYmxlcywgY2FuY2VsYWJsZSkge1xuXHRcdGlmICh0eXBlb2YgZXZlbnRPYmogPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0Ly8gc2tpcCBldmVyeXRoaW5nIGlmIHRoZXJlJ3Mgbm8gbGlzdGVuZXJzIGFuZCBpdCBkb2Vzbid0IGJ1YmJsZTpcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cdFx0XHRpZiAoIWJ1YmJsZXMgJiYgKCFsaXN0ZW5lcnMgfHwgIWxpc3RlbmVyc1tldmVudE9ial0pKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0XHRldmVudE9iaiA9IG5ldyBjcmVhdGVqcy5FdmVudChldmVudE9iaiwgYnViYmxlcywgY2FuY2VsYWJsZSk7XG5cdFx0fSBlbHNlIGlmIChldmVudE9iai50YXJnZXQgJiYgZXZlbnRPYmouY2xvbmUpIHtcblx0XHRcdC8vIHJlZGlzcGF0Y2hpbmcgYW4gYWN0aXZlIGV2ZW50IG9iamVjdCwgc28gY2xvbmUgaXQ6XG5cdFx0XHRldmVudE9iaiA9IGV2ZW50T2JqLmNsb25lKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIFRPRE86IGl0IHdvdWxkIGJlIG5pY2UgdG8gZWxpbWluYXRlIHRoaXMuIE1heWJlIGluIGZhdm91ciBvZiBldnRPYmogaW5zdGFuY2VvZiBFdmVudD8gT3IgISFldnRPYmouY3JlYXRlRXZlbnRcblx0XHR0cnkgeyBldmVudE9iai50YXJnZXQgPSB0aGlzOyB9IGNhdGNoIChlKSB7fSAvLyB0cnkvY2F0Y2ggYWxsb3dzIHJlZGlzcGF0Y2hpbmcgb2YgbmF0aXZlIGV2ZW50c1xuXG5cdFx0aWYgKCFldmVudE9iai5idWJibGVzIHx8ICF0aGlzLnBhcmVudCkge1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hFdmVudChldmVudE9iaiwgMik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciB0b3A9dGhpcywgbGlzdD1bdG9wXTtcblx0XHRcdHdoaWxlICh0b3AucGFyZW50KSB7IGxpc3QucHVzaCh0b3AgPSB0b3AucGFyZW50KTsgfVxuXHRcdFx0dmFyIGksIGw9bGlzdC5sZW5ndGg7XG5cblx0XHRcdC8vIGNhcHR1cmUgJiBhdFRhcmdldFxuXHRcdFx0Zm9yIChpPWwtMTsgaT49MCAmJiAhZXZlbnRPYmoucHJvcGFnYXRpb25TdG9wcGVkOyBpLS0pIHtcblx0XHRcdFx0bGlzdFtpXS5fZGlzcGF0Y2hFdmVudChldmVudE9iaiwgMSsoaT09MCkpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYnViYmxpbmdcblx0XHRcdGZvciAoaT0xOyBpPGwgJiYgIWV2ZW50T2JqLnByb3BhZ2F0aW9uU3RvcHBlZDsgaSsrKSB7XG5cdFx0XHRcdGxpc3RbaV0uX2Rpc3BhdGNoRXZlbnQoZXZlbnRPYmosIDMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gIWV2ZW50T2JqLmRlZmF1bHRQcmV2ZW50ZWQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudCB0eXBlLlxuXHQgKiBAbWV0aG9kIGhhc0V2ZW50TGlzdGVuZXJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cblx0ICoqL1xuXHRwLmhhc0V2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlKSB7XG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycywgY2FwdHVyZUxpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnM7XG5cdFx0cmV0dXJuICEhKChsaXN0ZW5lcnMgJiYgbGlzdGVuZXJzW3R5cGVdKSB8fCAoY2FwdHVyZUxpc3RlbmVycyAmJiBjYXB0dXJlTGlzdGVuZXJzW3R5cGVdKSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUgb24gdGhpcyBvYmplY3Qgb3IgYW55IG9mIGl0c1xuXHQgKiBhbmNlc3RvcnMgKHBhcmVudCwgcGFyZW50J3MgcGFyZW50LCBldGMpLiBBIHJldHVybiB2YWx1ZSBvZiB0cnVlIGluZGljYXRlcyB0aGF0IGlmIGEgYnViYmxpbmcgZXZlbnQgb2YgdGhlXG5cdCAqIHNwZWNpZmllZCB0eXBlIGlzIGRpc3BhdGNoZWQgZnJvbSB0aGlzIG9iamVjdCwgaXQgd2lsbCB0cmlnZ2VyIGF0IGxlYXN0IG9uZSBsaXN0ZW5lci5cblx0ICogXG5cdCAqIFRoaXMgaXMgc2ltaWxhciB0byB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvaGFzRXZlbnRMaXN0ZW5lclwifX17ey9jcm9zc0xpbmt9fSwgYnV0IGl0IHNlYXJjaGVzIHRoZSBlbnRpcmVcblx0ICogZXZlbnQgZmxvdyBmb3IgYSBsaXN0ZW5lciwgbm90IGp1c3QgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2Qgd2lsbFRyaWdnZXJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuXHQgKiovXG5cdHAud2lsbFRyaWdnZXIgPSBmdW5jdGlvbih0eXBlKSB7XG5cdFx0dmFyIG8gPSB0aGlzO1xuXHRcdHdoaWxlIChvKSB7XG5cdFx0XHRpZiAoby5oYXNFdmVudExpc3RlbmVyKHR5cGUpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0XHRvID0gby5wYXJlbnQ7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0V2ZW50RGlzcGF0Y2hlcl1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9kaXNwYXRjaEV2ZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0IHwgU3RyaW5nIHwgRXZlbnR9IGV2ZW50T2JqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFBoYXNlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oZXZlbnRPYmosIGV2ZW50UGhhc2UpIHtcblx0XHR2YXIgbCwgbGlzdGVuZXJzID0gKGV2ZW50UGhhc2U9PTEpID8gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA6IHRoaXMuX2xpc3RlbmVycztcblx0XHRpZiAoZXZlbnRPYmogJiYgbGlzdGVuZXJzKSB7XG5cdFx0XHR2YXIgYXJyID0gbGlzdGVuZXJzW2V2ZW50T2JqLnR5cGVdO1xuXHRcdFx0aWYgKCFhcnJ8fCEobD1hcnIubGVuZ3RoKSkgeyByZXR1cm47IH1cblx0XHRcdHRyeSB7IGV2ZW50T2JqLmN1cnJlbnRUYXJnZXQgPSB0aGlzOyB9IGNhdGNoIChlKSB7fVxuXHRcdFx0dHJ5IHsgZXZlbnRPYmouZXZlbnRQaGFzZSA9IGV2ZW50UGhhc2U7IH0gY2F0Y2ggKGUpIHt9XG5cdFx0XHRldmVudE9iai5yZW1vdmVkID0gZmFsc2U7XG5cdFx0XHRcblx0XHRcdGFyciA9IGFyci5zbGljZSgpOyAvLyB0byBhdm9pZCBpc3N1ZXMgd2l0aCBpdGVtcyBiZWluZyByZW1vdmVkIG9yIGFkZGVkIGR1cmluZyB0aGUgZGlzcGF0Y2hcblx0XHRcdGZvciAodmFyIGk9MDsgaTxsICYmICFldmVudE9iai5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ7IGkrKykge1xuXHRcdFx0XHR2YXIgbyA9IGFycltpXTtcblx0XHRcdFx0aWYgKG8uaGFuZGxlRXZlbnQpIHsgby5oYW5kbGVFdmVudChldmVudE9iaik7IH1cblx0XHRcdFx0ZWxzZSB7IG8oZXZlbnRPYmopOyB9XG5cdFx0XHRcdGlmIChldmVudE9iai5yZW1vdmVkKSB7XG5cdFx0XHRcdFx0dGhpcy5vZmYoZXZlbnRPYmoudHlwZSwgbywgZXZlbnRQaGFzZT09MSk7XG5cdFx0XHRcdFx0ZXZlbnRPYmoucmVtb3ZlZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cblx0Y3JlYXRlanMuRXZlbnREaXNwYXRjaGVyID0gRXZlbnREaXNwYXRjaGVyO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFRpY2tlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFRoZSBUaWNrZXIgcHJvdmlkZXMgYSBjZW50cmFsaXplZCB0aWNrIG9yIGhlYXJ0YmVhdCBicm9hZGNhc3QgYXQgYSBzZXQgaW50ZXJ2YWwuIExpc3RlbmVycyBjYW4gc3Vic2NyaWJlIHRvIHRoZSB0aWNrXG5cdCAqIGV2ZW50IHRvIGJlIG5vdGlmaWVkIHdoZW4gYSBzZXQgdGltZSBpbnRlcnZhbCBoYXMgZWxhcHNlZC5cblx0ICpcblx0ICogTm90ZSB0aGF0IHRoZSBpbnRlcnZhbCB0aGF0IHRoZSB0aWNrIGV2ZW50IGlzIGNhbGxlZCBpcyBhIHRhcmdldCBpbnRlcnZhbCwgYW5kIG1heSBiZSBicm9hZGNhc3QgYXQgYSBzbG93ZXIgaW50ZXJ2YWxcblx0ICogd2hlbiB1bmRlciBoaWdoIENQVSBsb2FkLiBUaGUgVGlja2VyIGNsYXNzIHVzZXMgYSBzdGF0aWMgaW50ZXJmYWNlIChleC4gYFRpY2tlci5mcmFtZXJhdGUgPSAzMDtgKSBhbmRcblx0ICogY2FuIG5vdCBiZSBpbnN0YW50aWF0ZWQuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5UaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgaGFuZGxlVGljayk7XG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlVGljayhldmVudCkge1xuXHQgKiAgICAgICAgICAvLyBBY3Rpb25zIGNhcnJpZWQgb3V0IGVhY2ggdGljayAoYWthIGZyYW1lKVxuXHQgKiAgICAgICAgICBpZiAoIWV2ZW50LnBhdXNlZCkge1xuXHQgKiAgICAgICAgICAgICAgLy8gQWN0aW9ucyBjYXJyaWVkIG91dCB3aGVuIHRoZSBUaWNrZXIgaXMgbm90IHBhdXNlZC5cblx0ICogICAgICAgICAgfVxuXHQgKiAgICAgIH1cblx0ICpcblx0ICogQGNsYXNzIFRpY2tlclxuXHQgKiBAdXNlcyBFdmVudERpc3BhdGNoZXJcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdGZ1bmN0aW9uIFRpY2tlcigpIHtcblx0XHR0aHJvdyBcIlRpY2tlciBjYW5ub3QgYmUgaW5zdGFudGlhdGVkLlwiO1xuXHR9XG5cblxuLy8gY29uc3RhbnRzOlxuXHQvKipcblx0ICogSW4gdGhpcyBtb2RlLCBUaWNrZXIgdXNlcyB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIEFQSSwgYnV0IGF0dGVtcHRzIHRvIHN5bmNoIHRoZSB0aWNrcyB0byB0YXJnZXQgZnJhbWVyYXRlLiBJdFxuXHQgKiB1c2VzIGEgc2ltcGxlIGhldXJpc3RpYyB0aGF0IGNvbXBhcmVzIHRoZSB0aW1lIG9mIHRoZSBSQUYgcmV0dXJuIHRvIHRoZSB0YXJnZXQgdGltZSBmb3IgdGhlIGN1cnJlbnQgZnJhbWUgYW5kXG5cdCAqIGRpc3BhdGNoZXMgdGhlIHRpY2sgd2hlbiB0aGUgdGltZSBpcyB3aXRoaW4gYSBjZXJ0YWluIHRocmVzaG9sZC5cblx0ICpcblx0ICogVGhpcyBtb2RlIGhhcyBhIGhpZ2hlciB2YXJpYW5jZSBmb3IgdGltZSBiZXR3ZWVuIGZyYW1lcyB0aGFuIHt7I2Nyb3NzTGluayBcIlRpY2tlci9USU1FT1VUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBidXQgZG9lcyBub3QgcmVxdWlyZSB0aGF0IGNvbnRlbnQgYmUgdGltZSBiYXNlZCBhcyB3aXRoIHt7I2Nyb3NzTGluayBcIlRpY2tlci9SQUY6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gd2hpbGVcblx0ICogZ2FpbmluZyB0aGUgYmVuZWZpdHMgb2YgdGhhdCBBUEkgKHNjcmVlbiBzeW5jaCwgYmFja2dyb3VuZCB0aHJvdHRsaW5nKS5cblx0ICpcblx0ICogVmFyaWFuY2UgaXMgdXN1YWxseSBsb3dlc3QgZm9yIGZyYW1lcmF0ZXMgdGhhdCBhcmUgYSBkaXZpc29yIG9mIHRoZSBSQUYgZnJlcXVlbmN5LiBUaGlzIGlzIHVzdWFsbHkgNjAsIHNvXG5cdCAqIGZyYW1lcmF0ZXMgb2YgMTAsIDEyLCAxNSwgMjAsIGFuZCAzMCB3b3JrIHdlbGwuXG5cdCAqXG5cdCAqIEZhbGxzIGJhY2sgdG8ge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1RJTUVPVVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaWYgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBBUEkgaXMgbm90XG5cdCAqIHN1cHBvcnRlZC5cblx0ICogQHByb3BlcnR5IFJBRl9TWU5DSEVEXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgXCJzeW5jaGVkXCJcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0VGlja2VyLlJBRl9TWU5DSEVEID0gXCJzeW5jaGVkXCI7XG5cblx0LyoqXG5cdCAqIEluIHRoaXMgbW9kZSwgVGlja2VyIHBhc3NlcyB0aHJvdWdoIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgaGVhcnRiZWF0LCBpZ25vcmluZyB0aGUgdGFyZ2V0IGZyYW1lcmF0ZSBjb21wbGV0ZWx5LlxuXHQgKiBCZWNhdXNlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBmcmVxdWVuY3kgaXMgbm90IGRldGVybWluaXN0aWMsIGFueSBjb250ZW50IHVzaW5nIHRoaXMgbW9kZSBzaG91bGQgYmUgdGltZSBiYXNlZC5cblx0ICogWW91IGNhbiBsZXZlcmFnZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvZ2V0VGltZVwifX17ey9jcm9zc0xpbmt9fSBhbmQgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci90aWNrOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IG9iamVjdCdzIFwiZGVsdGFcIiBwcm9wZXJ0aWVzIHRvIG1ha2UgdGhpcyBlYXNpZXIuXG5cdCAqXG5cdCAqIEZhbGxzIGJhY2sgb24ge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1RJTUVPVVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaWYgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBBUEkgaXMgbm90XG5cdCAqIHN1cHBvcnRlZC5cblx0ICogQHByb3BlcnR5IFJBRlxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IFwicmFmXCJcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0VGlja2VyLlJBRiA9IFwicmFmXCI7XG5cblx0LyoqXG5cdCAqIEluIHRoaXMgbW9kZSwgVGlja2VyIHVzZXMgdGhlIHNldFRpbWVvdXQgQVBJLiBUaGlzIHByb3ZpZGVzIHByZWRpY3RhYmxlLCBhZGFwdGl2ZSBmcmFtZSB0aW1pbmcsIGJ1dCBkb2VzIG5vdFxuXHQgKiBwcm92aWRlIHRoZSBiZW5lZml0cyBvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKHNjcmVlbiBzeW5jaCwgYmFja2dyb3VuZCB0aHJvdHRsaW5nKS5cblx0ICogQHByb3BlcnR5IFRJTUVPVVRcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBcInRpbWVvdXRcIlxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHRUaWNrZXIuVElNRU9VVCA9IFwidGltZW91dFwiO1xuXG5cbi8vIHN0YXRpYyBldmVudHM6XG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIGVhY2ggdGljay4gVGhlIGV2ZW50IHdpbGwgYmUgZGlzcGF0Y2hlZCB0byBlYWNoIGxpc3RlbmVyIGV2ZW4gd2hlbiB0aGUgVGlja2VyIGhhcyBiZWVuIHBhdXNlZCB1c2luZ1xuXHQgKiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvc2V0UGF1c2VkXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIGhhbmRsZVRpY2spO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZVRpY2soZXZlbnQpIHtcblx0ICogICAgICAgICAgY29uc29sZS5sb2coXCJQYXVzZWQ6XCIsIGV2ZW50LnBhdXNlZCwgZXZlbnQuZGVsdGEpO1xuXHQgKiAgICAgIH1cblx0ICpcblx0ICogQGV2ZW50IHRpY2tcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHBhdXNlZCBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGlja2VyIGlzIGN1cnJlbnRseSBwYXVzZWQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YSBUaGUgdGltZSBlbGFwc2VkIGluIG1zIHNpbmNlIHRoZSBsYXN0IHRpY2suXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFRoZSB0b3RhbCB0aW1lIGluIG1zIHNpbmNlIFRpY2tlciB3YXMgaW5pdGlhbGl6ZWQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBydW5UaW1lIFRoZSB0b3RhbCB0aW1lIGluIG1zIHRoYXQgVGlja2VyIHdhcyBub3QgcGF1c2VkIHNpbmNlIGl0IHdhcyBpbml0aWFsaXplZC4gRm9yIGV4YW1wbGUsXG5cdCAqIFx0eW91IGNvdWxkIGRldGVybWluZSB0aGUgYW1vdW50IG9mIHRpbWUgdGhhdCB0aGUgVGlja2VyIGhhcyBiZWVuIHBhdXNlZCBzaW5jZSBpbml0aWFsaXphdGlvbiB3aXRoIGB0aW1lLXJ1blRpbWVgLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblxuLy8gcHVibGljIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogRGVwcmVjYXRlZCBpbiBmYXZvdXIgb2Yge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3RpbWluZ01vZGVcIn19e3svY3Jvc3NMaW5rfX0sIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4gSWYgdHJ1ZSwgdGltaW5nTW9kZSB3aWxsXG5cdCAqIHVzZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvUkFGX1NZTkNIRURcIn19e3svY3Jvc3NMaW5rfX0gYnkgZGVmYXVsdC5cblx0ICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBpbiBmYXZvdXIgb2Yge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3RpbWluZ01vZGVcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBwcm9wZXJ0eSB1c2VSQUZcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICoqL1xuXHRUaWNrZXIudXNlUkFGID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIFNwZWNpZmllcyB0aGUgdGltaW5nIGFwaSAoc2V0VGltZW91dCBvciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIGFuZCBtb2RlIHRvIHVzZS4gU2VlXG5cdCAqIHt7I2Nyb3NzTGluayBcIlRpY2tlci9USU1FT1VUXCJ9fXt7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvUkFGXCJ9fXt7L2Nyb3NzTGlua319LCBhbmRcblx0ICoge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1JBRl9TWU5DSEVEXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb2RlIGRldGFpbHMuXG5cdCAqIEBwcm9wZXJ0eSB0aW1pbmdNb2RlXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgVGlja2VyLlRJTUVPVVRcblx0ICoqL1xuXHRUaWNrZXIudGltaW5nTW9kZSA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFNwZWNpZmllcyBhIG1heGltdW0gdmFsdWUgZm9yIHRoZSBkZWx0YSBwcm9wZXJ0eSBpbiB0aGUgdGljayBldmVudCBvYmplY3QuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYnVpbGRpbmcgdGltZVxuXHQgKiBiYXNlZCBhbmltYXRpb25zIGFuZCBzeXN0ZW1zIHRvIHByZXZlbnQgaXNzdWVzIGNhdXNlZCBieSBsYXJnZSB0aW1lIGdhcHMgY2F1c2VkIGJ5IGJhY2tncm91bmQgdGFicywgc3lzdGVtIHNsZWVwLFxuXHQgKiBhbGVydCBkaWFsb2dzLCBvciBvdGhlciBibG9ja2luZyByb3V0aW5lcy4gRG91YmxlIHRoZSBleHBlY3RlZCBmcmFtZSBkdXJhdGlvbiBpcyBvZnRlbiBhbiBlZmZlY3RpdmUgdmFsdWVcblx0ICogKGV4LiBtYXhEZWx0YT01MCB3aGVuIHJ1bm5pbmcgYXQgNDBmcHMpLlxuXHQgKiBcblx0ICogVGhpcyBkb2VzIG5vdCBpbXBhY3QgYW55IG90aGVyIHZhbHVlcyAoZXguIHRpbWUsIHJ1blRpbWUsIGV0YyksIHNvIHlvdSBtYXkgZXhwZXJpZW5jZSBpc3N1ZXMgaWYgeW91IGVuYWJsZSBtYXhEZWx0YVxuXHQgKiB3aGVuIHVzaW5nIGJvdGggZGVsdGEgYW5kIG90aGVyIHZhbHVlcy5cblx0ICogXG5cdCAqIElmIDAsIHRoZXJlIGlzIG5vIG1heGltdW0uXG5cdCAqIEBwcm9wZXJ0eSBtYXhEZWx0YVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDBcblx0ICovXG5cdFRpY2tlci5tYXhEZWx0YSA9IDA7XG5cdFxuXHQvKipcblx0ICogV2hlbiB0aGUgdGlja2VyIGlzIHBhdXNlZCwgYWxsIGxpc3RlbmVycyB3aWxsIHN0aWxsIHJlY2VpdmUgYSB0aWNrIGV2ZW50LCBidXQgdGhlIDxjb2RlPnBhdXNlZDwvY29kZT4gcHJvcGVydHlcblx0ICogb2YgdGhlIGV2ZW50IHdpbGwgYmUgYHRydWVgLiBBbHNvLCB3aGlsZSBwYXVzZWQgdGhlIGBydW5UaW1lYCB3aWxsIG5vdCBpbmNyZWFzZS4gU2VlIHt7I2Nyb3NzTGluayBcIlRpY2tlci90aWNrOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvZ2V0VGltZVwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHt7I2Nyb3NzTGluayBcIlRpY2tlci9nZXRFdmVudFRpbWVcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmVcblx0ICogaW5mby5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLlRpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBoYW5kbGVUaWNrKTtcblx0ICogICAgICBjcmVhdGVqcy5UaWNrZXIucGF1c2VkID0gdHJ1ZTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVUaWNrKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LnBhdXNlZCxcblx0ICogICAgICAgICAgXHRjcmVhdGVqcy5UaWNrZXIuZ2V0VGltZShmYWxzZSksXG5cdCAqICAgICAgICAgIFx0Y3JlYXRlanMuVGlja2VyLmdldFRpbWUodHJ1ZSkpO1xuXHQgKiAgICAgIH1cblx0ICpcblx0ICogQHByb3BlcnR5IHBhdXNlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAZGVmYXVsdCBmYWxzZVxuXHQgKiovXG5cdFRpY2tlci5wYXVzZWQgPSBmYWxzZTtcblxuXG4vLyBtaXgtaW5zOlxuXHQvLyBFdmVudERpc3BhdGNoZXIgbWV0aG9kczpcblx0VGlja2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBudWxsO1xuXHRUaWNrZXIucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMgPSBudWxsO1xuXHRUaWNrZXIuZGlzcGF0Y2hFdmVudCA9IG51bGw7XG5cdFRpY2tlci5oYXNFdmVudExpc3RlbmVyID0gbnVsbDtcblx0VGlja2VyLl9saXN0ZW5lcnMgPSBudWxsO1xuXHRjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZShUaWNrZXIpOyAvLyBpbmplY3QgRXZlbnREaXNwYXRjaGVyIG1ldGhvZHMuXG5cdFRpY2tlci5fYWRkRXZlbnRMaXN0ZW5lciA9IFRpY2tlci5hZGRFdmVudExpc3RlbmVyO1xuXHRUaWNrZXIuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuXHRcdCFUaWNrZXIuX2luaXRlZCYmVGlja2VyLmluaXQoKTtcblx0XHRyZXR1cm4gVGlja2VyLl9hZGRFdmVudExpc3RlbmVyLmFwcGx5KFRpY2tlciwgYXJndW1lbnRzKTtcblx0fTtcblxuXG4vLyBwcml2YXRlIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQHByb3BlcnR5IF9pbml0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5faW5pdGVkID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfc3RhcnRUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fc3RhcnRUaW1lID0gMDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IF9wYXVzZWRUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fcGF1c2VkVGltZT0wO1xuXG5cdC8qKlxuXHQgKiBUaGUgbnVtYmVyIG9mIHRpY2tzIHRoYXQgaGF2ZSBwYXNzZWRcblx0ICogQHByb3BlcnR5IF90aWNrc1xuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3RpY2tzID0gMDtcblxuXHQvKipcblx0ICogVGhlIG51bWJlciBvZiB0aWNrcyB0aGF0IGhhdmUgcGFzc2VkIHdoaWxlIFRpY2tlciBoYXMgYmVlbiBwYXVzZWRcblx0ICogQHByb3BlcnR5IF9wYXVzZWRUaWNrc1xuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3BhdXNlZFRpY2tzID0gMDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IF9pbnRlcnZhbFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX2ludGVydmFsID0gNTA7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfbGFzdFRpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9sYXN0VGltZSA9IDA7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfdGltZXNcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3RpbWVzID0gbnVsbDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IF90aWNrVGltZXNcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3RpY2tUaW1lcyA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFN0b3JlcyB0aGUgdGltZW91dCBvciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgaWQuXG5cdCAqIEBwcm9wZXJ0eSBfdGltZXJJZFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3RpbWVySWQgPSBudWxsO1xuXHRcblx0LyoqXG5cdCAqIFRydWUgaWYgY3VycmVudGx5IHVzaW5nIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgZmFsc2UgaWYgdXNpbmcgc2V0VGltZW91dC4gVGhpcyBtYXkgYmUgZGlmZmVyZW50IHRoYW4gdGltaW5nTW9kZVxuXHQgKiBpZiB0aGF0IHByb3BlcnR5IGNoYW5nZWQgYW5kIGEgdGljayBoYXNuJ3QgZmlyZWQuXG5cdCAqIEBwcm9wZXJ0eSBfcmFmXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3JhZiA9IHRydWU7XG5cdFxuXG4vLyBzdGF0aWMgZ2V0dGVyIC8gc2V0dGVyczpcblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2ludGVydmFsOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2Qgc2V0SW50ZXJ2YWxcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gaW50ZXJ2YWxcblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRUaWNrZXIuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbihpbnRlcnZhbCkge1xuXHRcdFRpY2tlci5faW50ZXJ2YWwgPSBpbnRlcnZhbDtcblx0XHRpZiAoIVRpY2tlci5faW5pdGVkKSB7IHJldHVybjsgfVxuXHRcdFRpY2tlci5fc2V0dXBUaWNrKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2ludGVydmFsOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2QgZ2V0SW50ZXJ2YWxcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0VGlja2VyLmdldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFRpY2tlci5faW50ZXJ2YWw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2ZyYW1lcmF0ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIHNldEZQU1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdFRpY2tlci5zZXRGUFMgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFRpY2tlci5zZXRJbnRlcnZhbCgxMDAwL3ZhbHVlKTtcblx0fTtcblxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvZnJhbWVyYXRlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2QgZ2V0RlBTXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdFRpY2tlci5nZXRGUFMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gMTAwMC9UaWNrZXIuX2ludGVydmFsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgdGhlIHRhcmdldCB0aW1lIChpbiBtaWxsaXNlY29uZHMpIGJldHdlZW4gdGlja3MuIERlZmF1bHQgaXMgNTAgKDIwIEZQUykuXG5cdCAqIE5vdGUgdGhhdCBhY3R1YWwgdGltZSBiZXR3ZWVuIHRpY2tzIG1heSBiZSBtb3JlIHRoYW4gc3BlY2lmaWVkIGRlcGVuZGluZyBvbiBDUFUgbG9hZC5cblx0ICogVGhpcyBwcm9wZXJ0eSBpcyBpZ25vcmVkIGlmIHRoZSB0aWNrZXIgaXMgdXNpbmcgdGhlIGBSQUZgIHRpbWluZyBtb2RlLlxuXHQgKiBAcHJvcGVydHkgaW50ZXJ2YWxcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiovXG5cdCBcblx0LyoqXG5cdCAqIEluZGljYXRlcyB0aGUgdGFyZ2V0IGZyYW1lIHJhdGUgaW4gZnJhbWVzIHBlciBzZWNvbmQgKEZQUykuIEVmZmVjdGl2ZWx5IGp1c3QgYSBzaG9ydGN1dCB0byBgaW50ZXJ2YWxgLCB3aGVyZVxuXHQgKiBgZnJhbWVyYXRlID09IDEwMDAvaW50ZXJ2YWxgLlxuXHQgKiBAcHJvcGVydHkgZnJhbWVyYXRlXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICoqL1xuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRpY2tlciwge1xuXHRcdFx0aW50ZXJ2YWw6IHsgZ2V0OiBUaWNrZXIuZ2V0SW50ZXJ2YWwsIHNldDogVGlja2VyLnNldEludGVydmFsIH0sXG5cdFx0XHRmcmFtZXJhdGU6IHsgZ2V0OiBUaWNrZXIuZ2V0RlBTLCBzZXQ6IFRpY2tlci5zZXRGUFMgfVxuXHRcdH0pO1xuXHR9IGNhdGNoIChlKSB7IGNvbnNvbGUubG9nKGUpOyB9XG5cblxuLy8gcHVibGljIHN0YXRpYyBtZXRob2RzOlxuXHQvKipcblx0ICogU3RhcnRzIHRoZSB0aWNrLiBUaGlzIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIGZpcnN0IGxpc3RlbmVyIGlzIGFkZGVkLlxuXHQgKiBAbWV0aG9kIGluaXRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRpY2tlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKFRpY2tlci5faW5pdGVkKSB7IHJldHVybjsgfVxuXHRcdFRpY2tlci5faW5pdGVkID0gdHJ1ZTtcblx0XHRUaWNrZXIuX3RpbWVzID0gW107XG5cdFx0VGlja2VyLl90aWNrVGltZXMgPSBbXTtcblx0XHRUaWNrZXIuX3N0YXJ0VGltZSA9IFRpY2tlci5fZ2V0VGltZSgpO1xuXHRcdFRpY2tlci5fdGltZXMucHVzaChUaWNrZXIuX2xhc3RUaW1lID0gMCk7XG5cdFx0VGlja2VyLmludGVydmFsID0gVGlja2VyLl9pbnRlcnZhbDtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBTdG9wcyB0aGUgVGlja2VyIGFuZCByZW1vdmVzIGFsbCBsaXN0ZW5lcnMuIFVzZSBpbml0KCkgdG8gcmVzdGFydCB0aGUgVGlja2VyLlxuXHQgKiBAbWV0aG9kIHJlc2V0XG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUaWNrZXIucmVzZXQgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoVGlja2VyLl9yYWYpIHtcblx0XHRcdHZhciBmID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm9DYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNDYW5jZWxBbmltYXRpb25GcmFtZTtcblx0XHRcdGYmJmYoVGlja2VyLl90aW1lcklkKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KFRpY2tlci5fdGltZXJJZCk7XG5cdFx0fVxuXHRcdFRpY2tlci5yZW1vdmVBbGxFdmVudExpc3RlbmVycyhcInRpY2tcIik7XG5cdFx0VGlja2VyLl90aW1lcklkID0gVGlja2VyLl90aW1lcyA9IFRpY2tlci5fdGlja1RpbWVzID0gbnVsbDtcblx0XHRUaWNrZXIuX3N0YXJ0VGltZSA9IFRpY2tlci5fbGFzdFRpbWUgPSBUaWNrZXIuX3RpY2tzID0gMDtcblx0XHRUaWNrZXIuX2luaXRlZCA9IGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhdmVyYWdlIHRpbWUgc3BlbnQgd2l0aGluIGEgdGljay4gVGhpcyBjYW4gdmFyeSBzaWduaWZpY2FudGx5IGZyb20gdGhlIHZhbHVlIHByb3ZpZGVkIGJ5IGdldE1lYXN1cmVkRlBTXG5cdCAqIGJlY2F1c2UgaXQgb25seSBtZWFzdXJlcyB0aGUgdGltZSBzcGVudCB3aXRoaW4gdGhlIHRpY2sgZXhlY3V0aW9uIHN0YWNrLiBcblx0ICogXG5cdCAqIEV4YW1wbGUgMTogV2l0aCBhIHRhcmdldCBGUFMgb2YgMjAsIGdldE1lYXN1cmVkRlBTKCkgcmV0dXJucyAyMGZwcywgd2hpY2ggaW5kaWNhdGVzIGFuIGF2ZXJhZ2Ugb2YgNTBtcyBiZXR3ZWVuIFxuXHQgKiB0aGUgZW5kIG9mIG9uZSB0aWNrIGFuZCB0aGUgZW5kIG9mIHRoZSBuZXh0LiBIb3dldmVyLCBnZXRNZWFzdXJlZFRpY2tUaW1lKCkgcmV0dXJucyAxNW1zLiBUaGlzIGluZGljYXRlcyB0aGF0IFxuXHQgKiB0aGVyZSBtYXkgYmUgdXAgdG8gMzVtcyBvZiBcImlkbGVcIiB0aW1lIGJldHdlZW4gdGhlIGVuZCBvZiBvbmUgdGljayBhbmQgdGhlIHN0YXJ0IG9mIHRoZSBuZXh0LlxuXHQgKlxuXHQgKiBFeGFtcGxlIDI6IFdpdGggYSB0YXJnZXQgRlBTIG9mIDMwLCBnZXRGUFMoKSByZXR1cm5zIDEwZnBzLCB3aGljaCBpbmRpY2F0ZXMgYW4gYXZlcmFnZSBvZiAxMDBtcyBiZXR3ZWVuIHRoZSBlbmQgb2Zcblx0ICogb25lIHRpY2sgYW5kIHRoZSBlbmQgb2YgdGhlIG5leHQuIEhvd2V2ZXIsIGdldE1lYXN1cmVkVGlja1RpbWUoKSByZXR1cm5zIDIwbXMuIFRoaXMgd291bGQgaW5kaWNhdGUgdGhhdCBzb21ldGhpbmdcblx0ICogb3RoZXIgdGhhbiB0aGUgdGljayBpcyB1c2luZyB+ODBtcyAoYW5vdGhlciBzY3JpcHQsIERPTSByZW5kZXJpbmcsIGV0YykuXG5cdCAqIEBtZXRob2QgZ2V0TWVhc3VyZWRUaWNrVGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGlja3NdIFRoZSBudW1iZXIgb2YgcHJldmlvdXMgdGlja3Mgb3ZlciB3aGljaCB0byBtZWFzdXJlIHRoZSBhdmVyYWdlIHRpbWUgc3BlbnQgaW4gYSB0aWNrLlxuXHQgKiBEZWZhdWx0cyB0byB0aGUgbnVtYmVyIG9mIHRpY2tzIHBlciBzZWNvbmQuIFRvIGdldCBvbmx5IHRoZSBsYXN0IHRpY2sncyB0aW1lLCBwYXNzIGluIDEuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGF2ZXJhZ2UgdGltZSBzcGVudCBpbiBhIHRpY2sgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKiovXG5cdFRpY2tlci5nZXRNZWFzdXJlZFRpY2tUaW1lID0gZnVuY3Rpb24odGlja3MpIHtcblx0XHR2YXIgdHRsPTAsIHRpbWVzPVRpY2tlci5fdGlja1RpbWVzO1xuXHRcdGlmICghdGltZXMgfHwgdGltZXMubGVuZ3RoIDwgMSkgeyByZXR1cm4gLTE7IH1cblxuXHRcdC8vIGJ5IGRlZmF1bHQsIGNhbGN1bGF0ZSBhdmVyYWdlIGZvciB0aGUgcGFzdCB+MSBzZWNvbmQ6XG5cdFx0dGlja3MgPSBNYXRoLm1pbih0aW1lcy5sZW5ndGgsIHRpY2tzfHwoVGlja2VyLmdldEZQUygpfDApKTtcblx0XHRmb3IgKHZhciBpPTA7IGk8dGlja3M7IGkrKykgeyB0dGwgKz0gdGltZXNbaV07IH1cblx0XHRyZXR1cm4gdHRsL3RpY2tzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhY3R1YWwgZnJhbWVzIC8gdGlja3MgcGVyIHNlY29uZC5cblx0ICogQG1ldGhvZCBnZXRNZWFzdXJlZEZQU1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGlja3NdIFRoZSBudW1iZXIgb2YgcHJldmlvdXMgdGlja3Mgb3ZlciB3aGljaCB0byBtZWFzdXJlIHRoZSBhY3R1YWwgZnJhbWVzIC8gdGlja3MgcGVyIHNlY29uZC5cblx0ICogRGVmYXVsdHMgdG8gdGhlIG51bWJlciBvZiB0aWNrcyBwZXIgc2Vjb25kLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBhY3R1YWwgZnJhbWVzIC8gdGlja3MgcGVyIHNlY29uZC4gRGVwZW5kaW5nIG9uIHBlcmZvcm1hbmNlLCB0aGlzIG1heSBkaWZmZXJcblx0ICogZnJvbSB0aGUgdGFyZ2V0IGZyYW1lcyBwZXIgc2Vjb25kLlxuXHQgKiovXG5cdFRpY2tlci5nZXRNZWFzdXJlZEZQUyA9IGZ1bmN0aW9uKHRpY2tzKSB7XG5cdFx0dmFyIHRpbWVzID0gVGlja2VyLl90aW1lcztcblx0XHRpZiAoIXRpbWVzIHx8IHRpbWVzLmxlbmd0aCA8IDIpIHsgcmV0dXJuIC0xOyB9XG5cblx0XHQvLyBieSBkZWZhdWx0LCBjYWxjdWxhdGUgZnBzIGZvciB0aGUgcGFzdCB+MSBzZWNvbmQ6XG5cdFx0dGlja3MgPSBNYXRoLm1pbih0aW1lcy5sZW5ndGgtMSwgdGlja3N8fChUaWNrZXIuZ2V0RlBTKCl8MCkpO1xuXHRcdHJldHVybiAxMDAwLygodGltZXNbMF0tdGltZXNbdGlja3NdKS90aWNrcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3BhdXNlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIHNldFBhdXNlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRUaWNrZXIuc2V0UGF1c2VkID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHQvLyBUT0RPOiBkZXByZWNhdGVkLlxuXHRcdFRpY2tlci5wYXVzZWQgPSB2YWx1ZTtcblx0fTtcblxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvcGF1c2VkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2QgZ2V0UGF1c2VkXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRUaWNrZXIuZ2V0UGF1c2VkID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gVE9ETzogZGVwcmVjYXRlZC5cblx0XHRyZXR1cm4gVGlja2VyLnBhdXNlZDtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZSBUaWNrZXIgd2FzIGluaXRpYWxpemVkIHZpYSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvaW5pdFwifX0uXG5cdCAqIFJldHVybnMgLTEgaWYgVGlja2VyIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZC4gRm9yIGV4YW1wbGUsIHlvdSBjb3VsZCB1c2Vcblx0ICogdGhpcyBpbiBhIHRpbWUgc3luY2hyb25pemVkIGFuaW1hdGlvbiB0byBkZXRlcm1pbmUgdGhlIGV4YWN0IGFtb3VudCBvZiB0aW1lIHRoYXQgaGFzIGVsYXBzZWQuXG5cdCAqIEBtZXRob2QgZ2V0VGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3J1blRpbWU9ZmFsc2VdIElmIHRydWUgb25seSB0aW1lIGVsYXBzZWQgd2hpbGUgVGlja2VyIHdhcyBub3QgcGF1c2VkIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIElmIGZhbHNlLCB0aGUgdmFsdWUgcmV0dXJuZWQgd2lsbCBiZSB0b3RhbCB0aW1lIGVsYXBzZWQgc2luY2UgdGhlIGZpcnN0IHRpY2sgZXZlbnQgbGlzdGVuZXIgd2FzIGFkZGVkLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IE51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2UgVGlja2VyIHdhcyBpbml0aWFsaXplZCBvciAtMS5cblx0ICoqL1xuXHRUaWNrZXIuZ2V0VGltZSA9IGZ1bmN0aW9uKHJ1blRpbWUpIHtcblx0XHRyZXR1cm4gVGlja2VyLl9zdGFydFRpbWUgPyBUaWNrZXIuX2dldFRpbWUoKSAtIChydW5UaW1lID8gVGlja2VyLl9wYXVzZWRUaW1lIDogMCkgOiAtMTtcblx0fTtcblxuXHQvKipcblx0ICogU2ltaWxhciB0byB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2dldFRpbWVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLCBidXQgcmV0dXJucyB0aGUgdGltZSBvbiB0aGUgbW9zdCByZWNlbnQge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3RpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIGdldEV2ZW50VGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSBydW5UaW1lIHtCb29sZWFufSBbcnVuVGltZT1mYWxzZV0gSWYgdHJ1ZSwgdGhlIHJ1blRpbWUgcHJvcGVydHkgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkIG9mIHRpbWUuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB0aW1lIG9yIHJ1blRpbWUgcHJvcGVydHkgZnJvbSB0aGUgbW9zdCByZWNlbnQgdGljayBldmVudCBvciAtMS5cblx0ICovXG5cdFRpY2tlci5nZXRFdmVudFRpbWUgPSBmdW5jdGlvbihydW5UaW1lKSB7XG5cdFx0cmV0dXJuIFRpY2tlci5fc3RhcnRUaW1lID8gKFRpY2tlci5fbGFzdFRpbWUgfHwgVGlja2VyLl9zdGFydFRpbWUpIC0gKHJ1blRpbWUgPyBUaWNrZXIuX3BhdXNlZFRpbWUgOiAwKSA6IC0xO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiB0aWNrcyB0aGF0IGhhdmUgYmVlbiBicm9hZGNhc3QgYnkgVGlja2VyLlxuXHQgKiBAbWV0aG9kIGdldFRpY2tzXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtCb29sZWFufSBwYXVzZWFibGUgSW5kaWNhdGVzIHdoZXRoZXIgdG8gaW5jbHVkZSB0aWNrcyB0aGF0IHdvdWxkIGhhdmUgYmVlbiBicm9hZGNhc3Rcblx0ICogd2hpbGUgVGlja2VyIHdhcyBwYXVzZWQuIElmIHRydWUgb25seSB0aWNrIGV2ZW50cyBicm9hZGNhc3Qgd2hpbGUgVGlja2VyIGlzIG5vdCBwYXVzZWQgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogSWYgZmFsc2UsIHRpY2sgZXZlbnRzIHRoYXQgd291bGQgaGF2ZSBiZWVuIGJyb2FkY2FzdCB3aGlsZSBUaWNrZXIgd2FzIHBhdXNlZCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSByZXR1cm5cblx0ICogdmFsdWUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGZhbHNlLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IG9mIHRpY2tzIHRoYXQgaGF2ZSBiZWVuIGJyb2FkY2FzdC5cblx0ICoqL1xuXHRUaWNrZXIuZ2V0VGlja3MgPSBmdW5jdGlvbihwYXVzZWFibGUpIHtcblx0XHRyZXR1cm4gIFRpY2tlci5fdGlja3MgLSAocGF1c2VhYmxlID8gVGlja2VyLl9wYXVzZWRUaWNrcyA6IDApO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgc3RhdGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVTeW5jaFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX2hhbmRsZVN5bmNoID0gZnVuY3Rpb24oKSB7XG5cdFx0VGlja2VyLl90aW1lcklkID0gbnVsbDtcblx0XHRUaWNrZXIuX3NldHVwVGljaygpO1xuXG5cdFx0Ly8gcnVuIGlmIGVub3VnaCB0aW1lIGhhcyBlbGFwc2VkLCB3aXRoIGEgbGl0dGxlIGJpdCBvZiBmbGV4aWJpbGl0eSB0byBiZSBlYXJseTpcblx0XHRpZiAoVGlja2VyLl9nZXRUaW1lKCkgLSBUaWNrZXIuX2xhc3RUaW1lID49IChUaWNrZXIuX2ludGVydmFsLTEpKjAuOTcpIHtcblx0XHRcdFRpY2tlci5fdGljaygpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlUkFGXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5faGFuZGxlUkFGID0gZnVuY3Rpb24oKSB7XG5cdFx0VGlja2VyLl90aW1lcklkID0gbnVsbDtcblx0XHRUaWNrZXIuX3NldHVwVGljaygpO1xuXHRcdFRpY2tlci5fdGljaygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVUaW1lb3V0XG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5faGFuZGxlVGltZW91dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFRpY2tlci5fdGltZXJJZCA9IG51bGw7XG5cdFx0VGlja2VyLl9zZXR1cFRpY2soKTtcblx0XHRUaWNrZXIuX3RpY2soKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfc2V0dXBUaWNrXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fc2V0dXBUaWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKFRpY2tlci5fdGltZXJJZCAhPSBudWxsKSB7IHJldHVybjsgfSAvLyBhdm9pZCBkdXBsaWNhdGVzXG5cblx0XHR2YXIgbW9kZSA9IFRpY2tlci50aW1pbmdNb2RlfHwoVGlja2VyLnVzZVJBRiYmVGlja2VyLlJBRl9TWU5DSEVEKTtcblx0XHRpZiAobW9kZSA9PSBUaWNrZXIuUkFGX1NZTkNIRUQgfHwgbW9kZSA9PSBUaWNrZXIuUkFGKSB7XG5cdFx0XHR2YXIgZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZTtcblx0XHRcdGlmIChmKSB7XG5cdFx0XHRcdFRpY2tlci5fdGltZXJJZCA9IGYobW9kZSA9PSBUaWNrZXIuUkFGID8gVGlja2VyLl9oYW5kbGVSQUYgOiBUaWNrZXIuX2hhbmRsZVN5bmNoKTtcblx0XHRcdFx0VGlja2VyLl9yYWYgPSB0cnVlO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFRpY2tlci5fcmFmID0gZmFsc2U7XG5cdFx0VGlja2VyLl90aW1lcklkID0gc2V0VGltZW91dChUaWNrZXIuX2hhbmRsZVRpbWVvdXQsIFRpY2tlci5faW50ZXJ2YWwpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF90aWNrXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fdGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXVzZWQgPSBUaWNrZXIucGF1c2VkO1xuXHRcdHZhciB0aW1lID0gVGlja2VyLl9nZXRUaW1lKCk7XG5cdFx0dmFyIGVsYXBzZWRUaW1lID0gdGltZS1UaWNrZXIuX2xhc3RUaW1lO1xuXHRcdFRpY2tlci5fbGFzdFRpbWUgPSB0aW1lO1xuXHRcdFRpY2tlci5fdGlja3MrKztcblx0XHRcblx0XHRpZiAocGF1c2VkKSB7XG5cdFx0XHRUaWNrZXIuX3BhdXNlZFRpY2tzKys7XG5cdFx0XHRUaWNrZXIuX3BhdXNlZFRpbWUgKz0gZWxhcHNlZFRpbWU7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChUaWNrZXIuaGFzRXZlbnRMaXN0ZW5lcihcInRpY2tcIikpIHtcblx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcInRpY2tcIik7XG5cdFx0XHR2YXIgbWF4RGVsdGEgPSBUaWNrZXIubWF4RGVsdGE7XG5cdFx0XHRldmVudC5kZWx0YSA9IChtYXhEZWx0YSAmJiBlbGFwc2VkVGltZSA+IG1heERlbHRhKSA/IG1heERlbHRhIDogZWxhcHNlZFRpbWU7XG5cdFx0XHRldmVudC5wYXVzZWQgPSBwYXVzZWQ7XG5cdFx0XHRldmVudC50aW1lID0gdGltZTtcblx0XHRcdGV2ZW50LnJ1blRpbWUgPSB0aW1lLVRpY2tlci5fcGF1c2VkVGltZTtcblx0XHRcdFRpY2tlci5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0XHR9XG5cdFx0XG5cdFx0VGlja2VyLl90aWNrVGltZXMudW5zaGlmdChUaWNrZXIuX2dldFRpbWUoKS10aW1lKTtcblx0XHR3aGlsZSAoVGlja2VyLl90aWNrVGltZXMubGVuZ3RoID4gMTAwKSB7IFRpY2tlci5fdGlja1RpbWVzLnBvcCgpOyB9XG5cblx0XHRUaWNrZXIuX3RpbWVzLnVuc2hpZnQodGltZSk7XG5cdFx0d2hpbGUgKFRpY2tlci5fdGltZXMubGVuZ3RoID4gMTAwKSB7IFRpY2tlci5fdGltZXMucG9wKCk7IH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0VGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHR2YXIgbm93ID0gd2luZG93LnBlcmZvcm1hbmNlICYmIChwZXJmb3JtYW5jZS5ub3cgfHwgcGVyZm9ybWFuY2UubW96Tm93IHx8IHBlcmZvcm1hbmNlLm1zTm93IHx8IHBlcmZvcm1hbmNlLm9Ob3cgfHwgcGVyZm9ybWFuY2Uud2Via2l0Tm93KTtcblx0VGlja2VyLl9nZXRUaW1lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICgobm93JiZub3cuY2FsbChwZXJmb3JtYW5jZSkpfHwobmV3IERhdGUoKS5nZXRUaW1lKCkpKSAtIFRpY2tlci5fc3RhcnRUaW1lO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuVGlja2VyID0gVGlja2VyO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFVJRC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEdsb2JhbCB1dGlsaXR5IGZvciBnZW5lcmF0aW5nIHNlcXVlbnRpYWwgdW5pcXVlIElEIG51bWJlcnMuIFRoZSBVSUQgY2xhc3MgdXNlcyBhIHN0YXRpYyBpbnRlcmZhY2UgKGV4LiA8Y29kZT5VSUQuZ2V0KCk8L2NvZGU+KVxuXHQgKiBhbmQgc2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQuXG5cdCAqIEBjbGFzcyBVSURcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdGZ1bmN0aW9uIFVJRCgpIHtcblx0XHR0aHJvdyBcIlVJRCBjYW5ub3QgYmUgaW5zdGFudGlhdGVkXCI7XG5cdH1cblxuXG4vLyBwcml2YXRlIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQHByb3BlcnR5IF9uZXh0SURcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRVSUQuX25leHRJRCA9IDA7XG5cblxuLy8gcHVibGljIHN0YXRpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbmV4dCB1bmlxdWUgaWQuXG5cdCAqIEBtZXRob2QgZ2V0XG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIG5leHQgdW5pcXVlIGlkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRVSUQuZ2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFVJRC5fbmV4dElEKys7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5VSUQgPSBVSUQ7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gTW91c2VFdmVudC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFBhc3NlZCBhcyB0aGUgcGFyYW1ldGVyIHRvIGFsbCBtb3VzZS9wb2ludGVyL3RvdWNoIHJlbGF0ZWQgZXZlbnRzLiBGb3IgYSBsaXN0aW5nIG9mIG1vdXNlIGV2ZW50cyBhbmQgdGhlaXIgcHJvcGVydGllcyxcblx0ICogc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0XCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJTdGFnZVwifX17ey9jcm9zc0xpbmt9fSBldmVudCBsaXN0aW5ncy5cblx0ICogQGNsYXNzIE1vdXNlRXZlbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYnViYmxlcyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZXZlbnQgd2lsbCBidWJibGUgdGhyb3VnaCB0aGUgZGlzcGxheSBsaXN0LlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNhbmNlbGFibGUgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9mIHRoaXMgZXZlbnQgY2FuIGJlIGNhbmNlbGxlZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YWdlWCBUaGUgbm9ybWFsaXplZCB4IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBzdGFnZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YWdlWSBUaGUgbm9ybWFsaXplZCB5IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBzdGFnZS5cblx0ICogQHBhcmFtIHtNb3VzZUV2ZW50fSBuYXRpdmVFdmVudCBUaGUgbmF0aXZlIERPTSBldmVudCByZWxhdGVkIHRvIHRoaXMgbW91c2UgZXZlbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb2ludGVySUQgVGhlIHVuaXF1ZSBpZCBmb3IgdGhlIHBvaW50ZXIuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJpbWFyeSBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIHRoZSBwcmltYXJ5IHBvaW50ZXIgaW4gYSBtdWx0aXRvdWNoIGVudmlyb25tZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmF3WCBUaGUgcmF3IHggcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHN0YWdlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmF3WSBUaGUgcmF3IHkgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHN0YWdlLlxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IHJlbGF0ZWRUYXJnZXQgVGhlIHNlY29uZGFyeSB0YXJnZXQgZm9yIHRoZSBldmVudC5cblx0ICogQGV4dGVuZHMgRXZlbnRcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gTW91c2VFdmVudCh0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlLCBzdGFnZVgsIHN0YWdlWSwgbmF0aXZlRXZlbnQsIHBvaW50ZXJJRCwgcHJpbWFyeSwgcmF3WCwgcmF3WSwgcmVsYXRlZFRhcmdldCkge1xuXHRcdHRoaXMuRXZlbnRfY29uc3RydWN0b3IodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSk7XG5cdFx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSBub3JtYWxpemVkIHggcG9zaXRpb24gb24gdGhlIHN0YWdlLiBUaGlzIHdpbGwgYWx3YXlzIGJlIHdpdGhpbiB0aGUgcmFuZ2UgMCB0byBzdGFnZSB3aWR0aC5cblx0XHQgKiBAcHJvcGVydHkgc3RhZ2VYXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0Ki9cblx0XHR0aGlzLnN0YWdlWCA9IHN0YWdlWDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIG5vcm1hbGl6ZWQgeSBwb3NpdGlvbiBvbiB0aGUgc3RhZ2UuIFRoaXMgd2lsbCBhbHdheXMgYmUgd2l0aGluIHRoZSByYW5nZSAwIHRvIHN0YWdlIGhlaWdodC5cblx0XHQgKiBAcHJvcGVydHkgc3RhZ2VZXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuc3RhZ2VZID0gc3RhZ2VZO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgcmF3IHggcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHN0YWdlLiBOb3JtYWxseSB0aGlzIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIHN0YWdlWCB2YWx1ZSwgdW5sZXNzXG5cdFx0ICogc3RhZ2UubW91c2VNb3ZlT3V0c2lkZSBpcyB0cnVlIGFuZCB0aGUgcG9pbnRlciBpcyBvdXRzaWRlIG9mIHRoZSBzdGFnZSBib3VuZHMuXG5cdFx0ICogQHByb3BlcnR5IHJhd1hcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQqL1xuXHRcdHRoaXMucmF3WCA9IChyYXdYPT1udWxsKT9zdGFnZVg6cmF3WDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHJhdyB5IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBzdGFnZS4gTm9ybWFsbHkgdGhpcyB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSBzdGFnZVkgdmFsdWUsIHVubGVzc1xuXHRcdCAqIHN0YWdlLm1vdXNlTW92ZU91dHNpZGUgaXMgdHJ1ZSBhbmQgdGhlIHBvaW50ZXIgaXMgb3V0c2lkZSBvZiB0aGUgc3RhZ2UgYm91bmRzLlxuXHRcdCAqIEBwcm9wZXJ0eSByYXdZXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0Ki9cblx0XHR0aGlzLnJhd1kgPSAocmF3WT09bnVsbCk/c3RhZ2VZOnJhd1k7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBuYXRpdmUgTW91c2VFdmVudCBnZW5lcmF0ZWQgYnkgdGhlIGJyb3dzZXIuIFRoZSBwcm9wZXJ0aWVzIGFuZCBBUEkgZm9yIHRoaXNcblx0XHQgKiBldmVudCBtYXkgZGlmZmVyIGJldHdlZW4gYnJvd3NlcnMuIFRoaXMgcHJvcGVydHkgd2lsbCBiZSBudWxsIGlmIHRoZVxuXHRcdCAqIEVhc2VsSlMgcHJvcGVydHkgd2FzIG5vdCBkaXJlY3RseSBnZW5lcmF0ZWQgZnJvbSBhIG5hdGl2ZSBNb3VzZUV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBuYXRpdmVFdmVudFxuXHRcdCAqIEB0eXBlIEh0bWxNb3VzZUV2ZW50XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqKi9cblx0XHR0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSB1bmlxdWUgaWQgZm9yIHRoZSBwb2ludGVyICh0b3VjaCBwb2ludCBvciBjdXJzb3IpLiBUaGlzIHdpbGwgYmUgZWl0aGVyIC0xIGZvciB0aGUgbW91c2UsIG9yIHRoZSBzeXN0ZW1cblx0XHQgKiBzdXBwbGllZCBpZCB2YWx1ZS5cblx0XHQgKiBAcHJvcGVydHkgcG9pbnRlcklEXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLnBvaW50ZXJJRCA9IHBvaW50ZXJJRDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyB0aGUgcHJpbWFyeSBwb2ludGVyIGluIGEgbXVsdGl0b3VjaCBlbnZpcm9ubWVudC4gVGhpcyB3aWxsIGFsd2F5cyBiZSB0cnVlIGZvciB0aGUgbW91c2UuXG5cdFx0ICogRm9yIHRvdWNoIHBvaW50ZXJzLCB0aGUgZmlyc3QgcG9pbnRlciBpbiB0aGUgY3VycmVudCBzdGFjayB3aWxsIGJlIGNvbnNpZGVyZWQgdGhlIHByaW1hcnkgcG9pbnRlci5cblx0XHQgKiBAcHJvcGVydHkgcHJpbWFyeVxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdHRoaXMucHJpbWFyeSA9ICEhcHJpbWFyeTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBUaGUgc2Vjb25kYXJ5IHRhcmdldCBmb3IgdGhlIGV2ZW50LCBpZiBhcHBsaWNhYmxlLiBUaGlzIGlzIHVzZWQgZm9yIG1vdXNlb3V0L3JvbGxvdXRcblx0XHQgKiBldmVudHMgdG8gaW5kaWNhdGUgdGhlIG9iamVjdCB0aGF0IHRoZSBtb3VzZSBlbnRlcmVkIGZyb20sIG1vdXNlb3Zlci9yb2xsb3ZlciBmb3IgdGhlIG9iamVjdCB0aGUgbW91c2UgZXhpdGVkLFxuXHRcdCAqIGFuZCBzdGFnZW1vdXNlZG93bi9zdGFnZW1vdXNldXAgZXZlbnRzIGZvciB0aGUgb2JqZWN0IHRoYXQgd2FzIHRoZSB1bmRlciB0aGUgY3Vyc29yLCBpZiBhbnkuXG5cdFx0ICogXG5cdFx0ICogT25seSB2YWxpZCBpbnRlcmFjdGlvbiB0YXJnZXRzIHdpbGwgYmUgcmV0dXJuZWQgKGllLiBvYmplY3RzIHdpdGggbW91c2UgbGlzdGVuZXJzIG9yIGEgY3Vyc29yIHNldCkuXG5cdFx0ICogQHByb3BlcnR5IHJlbGF0ZWRUYXJnZXRcblx0XHQgKiBAdHlwZSB7RGlzcGxheU9iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLnJlbGF0ZWRUYXJnZXQgPSByZWxhdGVkVGFyZ2V0O1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKE1vdXNlRXZlbnQsIGNyZWF0ZWpzLkV2ZW50KTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblx0XG5cdFxuLy8gZ2V0dGVyIC8gc2V0dGVyczpcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHggcG9zaXRpb24gb2YgdGhlIG1vdXNlIGluIHRoZSBsb2NhbCBjb29yZGluYXRlIHN5c3RlbSBvZiB0aGUgY3VycmVudCB0YXJnZXQgKGllLiB0aGUgZGlzcGF0Y2hlcikuXG5cdCAqIEBwcm9wZXJ0eSBsb2NhbFhcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHJlYWRvbmx5XG5cdCAqL1xuXHRwLl9nZXRfbG9jYWxYID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY3VycmVudFRhcmdldC5nbG9iYWxUb0xvY2FsKHRoaXMucmF3WCwgdGhpcy5yYXdZKS54O1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHkgcG9zaXRpb24gb2YgdGhlIG1vdXNlIGluIHRoZSBsb2NhbCBjb29yZGluYXRlIHN5c3RlbSBvZiB0aGUgY3VycmVudCB0YXJnZXQgKGllLiB0aGUgZGlzcGF0Y2hlcikuXG5cdCAqIEBwcm9wZXJ0eSBsb2NhbFlcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHJlYWRvbmx5XG5cdCAqL1xuXHRwLl9nZXRfbG9jYWxZID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY3VycmVudFRhcmdldC5nbG9iYWxUb0xvY2FsKHRoaXMucmF3WCwgdGhpcy5yYXdZKS55O1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBldmVudCB3YXMgZ2VuZXJhdGVkIGJ5IGEgdG91Y2ggaW5wdXQgKHZlcnN1cyBhIG1vdXNlIGlucHV0KS5cblx0ICogQHByb3BlcnR5IGlzVG91Y2hcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEByZWFkb25seVxuXHQgKi9cblx0cC5fZ2V0X2lzVG91Y2ggPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wb2ludGVySUQgIT09IC0xO1xuXHR9O1xuXHRcblx0XG5cdHRyeSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMocCwge1xuXHRcdFx0bG9jYWxYOiB7IGdldDogcC5fZ2V0X2xvY2FsWCB9LFxuXHRcdFx0bG9jYWxZOiB7IGdldDogcC5fZ2V0X2xvY2FsWSB9LFxuXHRcdFx0aXNUb3VjaDogeyBnZXQ6IHAuX2dldF9pc1RvdWNoIH1cblx0XHR9KTtcblx0fSBjYXRjaCAoZSkge30gLy8gVE9ETzogdXNlIExvZ1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBNb3VzZUV2ZW50IGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge01vdXNlRXZlbnR9IGEgY2xvbmUgb2YgdGhlIE1vdXNlRXZlbnQgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgTW91c2VFdmVudCh0aGlzLnR5cGUsIHRoaXMuYnViYmxlcywgdGhpcy5jYW5jZWxhYmxlLCB0aGlzLnN0YWdlWCwgdGhpcy5zdGFnZVksIHRoaXMubmF0aXZlRXZlbnQsIHRoaXMucG9pbnRlcklELCB0aGlzLnByaW1hcnksIHRoaXMucmF3WCwgdGhpcy5yYXdZKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW01vdXNlRXZlbnQgKHR5cGU9XCIrdGhpcy50eXBlK1wiIHN0YWdlWD1cIit0aGlzLnN0YWdlWCtcIiBzdGFnZVk9XCIrdGhpcy5zdGFnZVkrXCIpXVwiO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuTW91c2VFdmVudCA9IGNyZWF0ZWpzLnByb21vdGUoTW91c2VFdmVudCwgXCJFdmVudFwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBNYXRyaXgyRC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFJlcHJlc2VudHMgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCwgYW5kIHByb3ZpZGVzIHRvb2xzIGZvciBjb25zdHJ1Y3RpbmcgYW5kIGNvbmNhdGVuYXRpbmcgbWF0cmljZXMuXG5cdCAqXG5cdCAqIFRoaXMgbWF0cml4IGNhbiBiZSB2aXN1YWxpemVkIGFzOlxuXHQgKlxuXHQgKiBcdFsgYSAgYyAgdHhcblx0ICogXHQgIGIgIGQgIHR5XG5cdCAqIFx0ICAwICAwICAxICBdXG5cdCAqXG5cdCAqIE5vdGUgdGhlIGxvY2F0aW9ucyBvZiBiIGFuZCBjLlxuXHQgKlxuXHQgKiBAY2xhc3MgTWF0cml4MkRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthPTFdIFNwZWNpZmllcyB0aGUgYSBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYj0wXSBTcGVjaWZpZXMgdGhlIGIgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2M9MF0gU3BlY2lmaWVzIHRoZSBjIHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtkPTFdIFNwZWNpZmllcyB0aGUgZCBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdHg9MF0gU3BlY2lmaWVzIHRoZSB0eCBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdHk9MF0gU3BlY2lmaWVzIHRoZSB0eSBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIE1hdHJpeDJEKGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuXHRcdHRoaXMuc2V0VmFsdWVzKGEsYixjLGQsdHgsdHkpO1xuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvLyBhc3NpZ25lZCBpbiB0aGUgc2V0VmFsdWVzIG1ldGhvZC5cblx0XHQvKipcblx0XHQgKiBQb3NpdGlvbiAoMCwgMCkgaW4gYSAzeDMgYWZmaW5lIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cblx0XHQgKiBAcHJvcGVydHkgYVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogUG9zaXRpb24gKDAsIDEpIGluIGEgM3gzIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG5cdFx0ICogQHByb3BlcnR5IGJcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBvc2l0aW9uICgxLCAwKSBpbiBhIDN4MyBhZmZpbmUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuXHRcdCAqIEBwcm9wZXJ0eSBjXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBQb3NpdGlvbiAoMSwgMSkgaW4gYSAzeDMgYWZmaW5lIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cblx0XHQgKiBAcHJvcGVydHkgZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogUG9zaXRpb24gKDIsIDApIGluIGEgM3gzIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG5cdFx0ICogQHByb3BlcnR5IHR4XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBQb3NpdGlvbiAoMiwgMSkgaW4gYSAzeDMgYWZmaW5lIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cblx0XHQgKiBAcHJvcGVydHkgdHlcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdH1cblx0dmFyIHAgPSBNYXRyaXgyRC5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cbi8vIGNvbnN0YW50czpcblx0LyoqXG5cdCAqIE11bHRpcGxpZXIgZm9yIGNvbnZlcnRpbmcgZGVncmVlcyB0byByYWRpYW5zLiBVc2VkIGludGVybmFsbHkgYnkgTWF0cml4MkQuXG5cdCAqIEBwcm9wZXJ0eSBERUdfVE9fUkFEXG5cdCAqIEBzdGF0aWNcblx0ICogQGZpbmFsXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHRNYXRyaXgyRC5ERUdfVE9fUkFEID0gTWF0aC5QSS8xODA7XG5cblxuLy8gc3RhdGljIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQW4gaWRlbnRpdHkgbWF0cml4LCByZXByZXNlbnRpbmcgYSBudWxsIHRyYW5zZm9ybWF0aW9uLlxuXHQgKiBAcHJvcGVydHkgaWRlbnRpdHlcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSBNYXRyaXgyRFxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHRNYXRyaXgyRC5pZGVudGl0eSA9IG51bGw7IC8vIHNldCBhdCBib3R0b20gb2YgY2xhc3MgZGVmaW5pdGlvbi5cblx0XG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogU2V0cyB0aGUgc3BlY2lmaWVkIHZhbHVlcyBvbiB0aGlzIGluc3RhbmNlLiBcblx0ICogQG1ldGhvZCBzZXRWYWx1ZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthPTFdIFNwZWNpZmllcyB0aGUgYSBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYj0wXSBTcGVjaWZpZXMgdGhlIGIgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2M9MF0gU3BlY2lmaWVzIHRoZSBjIHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtkPTFdIFNwZWNpZmllcyB0aGUgZCBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdHg9MF0gU3BlY2lmaWVzIHRoZSB0eCBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdHk9MF0gU3BlY2lmaWVzIHRoZSB0eSBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0Ki9cblx0cC5zZXRWYWx1ZXMgPSBmdW5jdGlvbihhLCBiLCBjLCBkLCB0eCwgdHkpIHtcblx0XHQvLyBkb24ndCBmb3JnZXQgdG8gdXBkYXRlIGRvY3MgaW4gdGhlIGNvbnN0cnVjdG9yIGlmIHRoZXNlIGNoYW5nZTpcblx0XHR0aGlzLmEgPSAoYSA9PSBudWxsKSA/IDEgOiBhO1xuXHRcdHRoaXMuYiA9IGIgfHwgMDtcblx0XHR0aGlzLmMgPSBjIHx8IDA7XG5cdFx0dGhpcy5kID0gKGQgPT0gbnVsbCkgPyAxIDogZDtcblx0XHR0aGlzLnR4ID0gdHggfHwgMDtcblx0XHR0aGlzLnR5ID0gdHkgfHwgMDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQXBwZW5kcyB0aGUgc3BlY2lmaWVkIG1hdHJpeCBwcm9wZXJ0aWVzIHRvIHRoaXMgbWF0cml4LiBBbGwgcGFyYW1ldGVycyBhcmUgcmVxdWlyZWQuXG5cdCAqIFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgbXVsdGlwbHlpbmcgYCh0aGlzIG1hdHJpeCkgKiAoc3BlY2lmaWVkIG1hdHJpeClgLlxuXHQgKiBAbWV0aG9kIGFwcGVuZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gYVxuXHQgKiBAcGFyYW0ge051bWJlcn0gYlxuXHQgKiBAcGFyYW0ge051bWJlcn0gY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHR5XG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5hcHBlbmQgPSBmdW5jdGlvbihhLCBiLCBjLCBkLCB0eCwgdHkpIHtcblx0XHR2YXIgYTEgPSB0aGlzLmE7XG5cdFx0dmFyIGIxID0gdGhpcy5iO1xuXHRcdHZhciBjMSA9IHRoaXMuYztcblx0XHR2YXIgZDEgPSB0aGlzLmQ7XG5cdFx0aWYgKGEgIT0gMSB8fCBiICE9IDAgfHwgYyAhPSAwIHx8IGQgIT0gMSkge1xuXHRcdFx0dGhpcy5hICA9IGExKmErYzEqYjtcblx0XHRcdHRoaXMuYiAgPSBiMSphK2QxKmI7XG5cdFx0XHR0aGlzLmMgID0gYTEqYytjMSpkO1xuXHRcdFx0dGhpcy5kICA9IGIxKmMrZDEqZDtcblx0XHR9XG5cdFx0dGhpcy50eCA9IGExKnR4K2MxKnR5K3RoaXMudHg7XG5cdFx0dGhpcy50eSA9IGIxKnR4K2QxKnR5K3RoaXMudHk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFByZXBlbmRzIHRoZSBzcGVjaWZpZWQgbWF0cml4IHByb3BlcnRpZXMgdG8gdGhpcyBtYXRyaXguXG5cdCAqIFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgbXVsdGlwbHlpbmcgYChzcGVjaWZpZWQgbWF0cml4KSAqICh0aGlzIG1hdHJpeClgLlxuXHQgKiBBbGwgcGFyYW1ldGVycyBhcmUgcmVxdWlyZWQuXG5cdCAqIEBtZXRob2QgcHJlcGVuZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gYVxuXHQgKiBAcGFyYW0ge051bWJlcn0gYlxuXHQgKiBAcGFyYW0ge051bWJlcn0gY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHR5XG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5wcmVwZW5kID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgdHgsIHR5KSB7XG5cdFx0dmFyIGExID0gdGhpcy5hO1xuXHRcdHZhciBjMSA9IHRoaXMuYztcblx0XHR2YXIgdHgxID0gdGhpcy50eDtcblxuXHRcdHRoaXMuYSAgPSBhKmExK2MqdGhpcy5iO1xuXHRcdHRoaXMuYiAgPSBiKmExK2QqdGhpcy5iO1xuXHRcdHRoaXMuYyAgPSBhKmMxK2MqdGhpcy5kO1xuXHRcdHRoaXMuZCAgPSBiKmMxK2QqdGhpcy5kO1xuXHRcdHRoaXMudHggPSBhKnR4MStjKnRoaXMudHkrdHg7XG5cdFx0dGhpcy50eSA9IGIqdHgxK2QqdGhpcy50eSt0eTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQXBwZW5kcyB0aGUgc3BlY2lmaWVkIG1hdHJpeCB0byB0aGlzIG1hdHJpeC5cblx0ICogVGhpcyBpcyB0aGUgZXF1aXZhbGVudCBvZiBtdWx0aXBseWluZyBgKHRoaXMgbWF0cml4KSAqIChzcGVjaWZpZWQgbWF0cml4KWAuXG5cdCAqIEBtZXRob2QgYXBwZW5kTWF0cml4XG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeFxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAuYXBwZW5kTWF0cml4ID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG1hdHJpeC5hLCBtYXRyaXguYiwgbWF0cml4LmMsIG1hdHJpeC5kLCBtYXRyaXgudHgsIG1hdHJpeC50eSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFByZXBlbmRzIHRoZSBzcGVjaWZpZWQgbWF0cml4IHRvIHRoaXMgbWF0cml4LlxuXHQgKiBUaGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIG11bHRpcGx5aW5nIGAoc3BlY2lmaWVkIG1hdHJpeCkgKiAodGhpcyBtYXRyaXgpYC5cblx0ICogRm9yIGV4YW1wbGUsIHlvdSBjb3VsZCBjYWxjdWxhdGUgdGhlIGNvbWJpbmVkIHRyYW5zZm9ybWF0aW9uIGZvciBhIGNoaWxkIG9iamVjdCB1c2luZzpcblx0ICogXG5cdCAqIFx0dmFyIG8gPSBteURpc3BsYXlPYmplY3Q7XG5cdCAqIFx0dmFyIG10eCA9IG8uZ2V0TWF0cml4KCk7XG5cdCAqIFx0d2hpbGUgKG8gPSBvLnBhcmVudCkge1xuXHQgKiBcdFx0Ly8gcHJlcGVuZCBlYWNoIHBhcmVudCdzIHRyYW5zZm9ybWF0aW9uIGluIHR1cm46XG5cdCAqIFx0XHRvLnByZXBlbmRNYXRyaXgoby5nZXRNYXRyaXgoKSk7XG5cdCAqIFx0fVxuXHQgKiBAbWV0aG9kIHByZXBlbmRNYXRyaXhcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4XG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5wcmVwZW5kTWF0cml4ID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0cmV0dXJuIHRoaXMucHJlcGVuZChtYXRyaXguYSwgbWF0cml4LmIsIG1hdHJpeC5jLCBtYXRyaXguZCwgbWF0cml4LnR4LCBtYXRyaXgudHkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgbWF0cml4IHByb3BlcnRpZXMgZnJvbSB0aGUgc3BlY2lmaWVkIGRpc3BsYXkgb2JqZWN0IHRyYW5zZm9ybSBwcm9wZXJ0aWVzLCBhbmQgYXBwZW5kcyB0aGVtIHRvIHRoaXMgbWF0cml4LlxuXHQgKiBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgdGhpcyB0byBnZW5lcmF0ZSBhIG1hdHJpeCByZXByZXNlbnRpbmcgdGhlIHRyYW5zZm9ybWF0aW9ucyBvZiBhIGRpc3BsYXkgb2JqZWN0OlxuXHQgKiBcblx0ICogXHR2YXIgbXR4ID0gbmV3IGNyZWF0ZWpzLk1hdHJpeDJEKCk7XG5cdCAqIFx0bXR4LmFwcGVuZFRyYW5zZm9ybShvLngsIG8ueSwgby5zY2FsZVgsIG8uc2NhbGVZLCBvLnJvdGF0aW9uKTtcblx0ICogQG1ldGhvZCBhcHBlbmRUcmFuc2Zvcm1cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWFxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVZXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByb3RhdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2tld1hcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNrZXdZXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByZWdYIE9wdGlvbmFsLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmVnWSBPcHRpb25hbC5cblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLmFwcGVuZFRyYW5zZm9ybSA9IGZ1bmN0aW9uKHgsIHksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgc2tld1gsIHNrZXdZLCByZWdYLCByZWdZKSB7XG5cdFx0aWYgKHJvdGF0aW9uJTM2MCkge1xuXHRcdFx0dmFyIHIgPSByb3RhdGlvbipNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdFx0dmFyIGNvcyA9IE1hdGguY29zKHIpO1xuXHRcdFx0dmFyIHNpbiA9IE1hdGguc2luKHIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb3MgPSAxO1xuXHRcdFx0c2luID0gMDtcblx0XHR9XG5cblx0XHRpZiAoc2tld1ggfHwgc2tld1kpIHtcblx0XHRcdC8vIFRPRE86IGNhbiB0aGlzIGJlIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgYXBwZW5kIG9wZXJhdGlvbj9cblx0XHRcdHNrZXdYICo9IE1hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0XHRza2V3WSAqPSBNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdFx0dGhpcy5hcHBlbmQoTWF0aC5jb3Moc2tld1kpLCBNYXRoLnNpbihza2V3WSksIC1NYXRoLnNpbihza2V3WCksIE1hdGguY29zKHNrZXdYKSwgeCwgeSk7XG5cdFx0XHR0aGlzLmFwcGVuZChjb3Mqc2NhbGVYLCBzaW4qc2NhbGVYLCAtc2luKnNjYWxlWSwgY29zKnNjYWxlWSwgMCwgMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYXBwZW5kKGNvcypzY2FsZVgsIHNpbipzY2FsZVgsIC1zaW4qc2NhbGVZLCBjb3Mqc2NhbGVZLCB4LCB5KTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKHJlZ1ggfHwgcmVnWSkge1xuXHRcdFx0Ly8gYXBwZW5kIHRoZSByZWdpc3RyYXRpb24gb2Zmc2V0OlxuXHRcdFx0dGhpcy50eCAtPSByZWdYKnRoaXMuYStyZWdZKnRoaXMuYzsgXG5cdFx0XHR0aGlzLnR5IC09IHJlZ1gqdGhpcy5iK3JlZ1kqdGhpcy5kO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogR2VuZXJhdGVzIG1hdHJpeCBwcm9wZXJ0aWVzIGZyb20gdGhlIHNwZWNpZmllZCBkaXNwbGF5IG9iamVjdCB0cmFuc2Zvcm0gcHJvcGVydGllcywgYW5kIHByZXBlbmRzIHRoZW0gdG8gdGhpcyBtYXRyaXguXG5cdCAqIEZvciBleGFtcGxlLCB5b3UgY291bGQgY2FsY3VsYXRlIHRoZSBjb21iaW5lZCB0cmFuc2Zvcm1hdGlvbiBmb3IgYSBjaGlsZCBvYmplY3QgdXNpbmc6XG5cdCAqIFxuXHQgKiBcdHZhciBvID0gbXlEaXNwbGF5T2JqZWN0O1xuXHQgKiBcdHZhciBtdHggPSBuZXcgY3JlYXRlanMuTWF0cml4MkQoKTtcblx0ICogXHRkbyAge1xuXHQgKiBcdFx0Ly8gcHJlcGVuZCBlYWNoIHBhcmVudCdzIHRyYW5zZm9ybWF0aW9uIGluIHR1cm46XG5cdCAqIFx0XHRtdHgucHJlcGVuZFRyYW5zZm9ybShvLngsIG8ueSwgby5zY2FsZVgsIG8uc2NhbGVZLCBvLnJvdGF0aW9uLCBvLnNrZXdYLCBvLnNrZXdZLCBvLnJlZ1gsIG8ucmVnWSk7XG5cdCAqIFx0fSB3aGlsZSAobyA9IG8ucGFyZW50KTtcblx0ICogXHRcblx0ICogXHROb3RlIHRoYXQgdGhlIGFib3ZlIGV4YW1wbGUgd291bGQgbm90IGFjY291bnQgZm9yIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvdHJhbnNmb3JtTWF0cml4OnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIFx0dmFsdWVzLiBTZWUge3sjY3Jvc3NMaW5rIFwiTWF0cml4MkQvcHJlcGVuZE1hdHJpeFwifX17ey9jcm9zc0xpbmt9fSBmb3IgYW4gZXhhbXBsZSB0aGF0IGRvZXMuXG5cdCAqIEBtZXRob2QgcHJlcGVuZFRyYW5zZm9ybVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVYXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJvdGF0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBza2V3WFxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2tld1lcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJlZ1ggT3B0aW9uYWwuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByZWdZIE9wdGlvbmFsLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAucHJlcGVuZFRyYW5zZm9ybSA9IGZ1bmN0aW9uKHgsIHksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgc2tld1gsIHNrZXdZLCByZWdYLCByZWdZKSB7XG5cdFx0aWYgKHJvdGF0aW9uJTM2MCkge1xuXHRcdFx0dmFyIHIgPSByb3RhdGlvbipNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdFx0dmFyIGNvcyA9IE1hdGguY29zKHIpO1xuXHRcdFx0dmFyIHNpbiA9IE1hdGguc2luKHIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb3MgPSAxO1xuXHRcdFx0c2luID0gMDtcblx0XHR9XG5cblx0XHRpZiAocmVnWCB8fCByZWdZKSB7XG5cdFx0XHQvLyBwcmVwZW5kIHRoZSByZWdpc3RyYXRpb24gb2Zmc2V0OlxuXHRcdFx0dGhpcy50eCAtPSByZWdYOyB0aGlzLnR5IC09IHJlZ1k7XG5cdFx0fVxuXHRcdGlmIChza2V3WCB8fCBza2V3WSkge1xuXHRcdFx0Ly8gVE9ETzogY2FuIHRoaXMgYmUgY29tYmluZWQgaW50byBhIHNpbmdsZSBwcmVwZW5kIG9wZXJhdGlvbj9cblx0XHRcdHNrZXdYICo9IE1hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0XHRza2V3WSAqPSBNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdFx0dGhpcy5wcmVwZW5kKGNvcypzY2FsZVgsIHNpbipzY2FsZVgsIC1zaW4qc2NhbGVZLCBjb3Mqc2NhbGVZLCAwLCAwKTtcblx0XHRcdHRoaXMucHJlcGVuZChNYXRoLmNvcyhza2V3WSksIE1hdGguc2luKHNrZXdZKSwgLU1hdGguc2luKHNrZXdYKSwgTWF0aC5jb3Moc2tld1gpLCB4LCB5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wcmVwZW5kKGNvcypzY2FsZVgsIHNpbipzY2FsZVgsIC1zaW4qc2NhbGVZLCBjb3Mqc2NhbGVZLCB4LCB5KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgYSBjbG9ja3dpc2Ugcm90YXRpb24gdHJhbnNmb3JtYXRpb24gdG8gdGhlIG1hdHJpeC5cblx0ICogQG1ldGhvZCByb3RhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIFRoZSBhbmdsZSB0byByb3RhdGUgYnksIGluIGRlZ3JlZXMuIFRvIHVzZSBhIHZhbHVlIGluIHJhZGlhbnMsIG11bHRpcGx5IGl0IGJ5IGAxODAvTWF0aC5QSWAuXG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5yb3RhdGUgPSBmdW5jdGlvbihhbmdsZSkge1xuXHRcdGFuZ2xlID0gYW5nbGUqTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHR2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG5cblx0XHR2YXIgYTEgPSB0aGlzLmE7XG5cdFx0dmFyIGIxID0gdGhpcy5iO1xuXG5cdFx0dGhpcy5hID0gYTEqY29zK3RoaXMuYypzaW47XG5cdFx0dGhpcy5iID0gYjEqY29zK3RoaXMuZCpzaW47XG5cdFx0dGhpcy5jID0gLWExKnNpbit0aGlzLmMqY29zO1xuXHRcdHRoaXMuZCA9IC1iMSpzaW4rdGhpcy5kKmNvcztcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQXBwbGllcyBhIHNrZXcgdHJhbnNmb3JtYXRpb24gdG8gdGhlIG1hdHJpeC5cblx0ICogQG1ldGhvZCBza2V3XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBza2V3WCBUaGUgYW1vdW50IHRvIHNrZXcgaG9yaXpvbnRhbGx5IGluIGRlZ3JlZXMuIFRvIHVzZSBhIHZhbHVlIGluIHJhZGlhbnMsIG11bHRpcGx5IGl0IGJ5IGAxODAvTWF0aC5QSWAuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBza2V3WSBUaGUgYW1vdW50IHRvIHNrZXcgdmVydGljYWxseSBpbiBkZWdyZWVzLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQqL1xuXHRwLnNrZXcgPSBmdW5jdGlvbihza2V3WCwgc2tld1kpIHtcblx0XHRza2V3WCA9IHNrZXdYKk1hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0c2tld1kgPSBza2V3WSpNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdHRoaXMuYXBwZW5kKE1hdGguY29zKHNrZXdZKSwgTWF0aC5zaW4oc2tld1kpLCAtTWF0aC5zaW4oc2tld1gpLCBNYXRoLmNvcyhza2V3WCksIDAsIDApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIGEgc2NhbGUgdHJhbnNmb3JtYXRpb24gdG8gdGhlIG1hdHJpeC5cblx0ICogQG1ldGhvZCBzY2FsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgYW1vdW50IHRvIHNjYWxlIGhvcml6b250YWxseS4gRS5HLiBhIHZhbHVlIG9mIDIgd2lsbCBkb3VibGUgdGhlIHNpemUgaW4gdGhlIFggZGlyZWN0aW9uLCBhbmQgMC41IHdpbGwgaGFsdmUgaXQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBhbW91bnQgdG8gc2NhbGUgdmVydGljYWxseS5cblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLnNjYWxlID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdHRoaXMuYSAqPSB4O1xuXHRcdHRoaXMuYiAqPSB4O1xuXHRcdHRoaXMuYyAqPSB5O1xuXHRcdHRoaXMuZCAqPSB5O1xuXHRcdC8vdGhpcy50eCAqPSB4O1xuXHRcdC8vdGhpcy50eSAqPSB5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUcmFuc2xhdGVzIHRoZSBtYXRyaXggb24gdGhlIHggYW5kIHkgYXhlcy5cblx0ICogQG1ldGhvZCB0cmFuc2xhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLnR4ICs9IHRoaXMuYSp4ICsgdGhpcy5jKnk7XG5cdFx0dGhpcy50eSArPSB0aGlzLmIqeCArIHRoaXMuZCp5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBtYXRyaXggdG8gdGhvc2Ugb2YgYW4gaWRlbnRpdHkgbWF0cml4IChvbmUgdGhhdCBhcHBsaWVzIGEgbnVsbCB0cmFuc2Zvcm1hdGlvbikuXG5cdCAqIEBtZXRob2QgaWRlbnRpdHlcblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLmlkZW50aXR5ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5hID0gdGhpcy5kID0gMTtcblx0XHR0aGlzLmIgPSB0aGlzLmMgPSB0aGlzLnR4ID0gdGhpcy50eSA9IDA7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEludmVydHMgdGhlIG1hdHJpeCwgY2F1c2luZyBpdCB0byBwZXJmb3JtIHRoZSBvcHBvc2l0ZSB0cmFuc2Zvcm1hdGlvbi5cblx0ICogQG1ldGhvZCBpbnZlcnRcblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLmludmVydCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhMSA9IHRoaXMuYTtcblx0XHR2YXIgYjEgPSB0aGlzLmI7XG5cdFx0dmFyIGMxID0gdGhpcy5jO1xuXHRcdHZhciBkMSA9IHRoaXMuZDtcblx0XHR2YXIgdHgxID0gdGhpcy50eDtcblx0XHR2YXIgbiA9IGExKmQxLWIxKmMxO1xuXG5cdFx0dGhpcy5hID0gZDEvbjtcblx0XHR0aGlzLmIgPSAtYjEvbjtcblx0XHR0aGlzLmMgPSAtYzEvbjtcblx0XHR0aGlzLmQgPSBhMS9uO1xuXHRcdHRoaXMudHggPSAoYzEqdGhpcy50eS1kMSp0eDEpL247XG5cdFx0dGhpcy50eSA9IC0oYTEqdGhpcy50eS1iMSp0eDEpL247XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbWF0cml4IGlzIGFuIGlkZW50aXR5IG1hdHJpeC5cblx0ICogQG1ldGhvZCBpc0lkZW50aXR5XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqKi9cblx0cC5pc0lkZW50aXR5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudHggPT09IDAgJiYgdGhpcy50eSA9PT0gMCAmJiB0aGlzLmEgPT09IDEgJiYgdGhpcy5iID09PSAwICYmIHRoaXMuYyA9PT0gMCAmJiB0aGlzLmQgPT09IDE7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbWF0cml4IGlzIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWQgbWF0cml4IChhbGwgcHJvcGVydHkgdmFsdWVzIGFyZSBlcXVhbCkuXG5cdCAqIEBtZXRob2QgZXF1YWxzXG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeCBUaGUgbWF0cml4IHRvIGNvbXBhcmUuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqKi9cblx0cC5lcXVhbHMgPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRyZXR1cm4gdGhpcy50eCA9PT0gbWF0cml4LnR4ICYmIHRoaXMudHkgPT09IG1hdHJpeC50eSAmJiB0aGlzLmEgPT09IG1hdHJpeC5hICYmIHRoaXMuYiA9PT0gbWF0cml4LmIgJiYgdGhpcy5jID09PSBtYXRyaXguYyAmJiB0aGlzLmQgPT09IG1hdHJpeC5kO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUcmFuc2Zvcm1zIGEgcG9pbnQgYWNjb3JkaW5nIHRvIHRoaXMgbWF0cml4LlxuXHQgKiBAbWV0aG9kIHRyYW5zZm9ybVBvaW50XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgcG9pbnQgdG8gdHJhbnNmb3JtLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHBvaW50IHRvIHRyYW5zZm9ybS5cblx0ICogQHBhcmFtIHtQb2ludCB8IE9iamVjdH0gW3B0XSBBbiBvYmplY3QgdG8gY29weSB0aGUgcmVzdWx0IGludG8uIElmIG9taXR0ZWQgYSBnZW5lcmljIG9iamVjdCB3aXRoIHgveSBwcm9wZXJ0aWVzIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4ge1BvaW50fSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC50cmFuc2Zvcm1Qb2ludCA9IGZ1bmN0aW9uKHgsIHksIHB0KSB7XG5cdFx0cHQgPSBwdHx8e307XG5cdFx0cHQueCA9IHgqdGhpcy5hK3kqdGhpcy5jK3RoaXMudHg7XG5cdFx0cHQueSA9IHgqdGhpcy5iK3kqdGhpcy5kK3RoaXMudHk7XG5cdFx0cmV0dXJuIHB0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZWNvbXBvc2VzIHRoZSBtYXRyaXggaW50byB0cmFuc2Zvcm0gcHJvcGVydGllcyAoeCwgeSwgc2NhbGVYLCBzY2FsZVksIGFuZCByb3RhdGlvbikuIE5vdGUgdGhhdCB0aGVzZSB2YWx1ZXNcblx0ICogbWF5IG5vdCBtYXRjaCB0aGUgdHJhbnNmb3JtIHByb3BlcnRpZXMgeW91IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIG1hdHJpeCwgdGhvdWdoIHRoZXkgd2lsbCBwcm9kdWNlIHRoZSBzYW1lIHZpc3VhbFxuXHQgKiByZXN1bHRzLlxuXHQgKiBAbWV0aG9kIGRlY29tcG9zZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdG8gYXBwbHkgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0aWVzIHRvLiBJZiBudWxsLCB0aGVuIGEgbmV3IG9iamVjdCB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB0YXJnZXQsIG9yIGEgbmV3IGdlbmVyaWMgb2JqZWN0IHdpdGggdGhlIHRyYW5zZm9ybSBwcm9wZXJ0aWVzIGFwcGxpZWQuXG5cdCovXG5cdHAuZGVjb21wb3NlID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0Ly8gVE9ETzogaXQgd291bGQgYmUgbmljZSB0byBiZSBhYmxlIHRvIHNvbHZlIGZvciB3aGV0aGVyIHRoZSBtYXRyaXggY2FuIGJlIGRlY29tcG9zZWQgaW50byBvbmx5IHNjYWxlL3JvdGF0aW9uIGV2ZW4gd2hlbiBzY2FsZSBpcyBuZWdhdGl2ZVxuXHRcdGlmICh0YXJnZXQgPT0gbnVsbCkgeyB0YXJnZXQgPSB7fTsgfVxuXHRcdHRhcmdldC54ID0gdGhpcy50eDtcblx0XHR0YXJnZXQueSA9IHRoaXMudHk7XG5cdFx0dGFyZ2V0LnNjYWxlWCA9IE1hdGguc3FydCh0aGlzLmEgKiB0aGlzLmEgKyB0aGlzLmIgKiB0aGlzLmIpO1xuXHRcdHRhcmdldC5zY2FsZVkgPSBNYXRoLnNxcnQodGhpcy5jICogdGhpcy5jICsgdGhpcy5kICogdGhpcy5kKTtcblxuXHRcdHZhciBza2V3WCA9IE1hdGguYXRhbjIoLXRoaXMuYywgdGhpcy5kKTtcblx0XHR2YXIgc2tld1kgPSBNYXRoLmF0YW4yKHRoaXMuYiwgdGhpcy5hKTtcblxuXHRcdHZhciBkZWx0YSA9IE1hdGguYWJzKDEtc2tld1gvc2tld1kpO1xuXHRcdGlmIChkZWx0YSA8IDAuMDAwMDEpIHsgLy8gZWZmZWN0aXZlbHkgaWRlbnRpY2FsLCBjYW4gdXNlIHJvdGF0aW9uOlxuXHRcdFx0dGFyZ2V0LnJvdGF0aW9uID0gc2tld1kvTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRcdGlmICh0aGlzLmEgPCAwICYmIHRoaXMuZCA+PSAwKSB7XG5cdFx0XHRcdHRhcmdldC5yb3RhdGlvbiArPSAodGFyZ2V0LnJvdGF0aW9uIDw9IDApID8gMTgwIDogLTE4MDtcblx0XHRcdH1cblx0XHRcdHRhcmdldC5za2V3WCA9IHRhcmdldC5za2V3WSA9IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5za2V3WCA9IHNrZXdYL01hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0XHR0YXJnZXQuc2tld1kgPSBza2V3WS9NYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdH1cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENvcGllcyBhbGwgcHJvcGVydGllcyBmcm9tIHRoZSBzcGVjaWZpZWQgbWF0cml4IHRvIHRoaXMgbWF0cml4LlxuXHQgKiBAbWV0aG9kIGNvcHlcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4IFRoZSBtYXRyaXggdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCovXG5cdHAuY29weSA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHJldHVybiB0aGlzLnNldFZhbHVlcyhtYXRyaXguYSwgbWF0cml4LmIsIG1hdHJpeC5jLCBtYXRyaXguZCwgbWF0cml4LnR4LCBtYXRyaXgudHkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIE1hdHJpeDJEIGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBhIGNsb25lIG9mIHRoZSBNYXRyaXgyRCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBNYXRyaXgyRCh0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB0aGlzLmQsIHRoaXMudHgsIHRoaXMudHkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbTWF0cml4MkQgKGE9XCIrdGhpcy5hK1wiIGI9XCIrdGhpcy5iK1wiIGM9XCIrdGhpcy5jK1wiIGQ9XCIrdGhpcy5kK1wiIHR4PVwiK3RoaXMudHgrXCIgdHk9XCIrdGhpcy50eStcIildXCI7XG5cdH07XG5cblx0Ly8gdGhpcyBoYXMgdG8gYmUgcG9wdWxhdGVkIGFmdGVyIHRoZSBjbGFzcyBpcyBkZWZpbmVkOlxuXHRNYXRyaXgyRC5pZGVudGl0eSA9IG5ldyBNYXRyaXgyRCgpO1xuXG5cblx0Y3JlYXRlanMuTWF0cml4MkQgPSBNYXRyaXgyRDtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBEaXNwbGF5UHJvcHMuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIFVzZWQgZm9yIGNhbGN1bGF0aW5nIGFuZCBlbmNhcHN1bGF0aW5nIGRpc3BsYXkgcmVsYXRlZCBwcm9wZXJ0aWVzLlxuXHQgKiBAY2xhc3MgRGlzcGxheVByb3BzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdmlzaWJsZT10cnVlXSBWaXNpYmxlIHZhbHVlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2FscGhhPTFdIEFscGhhIHZhbHVlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NoYWRvdz1udWxsXSBBIFNoYWRvdyBpbnN0YW5jZSBvciBudWxsLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2NvbXBvc2l0ZU9wZXJhdGlvbj1udWxsXSBBIGNvbXBvc2l0ZU9wZXJhdGlvbiB2YWx1ZSBvciBudWxsLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW21hdHJpeF0gQSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguIERlZmF1bHRzIHRvIGEgbmV3IGlkZW50aXR5IG1hdHJpeC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gRGlzcGxheVByb3BzKHZpc2libGUsIGFscGhhLCBzaGFkb3csIGNvbXBvc2l0ZU9wZXJhdGlvbiwgbWF0cml4KSB7XG5cdFx0dGhpcy5zZXRWYWx1ZXModmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgY29tcG9zaXRlT3BlcmF0aW9uLCBtYXRyaXgpO1xuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvLyBhc3NpZ25lZCBpbiB0aGUgc2V0VmFsdWVzIG1ldGhvZC5cblx0XHQvKipcblx0XHQgKiBQcm9wZXJ0eSByZXByZXNlbnRpbmcgdGhlIGFscGhhIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGEgZGlzcGxheSBvYmplY3QuXG5cdFx0ICogQHByb3BlcnR5IGFscGhhXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBQcm9wZXJ0eSByZXByZXNlbnRpbmcgdGhlIHNoYWRvdyB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBhIGRpc3BsYXkgb2JqZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBzaGFkb3dcblx0XHQgKiBAdHlwZSBTaGFkb3dcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFByb3BlcnR5IHJlcHJlc2VudGluZyB0aGUgY29tcG9zaXRlT3BlcmF0aW9uIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGEgZGlzcGxheSBvYmplY3QuXG5cdFx0ICogWW91IGNhbiBmaW5kIGEgbGlzdCBvZiB2YWxpZCBjb21wb3NpdGUgb3BlcmF0aW9ucyBhdDpcblx0XHQgKiA8YSBocmVmPVwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vQ2FudmFzX3R1dG9yaWFsL0NvbXBvc2l0aW5nXCI+aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vQ2FudmFzX3R1dG9yaWFsL0NvbXBvc2l0aW5nPC9hPlxuXHRcdCAqIEBwcm9wZXJ0eSBjb21wb3NpdGVPcGVyYXRpb25cblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiovXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUHJvcGVydHkgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBmb3IgdmlzaWJsZSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBhIGRpc3BsYXkgb2JqZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSB2aXNpYmxlXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqKi9cblx0XHRcblx0XHQvKipcblx0XHQgKiBUaGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGEgZGlzcGxheSBvYmplY3QuXG5cdFx0ICogQHByb3BlcnR5IG1hdHJpeFxuXHRcdCAqIEB0eXBlIE1hdHJpeDJEXG5cdFx0ICoqL1xuXHR9XG5cdHZhciBwID0gRGlzcGxheVByb3BzLnByb3RvdHlwZTtcblxuLy8gaW5pdGlhbGl6YXRpb246XG5cdC8qKlxuXHQgKiBSZWluaXRpYWxpemVzIHRoZSBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWVzLlxuXHQgKiBAbWV0aG9kIHNldFZhbHVlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3Zpc2libGU9dHJ1ZV0gVmlzaWJsZSB2YWx1ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthbHBoYT0xXSBBbHBoYSB2YWx1ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzaGFkb3c9bnVsbF0gQSBTaGFkb3cgaW5zdGFuY2Ugb3IgbnVsbC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtjb21wb3NpdGVPcGVyYXRpb249bnVsbF0gQSBjb21wb3NpdGVPcGVyYXRpb24gdmFsdWUgb3IgbnVsbC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFttYXRyaXhdIEEgdHJhbnNmb3JtYXRpb24gbWF0cml4LiBEZWZhdWx0cyB0byBhbiBpZGVudGl0eSBtYXRyaXguXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlQcm9wc30gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5zZXRWYWx1ZXMgPSBmdW5jdGlvbiAodmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgY29tcG9zaXRlT3BlcmF0aW9uLCBtYXRyaXgpIHtcblx0XHR0aGlzLnZpc2libGUgPSB2aXNpYmxlID09IG51bGwgPyB0cnVlIDogISF2aXNpYmxlO1xuXHRcdHRoaXMuYWxwaGEgPSBhbHBoYSA9PSBudWxsID8gMSA6IGFscGhhO1xuXHRcdHRoaXMuc2hhZG93ID0gc2hhZG93O1xuXHRcdHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uID0gY29tcG9zaXRlT3BlcmF0aW9uO1xuXHRcdHRoaXMubWF0cml4ID0gbWF0cml4IHx8ICh0aGlzLm1hdHJpeCYmdGhpcy5tYXRyaXguaWRlbnRpdHkoKSkgfHwgbmV3IGNyZWF0ZWpzLk1hdHJpeDJEKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogQXBwZW5kcyB0aGUgc3BlY2lmaWVkIGRpc3BsYXkgcHJvcGVydGllcy4gVGhpcyBpcyBnZW5lcmFsbHkgdXNlZCB0byBhcHBseSBhIGNoaWxkJ3MgcHJvcGVydGllcyBpdHMgcGFyZW50J3MuXG5cdCAqIEBtZXRob2QgYXBwZW5kXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZSBkZXNpcmVkIHZpc2libGUgdmFsdWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFscGhhIGRlc2lyZWQgYWxwaGEgdmFsdWVcblx0ICogQHBhcmFtIHtTaGFkb3d9IHNoYWRvdyBkZXNpcmVkIHNoYWRvdyB2YWx1ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9zaXRlT3BlcmF0aW9uIGRlc2lyZWQgY29tcG9zaXRlIG9wZXJhdGlvbiB2YWx1ZVxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBbbWF0cml4XSBhIE1hdHJpeDJEIGluc3RhbmNlXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlQcm9wc30gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5hcHBlbmQgPSBmdW5jdGlvbih2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBjb21wb3NpdGVPcGVyYXRpb24sIG1hdHJpeCkge1xuXHRcdHRoaXMuYWxwaGEgKj0gYWxwaGE7XG5cdFx0dGhpcy5zaGFkb3cgPSBzaGFkb3cgfHwgdGhpcy5zaGFkb3c7XG5cdFx0dGhpcy5jb21wb3NpdGVPcGVyYXRpb24gPSBjb21wb3NpdGVPcGVyYXRpb24gfHwgdGhpcy5jb21wb3NpdGVPcGVyYXRpb247XG5cdFx0dGhpcy52aXNpYmxlID0gdGhpcy52aXNpYmxlICYmIHZpc2libGU7XG5cdFx0bWF0cml4JiZ0aGlzLm1hdHJpeC5hcHBlbmRNYXRyaXgobWF0cml4KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBQcmVwZW5kcyB0aGUgc3BlY2lmaWVkIGRpc3BsYXkgcHJvcGVydGllcy4gVGhpcyBpcyBnZW5lcmFsbHkgdXNlZCB0byBhcHBseSBhIHBhcmVudCdzIHByb3BlcnRpZXMgdG8gYSBjaGlsZCdzLlxuXHQgKiBGb3IgZXhhbXBsZSwgdG8gZ2V0IHRoZSBjb21iaW5lZCBkaXNwbGF5IHByb3BlcnRpZXMgdGhhdCB3b3VsZCBiZSBhcHBsaWVkIHRvIGEgY2hpbGQsIHlvdSBjb3VsZCB1c2U6XG5cdCAqIFxuXHQgKiBcdHZhciBvID0gbXlEaXNwbGF5T2JqZWN0O1xuXHQgKiBcdHZhciBwcm9wcyA9IG5ldyBjcmVhdGVqcy5EaXNwbGF5UHJvcHMoKTtcblx0ICogXHRkbyB7XG5cdCAqIFx0XHQvLyBwcmVwZW5kIGVhY2ggcGFyZW50J3MgcHJvcHMgaW4gdHVybjpcblx0ICogXHRcdHByb3BzLnByZXBlbmQoby52aXNpYmxlLCBvLmFscGhhLCBvLnNoYWRvdywgby5jb21wb3NpdGVPcGVyYXRpb24sIG8uZ2V0TWF0cml4KCkpO1xuXHQgKiBcdH0gd2hpbGUgKG8gPSBvLnBhcmVudCk7XG5cdCAqIFx0XG5cdCAqIEBtZXRob2QgcHJlcGVuZFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2libGUgZGVzaXJlZCB2aXNpYmxlIHZhbHVlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbHBoYSBkZXNpcmVkIGFscGhhIHZhbHVlXG5cdCAqIEBwYXJhbSB7U2hhZG93fSBzaGFkb3cgZGVzaXJlZCBzaGFkb3cgdmFsdWVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvc2l0ZU9wZXJhdGlvbiBkZXNpcmVkIGNvbXBvc2l0ZSBvcGVyYXRpb24gdmFsdWVcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gW21hdHJpeF0gYSBNYXRyaXgyRCBpbnN0YW5jZVxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5UHJvcHN9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAucHJlcGVuZCA9IGZ1bmN0aW9uKHZpc2libGUsIGFscGhhLCBzaGFkb3csIGNvbXBvc2l0ZU9wZXJhdGlvbiwgbWF0cml4KSB7XG5cdFx0dGhpcy5hbHBoYSAqPSBhbHBoYTtcblx0XHR0aGlzLnNoYWRvdyA9IHRoaXMuc2hhZG93IHx8IHNoYWRvdztcblx0XHR0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbiA9IHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uIHx8IGNvbXBvc2l0ZU9wZXJhdGlvbjtcblx0XHR0aGlzLnZpc2libGUgPSB0aGlzLnZpc2libGUgJiYgdmlzaWJsZTtcblx0XHRtYXRyaXgmJnRoaXMubWF0cml4LnByZXBlbmRNYXRyaXgobWF0cml4KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXNldHMgdGhpcyBpbnN0YW5jZSBhbmQgaXRzIG1hdHJpeCB0byBkZWZhdWx0IHZhbHVlcy5cblx0ICogQG1ldGhvZCBpZGVudGl0eVxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5UHJvcHN9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAuaWRlbnRpdHkgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXHRcdHRoaXMuYWxwaGEgPSAxO1xuXHRcdHRoaXMuc2hhZG93ID0gdGhpcy5jb21wb3NpdGVPcGVyYXRpb24gPSBudWxsO1xuXHRcdHRoaXMubWF0cml4LmlkZW50aXR5KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBEaXNwbGF5UHJvcHMgaW5zdGFuY2UuIENsb25lcyB0aGUgYXNzb2NpYXRlZCBtYXRyaXguXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7RGlzcGxheVByb3BzfSBhIGNsb25lIG9mIHRoZSBEaXNwbGF5UHJvcHMgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgRGlzcGxheVByb3BzKHRoaXMuYWxwaGEsIHRoaXMuc2hhZG93LCB0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbiwgdGhpcy52aXNpYmxlLCB0aGlzLm1hdHJpeC5jbG9uZSgpKTtcblx0fTtcblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXG5cdGNyZWF0ZWpzLkRpc3BsYXlQcm9wcyA9IERpc3BsYXlQcm9wcztcbn0pKCk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBQb2ludC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFJlcHJlc2VudHMgYSBwb2ludCBvbiBhIDIgZGltZW5zaW9uYWwgeCAvIHkgY29vcmRpbmF0ZSBzeXN0ZW0uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogXG5cdCAqICAgICAgdmFyIHBvaW50ID0gbmV3IGNyZWF0ZWpzLlBvaW50KDAsIDEwMCk7XG5cdCAqIFxuXHQgKiBAY2xhc3MgUG9pbnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt4PTBdIFggcG9zaXRpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSBZIHBvc2l0aW9uLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBQb2ludCh4LCB5KSB7XG5cdCBcdHRoaXMuc2V0VmFsdWVzKHgsIHkpO1xuXHQgXHRcblx0IFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8vIGFzc2lnbmVkIGluIHRoZSBzZXRWYWx1ZXMgbWV0aG9kLlxuXHRcdC8qKlxuXHRcdCAqIFggcG9zaXRpb24uXG5cdFx0ICogQHByb3BlcnR5IHhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFkgcG9zaXRpb24uXG5cdFx0ICogQHByb3BlcnR5IHlcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdH1cblx0dmFyIHAgPSBQb2ludC5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cdFxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKiBcblx0ICogU2V0cyB0aGUgc3BlY2lmaWVkIHZhbHVlcyBvbiB0aGlzIGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIHNldFZhbHVlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gWCBwb3NpdGlvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIFkgcG9zaXRpb24uXG5cdCAqIEByZXR1cm4ge1BvaW50fSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLnNldFZhbHVlcyA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLnggPSB4fHwwO1xuXHRcdHRoaXMueSA9IHl8fDA7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ29waWVzIGFsbCBwcm9wZXJ0aWVzIGZyb20gdGhlIHNwZWNpZmllZCBwb2ludCB0byB0aGlzIHBvaW50LlxuXHQgKiBAbWV0aG9kIGNvcHlcblx0ICogQHBhcmFtIHtQb2ludH0gcG9pbnQgVGhlIHBvaW50IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuXHQgKiBAcmV0dXJuIHtQb2ludH0gVGhpcyBwb2ludC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5jb3B5ID0gZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR0aGlzLnggPSBwb2ludC54O1xuXHRcdHRoaXMueSA9IHBvaW50Lnk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBQb2ludCBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtQb2ludH0gYSBjbG9uZSBvZiB0aGUgUG9pbnQgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbUG9pbnQgKHg9XCIrdGhpcy54K1wiIHk9XCIrdGhpcy55K1wiKV1cIjtcblx0fTtcblx0XG5cdFxuXHRjcmVhdGVqcy5Qb2ludCA9IFBvaW50O1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFJlY3RhbmdsZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFJlcHJlc2VudHMgYSByZWN0YW5nbGUgYXMgZGVmaW5lZCBieSB0aGUgcG9pbnRzICh4LCB5KSBhbmQgKHgrd2lkdGgsIHkraGVpZ2h0KS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciByZWN0ID0gbmV3IGNyZWF0ZWpzLlJlY3RhbmdsZSgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqXG5cdCAqIEBjbGFzcyBSZWN0YW5nbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt4PTBdIFggcG9zaXRpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSBZIHBvc2l0aW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPTBdIFRoZSB3aWR0aCBvZiB0aGUgUmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodD0wXSBUaGUgaGVpZ2h0IG9mIHRoZSBSZWN0YW5nbGUuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dGhpcy5zZXRWYWx1ZXMoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cdFx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8vIGFzc2lnbmVkIGluIHRoZSBzZXRWYWx1ZXMgbWV0aG9kLlxuXHRcdC8qKlxuXHRcdCAqIFggcG9zaXRpb24uXG5cdFx0ICogQHByb3BlcnR5IHhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFkgcG9zaXRpb24uXG5cdFx0ICogQHByb3BlcnR5IHlcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFdpZHRoLlxuXHRcdCAqIEBwcm9wZXJ0eSB3aWR0aFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogSGVpZ2h0LlxuXHRcdCAqIEBwcm9wZXJ0eSBoZWlnaHRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdH1cblx0dmFyIHAgPSBSZWN0YW5nbGUucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqIFxuXHQgKiBTZXRzIHRoZSBzcGVjaWZpZWQgdmFsdWVzIG9uIHRoaXMgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2Qgc2V0VmFsdWVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSBYIHBvc2l0aW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3k9MF0gWSBwb3NpdGlvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt3aWR0aD0wXSBUaGUgd2lkdGggb2YgdGhlIFJlY3RhbmdsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHQ9MF0gVGhlIGhlaWdodCBvZiB0aGUgUmVjdGFuZ2xlLlxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAuc2V0VmFsdWVzID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdC8vIGRvbid0IGZvcmdldCB0byB1cGRhdGUgZG9jcyBpbiB0aGUgY29uc3RydWN0b3IgaWYgdGhlc2UgY2hhbmdlOlxuXHRcdHRoaXMueCA9IHh8fDA7XG5cdFx0dGhpcy55ID0geXx8MDtcblx0XHR0aGlzLndpZHRoID0gd2lkdGh8fDA7XG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHR8fDA7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKiogXG5cdCAqIEV4dGVuZHMgdGhlIHJlY3RhbmdsZSdzIGJvdW5kcyB0byBpbmNsdWRlIHRoZSBkZXNjcmliZWQgcG9pbnQgb3IgcmVjdGFuZ2xlLlxuXHQgKiBAbWV0aG9kIGV4dGVuZFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBYIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvciByZWN0YW5nbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgcG9zaXRpb24gb2YgdGhlIHBvaW50IG9yIHJlY3RhbmdsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt3aWR0aD0wXSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHQ9MF0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlLlxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAuZXh0ZW5kID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdHdpZHRoID0gd2lkdGh8fDA7XG5cdFx0aGVpZ2h0ID0gaGVpZ2h0fHwwO1xuXHRcdGlmICh4K3dpZHRoID4gdGhpcy54K3RoaXMud2lkdGgpIHsgdGhpcy53aWR0aCA9IHgrd2lkdGgtdGhpcy54OyB9XG5cdFx0aWYgKHkraGVpZ2h0ID4gdGhpcy55K3RoaXMuaGVpZ2h0KSB7IHRoaXMuaGVpZ2h0ID0geStoZWlnaHQtdGhpcy55OyB9XG5cdFx0aWYgKHggPCB0aGlzLngpIHsgdGhpcy53aWR0aCArPSB0aGlzLngteDsgdGhpcy54ID0geDsgfVxuXHRcdGlmICh5IDwgdGhpcy55KSB7IHRoaXMuaGVpZ2h0ICs9IHRoaXMueS15OyB0aGlzLnkgPSB5OyB9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKiogXG5cdCAqIEFkZHMgdGhlIHNwZWNpZmllZCBwYWRkaW5nIHRvIHRoZSByZWN0YW5nbGUncyBib3VuZHMuXG5cdCAqIEBtZXRob2QgcGFkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0b3Bcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGxlZnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJpZ2h0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBib3R0b21cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLnBhZCA9IGZ1bmN0aW9uKHRvcCwgbGVmdCwgYm90dG9tLCByaWdodCkge1xuXHRcdHRoaXMueCAtPSBsZWZ0O1xuXHRcdHRoaXMueSAtPSB0b3A7XG5cdFx0dGhpcy53aWR0aCArPSBsZWZ0K3JpZ2h0O1xuXHRcdHRoaXMuaGVpZ2h0ICs9IHRvcCtib3R0b207XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ29waWVzIGFsbCBwcm9wZXJ0aWVzIGZyb20gdGhlIHNwZWNpZmllZCByZWN0YW5nbGUgdG8gdGhpcyByZWN0YW5nbGUuXG5cdCAqIEBtZXRob2QgY29weVxuXHQgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdGFuZ2xlIFRoZSByZWN0YW5nbGUgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gVGhpcyByZWN0YW5nbGUuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAuY29weSA9IGZ1bmN0aW9uKHJlY3RhbmdsZSkge1xuXHRcdHJldHVybiB0aGlzLnNldFZhbHVlcyhyZWN0YW5nbGUueCwgcmVjdGFuZ2xlLnksIHJlY3RhbmdsZS53aWR0aCwgcmVjdGFuZ2xlLmhlaWdodCk7XG5cdH07XG5cdFxuXHQvKiogXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHJlY3RhbmdsZSBmdWxseSBlbmNsb3NlcyB0aGUgZGVzY3JpYmVkIHBvaW50IG9yIHJlY3RhbmdsZS5cblx0ICogQG1ldGhvZCBjb250YWluc1xuXHQgKiBAcGFyYW0ge051bWJlcn0geCBYIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvciByZWN0YW5nbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgcG9zaXRpb24gb2YgdGhlIHBvaW50IG9yIHJlY3RhbmdsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt3aWR0aD0wXSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHQ9MF0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBkZXNjcmliZWQgcG9pbnQgb3IgcmVjdGFuZ2xlIGlzIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyByZWN0YW5nbGUuXG5cdCovXG5cdHAuY29udGFpbnMgPSBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0d2lkdGggPSB3aWR0aHx8MDtcblx0XHRoZWlnaHQgPSBoZWlnaHR8fDA7XG5cdFx0cmV0dXJuICh4ID49IHRoaXMueCAmJiB4K3dpZHRoIDw9IHRoaXMueCt0aGlzLndpZHRoICYmIHkgPj0gdGhpcy55ICYmIHkraGVpZ2h0IDw9IHRoaXMueSt0aGlzLmhlaWdodCk7XG5cdH07XG5cdFxuXHQvKiogXG5cdCAqIFJldHVybnMgYSBuZXcgcmVjdGFuZ2xlIHdoaWNoIGNvbnRhaW5zIHRoaXMgcmVjdGFuZ2xlIGFuZCB0aGUgc3BlY2lmaWVkIHJlY3RhbmdsZS5cblx0ICogQG1ldGhvZCB1bmlvblxuXHQgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdCBUaGUgcmVjdGFuZ2xlIHRvIGNhbGN1bGF0ZSBhIHVuaW9uIHdpdGguXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gQSBuZXcgcmVjdGFuZ2xlIGRlc2NyaWJpbmcgdGhlIHVuaW9uLlxuXHQqL1xuXHRwLnVuaW9uID0gZnVuY3Rpb24ocmVjdCkge1xuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuZXh0ZW5kKHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG5cdH07XG5cdFxuXHQvKiogXG5cdCAqIFJldHVybnMgYSBuZXcgcmVjdGFuZ2xlIHdoaWNoIGRlc2NyaWJlcyB0aGUgaW50ZXJzZWN0aW9uIChvdmVybGFwKSBvZiB0aGlzIHJlY3RhbmdsZSBhbmQgdGhlIHNwZWNpZmllZCByZWN0YW5nbGUsXG5cdCAqIG9yIG51bGwgaWYgdGhleSBkbyBub3QgaW50ZXJzZWN0LlxuXHQgKiBAbWV0aG9kIGludGVyc2VjdGlvblxuXHQgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdCBUaGUgcmVjdGFuZ2xlIHRvIGNhbGN1bGF0ZSBhbiBpbnRlcnNlY3Rpb24gd2l0aC5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBBIG5ldyByZWN0YW5nbGUgZGVzY3JpYmluZyB0aGUgaW50ZXJzZWN0aW9uIG9yIG51bGwuXG5cdCovXG5cdHAuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24ocmVjdCkge1xuXHRcdHZhciB4MSA9IHJlY3QueCwgeTEgPSByZWN0LnksIHgyID0geDErcmVjdC53aWR0aCwgeTIgPSB5MStyZWN0LmhlaWdodDtcblx0XHRpZiAodGhpcy54ID4geDEpIHsgeDEgPSB0aGlzLng7IH1cblx0XHRpZiAodGhpcy55ID4geTEpIHsgeTEgPSB0aGlzLnk7IH1cblx0XHRpZiAodGhpcy54ICsgdGhpcy53aWR0aCA8IHgyKSB7IHgyID0gdGhpcy54ICsgdGhpcy53aWR0aDsgfVxuXHRcdGlmICh0aGlzLnkgKyB0aGlzLmhlaWdodCA8IHkyKSB7IHkyID0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7IH1cblx0XHRyZXR1cm4gKHgyIDw9IHgxIHx8IHkyIDw9IHkxKSA/IG51bGwgOiBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIteDEsIHkyLXkxKTtcblx0fTtcblx0XG5cdC8qKiBcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgcmVjdGFuZ2xlIGludGVyc2VjdHMgKGhhcyBhbnkgb3ZlcmxhcCkgd2l0aCB0aGlzIHJlY3RhbmdsZS5cblx0ICogQG1ldGhvZCBpbnRlcnNlY3RzXG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IFRoZSByZWN0YW5nbGUgdG8gY29tcGFyZS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcmVjdGFuZ2xlcyBpbnRlcnNlY3QuXG5cdCovXG5cdHAuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHRyZXR1cm4gKHJlY3QueCA8PSB0aGlzLngrdGhpcy53aWR0aCAmJiB0aGlzLnggPD0gcmVjdC54K3JlY3Qud2lkdGggJiYgcmVjdC55IDw9IHRoaXMueSt0aGlzLmhlaWdodCAmJiB0aGlzLnkgPD0gcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuXHR9O1xuXHRcblx0LyoqIFxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHdpZHRoIG9yIGhlaWdodCBhcmUgZXF1YWwgb3IgbGVzcyB0aGFuIDAuXG5cdCAqIEBtZXRob2QgaXNFbXB0eVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSByZWN0YW5nbGUgaXMgZW1wdHkuXG5cdCovXG5cdHAuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMDtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIFJlY3RhbmdsZSBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IGEgY2xvbmUgb2YgdGhlIFJlY3RhbmdsZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1JlY3RhbmdsZSAoeD1cIit0aGlzLngrXCIgeT1cIit0aGlzLnkrXCIgd2lkdGg9XCIrdGhpcy53aWR0aCtcIiBoZWlnaHQ9XCIrdGhpcy5oZWlnaHQrXCIpXVwiO1xuXHR9O1xuXHRcblx0XG5cdGNyZWF0ZWpzLlJlY3RhbmdsZSA9IFJlY3RhbmdsZTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBCdXR0b25IZWxwZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBUaGUgQnV0dG9uSGVscGVyIGlzIGEgaGVscGVyIGNsYXNzIHRvIGNyZWF0ZSBpbnRlcmFjdGl2ZSBidXR0b25zIGZyb20ge3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwXCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNwcml0ZVwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZXMuIFRoaXMgY2xhc3Mgd2lsbCBpbnRlcmNlcHQgbW91c2UgZXZlbnRzIGZyb20gYW4gb2JqZWN0LCBhbmRcblx0ICogYXV0b21hdGljYWxseSBjYWxsIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9nb3RvQW5kU3RvcFwifX17ey9jcm9zc0xpbmt9fSBvciB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIHRvIHRoZSByZXNwZWN0aXZlIGFuaW1hdGlvbiBsYWJlbHMsIGFkZCBhIHBvaW50ZXIgY3Vyc29yLCBhbmQgYWxsb3dzIHRoZSB1c2VyIHRvIGRlZmluZSBhIGhpdCBzdGF0ZSBmcmFtZS5cblx0ICpcblx0ICogVGhlIEJ1dHRvbkhlbHBlciBpbnN0YW5jZSBkb2VzIG5vdCBuZWVkIHRvIGJlIGFkZGVkIHRvIHRoZSBzdGFnZSwgYnV0IGEgcmVmZXJlbmNlIHNob3VsZCBiZSBtYWludGFpbmVkIHRvIHByZXZlbnRcblx0ICogZ2FyYmFnZSBjb2xsZWN0aW9uLlxuXHQgKiBcblx0ICogTm90ZSB0aGF0IG92ZXIgc3RhdGVzIHdpbGwgbm90IHdvcmsgdW5sZXNzIHlvdSBjYWxsIHt7I2Nyb3NzTGluayBcIlN0YWdlL2VuYWJsZU1vdXNlT3ZlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBoZWxwZXIgPSBuZXcgY3JlYXRlanMuQnV0dG9uSGVscGVyKG15SW5zdGFuY2UsIFwib3V0XCIsIFwib3ZlclwiLCBcImRvd25cIiwgZmFsc2UsIG15SW5zdGFuY2UsIFwiaGl0XCIpO1xuXHQgKiAgICAgIG15SW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNsaWNrKTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuXHQgKiAgICAgICAgICAvLyBDbGljayBIYXBwZW5lZC5cblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBjbGFzcyBCdXR0b25IZWxwZXJcblx0ICogQHBhcmFtIHtTcHJpdGV8TW92aWVDbGlwfSB0YXJnZXQgVGhlIGluc3RhbmNlIHRvIG1hbmFnZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtvdXRMYWJlbD1cIm91dFwiXSBUaGUgbGFiZWwgb3IgYW5pbWF0aW9uIHRvIGdvIHRvIHdoZW4gdGhlIHVzZXIgcm9sbHMgb3V0IG9mIHRoZSBidXR0b24uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbb3ZlckxhYmVsPVwib3ZlclwiXSBUaGUgbGFiZWwgb3IgYW5pbWF0aW9uIHRvIGdvIHRvIHdoZW4gdGhlIHVzZXIgcm9sbHMgb3ZlciB0aGUgYnV0dG9uLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2Rvd25MYWJlbD1cImRvd25cIl0gVGhlIGxhYmVsIG9yIGFuaW1hdGlvbiB0byBnbyB0byB3aGVuIHRoZSB1c2VyIHByZXNzZXMgdGhlIGJ1dHRvbi5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcGxheT1mYWxzZV0gSWYgdGhlIGhlbHBlciBzaG91bGQgY2FsbCBcImdvdG9BbmRQbGF5XCIgb3IgXCJnb3RvQW5kU3RvcFwiIG9uIHRoZSBidXR0b24gd2hlbiBjaGFuZ2luZ1xuXHQgKiBzdGF0ZXMuXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gW2hpdEFyZWFdIEFuIG9wdGlvbmFsIGl0ZW0gdG8gdXNlIGFzIHRoZSBoaXQgc3RhdGUgZm9yIHRoZSBidXR0b24uIElmIHRoaXMgaXMgbm90IGRlZmluZWQsXG5cdCAqIHRoZW4gdGhlIGJ1dHRvbidzIHZpc2libGUgc3RhdGVzIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLiBOb3RlIHRoYXQgdGhlIHNhbWUgaW5zdGFuY2UgYXMgdGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgY2FuIGJlXG5cdCAqIHVzZWQgZm9yIHRoZSBoaXRTdGF0ZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtoaXRMYWJlbF0gVGhlIGxhYmVsIG9yIGFuaW1hdGlvbiBvbiB0aGUgaGl0QXJlYSBpbnN0YW5jZSB0aGF0IGRlZmluZXMgdGhlIGhpdEFyZWEgYm91bmRzLiBJZiB0aGlzIGlzXG5cdCAqIG51bGwsIHRoZW4gdGhlIGRlZmF1bHQgc3RhdGUgb2YgdGhlIGhpdEFyZWEgd2lsbCBiZSB1c2VkLiAqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gQnV0dG9uSGVscGVyKHRhcmdldCwgb3V0TGFiZWwsIG92ZXJMYWJlbCwgZG93bkxhYmVsLCBwbGF5LCBoaXRBcmVhLCBoaXRMYWJlbCkge1xuXHRcdGlmICghdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHsgcmV0dXJuOyB9XG5cdFxuXHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIHRhcmdldCBmb3IgdGhpcyBidXR0b24gaGVscGVyLlxuXHRcdCAqIEBwcm9wZXJ0eSB0YXJnZXRcblx0XHQgKiBAdHlwZSBNb3ZpZUNsaXAgfCBTcHJpdGVcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsYWJlbCBuYW1lIG9yIGZyYW1lIG51bWJlciB0byBkaXNwbGF5IHdoZW4gdGhlIHVzZXIgbW91c2VzIG91dCBvZiB0aGUgdGFyZ2V0LiBEZWZhdWx0cyB0byBcIm92ZXJcIi5cblx0XHQgKiBAcHJvcGVydHkgb3ZlckxhYmVsXG5cdFx0ICogQHR5cGUgU3RyaW5nIHwgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMub3ZlckxhYmVsID0gb3ZlckxhYmVsID09IG51bGwgPyBcIm92ZXJcIiA6IG92ZXJMYWJlbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGxhYmVsIG5hbWUgb3IgZnJhbWUgbnVtYmVyIHRvIGRpc3BsYXkgd2hlbiB0aGUgdXNlciBtb3VzZXMgb3ZlciB0aGUgdGFyZ2V0LiBEZWZhdWx0cyB0byBcIm91dFwiLlxuXHRcdCAqIEBwcm9wZXJ0eSBvdXRMYWJlbFxuXHRcdCAqIEB0eXBlIFN0cmluZyB8IE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLm91dExhYmVsID0gb3V0TGFiZWwgPT0gbnVsbCA/IFwib3V0XCIgOiBvdXRMYWJlbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGxhYmVsIG5hbWUgb3IgZnJhbWUgbnVtYmVyIHRvIGRpc3BsYXkgd2hlbiB0aGUgdXNlciBwcmVzc2VzIG9uIHRoZSB0YXJnZXQuIERlZmF1bHRzIHRvIFwiZG93blwiLlxuXHRcdCAqIEBwcm9wZXJ0eSBkb3duTGFiZWxcblx0XHQgKiBAdHlwZSBTdHJpbmcgfCBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5kb3duTGFiZWwgPSBkb3duTGFiZWwgPT0gbnVsbCA/IFwiZG93blwiIDogZG93bkxhYmVsO1xuXHRcblx0XHQvKipcblx0XHQgKiBJZiB0cnVlLCB0aGVuIEJ1dHRvbkhlbHBlciB3aWxsIGNhbGwgZ290b0FuZFBsYXksIGlmIGZhbHNlLCBpdCB3aWxsIHVzZSBnb3RvQW5kU3RvcC4gRGVmYXVsdCBpcyBmYWxzZS5cblx0XHQgKiBAcHJvcGVydHkgcGxheVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqKi9cblx0XHR0aGlzLnBsYXkgPSBwbGF5O1xuXHRcdFxuXHRcdFxuXHQvLyAgcHJpdmF0ZSBwcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9pc1ByZXNzZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9pc1ByZXNzZWQgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9pc092ZXJcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9pc092ZXIgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9lbmFibGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiovXG5cdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuXHRcdFxuXHQvLyBzZXR1cDpcblx0XHR0YXJnZXQubW91c2VDaGlsZHJlbiA9IGZhbHNlOyAvLyBwcmV2ZW50cyBpc3N1ZXMgd2hlbiBjaGlsZHJlbiBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBkaXNwbGF5IGxpc3Qgd2hlbiBzdGF0ZSBjaGFuZ2VzLlxuXHRcdHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cdFx0dGhpcy5oYW5kbGVFdmVudCh7fSk7XG5cdFx0aWYgKGhpdEFyZWEpIHtcblx0XHRcdGlmIChoaXRMYWJlbCkge1xuXHRcdFx0XHRoaXRBcmVhLmFjdGlvbnNFbmFibGVkID0gZmFsc2U7XG5cdFx0XHRcdGhpdEFyZWEuZ290b0FuZFN0b3AmJmhpdEFyZWEuZ290b0FuZFN0b3AoaGl0TGFiZWwpO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0LmhpdEFyZWEgPSBoaXRBcmVhO1xuXHRcdH1cblx0fVxuXHR2YXIgcCA9IEJ1dHRvbkhlbHBlci5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cdFxuLy8gZ2V0dGVyIC8gc2V0dGVyczpcblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiQnV0dG9uSGVscGVyL2VuYWJsZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBzZXRFbmFibGVkXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRwLnNldEVuYWJsZWQgPSBmdW5jdGlvbih2YWx1ZSkgeyAvLyBUT0RPOiBkZXByZWNhdGVkLlxuXHRcdGlmICh2YWx1ZSA9PSB0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxuXHRcdHZhciBvID0gdGhpcy50YXJnZXQ7XG5cdFx0dGhpcy5fZW5hYmxlZCA9IHZhbHVlO1xuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0by5jdXJzb3IgPSBcInBvaW50ZXJcIjtcblx0XHRcdG8uYWRkRXZlbnRMaXN0ZW5lcihcInJvbGxvdmVyXCIsIHRoaXMpO1xuXHRcdFx0by5hZGRFdmVudExpc3RlbmVyKFwicm9sbG91dFwiLCB0aGlzKTtcblx0XHRcdG8uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzKTtcblx0XHRcdG8uYWRkRXZlbnRMaXN0ZW5lcihcInByZXNzdXBcIiwgdGhpcyk7XG5cdFx0XHRpZiAoby5fcmVzZXQpIHsgby5fX3Jlc2V0ID0gby5fcmVzZXQ7IG8uX3Jlc2V0ID0gdGhpcy5fcmVzZXQ7fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvLmN1cnNvciA9IG51bGw7XG5cdFx0XHRvLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyb2xsb3ZlclwiLCB0aGlzKTtcblx0XHRcdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJvbGxvdXRcIiwgdGhpcyk7XG5cdFx0XHRvLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcyk7XG5cdFx0XHRvLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwcmVzc3VwXCIsIHRoaXMpO1xuXHRcdFx0aWYgKG8uX19yZXNldCkgeyBvLl9yZXNldCA9IG8uX19yZXNldDsgZGVsZXRlKG8uX19yZXNldCk7IH1cblx0XHR9XG5cdH07XG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIkJ1dHRvbkhlbHBlci9lbmFibGVkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2QgZ2V0RW5hYmxlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdHAuZ2V0RW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9lbmFibGVkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbmFibGVzIG9yIGRpc2FibGVzIHRoZSBidXR0b24gZnVuY3Rpb25hbGl0eSBvbiB0aGUgdGFyZ2V0LlxuXHQgKiBAcHJvcGVydHkgZW5hYmxlZFxuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICoqL1xuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHAsIHtcblx0XHRcdGVuYWJsZWQ6IHsgZ2V0OiBwLmdldEVuYWJsZWQsIHNldDogcC5zZXRFbmFibGVkIH1cblx0XHR9KTtcblx0fSBjYXRjaCAoZSkge30gLy8gVE9ETzogdXNlIExvZ1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0J1dHRvbkhlbHBlcl1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGhhbmRsZUV2ZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldnQgVGhlIG1vdXNlIGV2ZW50IHRvIGhhbmRsZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbihldnQpIHtcblx0XHR2YXIgbGFiZWwsIHQgPSB0aGlzLnRhcmdldCwgdHlwZSA9IGV2dC50eXBlO1xuXHRcdGlmICh0eXBlID09IFwibW91c2Vkb3duXCIpIHtcblx0XHRcdHRoaXMuX2lzUHJlc3NlZCA9IHRydWU7XG5cdFx0XHRsYWJlbCA9IHRoaXMuZG93bkxhYmVsO1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PSBcInByZXNzdXBcIikge1xuXHRcdFx0dGhpcy5faXNQcmVzc2VkID0gZmFsc2U7XG5cdFx0XHRsYWJlbCA9IHRoaXMuX2lzT3ZlciA/IHRoaXMub3ZlckxhYmVsIDogdGhpcy5vdXRMYWJlbDtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT0gXCJyb2xsb3ZlclwiKSB7XG5cdFx0XHR0aGlzLl9pc092ZXIgPSB0cnVlO1xuXHRcdFx0bGFiZWwgPSB0aGlzLl9pc1ByZXNzZWQgPyB0aGlzLmRvd25MYWJlbCA6IHRoaXMub3ZlckxhYmVsO1xuXHRcdH0gZWxzZSB7IC8vIHJvbGxvdXQgYW5kIGRlZmF1bHRcblx0XHRcdHRoaXMuX2lzT3ZlciA9IGZhbHNlO1xuXHRcdFx0bGFiZWwgPSB0aGlzLl9pc1ByZXNzZWQgPyB0aGlzLm92ZXJMYWJlbCA6IHRoaXMub3V0TGFiZWw7XG5cdFx0fVxuXHRcdGlmICh0aGlzLnBsYXkpIHtcblx0XHRcdHQuZ290b0FuZFBsYXkmJnQuZ290b0FuZFBsYXkobGFiZWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0LmdvdG9BbmRTdG9wJiZ0LmdvdG9BbmRTdG9wKGxhYmVsKTtcblx0XHR9XG5cdH07XG5cdFxuXHQvKipcblx0ICogSW5qZWN0ZWQgaW50byB0YXJnZXQuIFByZXNlcnZlcyB0aGUgcGF1c2VkIHN0YXRlIHRocm91Z2ggYSByZXNldC5cblx0ICogQG1ldGhvZCBfcmVzZXRcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3Jlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gVE9ETzogZXhwbG9yZSBiZXR0ZXIgd2F5cyB0byBoYW5kbGUgdGhpcyBpc3N1ZS4gVGhpcyBpcyBoYWNreSAmIGRpc3J1cHRzIG9iamVjdCBzaWduYXR1cmVzLlxuXHRcdHZhciBwID0gdGhpcy5wYXVzZWQ7XG5cdFx0dGhpcy5fX3Jlc2V0KCk7XG5cdFx0dGhpcy5wYXVzZWQgPSBwO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuQnV0dG9uSGVscGVyID0gQnV0dG9uSGVscGVyO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNoYWRvdy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFRoaXMgY2xhc3MgZW5jYXBzdWxhdGVzIHRoZSBwcm9wZXJ0aWVzIHJlcXVpcmVkIHRvIGRlZmluZSBhIHNoYWRvdyB0byBhcHBseSB0byBhIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3RcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogdmlhIGl0cyA8Y29kZT5zaGFkb3c8L2NvZGU+IHByb3BlcnR5LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgbXlJbWFnZS5zaGFkb3cgPSBuZXcgY3JlYXRlanMuU2hhZG93KFwiIzAwMDAwMFwiLCA1LCA1LCAxMCk7XG5cdCAqXG5cdCAqIEBjbGFzcyBTaGFkb3dcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBUaGUgY29sb3Igb2YgdGhlIHNoYWRvdy4gVGhpcyBjYW4gYmUgYW55IHZhbGlkIENTUyBjb2xvciB2YWx1ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFggVGhlIHggb2Zmc2V0IG9mIHRoZSBzaGFkb3cgaW4gcGl4ZWxzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0WSBUaGUgeSBvZmZzZXQgb2YgdGhlIHNoYWRvdyBpbiBwaXhlbHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBibHVyIFRoZSBzaXplIG9mIHRoZSBibHVycmluZyBlZmZlY3QuXG5cdCAqKi9cblx0ZnVuY3Rpb24gU2hhZG93KGNvbG9yLCBvZmZzZXRYLCBvZmZzZXRZLCBibHVyKSB7XG5cdFx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKiBcblx0XHQgKiBUaGUgY29sb3Igb2YgdGhlIHNoYWRvdy4gVGhpcyBjYW4gYmUgYW55IHZhbGlkIENTUyBjb2xvciB2YWx1ZS5cblx0XHQgKiBAcHJvcGVydHkgY29sb3Jcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5jb2xvciA9IGNvbG9yfHxcImJsYWNrXCI7XG5cdFxuXHRcdC8qKiBUaGUgeCBvZmZzZXQgb2YgdGhlIHNoYWRvdy5cblx0XHQgKiBAcHJvcGVydHkgb2Zmc2V0WFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLm9mZnNldFggPSBvZmZzZXRYfHwwO1xuXHRcblx0XHQvKiogVGhlIHkgb2Zmc2V0IG9mIHRoZSBzaGFkb3cuXG5cdFx0ICogQHByb3BlcnR5IG9mZnNldFlcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5vZmZzZXRZID0gb2Zmc2V0WXx8MDtcblx0XG5cdFx0LyoqIFRoZSBibHVyIG9mIHRoZSBzaGFkb3cuXG5cdFx0ICogQHByb3BlcnR5IGJsdXJcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5ibHVyID0gYmx1cnx8MDtcblx0fVxuXHR2YXIgcCA9IFNoYWRvdy5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cbi8vIHN0YXRpYyBwdWJsaWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIEFuIGlkZW50aXR5IHNoYWRvdyBvYmplY3QgKGFsbCBwcm9wZXJ0aWVzIGFyZSBzZXQgdG8gMCkuXG5cdCAqIEBwcm9wZXJ0eSBpZGVudGl0eVxuXHQgKiBAdHlwZSBTaGFkb3dcblx0ICogQHN0YXRpY1xuXHQgKiBAZmluYWxcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0U2hhZG93LmlkZW50aXR5ID0gbmV3IFNoYWRvdyhcInRyYW5zcGFyZW50XCIsIDAsIDAsIDApO1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1NoYWRvd11cIjtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgU2hhZG93IGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge1NoYWRvd30gQSBjbG9uZSBvZiB0aGUgY3VycmVudCBTaGFkb3cgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2hhZG93KHRoaXMuY29sb3IsIHRoaXMub2Zmc2V0WCwgdGhpcy5vZmZzZXRZLCB0aGlzLmJsdXIpO1xuXHR9O1xuXHRcblxuXHRjcmVhdGVqcy5TaGFkb3cgPSBTaGFkb3c7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU3ByaXRlU2hlZXQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBFbmNhcHN1bGF0ZXMgdGhlIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgYXNzb2NpYXRlZCB3aXRoIGEgc3ByaXRlIHNoZWV0LiBBIHNwcml0ZSBzaGVldCBpcyBhIHNlcmllcyBvZiBpbWFnZXMgKHVzdWFsbHlcblx0ICogYW5pbWF0aW9uIGZyYW1lcykgY29tYmluZWQgaW50byBhIGxhcmdlciBpbWFnZSAob3IgaW1hZ2VzKS4gRm9yIGV4YW1wbGUsIGFuIGFuaW1hdGlvbiBjb25zaXN0aW5nIG9mIGVpZ2h0IDEwMHgxMDBcblx0ICogaW1hZ2VzIGNvdWxkIGJlIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgNDAweDIwMCBzcHJpdGUgc2hlZXQgKDQgZnJhbWVzIGFjcm9zcyBieSAyIGhpZ2gpLlxuXHQgKlxuXHQgKiBUaGUgZGF0YSBwYXNzZWQgdG8gdGhlIFNwcml0ZVNoZWV0IGNvbnN0cnVjdG9yIGRlZmluZXM6XG5cdCAqIDxvbD5cblx0ICogXHQ8bGk+IFRoZSBzb3VyY2UgaW1hZ2Ugb3IgaW1hZ2VzIHRvIHVzZS48L2xpPlxuXHQgKiBcdDxsaT4gVGhlIHBvc2l0aW9ucyBvZiBpbmRpdmlkdWFsIGltYWdlIGZyYW1lcy48L2xpPlxuXHQgKiBcdDxsaT4gU2VxdWVuY2VzIG9mIGZyYW1lcyB0aGF0IGZvcm0gbmFtZWQgYW5pbWF0aW9ucy4gT3B0aW9uYWwuPC9saT5cblx0ICogXHQ8bGk+IFRoZSB0YXJnZXQgcGxheWJhY2sgZnJhbWVyYXRlLiBPcHRpb25hbC48L2xpPlxuXHQgKiA8L29sPlxuXHQgKiA8aDM+U3ByaXRlU2hlZXQgRm9ybWF0PC9oMz5cblx0ICogU3ByaXRlU2hlZXRzIGFyZSBhbiBvYmplY3Qgd2l0aCB0d28gcmVxdWlyZWQgcHJvcGVydGllcyAoYGltYWdlc2AgYW5kIGBmcmFtZXNgKSwgYW5kIHR3byBvcHRpb25hbCBwcm9wZXJ0aWVzXG5cdCAqIChgZnJhbWVyYXRlYCBhbmQgYGFuaW1hdGlvbnNgKS4gVGhpcyBtYWtlcyB0aGVtIGVhc3kgdG8gZGVmaW5lIGluIGphdmFzY3JpcHQgY29kZSwgb3IgaW4gSlNPTi5cblx0ICpcblx0ICogPGg0PmltYWdlczwvaDQ+XG5cdCAqIEFuIGFycmF5IG9mIHNvdXJjZSBpbWFnZXMuIEltYWdlcyBjYW4gYmUgZWl0aGVyIGFuIEhUTWxpbWFnZVxuXHQgKiBpbnN0YW5jZSwgb3IgYSB1cmkgdG8gYW4gaW1hZ2UuIFRoZSBmb3JtZXIgaXMgcmVjb21tZW5kZWQgdG8gY29udHJvbCBwcmVsb2FkaW5nLlxuXHQgKlxuXHQgKiBcdGltYWdlczogW2ltYWdlMSwgXCJwYXRoL3RvL2ltYWdlMi5wbmdcIl0sXG5cdCAqXG5cdCAqIDxoND5mcmFtZXM8L2g0PlxuXHQgKiBEZWZpbmVzIHRoZSBpbmRpdmlkdWFsIGZyYW1lcy4gVGhlcmUgYXJlIHR3byBzdXBwb3J0ZWQgZm9ybWF0cyBmb3IgZnJhbWUgZGF0YTpcblx0ICogV2hlbiBhbGwgb2YgdGhlIGZyYW1lcyBhcmUgdGhlIHNhbWUgc2l6ZSAoaW4gYSBncmlkKSwgdXNlIGFuIG9iamVjdCB3aXRoIGB3aWR0aGAsIGBoZWlnaHRgLCBgcmVnWGAsIGByZWdZYCxcblx0ICogYW5kIGBjb3VudGAgcHJvcGVydGllcy5cblx0ICpcblx0ICogPHVsPlxuXHQgKiAgPGxpPmB3aWR0aGAgJiBgaGVpZ2h0YCBhcmUgcmVxdWlyZWQgYW5kIHNwZWNpZnkgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGZyYW1lczwvbGk+XG5cdCAqICA8bGk+YHJlZ1hgICYgYHJlZ1lgIGluZGljYXRlIHRoZSByZWdpc3RyYXRpb24gcG9pbnQgb3IgXCJvcmlnaW5cIiBvZiB0aGUgZnJhbWVzPC9saT5cblx0ICogIDxsaT5gc3BhY2luZ2AgaW5kaWNhdGUgdGhlIHNwYWNpbmcgYmV0d2VlbiBmcmFtZXM8L2xpPlxuXHQgKiAgPGxpPmBtYXJnaW5gIHNwZWNpZnkgdGhlIG1hcmdpbiBhcm91bmQgdGhlIGltYWdlKHMpPC9saT5cblx0ICogIDxsaT5gY291bnRgIGFsbG93cyB5b3UgdG8gc3BlY2lmeSB0aGUgdG90YWwgbnVtYmVyIG9mIGZyYW1lcyBpbiB0aGUgc3ByaXRlc2hlZXQ7IGlmIG9taXR0ZWQsIHRoaXMgd2lsbFxuXHQgKiAgYmUgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgZGltZW5zaW9ucyBvZiB0aGUgc291cmNlIGltYWdlcyBhbmQgdGhlIGZyYW1lcy4gRnJhbWVzIHdpbGwgYmUgYXNzaWduZWRcblx0ICogIGluZGV4ZXMgYmFzZWQgb24gdGhlaXIgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSBpbWFnZXMgKGxlZnQgdG8gcmlnaHQsIHRvcCB0byBib3R0b20pLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqICBcdGZyYW1lczoge3dpZHRoOjY0LCBoZWlnaHQ6NjQsIGNvdW50OjIwLCByZWdYOiAzMiwgcmVnWTo2NCwgc3BhY2luZzowLCBtYXJnaW46MH1cblx0ICpcblx0ICogSWYgdGhlIGZyYW1lcyBhcmUgb2YgZGlmZmVyZW50IHNpemVzLCB1c2UgYW4gYXJyYXkgb2YgZnJhbWUgZGVmaW5pdGlvbnMuIEVhY2ggZGVmaW5pdGlvbiBpcyBpdHNlbGYgYW4gYXJyYXlcblx0ICogd2l0aCA0IHJlcXVpcmVkIGFuZCAzIG9wdGlvbmFsIGVudHJpZXMsIGluIHRoZSBvcmRlcjpcblx0ICpcblx0ICogPHVsPlxuXHQgKiAgPGxpPlRoZSBmaXJzdCBmb3VyLCBgeGAsIGB5YCwgYHdpZHRoYCwgYW5kIGBoZWlnaHRgIGFyZSByZXF1aXJlZCBhbmQgZGVmaW5lIHRoZSBmcmFtZSByZWN0YW5nbGUuPC9saT5cblx0ICogIDxsaT5UaGUgZmlmdGgsIGBpbWFnZUluZGV4YCwgc3BlY2lmaWVzIHRoZSBpbmRleCBvZiB0aGUgc291cmNlIGltYWdlIChkZWZhdWx0cyB0byAwKTwvbGk+XG5cdCAqICA8bGk+VGhlIGxhc3QgdHdvLCBgcmVnWGAgYW5kIGByZWdZYCBzcGVjaWZ5IHRoZSByZWdpc3RyYXRpb24gcG9pbnQgb2YgdGhlIGZyYW1lPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogXHRmcmFtZXM6IFtcblx0ICogXHRcdC8vIHgsIHksIHdpZHRoLCBoZWlnaHQsIGltYWdlSW5kZXgqLCByZWdYKiwgcmVnWSpcblx0ICogXHRcdFs2NCwgMCwgOTYsIDY0XSxcblx0ICogXHRcdFswLCAwLCA2NCwgNjQsIDEsIDMyLCAzMl1cblx0ICogXHRcdC8vIGV0Yy5cblx0ICogXHRdXG5cdCAqXG5cdCAqIDxoND5hbmltYXRpb25zPC9oND5cblx0ICogT3B0aW9uYWwuIEFuIG9iamVjdCBkZWZpbmluZyBzZXF1ZW5jZXMgb2YgZnJhbWVzIHRvIHBsYXkgYXMgbmFtZWQgYW5pbWF0aW9ucy4gRWFjaCBwcm9wZXJ0eSBjb3JyZXNwb25kcyB0byBhblxuXHQgKiBhbmltYXRpb24gb2YgdGhlIHNhbWUgbmFtZS4gRWFjaCBhbmltYXRpb24gbXVzdCBzcGVjaWZ5IHRoZSBmcmFtZXMgdG8gcGxheSwgYW5kIG1heVxuXHQgKiBhbHNvIGluY2x1ZGUgYSByZWxhdGl2ZSBwbGF5YmFjayBgc3BlZWRgIChleC4gMiB3b3VsZCBwbGF5YmFjayBhdCBkb3VibGUgc3BlZWQsIDAuNSBhdCBoYWxmKSwgYW5kXG5cdCAqIHRoZSBuYW1lIG9mIHRoZSBgbmV4dGAgYW5pbWF0aW9uIHRvIHNlcXVlbmNlIHRvIGFmdGVyIGl0IGNvbXBsZXRlcy5cblx0ICpcblx0ICogVGhlcmUgYXJlIHRocmVlIGZvcm1hdHMgc3VwcG9ydGVkIGZvciBkZWZpbmluZyB0aGUgZnJhbWVzIGluIGFuIGFuaW1hdGlvbiwgd2hpY2ggY2FuIGJlIG1peGVkIGFuZCBtYXRjaGVkIGFzIGFwcHJvcHJpYXRlOlxuXHQgKiA8b2w+XG5cdCAqIFx0PGxpPmZvciBhIHNpbmdsZSBmcmFtZSBhbmltYXRpb24sIHlvdSBjYW4gc2ltcGx5IHNwZWNpZnkgdGhlIGZyYW1lIGluZGV4XG5cdCAqXG5cdCAqIFx0XHRhbmltYXRpb25zOiB7XG5cdCAqIFx0XHRcdHNpdDogN1xuXHQgKiBcdFx0fVxuXHQgKlxuXHQgKiA8L2xpPlxuXHQgKiA8bGk+XG5cdCAqICAgICAgZm9yIGFuIGFuaW1hdGlvbiBvZiBjb25zZWN1dGl2ZSBmcmFtZXMsIHlvdSBjYW4gdXNlIGFuIGFycmF5IHdpdGggdHdvIHJlcXVpcmVkLCBhbmQgdHdvIG9wdGlvbmFsIGVudHJpZXNcblx0ICogXHRcdGluIHRoZSBvcmRlcjogYHN0YXJ0YCwgYGVuZGAsIGBuZXh0YCwgYW5kIGBzcGVlZGAuIFRoaXMgd2lsbCBwbGF5IHRoZSBmcmFtZXMgZnJvbSBzdGFydCB0byBlbmQgaW5jbHVzaXZlLlxuXHQgKlxuXHQgKiBcdFx0YW5pbWF0aW9uczoge1xuXHQgKiBcdFx0XHQvLyBzdGFydCwgZW5kLCBuZXh0Kiwgc3BlZWQqXG5cdCAqIFx0XHRcdHJ1bjogWzAsIDhdLFxuXHQgKiBcdFx0XHRqdW1wOiBbOSwgMTIsIFwicnVuXCIsIDJdXG5cdCAqIFx0XHR9XG5cdCAqXG5cdCAqICA8L2xpPlxuXHQgKiAgPGxpPlxuXHQgKiAgICAgZm9yIG5vbi1jb25zZWN1dGl2ZSBmcmFtZXMsIHlvdSBjYW4gdXNlIGFuIG9iamVjdCB3aXRoIGEgYGZyYW1lc2AgcHJvcGVydHkgZGVmaW5pbmcgYW4gYXJyYXkgb2YgZnJhbWVcblx0ICogICAgIGluZGV4ZXMgdG8gcGxheSBpbiBvcmRlci4gVGhlIG9iamVjdCBjYW4gYWxzbyBzcGVjaWZ5IGBuZXh0YCBhbmQgYHNwZWVkYCBwcm9wZXJ0aWVzLlxuXHQgKlxuXHQgKiBcdFx0YW5pbWF0aW9uczoge1xuXHQgKiBcdFx0XHR3YWxrOiB7XG5cdCAqIFx0XHRcdFx0ZnJhbWVzOiBbMSwyLDMsMywyLDFdXG5cdCAqIFx0XHRcdH0sXG5cdCAqIFx0XHRcdHNob290OiB7XG5cdCAqIFx0XHRcdFx0ZnJhbWVzOiBbMSw0LDUsNl0sXG5cdCAqIFx0XHRcdFx0bmV4dDogXCJ3YWxrXCIsXG5cdCAqIFx0XHRcdFx0c3BlZWQ6IDAuNVxuXHQgKiBcdFx0XHR9XG5cdCAqIFx0XHR9XG5cdCAqXG5cdCAqICA8L2xpPlxuXHQgKiA8L29sPlxuXHQgKiA8c3Ryb25nPk5vdGU6PC9zdHJvbmc+IHRoZSBgc3BlZWRgIHByb3BlcnR5IHdhcyBhZGRlZCBpbiBFYXNlbEpTIDAuNy4wLiBFYXJsaWVyIHZlcnNpb25zIGhhZCBhIGBmcmVxdWVuY3lgXG5cdCAqIHByb3BlcnR5IGluc3RlYWQsIHdoaWNoIHdhcyB0aGUgaW52ZXJzZSBvZiBgc3BlZWRgLiBGb3IgZXhhbXBsZSwgYSB2YWx1ZSBvZiBcIjRcIiB3b3VsZCBiZSAxLzQgbm9ybWFsIHNwZWVkIGluXG5cdCAqIGVhcmxpZXIgdmVyc2lvbnMsIGJ1dCBpcyA0eCBub3JtYWwgc3BlZWQgaW4gRWFzZWxKUyAwLjcuMCsuXG5cdCAqXG5cdCAqIDxoND5mcmFtZXJhdGU8L2g0PlxuXHQgKiBPcHRpb25hbC4gSW5kaWNhdGVzIHRoZSBkZWZhdWx0IGZyYW1lcmF0ZSB0byBwbGF5IHRoaXMgc3ByaXRlc2hlZXQgYXQgaW4gZnJhbWVzIHBlciBzZWNvbmQuIFNlZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldC9mcmFtZXJhdGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqXG5cdCAqIFx0XHRmcmFtZXJhdGU6IDIwXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUgU3ByaXRlIGZyYW1lcmF0ZSB3aWxsIG9ubHkgd29yayBpZiB0aGUgc3RhZ2UgdXBkYXRlIG1ldGhvZCBpcyBwcm92aWRlZCB3aXRoIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBnZW5lcmF0ZWQgYnkgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogXHRcdGNyZWF0ZWpzLlRpY2tlci5vbihcInRpY2tcIiwgaGFuZGxlVGljayk7XG5cdCAqIFx0XHRmdW5jdGlvbiBoYW5kbGVUaWNrKGV2ZW50KSB7XG5cdCAqXHRcdFx0c3RhZ2UudXBkYXRlKGV2ZW50KTtcblx0ICpcdFx0fVxuXHQgKlxuXHQgKiA8aDM+RXhhbXBsZTwvaDM+XG5cdCAqIFRvIGRlZmluZSBhIHNpbXBsZSBzcHJpdGUgc2hlZXQsIHdpdGggYSBzaW5nbGUgaW1hZ2UgXCJzcHJpdGVzLmpwZ1wiIGFycmFuZ2VkIGluIGEgcmVndWxhciA1MHg1MCBncmlkIHdpdGggdGhyZWVcblx0ICogYW5pbWF0aW9uczogXCJzdGFuZFwiIHNob3dpbmcgdGhlIGZpcnN0IGZyYW1lLCBcInJ1blwiIGxvb3BpbmcgZnJhbWUgMS01IGluY2x1c2l2ZSwgYW5kIFwianVtcFwiIHBsYXlpbmcgZnJhbWUgNi04IGFuZFxuXHQgKiBzZXF1ZW5jaW5nIGJhY2sgdG8gcnVuLlxuXHQgKlxuXHQgKiBcdFx0dmFyIGRhdGEgPSB7XG5cdCAqIFx0XHRcdGltYWdlczogW1wic3ByaXRlcy5qcGdcIl0sXG5cdCAqIFx0XHRcdGZyYW1lczoge3dpZHRoOjUwLCBoZWlnaHQ6NTB9LFxuXHQgKiBcdFx0XHRhbmltYXRpb25zOiB7XG5cdCAqIFx0XHRcdFx0c3RhbmQ6MCxcblx0ICogXHRcdFx0XHRydW46WzEsNV0sXG5cdCAqIFx0XHRcdFx0anVtcDpbNiw4LFwicnVuXCJdXG5cdCAqIFx0XHRcdH1cblx0ICogXHRcdH07XG5cdCAqIFx0XHR2YXIgc3ByaXRlU2hlZXQgPSBuZXcgY3JlYXRlanMuU3ByaXRlU2hlZXQoZGF0YSk7XG5cdCAqIFx0XHR2YXIgYW5pbWF0aW9uID0gbmV3IGNyZWF0ZWpzLlNwcml0ZShzcHJpdGVTaGVldCwgXCJydW5cIik7XG5cdCAqXG5cdCAqIDxoMz5HZW5lcmF0aW5nIFNwcml0ZVNoZWV0IEltYWdlczwvaDM+XG5cdCAqIFNwcml0ZXNoZWV0cyBjYW4gYmUgY3JlYXRlZCBtYW51YWxseSBieSBjb21iaW5pbmcgaW1hZ2VzIGluIFBob3RvU2hvcCwgYW5kIHNwZWNpZnlpbmcgdGhlIGZyYW1lIHNpemUgb3Jcblx0ICogY29vcmRpbmF0ZXMgbWFudWFsbHksIGhvd2V2ZXIgdGhlcmUgYXJlIGEgbnVtYmVyIG9mIHRvb2xzIHRoYXQgZmFjaWxpdGF0ZSB0aGlzLlxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+RXhwb3J0aW5nIFNwcml0ZVNoZWV0cyBvciBIVE1MNSBjb250ZW50IGZyb20gRmxhc2ggUHJvIHN1cHBvcnRzIHRoZSBFYXNlbEpTIFNwcml0ZVNoZWV0IGZvcm1hdC48L2xpPlxuXHQgKiAgICAgPGxpPlRoZSBwb3B1bGFyIDxhIGhyZWY9XCJodHRwczovL3d3dy5jb2RlYW5kd2ViLmNvbS90ZXh0dXJlcGFja2VyL2Vhc2VsanNcIiB0YXJnZXQ9XCJfYmxhbmtcIj5UZXh0dXJlIFBhY2tlcjwvYT4gaGFzXG5cdCAqICAgICBFYXNlbEpTIHN1cHBvcnQuXG5cdCAqICAgICA8bGk+U1dGIGFuaW1hdGlvbnMgaW4gRmxhc2ggY2FuIGJlIGV4cG9ydGVkIHRvIFNwcml0ZVNoZWV0cyB1c2luZyA8YSBocmVmPVwiaHR0cDovL2NyZWF0ZWpzLmNvbS96b2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj48L2E+PC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogPGgzPkNyb3NzIE9yaWdpbiBJc3N1ZXM8L2gzPlxuXHQgKiA8c3Ryb25nPldhcm5pbmc6PC9zdHJvbmc+IEltYWdlcyBsb2FkZWQgY3Jvc3Mtb3JpZ2luIHdpbGwgdGhyb3cgY3Jvc3Mtb3JpZ2luIHNlY3VyaXR5IGVycm9ycyB3aGVuIGludGVyYWN0ZWQgd2l0aFxuXHQgKiB1c2luZzpcblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPmEgbW91c2U8L2xpPlxuXHQgKiAgICAgPGxpPm1ldGhvZHMgc3VjaCBhcyB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvZ2V0T2JqZWN0VW5kZXJQb2ludFwifX17ey9jcm9zc0xpbmt9fTwvbGk+XG5cdCAqICAgICA8bGk+RmlsdGVycyAoc2VlIHt7I2Nyb3NzTGluayBcIkZpbHRlclwifX17ey9jcm9zc0xpbmt9fSk8L2xpPlxuXHQgKiAgICAgPGxpPmNhY2hpbmcgKHNlZSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2NhY2hlXCJ9fXt7L2Nyb3NzTGlua319KTwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqIFlvdSBjYW4gZ2V0IGFyb3VuZCB0aGlzIGJ5IHNldHRpbmcgYGNyb3NzT3JpZ2luYCBwcm9wZXJ0eSBvbiB5b3VyIGltYWdlcyBiZWZvcmUgcGFzc2luZyB0aGVtIHRvIEVhc2VsSlMsIG9yXG5cdCAqIHNldHRpbmcgdGhlIGBjcm9zc09yaWdpbmAgcHJvcGVydHkgb24gUHJlbG9hZEpTJyBMb2FkUXVldWUgb3IgTG9hZEl0ZW1zLlxuXHQgKlxuXHQgKiBcdFx0dmFyIGltYWdlID0gbmV3IEltYWdlKCk7XG5cdCAqIFx0XHRpbWcuY3Jvc3NPcmlnaW49XCJBbm9ueW1vdXNcIjtcblx0ICogXHRcdGltZy5zcmMgPSBcImh0dHA6Ly9zZXJ2ZXItd2l0aC1DT1JTLXN1cHBvcnQuY29tL3BhdGgvdG8vaW1hZ2UuanBnXCI7XG5cdCAqXG5cdCAqIElmIHlvdSBwYXNzIHN0cmluZyBwYXRocyB0byBTcHJpdGVTaGVldHMsIHRoZXkgd2lsbCBub3Qgd29yayBjcm9zcy1vcmlnaW4uIFRoZSBzZXJ2ZXIgdGhhdCBzdG9yZXMgdGhlIGltYWdlIG11c3Rcblx0ICogc3VwcG9ydCBjcm9zcy1vcmlnaW4gcmVxdWVzdHMsIG9yIHRoaXMgd2lsbCBub3Qgd29yay4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIGNoZWNrIG91dFxuXHQgKiA8YSBocmVmPVwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9BY2Nlc3NfY29udHJvbF9DT1JTXCIgdGFyZ2V0PVwiX2JsYW5rXCI+Q09SUyBvdmVydmlldyBvbiBNRE48L2E+LlxuXHQgKlxuXHQgKiBAY2xhc3MgU3ByaXRlU2hlZXRcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEFuIG9iamVjdCBkZXNjcmliaW5nIHRoZSBTcHJpdGVTaGVldCBkYXRhLlxuXHQgKiBAZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJcblx0ICoqL1xuXHRmdW5jdGlvbiBTcHJpdGVTaGVldChkYXRhKSB7XG5cdFx0dGhpcy5FdmVudERpc3BhdGNoZXJfY29uc3RydWN0b3IoKTtcblxuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgYWxsIGltYWdlcyBhcmUgZmluaXNoZWQgbG9hZGluZy5cblx0XHQgKiBAcHJvcGVydHkgY29tcGxldGVcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMuY29tcGxldGUgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogU3BlY2lmaWVzIHRoZSBmcmFtZXJhdGUgdG8gdXNlIGJ5IGRlZmF1bHQgZm9yIFNwcml0ZSBpbnN0YW5jZXMgdXNpbmcgdGhlIFNwcml0ZVNoZWV0LiBTZWUgdGhlIFNwcml0ZSBjbGFzc1xuXHRcdCAqIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9mcmFtZXJhdGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdFx0ICogQHByb3BlcnR5IGZyYW1lcmF0ZVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLmZyYW1lcmF0ZSA9IDA7XG5cblxuXHRcdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2FuaW1hdGlvbnNcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgQXJyYXlcblx0XHQgKiovXG5cdFx0dGhpcy5fYW5pbWF0aW9ucyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2ZyYW1lc1xuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBBcnJheVxuXHRcdCAqKi9cblx0XHR0aGlzLl9mcmFtZXMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9pbWFnZXNcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgQXJyYXlcblx0XHQgKiovXG5cdFx0dGhpcy5faW1hZ2VzID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfZGF0YVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiovXG5cdFx0dGhpcy5fZGF0YSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2xvYWRDb3VudFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fbG9hZENvdW50ID0gMDtcblxuXHRcdC8vIG9ubHkgdXNlZCBmb3Igc2ltcGxlIGZyYW1lIGRlZnM6XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9mcmFtZUhlaWdodFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fZnJhbWVIZWlnaHQgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9mcmFtZVdpZHRoXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9mcmFtZVdpZHRoID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfbnVtRnJhbWVzXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9udW1GcmFtZXMgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9yZWdYXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9yZWdYID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmVnWVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fcmVnWSA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3NwYWNpbmdcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3NwYWNpbmcgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9tYXJnaW5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX21hcmdpbiA9IDA7XG5cblx0XHQvLyBzZXR1cDpcblx0XHR0aGlzLl9wYXJzZURhdGEoZGF0YSk7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoU3ByaXRlU2hlZXQsIGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlcik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuLy8gZXZlbnRzOlxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIGFsbCBpbWFnZXMgYXJlIGxvYWRlZC4gIE5vdGUgdGhhdCB0aGlzIG9ubHkgZmlyZXMgaWYgdGhlIGltYWdlc1xuXHQgKiB3ZXJlIG5vdCBmdWxseSBsb2FkZWQgd2hlbiB0aGUgc3ByaXRlIHNoZWV0IHdhcyBpbml0aWFsaXplZC4gWW91IHNob3VsZCBjaGVjayB0aGUgY29tcGxldGUgcHJvcGVydHlcblx0ICogdG8gcHJpb3IgdG8gYWRkaW5nIGEgbGlzdGVuZXIuIEV4LlxuXHQgKlxuXHQgKiBcdHZhciBzaGVldCA9IG5ldyBjcmVhdGVqcy5TcHJpdGVTaGVldChkYXRhKTtcblx0ICogXHRpZiAoIXNoZWV0LmNvbXBsZXRlKSB7XG5cdCAqIFx0XHQvLyBub3QgcHJlbG9hZGVkLCBsaXN0ZW4gZm9yIHRoZSBjb21wbGV0ZSBldmVudDpcblx0ICogXHRcdHNoZWV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjb21wbGV0ZVwiLCBoYW5kbGVyKTtcblx0ICogXHR9XG5cdCAqXG5cdCAqIEBldmVudCBjb21wbGV0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIGdldEZyYW1lIGlzIGNhbGxlZCB3aXRoIGEgdmFsaWQgZnJhbWUgaW5kZXguIFRoaXMgaXMgcHJpbWFyaWx5IGludGVuZGVkIGZvciB1c2UgYnkge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRCdWlsZGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdoZW4gZG9pbmcgb24tZGVtYW5kIHJlbmRlcmluZy5cblx0ICogQGV2ZW50IGdldGZyYW1lXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgZnJhbWUgaW5kZXguXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBmcmFtZSBUaGUgZnJhbWUgb2JqZWN0IHRoYXQgZ2V0RnJhbWUgd2lsbCByZXR1cm4uXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gYW4gaW1hZ2UgZW5jb3VudGVycyBhbiBlcnJvci4gQSBTcHJpdGVTaGVldCB3aWxsIGRpc3BhdGNoIGFuIGVycm9yIGV2ZW50IGZvciBlYWNoIGltYWdlIHRoYXRcblx0ICogZW5jb3VudGVycyBhbiBlcnJvciwgYW5kIHdpbGwgc3RpbGwgZGlzcGF0Y2ggYSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldC9jb21wbGV0ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBvbmNlIGFsbCBpbWFnZXMgYXJlIGZpbmlzaGVkIHByb2Nlc3NpbmcsIGV2ZW4gaWYgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQuXG5cdCAqIEBldmVudCBlcnJvclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VyY2Ugb2YgdGhlIGltYWdlIHRoYXQgZmFpbGVkIHRvIGxvYWQuXG5cdCAqIEBzaW5jZSAwLjguMlxuXHQgKi9cblxuXG4vLyBnZXR0ZXIgLyBzZXR0ZXJzOlxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldC9hbmltYXRpb25zOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2QgZ2V0QW5pbWF0aW9uc1xuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRwLmdldEFuaW1hdGlvbnMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYW5pbWF0aW9ucy5zbGljZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBhdmFpbGFibGUgYW5pbWF0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGlzIHNwcml0ZSBzaGVldCBhcyBzdHJpbmdzLlxuXHQgKiBAcHJvcGVydHkgYW5pbWF0aW9uc1xuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdHRyeSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMocCwge1xuXHRcdFx0YW5pbWF0aW9uczogeyBnZXQ6IHAuZ2V0QW5pbWF0aW9ucyB9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHt9XG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2YgZnJhbWVzIGluIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uLCBvciBpbiB0aGUgd2hvbGUgc3ByaXRlXG5cdCAqIHNoZWV0IGlmIHRoZSBhbmltYXRpb24gcGFyYW0gaXMgb21pdHRlZC4gUmV0dXJucyAwIGlmIHRoZSBzcHJpdGVzaGVldCByZWxpZXMgb24gY2FsY3VsYXRlZCBmcmFtZSBjb3VudHMsIGFuZFxuXHQgKiB0aGUgaW1hZ2VzIGhhdmUgbm90IGJlZW4gZnVsbHkgbG9hZGVkLlxuXHQgKiBAbWV0aG9kIGdldE51bUZyYW1lc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gYW5pbWF0aW9uIFRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gZ2V0IGEgZnJhbWUgY291bnQgZm9yLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgZnJhbWVzIGluIHRoZSBhbmltYXRpb24sIG9yIGluIHRoZSBlbnRpcmUgc3ByaXRlIHNoZWV0IGlmIHRoZSBhbmltYXRpb24gcGFyYW0gaXMgb21pdHRlZC5cblx0ICovXG5cdHAuZ2V0TnVtRnJhbWVzID0gZnVuY3Rpb24oYW5pbWF0aW9uKSB7XG5cdFx0aWYgKGFuaW1hdGlvbiA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZnJhbWVzID8gdGhpcy5fZnJhbWVzLmxlbmd0aCA6IHRoaXMuX251bUZyYW1lcyB8fCAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgZGF0YSA9IHRoaXMuX2RhdGFbYW5pbWF0aW9uXTtcblx0XHRcdGlmIChkYXRhID09IG51bGwpIHsgcmV0dXJuIDA7IH1cblx0XHRcdGVsc2UgeyByZXR1cm4gZGF0YS5mcmFtZXMubGVuZ3RoOyB9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIG9iamVjdCBkZWZpbmluZyB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbi4gVGhlIHJldHVybmVkIG9iamVjdCBjb250YWluczo8VUw+XG5cdCAqIFx0PGxpPmZyYW1lczogYW4gYXJyYXkgb2YgdGhlIGZyYW1lIGlkcyBpbiB0aGUgYW5pbWF0aW9uPC9saT5cblx0ICogXHQ8bGk+c3BlZWQ6IHRoZSBwbGF5YmFjayBzcGVlZCBmb3IgdGhpcyBhbmltYXRpb248L2xpPlxuXHQgKiBcdDxsaT5uYW1lOiB0aGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uPC9saT5cblx0ICogXHQ8bGk+bmV4dDogdGhlIGRlZmF1bHQgYW5pbWF0aW9uIHRvIHBsYXkgbmV4dC4gSWYgdGhlIGFuaW1hdGlvbiBsb29wcywgdGhlIG5hbWUgYW5kIG5leHQgcHJvcGVydHkgd2lsbCBiZSB0aGVcblx0ICogXHRzYW1lLjwvbGk+XG5cdCAqIDwvVUw+XG5cdCAqIEBtZXRob2QgZ2V0QW5pbWF0aW9uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gZ2V0LlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IGEgZ2VuZXJpYyBvYmplY3Qgd2l0aCBmcmFtZXMsIHNwZWVkLCBuYW1lLCBhbmQgbmV4dCBwcm9wZXJ0aWVzLlxuXHQgKiovXG5cdHAuZ2V0QW5pbWF0aW9uID0gZnVuY3Rpb24obmFtZSkge1xuXHRcdHJldHVybiB0aGlzLl9kYXRhW25hbWVdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIG9iamVjdCBzcGVjaWZ5aW5nIHRoZSBpbWFnZSBhbmQgc291cmNlIHJlY3Qgb2YgdGhlIHNwZWNpZmllZCBmcmFtZS4gVGhlIHJldHVybmVkIG9iamVjdCBoYXM6PFVMPlxuXHQgKiBcdDxsaT5hbiBpbWFnZSBwcm9wZXJ0eSBob2xkaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBpbWFnZSBvYmplY3QgaW4gd2hpY2ggdGhlIGZyYW1lIGlzIGZvdW5kPC9saT5cblx0ICogXHQ8bGk+YSByZWN0IHByb3BlcnR5IGNvbnRhaW5pbmcgYSBSZWN0YW5nbGUgaW5zdGFuY2Ugd2hpY2ggZGVmaW5lcyB0aGUgYm91bmRhcmllcyBmb3IgdGhlIGZyYW1lIHdpdGhpbiB0aGF0XG5cdCAqIFx0aW1hZ2UuPC9saT5cblx0ICogXHQ8bGk+IEEgcmVnWCBhbmQgcmVnWSBwcm9wZXJ0eSBjb3JyZXNwb25kaW5nIHRvIHRoZSByZWdYL1kgdmFsdWVzIGZvciB0aGUgZnJhbWUuXG5cdCAqIDwvVUw+XG5cdCAqIEBtZXRob2QgZ2V0RnJhbWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lSW5kZXggVGhlIGluZGV4IG9mIHRoZSBmcmFtZS5cblx0ICogQHJldHVybiB7T2JqZWN0fSBhIGdlbmVyaWMgb2JqZWN0IHdpdGggaW1hZ2UgYW5kIHJlY3QgcHJvcGVydGllcy4gUmV0dXJucyBudWxsIGlmIHRoZSBmcmFtZSBkb2VzIG5vdCBleGlzdC5cblx0ICoqL1xuXHRwLmdldEZyYW1lID0gZnVuY3Rpb24oZnJhbWVJbmRleCkge1xuXHRcdHZhciBmcmFtZTtcblx0XHRpZiAodGhpcy5fZnJhbWVzICYmIChmcmFtZT10aGlzLl9mcmFtZXNbZnJhbWVJbmRleF0pKSB7IHJldHVybiBmcmFtZTsgfVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge3sjY3Jvc3NMaW5rIFwiUmVjdGFuZ2xlXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlIGRlZmluaW5nIHRoZSBib3VuZHMgb2YgdGhlIHNwZWNpZmllZCBmcmFtZSByZWxhdGl2ZVxuXHQgKiB0byB0aGUgb3JpZ2luLiBGb3IgZXhhbXBsZSwgYSA5MCB4IDcwIGZyYW1lIHdpdGggYSByZWdYIG9mIDUwIGFuZCBhIHJlZ1kgb2YgNDAgd291bGQgcmV0dXJuOlxuXHQgKlxuXHQgKiBcdFt4PS01MCwgeT0tNDAsIHdpZHRoPTkwLCBoZWlnaHQ9NzBdXG5cdCAqXG5cdCAqIEBtZXRob2QgZ2V0RnJhbWVCb3VuZHNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lSW5kZXggVGhlIGluZGV4IG9mIHRoZSBmcmFtZS5cblx0ICogQHBhcmFtIHtSZWN0YW5nbGV9IFtyZWN0YW5nbGVdIEEgUmVjdGFuZ2xlIGluc3RhbmNlIHRvIGNvcHkgdGhlIHZhbHVlcyBpbnRvLiBCeSBkZWZhdWx0IGEgbmV3IGluc3RhbmNlIGlzIGNyZWF0ZWQuXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gQSBSZWN0YW5nbGUgaW5zdGFuY2UuIFJldHVybnMgbnVsbCBpZiB0aGUgZnJhbWUgZG9lcyBub3QgZXhpc3QsIG9yIHRoZSBpbWFnZSBpcyBub3QgZnVsbHkgbG9hZGVkLlxuXHQgKiovXG5cdHAuZ2V0RnJhbWVCb3VuZHMgPSBmdW5jdGlvbihmcmFtZUluZGV4LCByZWN0YW5nbGUpIHtcblx0XHR2YXIgZnJhbWUgPSB0aGlzLmdldEZyYW1lKGZyYW1lSW5kZXgpO1xuXHRcdHJldHVybiBmcmFtZSA/IChyZWN0YW5nbGV8fG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoKSkuc2V0VmFsdWVzKC1mcmFtZS5yZWdYLCAtZnJhbWUucmVnWSwgZnJhbWUucmVjdC53aWR0aCwgZnJhbWUucmVjdC5oZWlnaHQpIDogbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1Nwcml0ZVNoZWV0XVwiO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTcHJpdGVTaGVldCBjYW5ub3QgYmUgY2xvbmVkLiBBIFNwcml0ZVNoZWV0IGNhbiBiZSBzaGFyZWQgYnkgbXVsdGlwbGUgU3ByaXRlIGluc3RhbmNlcyB3aXRob3V0IGNsb25pbmcgaXQuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3coXCJTcHJpdGVTaGVldCBjYW5ub3QgYmUgY2xvbmVkLlwiKVxuXHR9O1xuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9wYXJzZURhdGFcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIFNwcml0ZVNoZWV0IGRhdGEuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9wYXJzZURhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG5cdFx0dmFyIGksbCxvLGE7XG5cdFx0aWYgKGRhdGEgPT0gbnVsbCkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuZnJhbWVyYXRlID0gZGF0YS5mcmFtZXJhdGV8fDA7XG5cblx0XHQvLyBwYXJzZSBpbWFnZXM6XG5cdFx0aWYgKGRhdGEuaW1hZ2VzICYmIChsPWRhdGEuaW1hZ2VzLmxlbmd0aCkgPiAwKSB7XG5cdFx0XHRhID0gdGhpcy5faW1hZ2VzID0gW107XG5cdFx0XHRmb3IgKGk9MDsgaTxsOyBpKyspIHtcblx0XHRcdFx0dmFyIGltZyA9IGRhdGEuaW1hZ2VzW2ldO1xuXHRcdFx0XHRpZiAodHlwZW9mIGltZyA9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0dmFyIHNyYyA9IGltZztcblx0XHRcdFx0XHRpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuXHRcdFx0XHRcdGltZy5zcmMgPSBzcmM7XG5cdFx0XHRcdH1cblx0XHRcdFx0YS5wdXNoKGltZyk7XG5cdFx0XHRcdGlmICghaW1nLmdldENvbnRleHQgJiYgIWltZy5uYXR1cmFsV2lkdGgpIHtcblx0XHRcdFx0XHR0aGlzLl9sb2FkQ291bnQrKztcblx0XHRcdFx0XHR0aGlzLmNvbXBsZXRlID0gZmFsc2U7XG5cdFx0XHRcdFx0KGZ1bmN0aW9uKG8sIHNyYykgeyBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7IG8uX2hhbmRsZUltYWdlTG9hZChzcmMpOyB9IH0pKHRoaXMsIHNyYyk7XG5cdFx0XHRcdFx0KGZ1bmN0aW9uKG8sIHNyYykgeyBpbWcub25lcnJvciA9IGZ1bmN0aW9uKCkgeyBvLl9oYW5kbGVJbWFnZUVycm9yKHNyYyk7IH0gfSkodGhpcywgc3JjKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHBhcnNlIGZyYW1lczpcblx0XHRpZiAoZGF0YS5mcmFtZXMgPT0gbnVsbCkgeyAvLyBub3RoaW5nXG5cdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRhdGEuZnJhbWVzKSkge1xuXHRcdFx0dGhpcy5fZnJhbWVzID0gW107XG5cdFx0XHRhID0gZGF0YS5mcmFtZXM7XG5cdFx0XHRmb3IgKGk9MCxsPWEubGVuZ3RoO2k8bDtpKyspIHtcblx0XHRcdFx0dmFyIGFyciA9IGFbaV07XG5cdFx0XHRcdHRoaXMuX2ZyYW1lcy5wdXNoKHtpbWFnZTp0aGlzLl9pbWFnZXNbYXJyWzRdP2Fycls0XTowXSwgcmVjdDpuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKGFyclswXSxhcnJbMV0sYXJyWzJdLGFyclszXSksIHJlZ1g6YXJyWzVdfHwwLCByZWdZOmFycls2XXx8MCB9KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0byA9IGRhdGEuZnJhbWVzO1xuXHRcdFx0dGhpcy5fZnJhbWVXaWR0aCA9IG8ud2lkdGg7XG5cdFx0XHR0aGlzLl9mcmFtZUhlaWdodCA9IG8uaGVpZ2h0O1xuXHRcdFx0dGhpcy5fcmVnWCA9IG8ucmVnWHx8MDtcblx0XHRcdHRoaXMuX3JlZ1kgPSBvLnJlZ1l8fDA7XG5cdFx0XHR0aGlzLl9zcGFjaW5nID0gby5zcGFjaW5nfHwwO1xuXHRcdFx0dGhpcy5fbWFyZ2luID0gby5tYXJnaW58fDA7XG5cdFx0XHR0aGlzLl9udW1GcmFtZXMgPSBvLmNvdW50O1xuXHRcdFx0aWYgKHRoaXMuX2xvYWRDb3VudCA9PSAwKSB7IHRoaXMuX2NhbGN1bGF0ZUZyYW1lcygpOyB9XG5cdFx0fVxuXG5cdFx0Ly8gcGFyc2UgYW5pbWF0aW9uczpcblx0XHR0aGlzLl9hbmltYXRpb25zID0gW107XG5cdFx0aWYgKChvPWRhdGEuYW5pbWF0aW9ucykgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fZGF0YSA9IHt9O1xuXHRcdFx0dmFyIG5hbWU7XG5cdFx0XHRmb3IgKG5hbWUgaW4gbykge1xuXHRcdFx0XHR2YXIgYW5pbSA9IHtuYW1lOm5hbWV9O1xuXHRcdFx0XHR2YXIgb2JqID0gb1tuYW1lXTtcblx0XHRcdFx0aWYgKHR5cGVvZiBvYmogPT0gXCJudW1iZXJcIikgeyAvLyBzaW5nbGUgZnJhbWVcblx0XHRcdFx0XHRhID0gYW5pbS5mcmFtZXMgPSBbb2JqXTtcblx0XHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHsgLy8gc2ltcGxlXG5cdFx0XHRcdFx0aWYgKG9iai5sZW5ndGggPT0gMSkgeyBhbmltLmZyYW1lcyA9IFtvYmpbMF1dOyB9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRhbmltLnNwZWVkID0gb2JqWzNdO1xuXHRcdFx0XHRcdFx0YW5pbS5uZXh0ID0gb2JqWzJdO1xuXHRcdFx0XHRcdFx0YSA9IGFuaW0uZnJhbWVzID0gW107XG5cdFx0XHRcdFx0XHRmb3IgKGk9b2JqWzBdO2k8PW9ialsxXTtpKyspIHtcblx0XHRcdFx0XHRcdFx0YS5wdXNoKGkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHsgLy8gY29tcGxleFxuXHRcdFx0XHRcdGFuaW0uc3BlZWQgPSBvYmouc3BlZWQ7XG5cdFx0XHRcdFx0YW5pbS5uZXh0ID0gb2JqLm5leHQ7XG5cdFx0XHRcdFx0dmFyIGZyYW1lcyA9IG9iai5mcmFtZXM7XG5cdFx0XHRcdFx0YSA9IGFuaW0uZnJhbWVzID0gKHR5cGVvZiBmcmFtZXMgPT0gXCJudW1iZXJcIikgPyBbZnJhbWVzXSA6IGZyYW1lcy5zbGljZSgwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYW5pbS5uZXh0ID09PSB0cnVlIHx8IGFuaW0ubmV4dCA9PT0gdW5kZWZpbmVkKSB7IGFuaW0ubmV4dCA9IG5hbWU7IH0gLy8gbG9vcFxuXHRcdFx0XHRpZiAoYW5pbS5uZXh0ID09PSBmYWxzZSB8fCAoYS5sZW5ndGggPCAyICYmIGFuaW0ubmV4dCA9PSBuYW1lKSkgeyBhbmltLm5leHQgPSBudWxsOyB9IC8vIHN0b3Bcblx0XHRcdFx0aWYgKCFhbmltLnNwZWVkKSB7IGFuaW0uc3BlZWQgPSAxOyB9XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvbnMucHVzaChuYW1lKTtcblx0XHRcdFx0dGhpcy5fZGF0YVtuYW1lXSA9IGFuaW07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVJbWFnZUxvYWRcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2hhbmRsZUltYWdlTG9hZCA9IGZ1bmN0aW9uKHNyYykge1xuXHRcdGlmICgtLXRoaXMuX2xvYWRDb3VudCA9PSAwKSB7XG5cdFx0XHR0aGlzLl9jYWxjdWxhdGVGcmFtZXMoKTtcblx0XHRcdHRoaXMuY29tcGxldGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiY29tcGxldGVcIik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVJbWFnZUVycm9yXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2hhbmRsZUltYWdlRXJyb3IgPSBmdW5jdGlvbiAoc3JjKSB7XG5cdFx0dmFyIGVycm9yRXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJlcnJvclwiKTtcblx0XHRlcnJvckV2ZW50LnNyYyA9IHNyYztcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXJyb3JFdmVudCk7XG5cblx0XHQvLyBDb21wbGV0ZSBpcyBzdGlsbCBkaXNwYXRjaGVkLlxuXHRcdGlmICgtLXRoaXMuX2xvYWRDb3VudCA9PSAwKSB7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2NhbGN1bGF0ZUZyYW1lc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fY2FsY3VsYXRlRnJhbWVzID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2ZyYW1lcyB8fCB0aGlzLl9mcmFtZVdpZHRoID09IDApIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9mcmFtZXMgPSBbXTtcblxuXHRcdHZhciBtYXhGcmFtZXMgPSB0aGlzLl9udW1GcmFtZXMgfHwgMTAwMDAwOyAvLyBpZiB3ZSBnbyBvdmVyIHRoaXMsIHNvbWV0aGluZyBpcyB3cm9uZy5cblx0XHR2YXIgZnJhbWVDb3VudCA9IDAsIGZyYW1lV2lkdGggPSB0aGlzLl9mcmFtZVdpZHRoLCBmcmFtZUhlaWdodCA9IHRoaXMuX2ZyYW1lSGVpZ2h0O1xuXHRcdHZhciBzcGFjaW5nID0gdGhpcy5fc3BhY2luZywgbWFyZ2luID0gdGhpcy5fbWFyZ2luO1xuXHRcdFxuXHRcdGltZ0xvb3A6XG5cdFx0Zm9yICh2YXIgaT0wLCBpbWdzPXRoaXMuX2ltYWdlczsgaTxpbWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaW1nID0gaW1nc1tpXSwgaW1nVyA9IGltZy53aWR0aCwgaW1nSCA9IGltZy5oZWlnaHQ7XG5cblx0XHRcdHZhciB5ID0gbWFyZ2luO1xuXHRcdFx0d2hpbGUgKHkgPD0gaW1nSC1tYXJnaW4tZnJhbWVIZWlnaHQpIHtcblx0XHRcdFx0dmFyIHggPSBtYXJnaW47XG5cdFx0XHRcdHdoaWxlICh4IDw9IGltZ1ctbWFyZ2luLWZyYW1lV2lkdGgpIHtcblx0XHRcdFx0XHRpZiAoZnJhbWVDb3VudCA+PSBtYXhGcmFtZXMpIHsgYnJlYWsgaW1nTG9vcDsgfVxuXHRcdFx0XHRcdGZyYW1lQ291bnQrKztcblx0XHRcdFx0XHR0aGlzLl9mcmFtZXMucHVzaCh7XG5cdFx0XHRcdFx0XHRcdGltYWdlOiBpbWcsXG5cdFx0XHRcdFx0XHRcdHJlY3Q6IG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoeCwgeSwgZnJhbWVXaWR0aCwgZnJhbWVIZWlnaHQpLFxuXHRcdFx0XHRcdFx0XHRyZWdYOiB0aGlzLl9yZWdYLFxuXHRcdFx0XHRcdFx0XHRyZWdZOiB0aGlzLl9yZWdZXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR4ICs9IGZyYW1lV2lkdGgrc3BhY2luZztcblx0XHRcdFx0fVxuXHRcdFx0XHR5ICs9IGZyYW1lSGVpZ2h0K3NwYWNpbmc7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX251bUZyYW1lcyA9IGZyYW1lQ291bnQ7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5TcHJpdGVTaGVldCA9IGNyZWF0ZWpzLnByb21vdGUoU3ByaXRlU2hlZXQsIFwiRXZlbnREaXNwYXRjaGVyXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEdyYXBoaWNzLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogVGhlIEdyYXBoaWNzIGNsYXNzIGV4cG9zZXMgYW4gZWFzeSB0byB1c2UgQVBJIGZvciBnZW5lcmF0aW5nIHZlY3RvciBkcmF3aW5nIGluc3RydWN0aW9ucyBhbmQgZHJhd2luZyB0aGVtIHRvIGFcblx0ICogc3BlY2lmaWVkIGNvbnRleHQuIE5vdGUgdGhhdCB5b3UgY2FuIHVzZSBHcmFwaGljcyB3aXRob3V0IGFueSBkZXBlbmRlbmN5IG9uIHRoZSBFYXNlbEpTIGZyYW1ld29yayBieSBjYWxsaW5nIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZGlyZWN0bHksIG9yIGl0IGNhbiBiZSB1c2VkIHdpdGggdGhlIHt7I2Nyb3NzTGluayBcIlNoYXBlXCJ9fXt7L2Nyb3NzTGlua319IG9iamVjdCB0byBkcmF3IHZlY3RvciBncmFwaGljcyB3aXRoaW4gdGhlXG5cdCAqIGNvbnRleHQgb2YgYW4gRWFzZWxKUyBkaXNwbGF5IGxpc3QuXG5cdCAqXG5cdCAqIFRoZXJlIGFyZSB0d28gYXBwcm9hY2hlcyB0byB3b3JraW5nIHdpdGggR3JhcGhpY3Mgb2JqZWN0OiBjYWxsaW5nIG1ldGhvZHMgb24gYSBHcmFwaGljcyBpbnN0YW5jZSAodGhlIFwiR3JhcGhpY3MgQVBJXCIpLCBvclxuXHQgKiBpbnN0YW50aWF0aW5nIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0cyBhbmQgYWRkaW5nIHRoZW0gdG8gdGhlIGdyYXBoaWNzIHF1ZXVlIHZpYSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFRoZSBmb3JtZXIgYWJzdHJhY3RzIHRoZSBsYXR0ZXIsIHNpbXBsaWZ5aW5nIGJlZ2lubmluZyBhbmQgZW5kaW5nIHBhdGhzLCBmaWxscywgYW5kIHN0cm9rZXMuXG5cdCAqXG5cdCAqICAgICAgdmFyIGcgPSBuZXcgY3JlYXRlanMuR3JhcGhpY3MoKTtcblx0ICogICAgICBnLnNldFN0cm9rZVN0eWxlKDEpO1xuXHQgKiAgICAgIGcuYmVnaW5TdHJva2UoXCIjMDAwMDAwXCIpO1xuXHQgKiAgICAgIGcuYmVnaW5GaWxsKFwicmVkXCIpO1xuXHQgKiAgICAgIGcuZHJhd0NpcmNsZSgwLDAsMzApO1xuXHQgKlxuXHQgKiBBbGwgZHJhd2luZyBtZXRob2RzIGluIEdyYXBoaWNzIHJldHVybiB0aGUgR3JhcGhpY3MgaW5zdGFuY2UsIHNvIHRoZXkgY2FuIGJlIGNoYWluZWQgdG9nZXRoZXIuIEZvciBleGFtcGxlLFxuXHQgKiB0aGUgZm9sbG93aW5nIGxpbmUgb2YgY29kZSB3b3VsZCBnZW5lcmF0ZSB0aGUgaW5zdHJ1Y3Rpb25zIHRvIGRyYXcgYSByZWN0YW5nbGUgd2l0aCBhIHJlZCBzdHJva2UgYW5kIGJsdWUgZmlsbDpcblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLmJlZ2luU3Ryb2tlKFwicmVkXCIpLmJlZ2luRmlsbChcImJsdWVcIikuZHJhd1JlY3QoMjAsIDIwLCAxMDAsIDUwKTtcblx0ICpcblx0ICogRWFjaCBncmFwaGljcyBBUEkgY2FsbCBnZW5lcmF0ZXMgYSBjb21tYW5kIG9iamVjdCAoc2VlIGJlbG93KS4gVGhlIGxhc3QgY29tbWFuZCB0byBiZSBjcmVhdGVkIGNhbiBiZSBhY2Nlc3NlZCB2aWFcblx0ICoge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvY29tbWFuZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTpcblx0ICpcblx0ICogICAgICB2YXIgZmlsbENvbW1hbmQgPSBteUdyYXBoaWNzLmJlZ2luRmlsbChcInJlZFwiKS5jb21tYW5kO1xuXHQgKiAgICAgIC8vIC4uLiBsYXRlciwgdXBkYXRlIHRoZSBmaWxsIHN0eWxlL2NvbG9yOlxuXHQgKiAgICAgIGZpbGxDb21tYW5kLnN0eWxlID0gXCJibHVlXCI7XG5cdCAqICAgICAgLy8gb3IgY2hhbmdlIGl0IHRvIGEgYml0bWFwIGZpbGw6XG5cdCAqICAgICAgZmlsbENvbW1hbmQuYml0bWFwKG15SW1hZ2UpO1xuXHQgKlxuXHQgKiBGb3IgbW9yZSBkaXJlY3QgY29udHJvbCBvZiByZW5kZXJpbmcsIHlvdSBjYW4gaW5zdGFudGlhdGUgYW5kIGFwcGVuZCBjb21tYW5kIG9iamVjdHMgdG8gdGhlIGdyYXBoaWNzIHF1ZXVlIGRpcmVjdGx5LiBJbiB0aGlzIGNhc2UsIHlvdVxuXHQgKiBuZWVkIHRvIG1hbmFnZSBwYXRoIGNyZWF0aW9uIG1hbnVhbGx5LCBhbmQgZW5zdXJlIHRoYXQgZmlsbC9zdHJva2UgaXMgYXBwbGllZCB0byBhIGRlZmluZWQgcGF0aDpcblx0ICpcblx0ICogICAgICAvLyBzdGFydCBhIG5ldyBwYXRoLiBHcmFwaGljcy5iZWdpbkNtZCBpcyBhIHJldXNhYmxlIEJlZ2luUGF0aCBpbnN0YW5jZTpcblx0ICogICAgICBteUdyYXBoaWNzLmFwcGVuZChjcmVhdGVqcy5HcmFwaGljcy5iZWdpbkNtZCk7XG5cdCAqICAgICAgLy8gd2UgbmVlZCB0byBkZWZpbmUgdGhlIHBhdGggYmVmb3JlIGFwcGx5aW5nIHRoZSBmaWxsOlxuXHQgKiAgICAgIHZhciBjaXJjbGUgPSBuZXcgY3JlYXRlanMuR3JhcGhpY3MuQ2lyY2xlKDAsMCwzMCk7XG5cdCAqICAgICAgbXlHcmFwaGljcy5hcHBlbmQoY2lyY2xlKTtcblx0ICogICAgICAvLyBmaWxsIHRoZSBwYXRoIHdlIGp1c3QgZGVmaW5lZDpcblx0ICogICAgICB2YXIgZmlsbCA9IG5ldyBjcmVhdGVqcy5HcmFwaGljcy5GaWxsKFwicmVkXCIpO1xuXHQgKiAgICAgIG15R3JhcGhpY3MuYXBwZW5kKGZpbGwpO1xuXHQgKlxuXHQgKiBUaGVzZSBhcHByb2FjaGVzIGNhbiBiZSB1c2VkIHRvZ2V0aGVyLCBmb3IgZXhhbXBsZSB0byBpbnNlcnQgYSBjdXN0b20gY29tbWFuZDpcblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLmJlZ2luRmlsbChcInJlZFwiKTtcblx0ICogICAgICB2YXIgY3VzdG9tQ29tbWFuZCA9IG5ldyBDdXN0b21TcGlyYWxDb21tYW5kKGV0Yyk7XG5cdCAqICAgICAgbXlHcmFwaGljcy5hcHBlbmQoY3VzdG9tQ29tbWFuZCk7XG5cdCAqICAgICAgbXlHcmFwaGljcy5iZWdpbkZpbGwoXCJibHVlXCIpO1xuXHQgKiAgICAgIG15R3JhcGhpY3MuZHJhd0NpcmNsZSgwLCAwLCAzMCk7XG5cdCAqXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mbyBvbiBjcmVhdGluZyBjdXN0b20gY29tbWFuZHMuXG5cdCAqXG5cdCAqIDxoND5UaW55IEFQSTwvaDQ+XG5cdCAqIFRoZSBHcmFwaGljcyBjbGFzcyBhbHNvIGluY2x1ZGVzIGEgXCJ0aW55IEFQSVwiLCB3aGljaCBpcyBvbmUgb3IgdHdvLWxldHRlciBtZXRob2RzIHRoYXQgYXJlIHNob3J0Y3V0cyBmb3IgYWxsIG9mIHRoZVxuXHQgKiBHcmFwaGljcyBtZXRob2RzLiBUaGVzZSBtZXRob2RzIGFyZSBncmVhdCBmb3IgY3JlYXRpbmcgY29tcGFjdCBpbnN0cnVjdGlvbnMsIGFuZCBpcyB1c2VkIGJ5IHRoZSBUb29sa2l0IGZvciBDcmVhdGVKU1xuXHQgKiB0byBnZW5lcmF0ZSByZWFkYWJsZSBjb2RlLiBBbGwgdGlueSBtZXRob2RzIGFyZSBtYXJrZWQgYXMgcHJvdGVjdGVkLCBzbyB5b3UgY2FuIHZpZXcgdGhlbSBieSBlbmFibGluZyBwcm90ZWN0ZWRcblx0ICogZGVzY3JpcHRpb25zIGluIHRoZSBkb2NzLlxuXHQgKlxuXHQgKiA8dGFibGU+XG5cdCAqICAgICA8dHI+PHRkPjxiPlRpbnk8L2I+PC90ZD48dGQ+PGI+TWV0aG9kPC9iPjwvdGQ+PHRkPjxiPlRpbnk8L2I+PC90ZD48dGQ+PGI+TWV0aG9kPC9iPjwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+bXQ8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9tb3ZlVG9cIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5sdDwvdGQ+IDx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9saW5lVG9cIn19e3svY3Jvc3NMaW5rfX08L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPmEvYXQ8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcmNcIn19e3svY3Jvc3NMaW5rfX0gLyB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcmNUb1wifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPmJ0PC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmV6aWVyQ3VydmVUb1wifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPnF0PC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvcXVhZHJhdGljQ3VydmVUb1wifX17ey9jcm9zc0xpbmt9fSAoYWxzbyBjdXJ2ZVRvKTwvdGQ+XG5cdCAqICAgICA8dGQ+cjwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3JlY3RcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5jcDwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2Nsb3NlUGF0aFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPmM8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9jbGVhclwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPmY8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkZpbGxcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5sZjwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luTGluZWFyR3JhZGllbnRGaWxsXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+cmY8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpblJhZGlhbEdyYWRpZW50RmlsbFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPmJmPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5CaXRtYXBGaWxsXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+ZWY8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9lbmRGaWxsXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+c3MgLyBzZDwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3NldFN0cm9rZVN0eWxlXCJ9fXt7L2Nyb3NzTGlua319IC8ge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3Mvc2V0U3Ryb2tlRGFzaFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPnM8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpblN0cm9rZVwifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPmxzPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5MaW5lYXJHcmFkaWVudFN0cm9rZVwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPnJzPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5SYWRpYWxHcmFkaWVudFN0cm9rZVwifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPmJzPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5CaXRtYXBTdHJva2VcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5lczwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2VuZFN0cm9rZVwifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPmRyPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd1JlY3RcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5ycjwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdSb3VuZFJlY3RcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5yYzwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdSb3VuZFJlY3RDb21wbGV4XCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+ZGM8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Q2lyY2xlXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+ZGU8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3RWxsaXBzZVwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPmRwPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd1BvbHlTdGFyXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+cDwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RlY29kZVBhdGhcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiA8L3RhYmxlPlxuXHQgKlxuXHQgKiBIZXJlIGlzIHRoZSBhYm92ZSBleGFtcGxlLCB1c2luZyB0aGUgdGlueSBBUEkgaW5zdGVhZC5cblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLnMoXCJyZWRcIikuZihcImJsdWVcIikucigyMCwgMjAsIDEwMCwgNTApO1xuXHQgKlxuXHQgKiBAY2xhc3MgR3JhcGhpY3Ncblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gR3JhcGhpY3MoKSB7XG5cblxuXHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIGEgcmVmZXJlbmNlIHRvIHRoZSBsYXN0IGNvbW1hbmQgdGhhdCB3YXMgY3JlYXRlZCBvciBhcHBlbmRlZC4gRm9yIGV4YW1wbGUsIHlvdSBjb3VsZCByZXRhaW4gYSByZWZlcmVuY2Vcblx0XHQgKiB0byBhIEZpbGwgY29tbWFuZCBpbiBvcmRlciB0byBkeW5hbWljYWxseSB1cGRhdGUgdGhlIGNvbG9yIGxhdGVyIGJ5IHVzaW5nOlxuXHRcdCAqXG5cdFx0ICogXHRcdHZhciBteUZpbGwgPSBteUdyYXBoaWNzLmJlZ2luRmlsbChcInJlZFwiKS5jb21tYW5kO1xuXHRcdCAqIFx0XHQvLyB1cGRhdGUgY29sb3IgbGF0ZXI6XG5cdFx0ICogXHRcdG15RmlsbC5zdHlsZSA9IFwieWVsbG93XCI7XG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgY29tbWFuZFxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqKi9cblx0XHR0aGlzLmNvbW1hbmQgPSBudWxsO1xuXG5cblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9zdHJva2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge1N0cm9rZX1cblx0XHQgKiovXG5cdFx0dGhpcy5fc3Ryb2tlID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfc3Ryb2tlU3R5bGVcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge1N0cm9rZVN0eWxlfVxuXHRcdCAqKi9cblx0XHR0aGlzLl9zdHJva2VTdHlsZSA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9vbGRTdHJva2VTdHlsZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7U3Ryb2tlU3R5bGV9XG5cdFx0ICoqL1xuXHRcdHRoaXMuX29sZFN0cm9rZVN0eWxlID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3N0cm9rZURhc2hcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge1N0cm9rZURhc2h9XG5cdFx0ICoqL1xuXHRcdHRoaXMuX3N0cm9rZURhc2ggPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfb2xkU3Ryb2tlRGFzaFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7U3Ryb2tlRGFzaH1cblx0XHQgKiovXG5cdFx0dGhpcy5fb2xkU3Ryb2tlRGFzaCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3N0cm9rZUlnbm9yZVNjYWxlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiovXG5cdFx0dGhpcy5fc3Ryb2tlSWdub3JlU2NhbGUgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfZmlsbFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7RmlsbH1cblx0XHQgKiovXG5cdFx0dGhpcy5fZmlsbCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2luc3RydWN0aW9uc1xuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2luc3RydWN0aW9ucyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHRoZSBsYXN0IGluc3RydWN0aW9uIGluZGV4IHRoYXQgd2FzIGNvbW1pdHRlZC5cblx0XHQgKiBAcHJvcGVydHkgX2NvbW1pdEluZGV4XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2NvbW1pdEluZGV4ID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIFVuY29tbWl0dGVkIGluc3RydWN0aW9ucy5cblx0XHQgKiBAcHJvcGVydHkgX2FjdGl2ZUluc3RydWN0aW9uc1xuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2FjdGl2ZUluc3RydWN0aW9ucyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBoYXZlIGJlZW4gY2hhbmdlcyB0byB0aGUgYWN0aXZlSW5zdHJ1Y3Rpb24gbGlzdCBzaW5jZSB0aGUgbGFzdCB1cGRhdGVJbnN0cnVjdGlvbnMgY2FsbC5cblx0XHQgKiBAcHJvcGVydHkgX2RpcnR5XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBJbmRleCB0byBkcmF3IGZyb20gaWYgYSBzdG9yZSBvcGVyYXRpb24gaGFzIGhhcHBlbmVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfc3RvcmVJbmRleFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5fc3RvcmVJbmRleCA9IDA7XG5cblx0Ly8gc2V0dXA6XG5cdFx0dGhpcy5jbGVhcigpO1xuXHR9XG5cdHZhciBwID0gR3JhcGhpY3MucHJvdG90eXBlO1xuXHR2YXIgRyA9IEdyYXBoaWNzOyAvLyBzaG9ydGN1dFxuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG4vLyBzdGF0aWMgcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgQ1NTIGNvbXBhdGlibGUgY29sb3Igc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgUkdCIG51bWVyaWMgY29sb3IgdmFsdWVzIGluIHRoZSBmb3JtYXRcblx0ICogXCJyZ2JhKDI1NSwyNTUsMjU1LDEuMClcIiwgb3IgaWYgYWxwaGEgaXMgbnVsbCB0aGVuIGluIHRoZSBmb3JtYXQgXCJyZ2IoMjU1LDI1NSwyNTUpXCIuIEZvciBleGFtcGxlLFxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLkdyYXBoaWNzLmdldFJHQig1MCwgMTAwLCAxNTAsIDAuNSk7XG5cdCAqICAgICAgLy8gUmV0dXJucyBcInJnYmEoNTAsMTAwLDE1MCwwLjUpXCJcblx0ICpcblx0ICogSXQgYWxzbyBzdXBwb3J0cyBwYXNzaW5nIGEgc2luZ2xlIGhleCBjb2xvciB2YWx1ZSBhcyB0aGUgZmlyc3QgcGFyYW0sIGFuZCBhbiBvcHRpb25hbCBhbHBoYSB2YWx1ZSBhcyB0aGUgc2Vjb25kXG5cdCAqIHBhcmFtLiBGb3IgZXhhbXBsZSxcblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5HcmFwaGljcy5nZXRSR0IoMHhGRjAwRkYsIDAuMik7XG5cdCAqICAgICAgLy8gUmV0dXJucyBcInJnYmEoMjU1LDAsMjU1LDAuMilcIlxuXHQgKlxuXHQgKiBAbWV0aG9kIGdldFJHQlxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByIFRoZSByZWQgY29tcG9uZW50IGZvciB0aGUgY29sb3IsIGJldHdlZW4gMCBhbmQgMHhGRiAoMjU1KS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGcgVGhlIGdyZWVuIGNvbXBvbmVudCBmb3IgdGhlIGNvbG9yLCBiZXR3ZWVuIDAgYW5kIDB4RkYgKDI1NSkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBibHVlIGNvbXBvbmVudCBmb3IgdGhlIGNvbG9yLCBiZXR3ZWVuIDAgYW5kIDB4RkYgKDI1NSkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYWxwaGFdIFRoZSBhbHBoYSBjb21wb25lbnQgZm9yIHRoZSBjb2xvciB3aGVyZSAwIGlzIGZ1bGx5IHRyYW5zcGFyZW50IGFuZCAxIGlzIGZ1bGx5IG9wYXF1ZS5cblx0ICogQHJldHVybiB7U3RyaW5nfSBBIENTUyBjb21wYXRpYmxlIGNvbG9yIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIFJHQiBudW1lcmljIGNvbG9yIHZhbHVlcyBpbiB0aGUgZm9ybWF0XG5cdCAqIFwicmdiYSgyNTUsMjU1LDI1NSwxLjApXCIsIG9yIGlmIGFscGhhIGlzIG51bGwgdGhlbiBpbiB0aGUgZm9ybWF0IFwicmdiKDI1NSwyNTUsMjU1KVwiLlxuXHQgKiovXG5cdEdyYXBoaWNzLmdldFJHQiA9IGZ1bmN0aW9uKHIsIGcsIGIsIGFscGhhKSB7XG5cdFx0aWYgKHIgIT0gbnVsbCAmJiBiID09IG51bGwpIHtcblx0XHRcdGFscGhhID0gZztcblx0XHRcdGIgPSByJjB4RkY7XG5cdFx0XHRnID0gcj4+OCYweEZGO1xuXHRcdFx0ciA9IHI+PjE2JjB4RkY7XG5cdFx0fVxuXHRcdGlmIChhbHBoYSA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gXCJyZ2IoXCIrcitcIixcIitnK1wiLFwiK2IrXCIpXCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBcInJnYmEoXCIrcitcIixcIitnK1wiLFwiK2IrXCIsXCIrYWxwaGErXCIpXCI7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgQ1NTIGNvbXBhdGlibGUgY29sb3Igc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgSFNMIG51bWVyaWMgY29sb3IgdmFsdWVzIGluIHRoZSBmb3JtYXQgXCJoc2xhKDM2MCwxMDAsMTAwLDEuMClcIixcblx0ICogb3IgaWYgYWxwaGEgaXMgbnVsbCB0aGVuIGluIHRoZSBmb3JtYXQgXCJoc2woMzYwLDEwMCwxMDApXCIuXG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuR3JhcGhpY3MuZ2V0SFNMKDE1MCwgMTAwLCA3MCk7XG5cdCAqICAgICAgLy8gUmV0dXJucyBcImhzbCgxNTAsMTAwLDcwKVwiXG5cdCAqXG5cdCAqIEBtZXRob2QgZ2V0SFNMXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGh1ZSBUaGUgaHVlIGNvbXBvbmVudCBmb3IgdGhlIGNvbG9yLCBiZXR3ZWVuIDAgYW5kIDM2MC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNhdHVyYXRpb24gVGhlIHNhdHVyYXRpb24gY29tcG9uZW50IGZvciB0aGUgY29sb3IsIGJldHdlZW4gMCBhbmQgMTAwLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gbGlnaHRuZXNzIFRoZSBsaWdodG5lc3MgY29tcG9uZW50IGZvciB0aGUgY29sb3IsIGJldHdlZW4gMCBhbmQgMTAwLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2FscGhhXSBUaGUgYWxwaGEgY29tcG9uZW50IGZvciB0aGUgY29sb3Igd2hlcmUgMCBpcyBmdWxseSB0cmFuc3BhcmVudCBhbmQgMSBpcyBmdWxseSBvcGFxdWUuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gQSBDU1MgY29tcGF0aWJsZSBjb2xvciBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBIU0wgbnVtZXJpYyBjb2xvciB2YWx1ZXMgaW4gdGhlIGZvcm1hdFxuXHQgKiBcImhzbGEoMzYwLDEwMCwxMDAsMS4wKVwiLCBvciBpZiBhbHBoYSBpcyBudWxsIHRoZW4gaW4gdGhlIGZvcm1hdCBcImhzbCgzNjAsMTAwLDEwMClcIi5cblx0ICoqL1xuXHRHcmFwaGljcy5nZXRIU0wgPSBmdW5jdGlvbihodWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcywgYWxwaGEpIHtcblx0XHRpZiAoYWxwaGEgPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIFwiaHNsKFwiKyhodWUlMzYwKStcIixcIitzYXR1cmF0aW9uK1wiJSxcIitsaWdodG5lc3MrXCIlKVwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gXCJoc2xhKFwiKyhodWUlMzYwKStcIixcIitzYXR1cmF0aW9uK1wiJSxcIitsaWdodG5lc3MrXCIlLFwiK2FscGhhK1wiKVwiO1xuXHRcdH1cblx0fTtcblxuXG4vLyBzdGF0aWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIEEgcmV1c2FibGUgaW5zdGFuY2Ugb2Yge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvQmVnaW5QYXRoXCJ9fXt7L2Nyb3NzTGlua319IHRvIGF2b2lkXG5cdCAqIHVubmVjZXNzYXJ5IGluc3RhbnRpYXRpb24uXG5cdCAqIEBwcm9wZXJ0eSBiZWdpbkNtZFxuXHQgKiBAdHlwZSB7R3JhcGhpY3MuQmVnaW5QYXRofVxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0IC8vIGRlZmluZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG5cblx0LyoqXG5cdCAqIE1hcCBvZiBCYXNlNjQgY2hhcmFjdGVycyB0byB2YWx1ZXMuIFVzZWQgYnkge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZGVjb2RlUGF0aFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQHByb3BlcnR5IEJBU0VfNjRcblx0ICogQHN0YXRpY1xuXHQgKiBAZmluYWxcblx0ICogQHJlYWRvbmx5XG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqKi9cblx0R3JhcGhpY3MuQkFTRV82NCA9IHtcIkFcIjowLFwiQlwiOjEsXCJDXCI6MixcIkRcIjozLFwiRVwiOjQsXCJGXCI6NSxcIkdcIjo2LFwiSFwiOjcsXCJJXCI6OCxcIkpcIjo5LFwiS1wiOjEwLFwiTFwiOjExLFwiTVwiOjEyLFwiTlwiOjEzLFwiT1wiOjE0LFwiUFwiOjE1LFwiUVwiOjE2LFwiUlwiOjE3LFwiU1wiOjE4LFwiVFwiOjE5LFwiVVwiOjIwLFwiVlwiOjIxLFwiV1wiOjIyLFwiWFwiOjIzLFwiWVwiOjI0LFwiWlwiOjI1LFwiYVwiOjI2LFwiYlwiOjI3LFwiY1wiOjI4LFwiZFwiOjI5LFwiZVwiOjMwLFwiZlwiOjMxLFwiZ1wiOjMyLFwiaFwiOjMzLFwiaVwiOjM0LFwialwiOjM1LFwia1wiOjM2LFwibFwiOjM3LFwibVwiOjM4LFwiblwiOjM5LFwib1wiOjQwLFwicFwiOjQxLFwicVwiOjQyLFwiclwiOjQzLFwic1wiOjQ0LFwidFwiOjQ1LFwidVwiOjQ2LFwidlwiOjQ3LFwid1wiOjQ4LFwieFwiOjQ5LFwieVwiOjUwLFwielwiOjUxLFwiMFwiOjUyLFwiMVwiOjUzLFwiMlwiOjU0LFwiM1wiOjU1LFwiNFwiOjU2LFwiNVwiOjU3LFwiNlwiOjU4LFwiN1wiOjU5LFwiOFwiOjYwLFwiOVwiOjYxLFwiK1wiOjYyLFwiL1wiOjYzfTtcblxuXHQvKipcblx0ICogTWFwcyBudW1lcmljIHZhbHVlcyBmb3IgdGhlIGNhcHMgcGFyYW1ldGVyIG9mIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3NldFN0cm9rZVN0eWxlXCJ9fXt7L2Nyb3NzTGlua319IHRvXG5cdCAqIGNvcnJlc3BvbmRpbmcgc3RyaW5nIHZhbHVlcy4gVGhpcyBpcyBwcmltYXJpbHkgZm9yIHVzZSB3aXRoIHRoZSB0aW55IEFQSS4gVGhlIG1hcHBpbmdzIGFyZSBhcyBmb2xsb3dzOiAwIHRvXG5cdCAqIFwiYnV0dFwiLCAxIHRvIFwicm91bmRcIiwgYW5kIDIgdG8gXCJzcXVhcmVcIi5cblx0ICogRm9yIGV4YW1wbGUsIHRvIHNldCB0aGUgbGluZSBjYXBzIHRvIFwic3F1YXJlXCI6XG5cdCAqXG5cdCAqICAgICAgbXlHcmFwaGljcy5zcygxNiwgMik7XG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBTVFJPS0VfQ0FQU19NQVBcblx0ICogQHN0YXRpY1xuXHQgKiBAZmluYWxcblx0ICogQHJlYWRvbmx5XG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICoqL1xuXHRHcmFwaGljcy5TVFJPS0VfQ0FQU19NQVAgPSBbXCJidXR0XCIsIFwicm91bmRcIiwgXCJzcXVhcmVcIl07XG5cblx0LyoqXG5cdCAqIE1hcHMgbnVtZXJpYyB2YWx1ZXMgZm9yIHRoZSBqb2ludHMgcGFyYW1ldGVyIG9mIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3NldFN0cm9rZVN0eWxlXCJ9fXt7L2Nyb3NzTGlua319IHRvXG5cdCAqIGNvcnJlc3BvbmRpbmcgc3RyaW5nIHZhbHVlcy4gVGhpcyBpcyBwcmltYXJpbHkgZm9yIHVzZSB3aXRoIHRoZSB0aW55IEFQSS4gVGhlIG1hcHBpbmdzIGFyZSBhcyBmb2xsb3dzOiAwIHRvXG5cdCAqIFwibWl0ZXJcIiwgMSB0byBcInJvdW5kXCIsIGFuZCAyIHRvIFwiYmV2ZWxcIi5cblx0ICogRm9yIGV4YW1wbGUsIHRvIHNldCB0aGUgbGluZSBqb2ludHMgdG8gXCJiZXZlbFwiOlxuXHQgKlxuXHQgKiAgICAgIG15R3JhcGhpY3Muc3MoMTYsIDAsIDIpO1xuXHQgKlxuXHQgKiBAcHJvcGVydHkgU1RST0tFX0pPSU5UU19NQVBcblx0ICogQHN0YXRpY1xuXHQgKiBAZmluYWxcblx0ICogQHJlYWRvbmx5XG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICoqL1xuXHRHcmFwaGljcy5TVFJPS0VfSk9JTlRTX01BUCA9IFtcIm1pdGVyXCIsIFwicm91bmRcIiwgXCJiZXZlbFwiXTtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IF9jdHhcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG5cdCAqKi9cblx0dmFyIGNhbnZhcyA9IChjcmVhdGVqcy5jcmVhdGVDYW52YXM/Y3JlYXRlanMuY3JlYXRlQ2FudmFzKCk6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSk7XG5cdGlmIChjYW52YXMuZ2V0Q29udGV4dCkge1xuXHRcdEdyYXBoaWNzLl9jdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAxO1xuXHR9XG5cblxuLy8gZ2V0dGVyIC8gc2V0dGVyczpcblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvaW5zdHJ1Y3Rpb25zOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2QgZ2V0SW5zdHJ1Y3Rpb25zXG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdHAuZ2V0SW5zdHJ1Y3Rpb25zID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fdXBkYXRlSW5zdHJ1Y3Rpb25zKCk7XG5cdFx0cmV0dXJuIHRoaXMuX2luc3RydWN0aW9ucztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZ3JhcGhpY3MgaW5zdHJ1Y3Rpb25zIGFycmF5LiBFYWNoIGVudHJ5IGlzIGEgZ3JhcGhpY3MgY29tbWFuZCBvYmplY3QgKGV4LiBHcmFwaGljcy5GaWxsLCBHcmFwaGljcy5SZWN0KVxuXHQgKiBNb2RpZnlpbmcgdGhlIHJldHVybmVkIGFycmF5IGRpcmVjdGx5IGlzIG5vdCByZWNvbW1lbmRlZCwgYW5kIGlzIGxpa2VseSB0byByZXN1bHQgaW4gdW5leHBlY3RlZCBiZWhhdmlvdXIuXG5cdCAqXG5cdCAqIFRoaXMgcHJvcGVydHkgaXMgbWFpbmx5IGludGVuZGVkIGZvciBpbnRyb3NwZWN0aW9uIG9mIHRoZSBpbnN0cnVjdGlvbnMgKGV4LiBmb3IgZ3JhcGhpY3MgZXhwb3J0KS5cblx0ICogQHByb3BlcnR5IGluc3RydWN0aW9uc1xuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdHRyeSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMocCwge1xuXHRcdFx0aW5zdHJ1Y3Rpb25zOiB7IGdldDogcC5nZXRJbnN0cnVjdGlvbnMgfVxuXHRcdH0pO1xuXHR9IGNhdGNoIChlKSB7fVxuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoaXMgR3JhcGhpY3MgaW5zdGFuY2UgaGFzIG5vIGRyYXdpbmcgY29tbWFuZHMuXG5cdCAqIEBtZXRob2QgaXNFbXB0eVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhpcyBHcmFwaGljcyBpbnN0YW5jZSBoYXMgbm8gZHJhd2luZyBjb21tYW5kcy5cblx0ICoqL1xuXHRwLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISh0aGlzLl9pbnN0cnVjdGlvbnMubGVuZ3RoIHx8IHRoaXMuX2FjdGl2ZUluc3RydWN0aW9ucy5sZW5ndGgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyB0aGUgZGlzcGxheSBvYmplY3QgaW50byB0aGUgc3BlY2lmaWVkIGNvbnRleHQgaWdub3JpbmcgaXRzIHZpc2libGUsIGFscGhhLCBzaGFkb3csIGFuZCB0cmFuc2Zvcm0uXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZHJhdyB3YXMgaGFuZGxlZCAodXNlZnVsIGZvciBvdmVycmlkaW5nIGZ1bmN0aW9uYWxpdHkpLlxuXHQgKlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgZHJhd1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBPcHRpb25hbCBkYXRhIHRoYXQgaXMgcGFzc2VkIHRvIGdyYXBoaWNzIGNvbW1hbmQgZXhlYyBtZXRob2RzLiBXaGVuIGNhbGxlZCBmcm9tIGEgU2hhcGUgaW5zdGFuY2UsIHRoZSBzaGFwZSBwYXNzZXMgaXRzZWxmIGFzIHRoZSBkYXRhIHBhcmFtZXRlci4gVGhpcyBjYW4gYmUgdXNlZCBieSBjdXN0b20gZ3JhcGhpYyBjb21tYW5kcyB0byBpbnNlcnQgY29udGV4dHVhbCBkYXRhLlxuXHQgKiovXG5cdHAuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgZGF0YSkge1xuXHRcdHRoaXMuX3VwZGF0ZUluc3RydWN0aW9ucygpO1xuXHRcdHZhciBpbnN0ciA9IHRoaXMuX2luc3RydWN0aW9ucztcblx0XHRmb3IgKHZhciBpPXRoaXMuX3N0b3JlSW5kZXgsIGw9aW5zdHIubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0aW5zdHJbaV0uZXhlYyhjdHgsIGRhdGEpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRHJhd3Mgb25seSB0aGUgcGF0aCBkZXNjcmliZWQgZm9yIHRoaXMgR3JhcGhpY3MgaW5zdGFuY2UsIHNraXBwaW5nIGFueSBub24tcGF0aCBpbnN0cnVjdGlvbnMsIGluY2x1ZGluZyBmaWxsIGFuZFxuXHQgKiBzdHJva2UgZGVzY3JpcHRpb25zLiBVc2VkIGZvciA8Y29kZT5EaXNwbGF5T2JqZWN0Lm1hc2s8L2NvZGU+IHRvIGRyYXcgdGhlIGNsaXBwaW5nIHBhdGgsIGZvciBleGFtcGxlLlxuXHQgKlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgZHJhd0FzUGF0aFxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxuXHQgKiovXG5cdHAuZHJhd0FzUGF0aCA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdHRoaXMuX3VwZGF0ZUluc3RydWN0aW9ucygpO1xuXHRcdHZhciBpbnN0ciwgaW5zdHJzID0gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuXHRcdGZvciAodmFyIGk9dGhpcy5fc3RvcmVJbmRleCwgbD1pbnN0cnMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0Ly8gdGhlIGZpcnN0IGNvbW1hbmQgaXMgYWx3YXlzIGEgYmVnaW5QYXRoIGNvbW1hbmQuXG5cdFx0XHRpZiAoKGluc3RyID0gaW5zdHJzW2ldKS5wYXRoICE9PSBmYWxzZSkgeyBpbnN0ci5leGVjKGN0eCk7IH1cblx0XHR9XG5cdH07XG5cblxuLy8gcHVibGljIG1ldGhvZHMgdGhhdCBtYXAgZGlyZWN0bHkgdG8gY29udGV4dCAyRCBjYWxsczpcblx0LyoqXG5cdCAqIE1vdmVzIHRoZSBkcmF3aW5nIHBvaW50IHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uIEEgdGlueSBBUEkgbWV0aG9kIFwibXRcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBtb3ZlVG9cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggY29vcmRpbmF0ZSB0aGUgZHJhd2luZyBwb2ludCBzaG91bGQgbW92ZSB0by5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29vcmRpbmF0ZSB0aGUgZHJhd2luZyBwb2ludCBzaG91bGQgbW92ZSB0by5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscykuXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLm1vdmVUbyA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IEcuTW92ZVRvKHgseSksIHRydWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIGxpbmUgZnJvbSB0aGUgY3VycmVudCBkcmF3aW5nIHBvaW50IHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24sIHdoaWNoIGJlY29tZSB0aGUgbmV3IGN1cnJlbnQgZHJhd2luZ1xuXHQgKiBwb2ludC4gTm90ZSB0aGF0IHlvdSAqbXVzdCogY2FsbCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9tb3ZlVG9cIn19e3svY3Jvc3NMaW5rfX0gYmVmb3JlIHRoZSBmaXJzdCBgbGluZVRvKClgLlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImx0XCIgYWxzbyBleGlzdHMuXG5cdCAqXG5cdCAqIEZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiwgcmVhZCB0aGVcblx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2NvbXBsZXgtc2hhcGVzLShwYXRocylcIj5cblx0ICogd2hhdHdnIHNwZWM8L2E+LlxuXHQgKiBAbWV0aG9kIGxpbmVUb1xuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBkcmF3IHRvLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBkcmF3IHRvLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAubGluZVRvID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5MaW5lVG8oeCx5KSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGFuIGFyYyB3aXRoIHRoZSBzcGVjaWZpZWQgY29udHJvbCBwb2ludHMgYW5kIHJhZGl1cy4gIEZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiwgcmVhZCB0aGVcblx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2RvbS1jb250ZXh0LTJkLWFyY3RvXCI+XG5cdCAqIHdoYXR3ZyBzcGVjPC9hPi4gQSB0aW55IEFQSSBtZXRob2QgXCJhdFwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGFyY1RvXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geTFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hcmNUbyA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IEcuQXJjVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBhbiBhcmMgZGVmaW5lZCBieSB0aGUgcmFkaXVzLCBzdGFydEFuZ2xlIGFuZCBlbmRBbmdsZSBhcmd1bWVudHMsIGNlbnRlcmVkIGF0IHRoZSBwb3NpdGlvbiAoeCwgeSkuIEZvclxuXHQgKiBleGFtcGxlLCB0byBkcmF3IGEgZnVsbCBjaXJjbGUgd2l0aCBhIHJhZGl1cyBvZiAyMCBjZW50ZXJlZCBhdCAoMTAwLCAxMDApOlxuXHQgKlxuXHQgKiAgICAgIGFyYygxMDAsIDEwMCwgMjAsIDAsIE1hdGguUEkqMik7XG5cdCAqXG5cdCAqIEZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiwgcmVhZCB0aGVcblx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2RvbS1jb250ZXh0LTJkLWFyY1wiPndoYXR3ZyBzcGVjPC9hPi5cblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJhXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYXJjXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0QW5nbGUgTWVhc3VyZWQgaW4gcmFkaWFucy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGVuZEFuZ2xlIE1lYXN1cmVkIGluIHJhZGlhbnMuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYW50aWNsb2Nrd2lzZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYXJjID0gZnVuY3Rpb24oeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5BcmMoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIHF1YWRyYXRpYyBjdXJ2ZSBmcm9tIHRoZSBjdXJyZW50IGRyYXdpbmcgcG9pbnQgdG8gKHgsIHkpIHVzaW5nIHRoZSBjb250cm9sIHBvaW50IChjcHgsIGNweSkuIEZvciBkZXRhaWxlZFxuXHQgKiBpbmZvcm1hdGlvbiwgcmVhZCB0aGUgPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2RvbS1jb250ZXh0LTJkLXF1YWRyYXRpY2N1cnZldG9cIj5cblx0ICogd2hhdHdnIHNwZWM8L2E+LiBBIHRpbnkgQVBJIG1ldGhvZCBcInF0XCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgcXVhZHJhdGljQ3VydmVUb1xuXHQgKiBAcGFyYW0ge051bWJlcn0gY3B4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLnF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbihjcHgsIGNweSwgeCwgeSkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5RdWFkcmF0aWNDdXJ2ZVRvKGNweCwgY3B5LCB4LCB5KSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgYmV6aWVyIGN1cnZlIGZyb20gdGhlIGN1cnJlbnQgZHJhd2luZyBwb2ludCB0byAoeCwgeSkgdXNpbmcgdGhlIGNvbnRyb2wgcG9pbnRzIChjcDF4LCBjcDF5KSBhbmQgKGNwMngsXG5cdCAqIGNwMnkpLiBGb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24sIHJlYWQgdGhlXG5cdCAqIDxhIGhyZWY9XCJodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCNkb20tY29udGV4dC0yZC1iZXppZXJjdXJ2ZXRvXCI+XG5cdCAqIHdoYXR3ZyBzcGVjPC9hPi4gQSB0aW55IEFQSSBtZXRob2QgXCJidFwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlemllckN1cnZlVG9cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMXhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMXlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMnhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMnlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmJlemllckN1cnZlVG8gPSBmdW5jdGlvbihjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLkJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIHJlY3RhbmdsZSBhdCAoeCwgeSkgd2l0aCB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQgdXNpbmcgdGhlIGN1cnJlbnQgZmlsbCBhbmQvb3Igc3Ryb2tlLlxuXHQgKiBGb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24sIHJlYWQgdGhlXG5cdCAqIDxhIGhyZWY9XCJodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCNkb20tY29udGV4dC0yZC1yZWN0XCI+XG5cdCAqIHdoYXR3ZyBzcGVjPC9hPi4gQSB0aW55IEFQSSBtZXRob2QgXCJyXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgcmVjdFxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdyBXaWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoIEhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5yZWN0ID0gZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5SZWN0KHgsIHksIHcsIGgpKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2xvc2VzIHRoZSBjdXJyZW50IHBhdGgsIGVmZmVjdGl2ZWx5IGRyYXdpbmcgYSBsaW5lIGZyb20gdGhlIGN1cnJlbnQgZHJhd2luZyBwb2ludCB0byB0aGUgZmlyc3QgZHJhd2luZyBwb2ludCBzcGVjaWZpZWRcblx0ICogc2luY2UgdGhlIGZpbGwgb3Igc3Ryb2tlIHdhcyBsYXN0IHNldC4gQSB0aW55IEFQSSBtZXRob2QgXCJjcFwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGNsb3NlUGF0aFxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuY2xvc2VQYXRoID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FjdGl2ZUluc3RydWN0aW9ucy5sZW5ndGggPyB0aGlzLmFwcGVuZChuZXcgRy5DbG9zZVBhdGgoKSkgOiB0aGlzO1xuXHR9O1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzIHRoYXQgcm91Z2hseSBtYXAgdG8gRmxhc2ggZ3JhcGhpY3MgQVBJczpcblx0LyoqXG5cdCAqIENsZWFycyBhbGwgZHJhd2luZyBpbnN0cnVjdGlvbnMsIGVmZmVjdGl2ZWx5IHJlc2V0dGluZyB0aGlzIEdyYXBoaWNzIGluc3RhbmNlLiBBbnkgbGluZSBhbmQgZmlsbCBzdHlsZXMgd2lsbCBuZWVkXG5cdCAqIHRvIGJlIHJlZGVmaW5lZCB0byBkcmF3IHNoYXBlcyBmb2xsb3dpbmcgYSBjbGVhciBjYWxsLiBBIHRpbnkgQVBJIG1ldGhvZCBcImNcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBjbGVhclxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9pbnN0cnVjdGlvbnMubGVuZ3RoID0gdGhpcy5fYWN0aXZlSW5zdHJ1Y3Rpb25zLmxlbmd0aCA9IHRoaXMuX2NvbW1pdEluZGV4ID0gMDtcblx0XHR0aGlzLl9zdHJva2VTdHlsZSA9IHRoaXMuX29sZFN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlID0gdGhpcy5fZmlsbCA9IHRoaXMuX3N0cm9rZURhc2ggPSB0aGlzLl9vbGRTdHJva2VEYXNoID0gbnVsbDtcblx0XHR0aGlzLl9kaXJ0eSA9IHRoaXMuX3N0cm9rZUlnbm9yZVNjYWxlID0gZmFsc2U7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2lucyBhIGZpbGwgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbG9yLiBUaGlzIGVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGguIEEgdGlueSBBUEkgbWV0aG9kIFwiZlwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlZ2luRmlsbFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQSBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZSAoZXguIFwicmVkXCIsIFwiI0ZGMDAwMFwiLCBvciBcInJnYmEoMjU1LDAsMCwwLjUpXCIpLiBTZXR0aW5nIHRvXG5cdCAqIG51bGwgd2lsbCByZXN1bHQgaW4gbm8gZmlsbC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmJlZ2luRmlsbCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldEZpbGwoY29sb3IgPyBuZXcgRy5GaWxsKGNvbG9yKSA6IG51bGwpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBCZWdpbnMgYSBsaW5lYXIgZ3JhZGllbnQgZmlsbCBkZWZpbmVkIGJ5IHRoZSBsaW5lICh4MCwgeTApIHRvICh4MSwgeTEpLiBUaGlzIGVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGguIEZvclxuXHQgKiBleGFtcGxlLCB0aGUgZm9sbG93aW5nIGNvZGUgZGVmaW5lcyBhIGJsYWNrIHRvIHdoaXRlIHZlcnRpY2FsIGdyYWRpZW50IHJhbmdpbmcgZnJvbSAyMHB4IHRvIDEyMHB4LCBhbmQgZHJhd3MgYVxuXHQgKiBzcXVhcmUgdG8gZGlzcGxheSBpdDpcblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLmJlZ2luTGluZWFyR3JhZGllbnRGaWxsKFtcIiMwMDBcIixcIiNGRkZcIl0sIFswLCAxXSwgMCwgMjAsIDAsIDEyMCkuZHJhd1JlY3QoMjAsIDIwLCAxMjAsIDEyMCk7XG5cdCAqXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwibGZcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBiZWdpbkxpbmVhckdyYWRpZW50RmlsbFxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnMgQW4gYXJyYXkgb2YgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWVzLiBGb3IgZXhhbXBsZSwgW1wiI0YwMFwiLFwiIzAwRlwiXSB3b3VsZCBkZWZpbmUgYSBncmFkaWVudFxuXHQgKiBkcmF3aW5nIGZyb20gcmVkIHRvIGJsdWUuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvcyBBbiBhcnJheSBvZiBncmFkaWVudCBwb3NpdGlvbnMgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgY29sb3JzLiBGb3IgZXhhbXBsZSwgWzAuMSwgMC45XSB3b3VsZCBkcmF3XG5cdCAqIHRoZSBmaXJzdCBjb2xvciB0byAxMCUgdGhlbiBpbnRlcnBvbGF0aW5nIHRvIHRoZSBzZWNvbmQgY29sb3IgYXQgOTAlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDAgVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwIFRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MSBUaGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYmVnaW5MaW5lYXJHcmFkaWVudEZpbGwgPSBmdW5jdGlvbihjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCB4MSwgeTEpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0RmlsbChuZXcgRy5GaWxsKCkubGluZWFyR3JhZGllbnQoY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgeDEsIHkxKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2lucyBhIHJhZGlhbCBncmFkaWVudCBmaWxsLiBUaGlzIGVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGguIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nIGNvZGUgZGVmaW5lcyBhIHJlZCB0b1xuXHQgKiBibHVlIHJhZGlhbCBncmFkaWVudCBjZW50ZXJlZCBhdCAoMTAwLCAxMDApLCB3aXRoIGEgcmFkaXVzIG9mIDUwLCBhbmQgZHJhd3MgYSBjaXJjbGUgdG8gZGlzcGxheSBpdDpcblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLmJlZ2luUmFkaWFsR3JhZGllbnRGaWxsKFtcIiNGMDBcIixcIiMwMEZcIl0sIFswLCAxXSwgMTAwLCAxMDAsIDAsIDEwMCwgMTAwLCA1MCkuZHJhd0NpcmNsZSgxMDAsIDEwMCwgNTApO1xuXHQgKlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcInJmXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYmVnaW5SYWRpYWxHcmFkaWVudEZpbGxcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzIEFuIGFycmF5IG9mIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlcy4gRm9yIGV4YW1wbGUsIFtcIiNGMDBcIixcIiMwMEZcIl0gd291bGQgZGVmaW5lXG5cdCAqIGEgZ3JhZGllbnQgZHJhd2luZyBmcm9tIHJlZCB0byBibHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3MgQW4gYXJyYXkgb2YgZ3JhZGllbnQgcG9zaXRpb25zIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIGNvbG9ycy4gRm9yIGV4YW1wbGUsIFswLjEsXG5cdCAqIDAuOV0gd291bGQgZHJhdyB0aGUgZmlyc3QgY29sb3IgdG8gMTAlIHRoZW4gaW50ZXJwb2xhdGluZyB0byB0aGUgc2Vjb25kIGNvbG9yIGF0IDkwJS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MCBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjAgUmFkaXVzIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MSBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjEgUmFkaXVzIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmJlZ2luUmFkaWFsR3JhZGllbnRGaWxsID0gZnVuY3Rpb24oY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgcjAsIHgxLCB5MSwgcjEpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0RmlsbChuZXcgRy5GaWxsKCkucmFkaWFsR3JhZGllbnQoY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgcjAsIHgxLCB5MSwgcjEpKTtcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW5zIGEgcGF0dGVybiBmaWxsIHVzaW5nIHRoZSBzcGVjaWZpZWQgaW1hZ2UuIFRoaXMgZW5kcyB0aGUgY3VycmVudCBzdWItcGF0aC4gQSB0aW55IEFQSSBtZXRob2QgXCJiZlwiIGFsc29cblx0ICogZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlZ2luQml0bWFwRmlsbFxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnR9IGltYWdlIFRoZSBJbWFnZSwgQ2FudmFzLCBvciBWaWRlbyBvYmplY3QgdG8gdXNlXG5cdCAqIGFzIHRoZSBwYXR0ZXJuLiBNdXN0IGJlIGxvYWRlZCBwcmlvciB0byBjcmVhdGluZyBhIGJpdG1hcCBmaWxsLCBvciB0aGUgZmlsbCB3aWxsIGJlIGVtcHR5LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcmVwZXRpdGlvbiBPcHRpb25hbC4gSW5kaWNhdGVzIHdoZXRoZXIgdG8gcmVwZWF0IHRoZSBpbWFnZSBpbiB0aGUgZmlsbCBhcmVhLiBPbmUgb2YgXCJyZXBlYXRcIixcblx0ICogXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuIERlZmF1bHRzIHRvIFwicmVwZWF0XCIuIE5vdGUgdGhhdCBGaXJlZm94IGRvZXMgbm90IHN1cHBvcnQgXCJyZXBlYXQteFwiIG9yXG5cdCAqIFwicmVwZWF0LXlcIiAobGF0ZXN0IHRlc3RzIHdlcmUgaW4gRkYgMjAuMCksIGFuZCB3aWxsIGRlZmF1bHQgdG8gXCJyZXBlYXRcIi5cblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4IE9wdGlvbmFsLiBTcGVjaWZpZXMgYSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggZm9yIHRoZSBiaXRtYXAgZmlsbC4gVGhpcyB0cmFuc2Zvcm1hdGlvblxuXHQgKiB3aWxsIGJlIGFwcGxpZWQgcmVsYXRpdmUgdG8gdGhlIHBhcmVudCB0cmFuc2Zvcm0uXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5iZWdpbkJpdG1hcEZpbGwgPSBmdW5jdGlvbihpbWFnZSwgcmVwZXRpdGlvbiwgbWF0cml4KSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldEZpbGwobmV3IEcuRmlsbChudWxsLG1hdHJpeCkuYml0bWFwKGltYWdlLCByZXBldGl0aW9uKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGgsIGFuZCBiZWdpbnMgYSBuZXcgb25lIHdpdGggbm8gZmlsbC4gRnVuY3Rpb25hbGx5IGlkZW50aWNhbCB0byA8Y29kZT5iZWdpbkZpbGwobnVsbCk8L2NvZGU+LlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImVmXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgZW5kRmlsbFxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuZW5kRmlsbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmJlZ2luRmlsbCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBzdHJva2Ugc3R5bGUuIExpa2UgYWxsIGRyYXdpbmcgbWV0aG9kcywgdGhpcyBjYW4gYmUgY2hhaW5lZCwgc28geW91IGNhbiBkZWZpbmVcblx0ICogdGhlIHN0cm9rZSBzdHlsZSBhbmQgY29sb3IgaW4gYSBzaW5nbGUgbGluZSBvZiBjb2RlIGxpa2Ugc286XG5cdCAqXG5cdCAqIFx0bXlHcmFwaGljcy5zZXRTdHJva2VTdHlsZSg4LFwicm91bmRcIikuYmVnaW5TdHJva2UoXCIjRjAwXCIpO1xuXHQgKlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcInNzXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2Qgc2V0U3Ryb2tlU3R5bGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRoaWNrbmVzcyBUaGUgd2lkdGggb2YgdGhlIHN0cm9rZS5cblx0ICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IFtjYXBzPTBdIEluZGljYXRlcyB0aGUgdHlwZSBvZiBjYXBzIHRvIHVzZSBhdCB0aGUgZW5kIG9mIGxpbmVzLiBPbmUgb2YgYnV0dCxcblx0ICogcm91bmQsIG9yIHNxdWFyZS4gRGVmYXVsdHMgdG8gXCJidXR0XCIuIEFsc28gYWNjZXB0cyB0aGUgdmFsdWVzIDAgKGJ1dHQpLCAxIChyb3VuZCksIGFuZCAyIChzcXVhcmUpIGZvciB1c2Ugd2l0aFxuXHQgKiB0aGUgdGlueSBBUEkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBbam9pbnRzPTBdIFNwZWNpZmllcyB0aGUgdHlwZSBvZiBqb2ludHMgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVyZSB0d28gbGluZXMgbWVldC5cblx0ICogT25lIG9mIGJldmVsLCByb3VuZCwgb3IgbWl0ZXIuIERlZmF1bHRzIHRvIFwibWl0ZXJcIi4gQWxzbyBhY2NlcHRzIHRoZSB2YWx1ZXMgMCAobWl0ZXIpLCAxIChyb3VuZCksIGFuZCAyIChiZXZlbClcblx0ICogZm9yIHVzZSB3aXRoIHRoZSB0aW55IEFQSS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFttaXRlckxpbWl0PTEwXSBJZiBqb2ludHMgaXMgc2V0IHRvIFwibWl0ZXJcIiwgdGhlbiB5b3UgY2FuIHNwZWNpZnkgYSBtaXRlciBsaW1pdCByYXRpbyB3aGljaFxuXHQgKiBjb250cm9scyBhdCB3aGF0IHBvaW50IGEgbWl0ZXJlZCBqb2ludCB3aWxsIGJlIGNsaXBwZWQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZVNjYWxlPWZhbHNlXSBJZiB0cnVlLCB0aGUgc3Ryb2tlIHdpbGwgYmUgZHJhd24gYXQgdGhlIHNwZWNpZmllZCB0aGlja25lc3MgcmVnYXJkbGVzc1xuXHQgKiBvZiBhY3RpdmUgdHJhbnNmb3JtYXRpb25zLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuc2V0U3Ryb2tlU3R5bGUgPSBmdW5jdGlvbih0aGlja25lc3MsIGNhcHMsIGpvaW50cywgbWl0ZXJMaW1pdCwgaWdub3JlU2NhbGUpIHtcblx0XHR0aGlzLl91cGRhdGVJbnN0cnVjdGlvbnModHJ1ZSk7XG5cdFx0dGhpcy5fc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbW1hbmQgPSBuZXcgRy5TdHJva2VTdHlsZSh0aGlja25lc3MsIGNhcHMsIGpvaW50cywgbWl0ZXJMaW1pdCwgaWdub3JlU2NhbGUpO1xuXG5cdFx0Ly8gaWdub3JlU2NhbGUgbGl2ZXMgb24gU3Ryb2tlLCBub3QgU3Ryb2tlU3R5bGUsIHNvIHdlIGRvIGEgbGl0dGxlIHRyaWNrZXJ5OlxuXHRcdGlmICh0aGlzLl9zdHJva2UpIHsgdGhpcy5fc3Ryb2tlLmlnbm9yZVNjYWxlID0gaWdub3JlU2NhbGU7IH1cblx0XHR0aGlzLl9zdHJva2VJZ25vcmVTY2FsZSA9IGlnbm9yZVNjYWxlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFNldHMgb3IgY2xlYXJzIHRoZSBzdHJva2UgZGFzaCBwYXR0ZXJuLlxuXHQgKlxuXHQgKiBcdG15R3JhcGhpY3Muc2V0U3Ryb2tlRGFzaChbMjAsIDEwXSwgMCk7XG5cdCAqXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIGBzZGAgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2Qgc2V0U3Ryb2tlRGFzaFxuXHQgKiBAcGFyYW0ge0FycmF5fSBbc2VnbWVudHNdIEFuIGFycmF5IHNwZWNpZnlpbmcgdGhlIGRhc2ggcGF0dGVybiwgYWx0ZXJuYXRpbmcgYmV0d2VlbiBsaW5lIGFuZCBnYXAuXG5cdCAqIEZvciBleGFtcGxlLCBgWzIwLDEwXWAgd291bGQgY3JlYXRlIGEgcGF0dGVybiBvZiAyMCBwaXhlbCBsaW5lcyB3aXRoIDEwIHBpeGVsIGdhcHMgYmV0d2VlbiB0aGVtLlxuXHQgKiBQYXNzaW5nIG51bGwgb3IgYW4gZW1wdHkgYXJyYXkgd2lsbCBjbGVhciB0aGUgZXhpc3Rpbmcgc3Ryb2tlIGRhc2guXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0PTBdIFRoZSBvZmZzZXQgb2YgdGhlIGRhc2ggcGF0dGVybi4gRm9yIGV4YW1wbGUsIHlvdSBjb3VsZCBpbmNyZW1lbnQgdGhpcyB2YWx1ZSB0byBjcmVhdGUgYSBcIm1hcmNoaW5nIGFudHNcIiBlZmZlY3QuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5zZXRTdHJva2VEYXNoID0gZnVuY3Rpb24oc2VnbWVudHMsIG9mZnNldCkge1xuXHRcdHRoaXMuX3VwZGF0ZUluc3RydWN0aW9ucyh0cnVlKTtcblx0XHR0aGlzLl9zdHJva2VEYXNoID0gdGhpcy5jb21tYW5kID0gbmV3IEcuU3Ryb2tlRGFzaChzZWdtZW50cywgb2Zmc2V0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW5zIGEgc3Ryb2tlIHdpdGggdGhlIHNwZWNpZmllZCBjb2xvci4gVGhpcyBlbmRzIHRoZSBjdXJyZW50IHN1Yi1wYXRoLiBBIHRpbnkgQVBJIG1ldGhvZCBcInNcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBiZWdpblN0cm9rZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQSBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZSAoZXguIFwiI0ZGMDAwMFwiLCBcInJlZFwiLCBvciBcInJnYmEoMjU1LDAsMCwwLjUpXCIpLiBTZXR0aW5nIHRvXG5cdCAqIG51bGwgd2lsbCByZXN1bHQgaW4gbm8gc3Ryb2tlLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYmVnaW5TdHJva2UgPSBmdW5jdGlvbihjb2xvcikge1xuXHRcdHJldHVybiB0aGlzLl9zZXRTdHJva2UoY29sb3IgPyBuZXcgRy5TdHJva2UoY29sb3IpIDogbnVsbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2lucyBhIGxpbmVhciBncmFkaWVudCBzdHJva2UgZGVmaW5lZCBieSB0aGUgbGluZSAoeDAsIHkwKSB0byAoeDEsIHkxKS4gVGhpcyBlbmRzIHRoZSBjdXJyZW50IHN1Yi1wYXRoLiBGb3Jcblx0ICogZXhhbXBsZSwgdGhlIGZvbGxvd2luZyBjb2RlIGRlZmluZXMgYSBibGFjayB0byB3aGl0ZSB2ZXJ0aWNhbCBncmFkaWVudCByYW5naW5nIGZyb20gMjBweCB0byAxMjBweCwgYW5kIGRyYXdzIGFcblx0ICogc3F1YXJlIHRvIGRpc3BsYXkgaXQ6XG5cdCAqXG5cdCAqICAgICAgbXlHcmFwaGljcy5zZXRTdHJva2VTdHlsZSgxMCkuXG5cdCAqICAgICAgICAgIGJlZ2luTGluZWFyR3JhZGllbnRTdHJva2UoW1wiIzAwMFwiLFwiI0ZGRlwiXSwgWzAsIDFdLCAwLCAyMCwgMCwgMTIwKS5kcmF3UmVjdCgyMCwgMjAsIDEyMCwgMTIwKTtcblx0ICpcblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJsc1wiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlZ2luTGluZWFyR3JhZGllbnRTdHJva2Vcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzIEFuIGFycmF5IG9mIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlcy4gRm9yIGV4YW1wbGUsIFtcIiNGMDBcIixcIiMwMEZcIl0gd291bGQgZGVmaW5lXG5cdCAqIGEgZ3JhZGllbnQgZHJhd2luZyBmcm9tIHJlZCB0byBibHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3MgQW4gYXJyYXkgb2YgZ3JhZGllbnQgcG9zaXRpb25zIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIGNvbG9ycy4gRm9yIGV4YW1wbGUsIFswLjEsXG5cdCAqIDAuOV0gd291bGQgZHJhdyB0aGUgZmlyc3QgY29sb3IgdG8gMTAlIHRoZW4gaW50ZXJwb2xhdGluZyB0byB0aGUgc2Vjb25kIGNvbG9yIGF0IDkwJS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwIFRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MCBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDEgVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MSBUaGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmJlZ2luTGluZWFyR3JhZGllbnRTdHJva2UgPSBmdW5jdGlvbihjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCB4MSwgeTEpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0U3Ryb2tlKG5ldyBHLlN0cm9rZSgpLmxpbmVhckdyYWRpZW50KGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHgxLCB5MSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBCZWdpbnMgYSByYWRpYWwgZ3JhZGllbnQgc3Ryb2tlLiBUaGlzIGVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGguIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nIGNvZGUgZGVmaW5lcyBhIHJlZCB0b1xuXHQgKiBibHVlIHJhZGlhbCBncmFkaWVudCBjZW50ZXJlZCBhdCAoMTAwLCAxMDApLCB3aXRoIGEgcmFkaXVzIG9mIDUwLCBhbmQgZHJhd3MgYSByZWN0YW5nbGUgdG8gZGlzcGxheSBpdDpcblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLnNldFN0cm9rZVN0eWxlKDEwKVxuXHQgKiAgICAgICAgICAuYmVnaW5SYWRpYWxHcmFkaWVudFN0cm9rZShbXCIjRjAwXCIsXCIjMDBGXCJdLCBbMCwgMV0sIDEwMCwgMTAwLCAwLCAxMDAsIDEwMCwgNTApXG5cdCAqICAgICAgICAgIC5kcmF3UmVjdCg1MCwgOTAsIDE1MCwgMTEwKTtcblx0ICpcblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJyc1wiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlZ2luUmFkaWFsR3JhZGllbnRTdHJva2Vcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzIEFuIGFycmF5IG9mIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlcy4gRm9yIGV4YW1wbGUsIFtcIiNGMDBcIixcIiMwMEZcIl0gd291bGQgZGVmaW5lXG5cdCAqIGEgZ3JhZGllbnQgZHJhd2luZyBmcm9tIHJlZCB0byBibHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3MgQW4gYXJyYXkgb2YgZ3JhZGllbnQgcG9zaXRpb25zIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIGNvbG9ycy4gRm9yIGV4YW1wbGUsIFswLjEsXG5cdCAqIDAuOV0gd291bGQgZHJhdyB0aGUgZmlyc3QgY29sb3IgdG8gMTAlIHRoZW4gaW50ZXJwb2xhdGluZyB0byB0aGUgc2Vjb25kIGNvbG9yIGF0IDkwJSwgdGhlbiBkcmF3IHRoZSBzZWNvbmQgY29sb3Jcblx0ICogdG8gMTAwJS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MCBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjAgUmFkaXVzIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MSBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjEgUmFkaXVzIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmJlZ2luUmFkaWFsR3JhZGllbnRTdHJva2UgPSBmdW5jdGlvbihjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCByMCwgeDEsIHkxLCByMSkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRTdHJva2UobmV3IEcuU3Ryb2tlKCkucmFkaWFsR3JhZGllbnQoY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgcjAsIHgxLCB5MSwgcjEpKTtcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW5zIGEgcGF0dGVybiBmaWxsIHVzaW5nIHRoZSBzcGVjaWZpZWQgaW1hZ2UuIFRoaXMgZW5kcyB0aGUgY3VycmVudCBzdWItcGF0aC4gTm90ZSB0aGF0IHVubGlrZSBiaXRtYXAgZmlsbHMsXG5cdCAqIHN0cm9rZXMgZG8gbm90IGN1cnJlbnRseSBzdXBwb3J0IGEgbWF0cml4IHBhcmFtZXRlciBkdWUgdG8gbGltaXRhdGlvbnMgaW4gdGhlIGNhbnZhcyBBUEkuIEEgdGlueSBBUEkgbWV0aG9kIFwiYnNcIlxuXHQgKiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBiZWdpbkJpdG1hcFN0cm9rZVxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnR9IGltYWdlIFRoZSBJbWFnZSwgQ2FudmFzLCBvciBWaWRlbyBvYmplY3QgdG8gdXNlXG5cdCAqIGFzIHRoZSBwYXR0ZXJuLiBNdXN0IGJlIGxvYWRlZCBwcmlvciB0byBjcmVhdGluZyBhIGJpdG1hcCBmaWxsLCBvciB0aGUgZmlsbCB3aWxsIGJlIGVtcHR5LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3JlcGV0aXRpb249cmVwZWF0XSBPcHRpb25hbC4gSW5kaWNhdGVzIHdoZXRoZXIgdG8gcmVwZWF0IHRoZSBpbWFnZSBpbiB0aGUgZmlsbCBhcmVhLiBPbmUgb2Zcblx0ICogXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuIERlZmF1bHRzIHRvIFwicmVwZWF0XCIuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5iZWdpbkJpdG1hcFN0cm9rZSA9IGZ1bmN0aW9uKGltYWdlLCByZXBldGl0aW9uKSB7XG5cdFx0Ly8gTk9URTogbWF0cml4IGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHN0cm9rZSBiZWNhdXNlIHRyYW5zZm9ybXMgb24gc3Ryb2tlcyBhbHNvIGFmZmVjdCB0aGUgZHJhd24gc3Ryb2tlIHdpZHRoLlxuXHRcdHJldHVybiB0aGlzLl9zZXRTdHJva2UobmV3IEcuU3Ryb2tlKCkuYml0bWFwKGltYWdlLCByZXBldGl0aW9uKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGgsIGFuZCBiZWdpbnMgYSBuZXcgb25lIHdpdGggbm8gc3Ryb2tlLiBGdW5jdGlvbmFsbHkgaWRlbnRpY2FsIHRvIDxjb2RlPmJlZ2luU3Ryb2tlKG51bGwpPC9jb2RlPi5cblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJlc1wiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGVuZFN0cm9rZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuZW5kU3Ryb2tlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYmVnaW5TdHJva2UoKTtcblx0fTtcblxuXHQvKipcblx0ICogTWFwcyB0aGUgZmFtaWxpYXIgQWN0aW9uU2NyaXB0IDxjb2RlPmN1cnZlVG8oKTwvY29kZT4gbWV0aG9kIHRvIHRoZSBmdW5jdGlvbmFsbHkgc2ltaWxhciB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9xdWFkcmF0aWNDdXJ2ZVRvXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZC5cblx0ICogQG1ldGhvZCBxdWFkcmF0aWNDdXJ2ZVRvXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNweVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuY3VydmVUbyA9IHAucXVhZHJhdGljQ3VydmVUbztcblxuXHQvKipcblx0ICpcblx0ICogTWFwcyB0aGUgZmFtaWxpYXIgQWN0aW9uU2NyaXB0IDxjb2RlPmRyYXdSZWN0KCk8L2NvZGU+IG1ldGhvZCB0byB0aGUgZnVuY3Rpb25hbGx5IHNpbWlsYXIge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvcmVjdFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuXG5cdCAqIEBtZXRob2QgZHJhd1JlY3Rcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHcgV2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaCBIZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuZHJhd1JlY3QgPSBwLnJlY3Q7XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgcm91bmRlZCByZWN0YW5nbGUgd2l0aCBhbGwgY29ybmVycyB3aXRoIHRoZSBzcGVjaWZpZWQgcmFkaXVzLlxuXHQgKiBAbWV0aG9kIGRyYXdSb3VuZFJlY3Rcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyBDb3JuZXIgcmFkaXVzLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuZHJhd1JvdW5kUmVjdCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgsIHJhZGl1cykge1xuXHRcdHJldHVybiB0aGlzLmRyYXdSb3VuZFJlY3RDb21wbGV4KHgsIHksIHcsIGgsIHJhZGl1cywgcmFkaXVzLCByYWRpdXMsIHJhZGl1cyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgcm91bmRlZCByZWN0YW5nbGUgd2l0aCBkaWZmZXJlbnQgY29ybmVyIHJhZGlpLiBTdXBwb3J0cyBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgY29ybmVyIHJhZGlpLiBBIHRpbnkgQVBJXG5cdCAqIG1ldGhvZCBcInJjXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgZHJhd1JvdW5kUmVjdENvbXBsZXhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZSB0byBkcmF3IHRoZSByb3VuZCByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgdmVydGljYWwgY29vcmRpbmF0ZSB0byBkcmF3IHRoZSByb3VuZCByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdyBUaGUgd2lkdGggb2YgdGhlIHJvdW5kIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoIFRoZSBoZWlnaHQgb2YgdGhlIHJvdW5kIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNUTCBUb3AgbGVmdCBjb3JuZXIgcmFkaXVzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzVFIgVG9wIHJpZ2h0IGNvcm5lciByYWRpdXMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNCUiBCb3R0b20gcmlnaHQgY29ybmVyIHJhZGl1cy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c0JMIEJvdHRvbSBsZWZ0IGNvcm5lciByYWRpdXMuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5kcmF3Um91bmRSZWN0Q29tcGxleCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgsIHJhZGl1c1RMLCByYWRpdXNUUiwgcmFkaXVzQlIsIHJhZGl1c0JMKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLlJvdW5kUmVjdCh4LCB5LCB3LCBoLCByYWRpdXNUTCwgcmFkaXVzVFIsIHJhZGl1c0JSLCByYWRpdXNCTCkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIGNpcmNsZSB3aXRoIHRoZSBzcGVjaWZpZWQgcmFkaXVzIGF0ICh4LCB5KS5cblx0ICpcblx0ICogICAgICB2YXIgZyA9IG5ldyBjcmVhdGVqcy5HcmFwaGljcygpO1xuXHQgKlx0ICAgIGcuc2V0U3Ryb2tlU3R5bGUoMSk7XG5cdCAqXHQgICAgZy5iZWdpblN0cm9rZShjcmVhdGVqcy5HcmFwaGljcy5nZXRSR0IoMCwwLDApKTtcblx0ICpcdCAgICBnLmJlZ2luRmlsbChjcmVhdGVqcy5HcmFwaGljcy5nZXRSR0IoMjU1LDAsMCkpO1xuXHQgKlx0ICAgIGcuZHJhd0NpcmNsZSgwLDAsMyk7XG5cdCAqXG5cdCAqXHQgICAgdmFyIHMgPSBuZXcgY3JlYXRlanMuU2hhcGUoZyk7XG5cdCAqXHRcdHMueCA9IDEwMDtcblx0ICpcdFx0cy55ID0gMTAwO1xuXHQgKlxuXHQgKlx0ICAgIHN0YWdlLmFkZENoaWxkKHMpO1xuXHQgKlx0ICAgIHN0YWdlLnVwZGF0ZSgpO1xuXHQgKlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImRjXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgZHJhd0NpcmNsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0geCB4IGNvb3JkaW5hdGUgY2VudGVyIHBvaW50IG9mIGNpcmNsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgeSBjb29yZGluYXRlIGNlbnRlciBwb2ludCBvZiBjaXJjbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXMgUmFkaXVzIG9mIGNpcmNsZS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmRyYXdDaXJjbGUgPSBmdW5jdGlvbih4LCB5LCByYWRpdXMpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IEcuQ2lyY2xlKHgsIHksIHJhZGl1cykpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBhbiBlbGxpcHNlIChvdmFsKSB3aXRoIGEgc3BlY2lmaWVkIHdpZHRoICh3KSBhbmQgaGVpZ2h0IChoKS4gU2ltaWxhciB0byB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Q2lyY2xlXCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBleGNlcHQgdGhlIHdpZHRoIGFuZCBoZWlnaHQgY2FuIGJlIGRpZmZlcmVudC4gQSB0aW55IEFQSSBtZXRob2QgXCJkZVwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGRyYXdFbGxpcHNlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBsZWZ0IGNvb3JkaW5hdGUgcG9pbnQgb2YgdGhlIGVsbGlwc2UuIE5vdGUgdGhhdCB0aGlzIGlzIGRpZmZlcmVudCBmcm9tIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdDaXJjbGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2hpY2ggZHJhd3MgZnJvbSBjZW50ZXIuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB0b3AgY29vcmRpbmF0ZSBwb2ludCBvZiB0aGUgZWxsaXBzZS4gTm90ZSB0aGF0IHRoaXMgaXMgZGlmZmVyZW50IGZyb20ge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd0NpcmNsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aGljaCBkcmF3cyBmcm9tIHRoZSBjZW50ZXIuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3IFRoZSBoZWlnaHQgKGhvcml6b250YWwgZGlhbWV0ZXIpIG9mIHRoZSBlbGxpcHNlLiBUaGUgaG9yaXpvbnRhbCByYWRpdXMgd2lsbCBiZSBoYWxmIG9mIHRoaXNcblx0ICogbnVtYmVyLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaCBUaGUgd2lkdGggKHZlcnRpY2FsIGRpYW1ldGVyKSBvZiB0aGUgZWxsaXBzZS4gVGhlIHZlcnRpY2FsIHJhZGl1cyB3aWxsIGJlIGhhbGYgb2YgdGhpcyBudW1iZXIuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5kcmF3RWxsaXBzZSA9IGZ1bmN0aW9uKHgsIHksIHcsIGgpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IEcuRWxsaXBzZSh4LCB5LCB3LCBoKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgc3RhciBpZiBwb2ludFNpemUgaXMgZ3JlYXRlciB0aGFuIDAsIG9yIGEgcmVndWxhciBwb2x5Z29uIGlmIHBvaW50U2l6ZSBpcyAwIHdpdGggdGhlIHNwZWNpZmllZCBudW1iZXIgb2Zcblx0ICogcG9pbnRzLiBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyBjb2RlIHdpbGwgZHJhdyBhIGZhbWlsaWFyIDUgcG9pbnRlZCBzdGFyIHNoYXBlIGNlbnRlcmVkIGF0IDEwMCwgMTAwIGFuZCB3aXRoIGFcblx0ICogcmFkaXVzIG9mIDUwOlxuXHQgKlxuXHQgKiAgICAgIG15R3JhcGhpY3MuYmVnaW5GaWxsKFwiI0ZGMFwiKS5kcmF3UG9seVN0YXIoMTAwLCAxMDAsIDUwLCA1LCAwLjYsIC05MCk7XG5cdCAqICAgICAgLy8gTm90ZTogLTkwIG1ha2VzIHRoZSBmaXJzdCBwb2ludCB2ZXJ0aWNhbFxuXHQgKlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImRwXCIgYWxzbyBleGlzdHMuXG5cdCAqXG5cdCAqIEBtZXRob2QgZHJhd1BvbHlTdGFyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHNoYXBlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBQb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9mIHRoZSBzaGFwZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBzaGFwZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNpZGVzIFRoZSBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBzdGFyIG9yIHNpZGVzIG9uIHRoZSBwb2x5Z29uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9pbnRTaXplIFRoZSBkZXB0aCBvciBcInBvaW50eS1uZXNzXCIgb2YgdGhlIHN0YXIgcG9pbnRzLiBBIHBvaW50U2l6ZSBvZiAwIHdpbGwgZHJhdyBhIHJlZ3VsYXJcblx0ICogcG9seWdvbiAobm8gcG9pbnRzKSwgYSBwb2ludFNpemUgb2YgMSB3aWxsIGRyYXcgbm90aGluZyBiZWNhdXNlIHRoZSBwb2ludHMgYXJlIGluZmluaXRlbHkgcG9pbnR5LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgVGhlIGFuZ2xlIG9mIHRoZSBmaXJzdCBwb2ludCAvIGNvcm5lci4gRm9yIGV4YW1wbGUgYSB2YWx1ZSBvZiAwIHdpbGwgZHJhdyB0aGUgZmlyc3QgcG9pbnRcblx0ICogZGlyZWN0bHkgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjZW50ZXIuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5kcmF3UG9seVN0YXIgPSBmdW5jdGlvbih4LCB5LCByYWRpdXMsIHNpZGVzLCBwb2ludFNpemUsIGFuZ2xlKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLlBvbHlTdGFyKHgsIHksIHJhZGl1cywgc2lkZXMsIHBvaW50U2l6ZSwgYW5nbGUpKTtcblx0fTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkLlxuXHQvKipcblx0ICogUmVtb3ZlZCBpbiBmYXZvdXIgb2YgdXNpbmcgY3VzdG9tIGNvbW1hbmQgb2JqZWN0cyB3aXRoIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBpbmplY3Rcblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXG5cdC8qKlxuXHQgKiBBcHBlbmRzIGEgZ3JhcGhpY3MgY29tbWFuZCBvYmplY3QgdG8gdGhlIGdyYXBoaWNzIHF1ZXVlLiBDb21tYW5kIG9iamVjdHMgZXhwb3NlIGFuIFwiZXhlY1wiIG1ldGhvZFxuXHQgKiB0aGF0IGFjY2VwdHMgdHdvIHBhcmFtZXRlcnM6IHRoZSBDb250ZXh0MkQgdG8gb3BlcmF0ZSBvbiwgYW5kIGFuIGFyYml0cmFyeSBkYXRhIG9iamVjdCBwYXNzZWQgaW50b1xuXHQgKiB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3XCJ9fXt7L2Nyb3NzTGlua319LiBUaGUgbGF0dGVyIHdpbGwgdXN1YWxseSBiZSB0aGUgU2hhcGUgaW5zdGFuY2UgdGhhdCBjYWxsZWQgZHJhdy5cblx0ICpcblx0ICogVGhpcyBtZXRob2QgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IEdyYXBoaWNzIG1ldGhvZHMsIHN1Y2ggYXMgZHJhd0NpcmNsZSwgYnV0IGNhbiBhbHNvIGJlIHVzZWQgZGlyZWN0bHkgdG8gaW5zZXJ0XG5cdCAqIGJ1aWx0LWluIG9yIGN1c3RvbSBncmFwaGljcyBjb21tYW5kcy4gRm9yIGV4YW1wbGU6XG5cdCAqXG5cdCAqIFx0XHQvLyBhdHRhY2ggZGF0YSB0byBvdXIgc2hhcGUsIHNvIHdlIGNhbiBhY2Nlc3MgaXQgZHVyaW5nIHRoZSBkcmF3OlxuXHQgKiBcdFx0bXlTaGFwZS5jb2xvciA9IFwicmVkXCI7XG5cdCAqXG5cdCAqIFx0XHQvLyBhcHBlbmQgYSBDaXJjbGUgY29tbWFuZCBvYmplY3Q6XG5cdCAqIFx0XHRteVNoYXBlLmdyYXBoaWNzLmFwcGVuZChuZXcgY3JlYXRlanMuR3JhcGhpY3MuQ2lyY2xlKDUwLCA1MCwgMzApKTtcblx0ICpcblx0ICogXHRcdC8vIGFwcGVuZCBhIGN1c3RvbSBjb21tYW5kIG9iamVjdCB3aXRoIGFuIGV4ZWMgbWV0aG9kIHRoYXQgc2V0cyB0aGUgZmlsbCBzdHlsZVxuXHQgKiBcdFx0Ly8gYmFzZWQgb24gdGhlIHNoYXBlJ3MgZGF0YSwgYW5kIHRoZW4gZmlsbHMgdGhlIGNpcmNsZS5cblx0ICogXHRcdG15U2hhcGUuZ3JhcGhpY3MuYXBwZW5kKHtleGVjOmZ1bmN0aW9uKGN0eCwgc2hhcGUpIHtcblx0ICogXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHNoYXBlLmNvbG9yO1xuXHQgKiBcdFx0XHRjdHguZmlsbCgpO1xuXHQgKiBcdFx0fX0pO1xuXHQgKlxuXHQgKiBAbWV0aG9kIGFwcGVuZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gY29tbWFuZCBBIGdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0IGV4cG9zaW5nIGFuIFwiZXhlY1wiIG1ldGhvZC5cblx0ICogQHBhcmFtIHtib29sZWFufSBjbGVhbiBUaGUgY2xlYW4gcGFyYW0gaXMgcHJpbWFyaWx5IGZvciBpbnRlcm5hbCB1c2UuIEEgdmFsdWUgb2YgdHJ1ZSBpbmRpY2F0ZXMgdGhhdCBhIGNvbW1hbmQgZG9lcyBub3QgZ2VuZXJhdGUgYSBwYXRoIHRoYXQgc2hvdWxkIGJlIHN0cm9rZWQgb3IgZmlsbGVkLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYXBwZW5kID0gZnVuY3Rpb24oY29tbWFuZCwgY2xlYW4pIHtcblx0XHR0aGlzLl9hY3RpdmVJbnN0cnVjdGlvbnMucHVzaChjb21tYW5kKTtcblx0XHR0aGlzLmNvbW1hbmQgPSBjb21tYW5kO1xuXHRcdGlmICghY2xlYW4pIHsgdGhpcy5fZGlydHkgPSB0cnVlOyB9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIERlY29kZXMgYSBjb21wYWN0IGVuY29kZWQgcGF0aCBzdHJpbmcgaW50byBhIHNlcmllcyBvZiBkcmF3IGluc3RydWN0aW9ucy5cblx0ICogVGhpcyBmb3JtYXQgaXMgbm90IGludGVuZGVkIHRvIGJlIGh1bWFuIHJlYWRhYmxlLCBhbmQgaXMgbWVhbnQgZm9yIHVzZSBieSBhdXRob3JpbmcgdG9vbHMuXG5cdCAqIFRoZSBmb3JtYXQgdXNlcyBhIGJhc2U2NCBjaGFyYWN0ZXIgc2V0LCB3aXRoIGVhY2ggY2hhcmFjdGVyIHJlcHJlc2VudGluZyA2IGJpdHMsIHRvIGRlZmluZSBhIHNlcmllcyBvZiBkcmF3XG5cdCAqIGNvbW1hbmRzLlxuXHQgKlxuXHQgKiBFYWNoIGNvbW1hbmQgaXMgY29tcHJpc2VkIG9mIGEgc2luZ2xlIFwiaGVhZGVyXCIgY2hhcmFjdGVyIGZvbGxvd2VkIGJ5IGEgdmFyaWFibGUgbnVtYmVyIG9mIGFsdGVybmF0aW5nIHggYW5kIHlcblx0ICogcG9zaXRpb24gdmFsdWVzLiBSZWFkaW5nIHRoZSBoZWFkZXIgYml0cyBmcm9tIGxlZnQgdG8gcmlnaHQgKG1vc3QgdG8gbGVhc3Qgc2lnbmlmaWNhbnQpOiBiaXRzIDEgdG8gMyBzcGVjaWZ5IHRoZVxuXHQgKiB0eXBlIG9mIG9wZXJhdGlvbiAoMC1tb3ZlVG8sIDEtbGluZVRvLCAyLXF1YWRyYXRpY0N1cnZlVG8sIDMtYmV6aWVyQ3VydmVUbywgNC1jbG9zZVBhdGgsIDUtNyB1bnVzZWQpLiBCaXQgNFxuXHQgKiBpbmRpY2F0ZXMgd2hldGhlciBwb3NpdGlvbiB2YWx1ZXMgdXNlIDEyIGJpdHMgKDIgY2hhcmFjdGVycykgb3IgMTggYml0cyAoMyBjaGFyYWN0ZXJzKSwgd2l0aCBhIG9uZSBpbmRpY2F0aW5nIHRoZVxuXHQgKiBsYXR0ZXIuIEJpdHMgNSBhbmQgNiBhcmUgY3VycmVudGx5IHVudXNlZC5cblx0ICpcblx0ICogRm9sbG93aW5nIHRoZSBoZWFkZXIgaXMgYSBzZXJpZXMgb2YgMCAoY2xvc2VQYXRoKSwgMiAobW92ZVRvLCBsaW5lVG8pLCA0IChxdWFkcmF0aWNDdXJ2ZVRvKSwgb3IgNiAoYmV6aWVyQ3VydmVUbylcblx0ICogcGFyYW1ldGVycy4gVGhlc2UgcGFyYW1ldGVycyBhcmUgYWx0ZXJuYXRpbmcgeC95IHBvc2l0aW9ucyByZXByZXNlbnRlZCBieSAyIG9yIDMgY2hhcmFjdGVycyAoYXMgaW5kaWNhdGVkIGJ5IHRoZVxuXHQgKiA0dGggYml0IGluIHRoZSBjb21tYW5kIGNoYXIpLiBUaGVzZSBjaGFyYWN0ZXJzIGNvbnNpc3Qgb2YgYSAxIGJpdCBzaWduICgxIGlzIG5lZ2F0aXZlLCAwIGlzIHBvc2l0aXZlKSwgZm9sbG93ZWRcblx0ICogYnkgYW4gMTEgKDIgY2hhcikgb3IgMTcgKDMgY2hhcikgYml0IGludGVnZXIgdmFsdWUuIEFsbCBwb3NpdGlvbiB2YWx1ZXMgYXJlIGluIHRlbnRocyBvZiBhIHBpeGVsLiBFeGNlcHQgaW4gdGhlXG5cdCAqIGNhc2Ugb2YgbW92ZSBvcGVyYXRpb25zIHdoaWNoIGFyZSBhYnNvbHV0ZSwgdGhpcyB2YWx1ZSBpcyBhIGRlbHRhIGZyb20gdGhlIHByZXZpb3VzIHggb3IgeSBwb3NpdGlvbiAoYXNcblx0ICogYXBwcm9wcmlhdGUpLlxuXHQgKlxuXHQgKiBGb3IgZXhhbXBsZSwgdGhlIHN0cmluZyBcIkEzY0FBTUF1NEFBQVwiIHJlcHJlc2VudHMgYSBsaW5lIHN0YXJ0aW5nIGF0IC0xNTAsMCBhbmQgZW5kaW5nIGF0IDE1MCwwLlxuXHQgKiA8YnIgLz5BIC0gYml0cyAwMDAwMDAuIEZpcnN0IDMgYml0cyAoMDAwKSBpbmRpY2F0ZSBhIG1vdmVUbyBvcGVyYXRpb24uIDR0aCBiaXQgKDApIGluZGljYXRlcyAyIGNoYXJzIHBlclxuXHQgKiBwYXJhbWV0ZXIuXG5cdCAqIDxiciAvPm4wIC0gMTEwMTExMDExMTAwLiBBYnNvbHV0ZSB4IHBvc2l0aW9uIG9mIC0xNTAuMHB4LiBGaXJzdCBiaXQgaW5kaWNhdGVzIGEgbmVnYXRpdmUgdmFsdWUsIHJlbWFpbmluZyBiaXRzXG5cdCAqIGluZGljYXRlIDE1MDAgdGVudGhzIG9mIGEgcGl4ZWwuXG5cdCAqIDxiciAvPkFBIC0gMDAwMDAwMDAwMDAwLiBBYnNvbHV0ZSB5IHBvc2l0aW9uIG9mIDAuXG5cdCAqIDxiciAvPkkgLSAwMDExMDAuIEZpcnN0IDMgYml0cyAoMDAxKSBpbmRpY2F0ZSBhIGxpbmVUbyBvcGVyYXRpb24uIDR0aCBiaXQgKDEpIGluZGljYXRlcyAzIGNoYXJzIHBlciBwYXJhbWV0ZXIuXG5cdCAqIDxiciAvPkF1NCAtIDAwMDAwMDEwMTExMDExMTAwMC4gQW4geCBkZWx0YSBvZiAzMDAuMHB4LCB3aGljaCBpcyBhZGRlZCB0byB0aGUgcHJldmlvdXMgeCB2YWx1ZSBvZiAtMTUwLjBweCB0b1xuXHQgKiBwcm92aWRlIGFuIGFic29sdXRlIHBvc2l0aW9uIG9mICsxNTAuMHB4LlxuXHQgKiA8YnIgLz5BQUEgLSAwMDAwMDAwMDAwMDAwMDAwMDAuIEEgeSBkZWx0YSB2YWx1ZSBvZiAwLlxuXHQgKlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcInBcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBkZWNvZGVQYXRoXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHBhdGggc3RyaW5nIHRvIGRlY29kZS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmRlY29kZVBhdGggPSBmdW5jdGlvbihzdHIpIHtcblx0XHR2YXIgaW5zdHJ1Y3Rpb25zID0gW3RoaXMubW92ZVRvLCB0aGlzLmxpbmVUbywgdGhpcy5xdWFkcmF0aWNDdXJ2ZVRvLCB0aGlzLmJlemllckN1cnZlVG8sIHRoaXMuY2xvc2VQYXRoXTtcblx0XHR2YXIgcGFyYW1Db3VudCA9IFsyLCAyLCA0LCA2LCAwXTtcblx0XHR2YXIgaT0wLCBsPXN0ci5sZW5ndGg7XG5cdFx0dmFyIHBhcmFtcyA9IFtdO1xuXHRcdHZhciB4PTAsIHk9MDtcblx0XHR2YXIgYmFzZTY0ID0gR3JhcGhpY3MuQkFTRV82NDtcblxuXHRcdHdoaWxlIChpPGwpIHtcblx0XHRcdHZhciBjID0gc3RyLmNoYXJBdChpKTtcblx0XHRcdHZhciBuID0gYmFzZTY0W2NdO1xuXHRcdFx0dmFyIGZpID0gbj4+MzsgLy8gaGlnaGVzdCBvcmRlciBiaXRzIDEtMyBjb2RlIGZvciBvcGVyYXRpb24uXG5cdFx0XHR2YXIgZiA9IGluc3RydWN0aW9uc1tmaV07XG5cdFx0XHQvLyBjaGVjayB0aGF0IHdlIGhhdmUgYSB2YWxpZCBpbnN0cnVjdGlvbiAmIHRoYXQgdGhlIHVudXNlZCBiaXRzIGFyZSBlbXB0eTpcblx0XHRcdGlmICghZiB8fCAobiYzKSkgeyB0aHJvdyhcImJhZCBwYXRoIGRhdGEgKEBcIitpK1wiKTogXCIrYyk7IH1cblx0XHRcdHZhciBwbCA9IHBhcmFtQ291bnRbZmldO1xuXHRcdFx0aWYgKCFmaSkgeyB4PXk9MDsgfSAvLyBtb3ZlIG9wZXJhdGlvbnMgcmVzZXQgdGhlIHBvc2l0aW9uLlxuXHRcdFx0cGFyYW1zLmxlbmd0aCA9IDA7XG5cdFx0XHRpKys7XG5cdFx0XHR2YXIgY2hhckNvdW50ID0gKG4+PjImMSkrMjsgIC8vIDR0aCBoZWFkZXIgYml0IGluZGljYXRlcyBudW1iZXIgc2l6ZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdFx0XHRmb3IgKHZhciBwPTA7IHA8cGw7IHArKykge1xuXHRcdFx0XHR2YXIgbnVtID0gYmFzZTY0W3N0ci5jaGFyQXQoaSldO1xuXHRcdFx0XHR2YXIgc2lnbiA9IChudW0+PjUpID8gLTEgOiAxO1xuXHRcdFx0XHRudW0gPSAoKG51bSYzMSk8PDYpfChiYXNlNjRbc3RyLmNoYXJBdChpKzEpXSk7XG5cdFx0XHRcdGlmIChjaGFyQ291bnQgPT0gMykgeyBudW0gPSAobnVtPDw2KXwoYmFzZTY0W3N0ci5jaGFyQXQoaSsyKV0pOyB9XG5cdFx0XHRcdG51bSA9IHNpZ24qbnVtLzEwO1xuXHRcdFx0XHRpZiAocCUyKSB7IHggPSAobnVtICs9IHgpOyB9XG5cdFx0XHRcdGVsc2UgeyB5ID0gKG51bSArPSB5KTsgfVxuXHRcdFx0XHRwYXJhbXNbcF0gPSBudW07XG5cdFx0XHRcdGkgKz0gY2hhckNvdW50O1xuXHRcdFx0fVxuXHRcdFx0Zi5hcHBseSh0aGlzLHBhcmFtcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdG9yZXMgYWxsIGdyYXBoaWNzIGNvbW1hbmRzIHNvIHRoZXkgd29uJ3QgYmUgZXhlY3V0ZWQgaW4gZnV0dXJlIGRyYXdzLiBDYWxsaW5nIHN0b3JlKCkgYSBzZWNvbmQgdGltZSBhZGRzIHRvXG5cdCAqIHRoZSBleGlzdGluZyBzdG9yZS4gVGhpcyBhbHNvIGFmZmVjdHMgYGRyYXdBc1BhdGgoKWAuXG5cdCAqXG5cdCAqIFRoaXMgaXMgdXNlZnVsIGluIGNhc2VzIHdoZXJlIHlvdSBhcmUgY3JlYXRpbmcgdmVjdG9yIGdyYXBoaWNzIGluIGFuIGl0ZXJhdGl2ZSBtYW5uZXIgKGV4LiBnZW5lcmF0aXZlIGFydCksIHNvXG5cdCAqIHRoYXQgb25seSBuZXcgZ3JhcGhpY3MgbmVlZCB0byBiZSBkcmF3biAod2hpY2ggY2FuIHByb3ZpZGUgaHVnZSBwZXJmb3JtYW5jZSBiZW5lZml0cyksIGJ1dCB5b3Ugd2lzaCB0byByZXRhaW4gYWxsXG5cdCAqIG9mIHRoZSB2ZWN0b3IgaW5zdHJ1Y3Rpb25zIGZvciBsYXRlciB1c2UgKGV4LiBzY2FsaW5nLCBtb2RpZnlpbmcsIG9yIGV4cG9ydGluZykuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBjYWxsaW5nIHN0b3JlKCkgd2lsbCBmb3JjZSB0aGUgYWN0aXZlIHBhdGggKGlmIGFueSkgdG8gYmUgZW5kZWQgaW4gYSBtYW5uZXIgc2ltaWxhciB0byBjaGFuZ2luZ1xuXHQgKiB0aGUgZmlsbCBvciBzdHJva2UuXG5cdCAqXG5cdCAqIEZvciBleGFtcGxlLCBjb25zaWRlciBhIGFwcGxpY2F0aW9uIHdoZXJlIHRoZSB1c2VyIGRyYXdzIGxpbmVzIHdpdGggdGhlIG1vdXNlLiBBcyBlYWNoIGxpbmUgc2VnbWVudCAob3IgY29sbGVjdGlvbiBvZlxuXHQgKiBzZWdtZW50cykgYXJlIGFkZGVkIHRvIGEgU2hhcGUsIGl0IGNhbiBiZSByYXN0ZXJpemVkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvdXBkYXRlQ2FjaGVcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIGFuZCB0aGVuIHN0b3JlZCwgc28gdGhhdCBpdCBjYW4gYmUgcmVkcmF3biBhdCBhIGRpZmZlcmVudCBzY2FsZSB3aGVuIHRoZSBhcHBsaWNhdGlvbiBpcyByZXNpemVkLCBvciBleHBvcnRlZCB0byBTVkcuXG5cdCAqXG5cdCAqIFx0Ly8gc2V0IHVwIGNhY2hlOlxuXHQgKiBcdG15U2hhcGUuY2FjaGUoMCwwLDUwMCw1MDAsc2NhbGUpO1xuXHQgKlxuXHQgKiBcdC8vIHdoZW4gdGhlIHVzZXIgZHJhZ3MsIGRyYXcgYSBuZXcgbGluZTpcblx0ICogXHRteVNoYXBlLmdyYXBoaWNzLm1vdmVUbyhvbGRYLG9sZFkpLmxpbmVUbyhuZXdYLG5ld1kpO1xuXHQgKiBcdC8vIHRoZW4gZHJhdyBpdCBpbnRvIHRoZSBleGlzdGluZyBjYWNoZTpcblx0ICogXHRteVNoYXBlLnVwZGF0ZUNhY2hlKFwic291cmNlLW92ZXJcIik7XG5cdCAqIFx0Ly8gc3RvcmUgdGhlIG5ldyBsaW5lLCBzbyBpdCBpc24ndCByZWRyYXduIG5leHQgdGltZTpcblx0ICogXHRteVNoYXBlLnN0b3JlKCk7XG5cdCAqXG5cdCAqIFx0Ly8gdGhlbiwgd2hlbiB0aGUgd2luZG93IHJlc2l6ZXMsIHdlIGNhbiByZS1yZW5kZXIgYXQgYSBkaWZmZXJlbnQgc2NhbGU6XG5cdCAqIFx0Ly8gZmlyc3QsIHVuc3RvcmUgYWxsIG91ciBsaW5lczpcblx0ICogXHRteVNoYXBlLnVuc3RvcmUoKTtcblx0ICogXHQvLyB0aGVuIGNhY2hlIHVzaW5nIHRoZSBuZXcgc2NhbGU6XG5cdCAqIFx0bXlTaGFwZS5jYWNoZSgwLDAsNTAwLDUwMCxuZXdTY2FsZSk7XG5cdCAqIFx0Ly8gZmluYWxseSwgc3RvcmUgdGhlIGV4aXN0aW5nIGNvbW1hbmRzIGFnYWluOlxuXHQgKiBcdG15U2hhcGUuc3RvcmUoKTtcblx0ICpcblx0ICogQG1ldGhvZCBzdG9yZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuc3RvcmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl91cGRhdGVJbnN0cnVjdGlvbnModHJ1ZSk7XG5cdFx0dGhpcy5fc3RvcmVJbmRleCA9IHRoaXMuX2luc3RydWN0aW9ucy5sZW5ndGg7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVuc3RvcmVzIGFueSBncmFwaGljcyBjb21tYW5kcyB0aGF0IHdlcmUgcHJldmlvdXNseSBzdG9yZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3Mvc3RvcmVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogc28gdGhhdCB0aGV5IHdpbGwgYmUgZXhlY3V0ZWQgaW4gc3Vic2VxdWVudCBkcmF3IGNhbGxzLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHVuc3RvcmVcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLnVuc3RvcmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9zdG9yZUluZGV4ID0gMDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgR3JhcGhpY3MgaW5zdGFuY2UuIE5vdGUgdGhhdCB0aGUgaW5kaXZpZHVhbCBjb21tYW5kIG9iamVjdHMgYXJlIG5vdCBjbG9uZWQuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IEEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3MgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvID0gbmV3IEdyYXBoaWNzKCk7XG5cdFx0by5jb21tYW5kID0gdGhpcy5jb21tYW5kO1xuXHRcdG8uX3N0cm9rZSA9IHRoaXMuX3N0cm9rZTtcblx0XHRvLl9zdHJva2VTdHlsZSA9IHRoaXMuX3N0cm9rZVN0eWxlO1xuXHRcdG8uX3N0cm9rZURhc2ggPSB0aGlzLl9zdHJva2VEYXNoO1xuXHRcdG8uX3N0cm9rZUlnbm9yZVNjYWxlID0gdGhpcy5fc3Ryb2tlSWdub3JlU2NhbGU7XG5cdFx0by5fZmlsbCA9IHRoaXMuX2ZpbGw7XG5cdFx0by5faW5zdHJ1Y3Rpb25zID0gdGhpcy5faW5zdHJ1Y3Rpb25zLnNsaWNlKCk7XG5cdFx0by5fY29tbWl0SW5kZXggPSB0aGlzLl9jb21taXRJbmRleDtcblx0XHRvLl9hY3RpdmVJbnN0cnVjdGlvbnMgPSB0aGlzLl9hY3RpdmVJbnN0cnVjdGlvbnMuc2xpY2UoKTtcblx0XHRvLl9kaXJ0eSA9IHRoaXMuX2RpcnR5O1xuXHRcdG8uX3N0b3JlSW5kZXggPSB0aGlzLl9zdG9yZUluZGV4O1xuXHRcdHJldHVybiBvO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbR3JhcGhpY3NdXCI7XG5cdH07XG5cblxuLy8gdGlueSBBUEk6XG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBtb3ZlVG8uXG5cdCAqIEBtZXRob2QgbXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggY29vcmRpbmF0ZSB0aGUgZHJhd2luZyBwb2ludCBzaG91bGQgbW92ZSB0by5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29vcmRpbmF0ZSB0aGUgZHJhd2luZyBwb2ludCBzaG91bGQgbW92ZSB0by5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscykuXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAubXQgPSBwLm1vdmVUbztcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gbGluZVRvLlxuXHQgKiBAbWV0aG9kIGx0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUgdGhlIGRyYXdpbmcgcG9pbnQgc2hvdWxkIGRyYXcgdG8uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgdGhlIGRyYXdpbmcgcG9pbnQgc2hvdWxkIGRyYXcgdG8uXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmx0ID0gcC5saW5lVG87XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGFyY1RvLlxuXHQgKiBAbWV0aG9kIGF0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geTFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmF0ID0gcC5hcmNUbztcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gYmV6aWVyQ3VydmVUby5cblx0ICogQG1ldGhvZCBidFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AxeFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AxeVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AyeFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AyeVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5idCA9IHAuYmV6aWVyQ3VydmVUbztcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gcXVhZHJhdGljQ3VydmVUbyAvIGN1cnZlVG8uXG5cdCAqIEBtZXRob2QgcXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNweFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3B5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAucXQgPSBwLnF1YWRyYXRpY0N1cnZlVG87XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGFyYy5cblx0ICogQG1ldGhvZCBhXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0QW5nbGUgTWVhc3VyZWQgaW4gcmFkaWFucy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGVuZEFuZ2xlIE1lYXN1cmVkIGluIHJhZGlhbnMuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYW50aWNsb2Nrd2lzZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hID0gcC5hcmM7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIHJlY3QuXG5cdCAqIEBtZXRob2QgclxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdyBXaWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoIEhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnIgPSBwLnJlY3Q7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGNsb3NlUGF0aC5cblx0ICogQG1ldGhvZCBjcFxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5jcCA9IHAuY2xvc2VQYXRoO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBjbGVhci5cblx0ICogQG1ldGhvZCBjXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmMgPSBwLmNsZWFyO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZWdpbkZpbGwuXG5cdCAqIEBtZXRob2QgZlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQSBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZSAoZXguIFwicmVkXCIsIFwiI0ZGMDAwMFwiLCBvciBcInJnYmEoMjU1LDAsMCwwLjUpXCIpLiBTZXR0aW5nIHRvXG5cdCAqIG51bGwgd2lsbCByZXN1bHQgaW4gbm8gZmlsbC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuZiA9IHAuYmVnaW5GaWxsO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZWdpbkxpbmVhckdyYWRpZW50RmlsbC5cblx0ICogQG1ldGhvZCBsZlxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnMgQW4gYXJyYXkgb2YgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWVzLiBGb3IgZXhhbXBsZSwgW1wiI0YwMFwiLFwiIzAwRlwiXSB3b3VsZCBkZWZpbmUgYSBncmFkaWVudFxuXHQgKiBkcmF3aW5nIGZyb20gcmVkIHRvIGJsdWUuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvcyBBbiBhcnJheSBvZiBncmFkaWVudCBwb3NpdGlvbnMgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgY29sb3JzLiBGb3IgZXhhbXBsZSwgWzAuMSwgMC45XSB3b3VsZCBkcmF3XG5cdCAqIHRoZSBmaXJzdCBjb2xvciB0byAxMCUgdGhlbiBpbnRlcnBvbGF0aW5nIHRvIHRoZSBzZWNvbmQgY29sb3IgYXQgOTAlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDAgVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwIFRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MSBUaGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5sZiA9IHAuYmVnaW5MaW5lYXJHcmFkaWVudEZpbGw7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGJlZ2luUmFkaWFsR3JhZGllbnRGaWxsLlxuXHQgKiBAbWV0aG9kIHJmXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9ycyBBbiBhcnJheSBvZiBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZXMuIEZvciBleGFtcGxlLCBbXCIjRjAwXCIsXCIjMDBGXCJdIHdvdWxkIGRlZmluZVxuXHQgKiBhIGdyYWRpZW50IGRyYXdpbmcgZnJvbSByZWQgdG8gYmx1ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zIEFuIGFycmF5IG9mIGdyYWRpZW50IHBvc2l0aW9ucyB3aGljaCBjb3JyZXNwb25kIHRvIHRoZSBjb2xvcnMuIEZvciBleGFtcGxlLCBbMC4xLFxuXHQgKiAwLjldIHdvdWxkIGRyYXcgdGhlIGZpcnN0IGNvbG9yIHRvIDEwJSB0aGVuIGludGVycG9sYXRpbmcgdG8gdGhlIHNlY29uZCBjb2xvciBhdCA5MCUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MCBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTAgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIwIFJhZGl1cyBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MSBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTEgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIxIFJhZGl1cyBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnJmID0gcC5iZWdpblJhZGlhbEdyYWRpZW50RmlsbDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gYmVnaW5CaXRtYXBGaWxsLlxuXHQgKiBAbWV0aG9kIGJmXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudH0gaW1hZ2UgVGhlIEltYWdlLCBDYW52YXMsIG9yIFZpZGVvIG9iamVjdCB0byB1c2Vcblx0ICogYXMgdGhlIHBhdHRlcm4uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSByZXBldGl0aW9uIE9wdGlvbmFsLiBJbmRpY2F0ZXMgd2hldGhlciB0byByZXBlYXQgdGhlIGltYWdlIGluIHRoZSBmaWxsIGFyZWEuIE9uZSBvZiBcInJlcGVhdFwiLFxuXHQgKiBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gRGVmYXVsdHMgdG8gXCJyZXBlYXRcIi4gTm90ZSB0aGF0IEZpcmVmb3ggZG9lcyBub3Qgc3VwcG9ydCBcInJlcGVhdC14XCIgb3Jcblx0ICogXCJyZXBlYXQteVwiIChsYXRlc3QgdGVzdHMgd2VyZSBpbiBGRiAyMC4wKSwgYW5kIHdpbGwgZGVmYXVsdCB0byBcInJlcGVhdFwiLlxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXggT3B0aW9uYWwuIFNwZWNpZmllcyBhIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBmb3IgdGhlIGJpdG1hcCBmaWxsLiBUaGlzIHRyYW5zZm9ybWF0aW9uXG5cdCAqIHdpbGwgYmUgYXBwbGllZCByZWxhdGl2ZSB0byB0aGUgcGFyZW50IHRyYW5zZm9ybS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuYmYgPSBwLmJlZ2luQml0bWFwRmlsbDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gZW5kRmlsbC5cblx0ICogQG1ldGhvZCBlZlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5lZiA9IHAuZW5kRmlsbDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gc2V0U3Ryb2tlU3R5bGUuXG5cdCAqIEBtZXRob2Qgc3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRoaWNrbmVzcyBUaGUgd2lkdGggb2YgdGhlIHN0cm9rZS5cblx0ICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IFtjYXBzPTBdIEluZGljYXRlcyB0aGUgdHlwZSBvZiBjYXBzIHRvIHVzZSBhdCB0aGUgZW5kIG9mIGxpbmVzLiBPbmUgb2YgYnV0dCxcblx0ICogcm91bmQsIG9yIHNxdWFyZS4gRGVmYXVsdHMgdG8gXCJidXR0XCIuIEFsc28gYWNjZXB0cyB0aGUgdmFsdWVzIDAgKGJ1dHQpLCAxIChyb3VuZCksIGFuZCAyIChzcXVhcmUpIGZvciB1c2Ugd2l0aFxuXHQgKiB0aGUgdGlueSBBUEkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBbam9pbnRzPTBdIFNwZWNpZmllcyB0aGUgdHlwZSBvZiBqb2ludHMgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVyZSB0d28gbGluZXMgbWVldC5cblx0ICogT25lIG9mIGJldmVsLCByb3VuZCwgb3IgbWl0ZXIuIERlZmF1bHRzIHRvIFwibWl0ZXJcIi4gQWxzbyBhY2NlcHRzIHRoZSB2YWx1ZXMgMCAobWl0ZXIpLCAxIChyb3VuZCksIGFuZCAyIChiZXZlbClcblx0ICogZm9yIHVzZSB3aXRoIHRoZSB0aW55IEFQSS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFttaXRlckxpbWl0PTEwXSBJZiBqb2ludHMgaXMgc2V0IHRvIFwibWl0ZXJcIiwgdGhlbiB5b3UgY2FuIHNwZWNpZnkgYSBtaXRlciBsaW1pdCByYXRpbyB3aGljaFxuXHQgKiBjb250cm9scyBhdCB3aGF0IHBvaW50IGEgbWl0ZXJlZCBqb2ludCB3aWxsIGJlIGNsaXBwZWQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZVNjYWxlPWZhbHNlXSBJZiB0cnVlLCB0aGUgc3Ryb2tlIHdpbGwgYmUgZHJhd24gYXQgdGhlIHNwZWNpZmllZCB0aGlja25lc3MgcmVnYXJkbGVzc1xuXHQgKiBvZiBhY3RpdmUgdHJhbnNmb3JtYXRpb25zLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5zcyA9IHAuc2V0U3Ryb2tlU3R5bGU7XG5cdFxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gc2V0U3Ryb2tlRGFzaC5cblx0ICogQG1ldGhvZCBzZFxuXHQgKiBAcGFyYW0ge0FycmF5fSBbc2VnbWVudHNdIEFuIGFycmF5IHNwZWNpZnlpbmcgdGhlIGRhc2ggcGF0dGVybiwgYWx0ZXJuYXRpbmcgYmV0d2VlbiBsaW5lIGFuZCBnYXAuXG5cdCAqIEZvciBleGFtcGxlLCBbMjAsMTBdIHdvdWxkIGNyZWF0ZSBhIHBhdHRlcm4gb2YgMjAgcGl4ZWwgbGluZXMgd2l0aCAxMCBwaXhlbCBnYXBzIGJldHdlZW4gdGhlbS5cblx0ICogUGFzc2luZyBudWxsIG9yIGFuIGVtcHR5IGFycmF5IHdpbGwgY2xlYXIgYW55IGV4aXN0aW5nIGRhc2guXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0PTBdIFRoZSBvZmZzZXQgb2YgdGhlIGRhc2ggcGF0dGVybi4gRm9yIGV4YW1wbGUsIHlvdSBjb3VsZCBpbmNyZW1lbnQgdGhpcyB2YWx1ZSB0byBjcmVhdGUgYSBcIm1hcmNoaW5nIGFudHNcIiBlZmZlY3QuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnNkID0gcC5zZXRTdHJva2VEYXNoO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZWdpblN0cm9rZS5cblx0ICogQG1ldGhvZCBzXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBBIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlIChleC4gXCIjRkYwMDAwXCIsIFwicmVkXCIsIG9yIFwicmdiYSgyNTUsMCwwLDAuNSlcIikuIFNldHRpbmcgdG9cblx0ICogbnVsbCB3aWxsIHJlc3VsdCBpbiBubyBzdHJva2UuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnMgPSBwLmJlZ2luU3Ryb2tlO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZWdpbkxpbmVhckdyYWRpZW50U3Ryb2tlLlxuXHQgKiBAbWV0aG9kIGxzXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9ycyBBbiBhcnJheSBvZiBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZXMuIEZvciBleGFtcGxlLCBbXCIjRjAwXCIsXCIjMDBGXCJdIHdvdWxkIGRlZmluZVxuXHQgKiBhIGdyYWRpZW50IGRyYXdpbmcgZnJvbSByZWQgdG8gYmx1ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zIEFuIGFycmF5IG9mIGdyYWRpZW50IHBvc2l0aW9ucyB3aGljaCBjb3JyZXNwb25kIHRvIHRoZSBjb2xvcnMuIEZvciBleGFtcGxlLCBbMC4xLFxuXHQgKiAwLjldIHdvdWxkIGRyYXcgdGhlIGZpcnN0IGNvbG9yIHRvIDEwJSB0aGVuIGludGVycG9sYXRpbmcgdG8gdGhlIHNlY29uZCBjb2xvciBhdCA5MCUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MCBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTAgVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTEgVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmxzID0gcC5iZWdpbkxpbmVhckdyYWRpZW50U3Ryb2tlO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZWdpblJhZGlhbEdyYWRpZW50U3Ryb2tlLlxuXHQgKiBAbWV0aG9kIHJzXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9ycyBBbiBhcnJheSBvZiBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZXMuIEZvciBleGFtcGxlLCBbXCIjRjAwXCIsXCIjMDBGXCJdIHdvdWxkIGRlZmluZVxuXHQgKiBhIGdyYWRpZW50IGRyYXdpbmcgZnJvbSByZWQgdG8gYmx1ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zIEFuIGFycmF5IG9mIGdyYWRpZW50IHBvc2l0aW9ucyB3aGljaCBjb3JyZXNwb25kIHRvIHRoZSBjb2xvcnMuIEZvciBleGFtcGxlLCBbMC4xLFxuXHQgKiAwLjldIHdvdWxkIGRyYXcgdGhlIGZpcnN0IGNvbG9yIHRvIDEwJSB0aGVuIGludGVycG9sYXRpbmcgdG8gdGhlIHNlY29uZCBjb2xvciBhdCA5MCUsIHRoZW4gZHJhdyB0aGUgc2Vjb25kIGNvbG9yXG5cdCAqIHRvIDEwMCUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MCBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTAgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIwIFJhZGl1cyBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MSBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTEgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIxIFJhZGl1cyBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnJzID0gcC5iZWdpblJhZGlhbEdyYWRpZW50U3Ryb2tlO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZWdpbkJpdG1hcFN0cm9rZS5cblx0ICogQG1ldGhvZCBic1xuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnR9IGltYWdlIFRoZSBJbWFnZSwgQ2FudmFzLCBvciBWaWRlbyBvYmplY3QgdG8gdXNlXG5cdCAqIGFzIHRoZSBwYXR0ZXJuLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3JlcGV0aXRpb249cmVwZWF0XSBPcHRpb25hbC4gSW5kaWNhdGVzIHdoZXRoZXIgdG8gcmVwZWF0IHRoZSBpbWFnZSBpbiB0aGUgZmlsbCBhcmVhLiBPbmUgb2Zcblx0ICogXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuIERlZmF1bHRzIHRvIFwicmVwZWF0XCIuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmJzID0gcC5iZWdpbkJpdG1hcFN0cm9rZTtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gZW5kU3Ryb2tlLlxuXHQgKiBAbWV0aG9kIGVzXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmVzID0gcC5lbmRTdHJva2U7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGRyYXdSZWN0LlxuXHQgKiBAbWV0aG9kIGRyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3IFdpZHRoIG9mIHRoZSByZWN0YW5nbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGggSGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuZHIgPSBwLmRyYXdSZWN0O1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBkcmF3Um91bmRSZWN0LlxuXHQgKiBAbWV0aG9kIHJyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXMgQ29ybmVyIHJhZGl1cy5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAucnIgPSBwLmRyYXdSb3VuZFJlY3Q7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGRyYXdSb3VuZFJlY3RDb21wbGV4LlxuXHQgKiBAbWV0aG9kIHJjXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUgdG8gZHJhdyB0aGUgcm91bmQgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUgdG8gZHJhdyB0aGUgcm91bmQgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHcgVGhlIHdpZHRoIG9mIHRoZSByb3VuZCByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaCBUaGUgaGVpZ2h0IG9mIHRoZSByb3VuZCByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzVEwgVG9wIGxlZnQgY29ybmVyIHJhZGl1cy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1RSIFRvcCByaWdodCBjb3JuZXIgcmFkaXVzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzQlIgQm90dG9tIHJpZ2h0IGNvcm5lciByYWRpdXMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNCTCBCb3R0b20gbGVmdCBjb3JuZXIgcmFkaXVzLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5yYyA9IHAuZHJhd1JvdW5kUmVjdENvbXBsZXg7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGRyYXdDaXJjbGUuXG5cdCAqIEBtZXRob2QgZGNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggeCBjb29yZGluYXRlIGNlbnRlciBwb2ludCBvZiBjaXJjbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IHkgY29vcmRpbmF0ZSBjZW50ZXIgcG9pbnQgb2YgY2lyY2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiBjaXJjbGUuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmRjID0gcC5kcmF3Q2lyY2xlO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBkcmF3RWxsaXBzZS5cblx0ICogQG1ldGhvZCBkZVxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgbGVmdCBjb29yZGluYXRlIHBvaW50IG9mIHRoZSBlbGxpcHNlLiBOb3RlIHRoYXQgdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Q2lyY2xlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdoaWNoIGRyYXdzIGZyb20gY2VudGVyLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgdG9wIGNvb3JkaW5hdGUgcG9pbnQgb2YgdGhlIGVsbGlwc2UuIE5vdGUgdGhhdCB0aGlzIGlzIGRpZmZlcmVudCBmcm9tIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdDaXJjbGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2hpY2ggZHJhd3MgZnJvbSB0aGUgY2VudGVyLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdyBUaGUgaGVpZ2h0IChob3Jpem9udGFsIGRpYW1ldGVyKSBvZiB0aGUgZWxsaXBzZS4gVGhlIGhvcml6b250YWwgcmFkaXVzIHdpbGwgYmUgaGFsZiBvZiB0aGlzXG5cdCAqIG51bWJlci5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGggVGhlIHdpZHRoICh2ZXJ0aWNhbCBkaWFtZXRlcikgb2YgdGhlIGVsbGlwc2UuIFRoZSB2ZXJ0aWNhbCByYWRpdXMgd2lsbCBiZSBoYWxmIG9mIHRoaXMgbnVtYmVyLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5kZSA9IHAuZHJhd0VsbGlwc2U7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGRyYXdQb2x5U3Rhci5cblx0ICogQG1ldGhvZCBkcFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBQb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9mIHRoZSBzaGFwZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgUG9zaXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGUgc2hhcGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXMgVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgc2hhcGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzaWRlcyBUaGUgbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgc3RhciBvciBzaWRlcyBvbiB0aGUgcG9seWdvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvaW50U2l6ZSBUaGUgZGVwdGggb3IgXCJwb2ludHktbmVzc1wiIG9mIHRoZSBzdGFyIHBvaW50cy4gQSBwb2ludFNpemUgb2YgMCB3aWxsIGRyYXcgYSByZWd1bGFyXG5cdCAqIHBvbHlnb24gKG5vIHBvaW50cyksIGEgcG9pbnRTaXplIG9mIDEgd2lsbCBkcmF3IG5vdGhpbmcgYmVjYXVzZSB0aGUgcG9pbnRzIGFyZSBpbmZpbml0ZWx5IHBvaW50eS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIFRoZSBhbmdsZSBvZiB0aGUgZmlyc3QgcG9pbnQgLyBjb3JuZXIuIEZvciBleGFtcGxlIGEgdmFsdWUgb2YgMCB3aWxsIGRyYXcgdGhlIGZpcnN0IHBvaW50XG5cdCAqIGRpcmVjdGx5IHRvIHRoZSByaWdodCBvZiB0aGUgY2VudGVyLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5kcCA9IHAuZHJhd1BvbHlTdGFyO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBkZWNvZGVQYXRoLlxuXHQgKiBAbWV0aG9kIHBcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgcGF0aCBzdHJpbmcgdG8gZGVjb2RlLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5wID0gcC5kZWNvZGVQYXRoO1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX3VwZGF0ZUluc3RydWN0aW9uc1xuXHQgKiBAcGFyYW0gY29tbWl0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl91cGRhdGVJbnN0cnVjdGlvbnMgPSBmdW5jdGlvbihjb21taXQpIHtcblx0XHR2YXIgaW5zdHIgPSB0aGlzLl9pbnN0cnVjdGlvbnMsIGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZUluc3RydWN0aW9ucywgY29tbWl0SW5kZXggPSB0aGlzLl9jb21taXRJbmRleDtcblxuXHRcdGlmICh0aGlzLl9kaXJ0eSAmJiBhY3RpdmUubGVuZ3RoKSB7XG5cdFx0XHRpbnN0ci5sZW5ndGggPSBjb21taXRJbmRleDsgLy8gcmVtb3ZlIG9sZCwgdW5jb21taXR0ZWQgY29tbWFuZHNcblx0XHRcdGluc3RyLnB1c2goR3JhcGhpY3MuYmVnaW5DbWQpO1xuXG5cdFx0XHR2YXIgbCA9IGFjdGl2ZS5sZW5ndGgsIGxsID0gaW5zdHIubGVuZ3RoO1xuXHRcdFx0aW5zdHIubGVuZ3RoID0gbGwrbDtcblx0XHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKyspIHsgaW5zdHJbaStsbF0gPSBhY3RpdmVbaV07IH1cblxuXHRcdFx0aWYgKHRoaXMuX2ZpbGwpIHsgaW5zdHIucHVzaCh0aGlzLl9maWxsKTsgfVxuXHRcdFx0aWYgKHRoaXMuX3N0cm9rZSkge1xuXHRcdFx0XHQvLyBkb2Vzbid0IG5lZWQgdG8gYmUgcmUtYXBwbGllZCBpZiBpdCBoYXNuJ3QgY2hhbmdlZC5cblx0XHRcdFx0aWYgKHRoaXMuX3N0cm9rZURhc2ggIT09IHRoaXMuX29sZFN0cm9rZURhc2gpIHtcblx0XHRcdFx0XHR0aGlzLl9vbGRTdHJva2VEYXNoID0gdGhpcy5fc3Ryb2tlRGFzaDtcblx0XHRcdFx0XHRpbnN0ci5wdXNoKHRoaXMuX3N0cm9rZURhc2gpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl9zdHJva2VTdHlsZSAhPT0gdGhpcy5fb2xkU3Ryb2tlU3R5bGUpIHtcblx0XHRcdFx0XHR0aGlzLl9vbGRTdHJva2VTdHlsZSA9IHRoaXMuX3N0cm9rZVN0eWxlO1xuXHRcdFx0XHRcdGluc3RyLnB1c2godGhpcy5fc3Ryb2tlU3R5bGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluc3RyLnB1c2godGhpcy5fc3Ryb2tlKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoY29tbWl0KSB7XG5cdFx0XHRhY3RpdmUubGVuZ3RoID0gMDtcblx0XHRcdHRoaXMuX2NvbW1pdEluZGV4ID0gaW5zdHIubGVuZ3RoO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfc2V0RmlsbFxuXHQgKiBAcGFyYW0gZmlsbFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fc2V0RmlsbCA9IGZ1bmN0aW9uKGZpbGwpIHtcblx0XHR0aGlzLl91cGRhdGVJbnN0cnVjdGlvbnModHJ1ZSk7XG5cdFx0dGhpcy5jb21tYW5kID0gdGhpcy5fZmlsbCA9IGZpbGw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3NldFN0cm9rZVxuXHQgKiBAcGFyYW0gc3Ryb2tlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9zZXRTdHJva2UgPSBmdW5jdGlvbihzdHJva2UpIHtcblx0XHR0aGlzLl91cGRhdGVJbnN0cnVjdGlvbnModHJ1ZSk7XG5cdFx0aWYgKHRoaXMuY29tbWFuZCA9IHRoaXMuX3N0cm9rZSA9IHN0cm9rZSkge1xuXHRcdFx0c3Ryb2tlLmlnbm9yZVNjYWxlID0gdGhpcy5fc3Ryb2tlSWdub3JlU2NhbGU7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG4vLyBDb21tYW5kIE9iamVjdHM6XG5cdC8qKlxuXHQgKiBAbmFtZXNwYWNlIEdyYXBoaWNzXG5cdCAqL1xuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9saW5lVG9cIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBMaW5lVG9cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHQoRy5MaW5lVG8gPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHsgY3R4LmxpbmVUbyh0aGlzLngsdGhpcy55KTsgfTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9tb3ZlVG9cIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIE1vdmVUb1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG5cdChHLk1vdmVUbyA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLnggPSB4OyB0aGlzLnkgPSB5O1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHgubW92ZVRvKHRoaXMueCwgdGhpcy55KTsgfTtcblxuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FyY1RvXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBBcmNUb1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geDJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHgxXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5MVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeDJcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHkyXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSByYWRpdXNcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdChHLkFyY1RvID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuXHRcdHRoaXMueDEgPSB4MTsgdGhpcy55MSA9IHkxO1xuXHRcdHRoaXMueDIgPSB4MjsgdGhpcy55MiA9IHkyO1xuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHguYXJjVG8odGhpcy54MSwgdGhpcy55MSwgdGhpcy54MiwgdGhpcy55MiwgdGhpcy5yYWRpdXMpOyB9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FyY1wifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgQXJjXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEFuZ2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBlbmRBbmdsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW50aWNsb2Nrd2lzZVxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcmFkaXVzXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBzdGFydEFuZ2xlXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBlbmRBbmdsZVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgYW50aWNsb2Nrd2lzZVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0KEcuQXJjID0gZnVuY3Rpb24oeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuXHRcdHRoaXMueCA9IHg7IHRoaXMueSA9IHk7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdFx0dGhpcy5zdGFydEFuZ2xlID0gc3RhcnRBbmdsZTsgdGhpcy5lbmRBbmdsZSA9IGVuZEFuZ2xlO1xuXHRcdHRoaXMuYW50aWNsb2Nrd2lzZSA9ICEhYW50aWNsb2Nrd2lzZTtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHsgY3R4LmFyYyh0aGlzLngsIHRoaXMueSwgdGhpcy5yYWRpdXMsIHRoaXMuc3RhcnRBbmdsZSwgdGhpcy5lbmRBbmdsZSwgdGhpcy5hbnRpY2xvY2t3aXNlKTsgfTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9xdWFkcmF0aWNDdXJ2ZVRvXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBRdWFkcmF0aWNDdXJ2ZVRvXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3B4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGNweFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgY3B5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHQoRy5RdWFkcmF0aWNDdXJ2ZVRvID0gZnVuY3Rpb24oY3B4LCBjcHksIHgsIHkpIHtcblx0XHR0aGlzLmNweCA9IGNweDsgdGhpcy5jcHkgPSBjcHk7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHsgY3R4LnF1YWRyYXRpY0N1cnZlVG8odGhpcy5jcHgsIHRoaXMuY3B5LCB0aGlzLngsIHRoaXMueSk7IH07XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmV6aWVyQ3VydmVUb1wifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgQmV6aWVyQ3VydmVUb1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMXhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMXlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMnhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMnlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGNwMXhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGNwMXlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGNwMnhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGNwMnlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdChHLkJlemllckN1cnZlVG8gPSBmdW5jdGlvbihjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KSB7XG5cdFx0dGhpcy5jcDF4ID0gY3AxeDsgdGhpcy5jcDF5ID0gY3AxeTtcblx0XHR0aGlzLmNwMnggPSBjcDJ4OyB0aGlzLmNwMnkgPSBjcDJ5O1xuXHRcdHRoaXMueCA9IHg7IHRoaXMueSA9IHk7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7IGN0eC5iZXppZXJDdXJ2ZVRvKHRoaXMuY3AxeCwgdGhpcy5jcDF5LCB0aGlzLmNwMngsIHRoaXMuY3AyeSwgdGhpcy54LCB0aGlzLnkpOyB9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3JlY3RcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIFJlY3Rcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB3XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBoXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHQoRy5SZWN0ID0gZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuXHRcdHRoaXMueCA9IHg7IHRoaXMueSA9IHk7XG5cdFx0dGhpcy53ID0gdzsgdGhpcy5oID0gaDtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHsgY3R4LnJlY3QodGhpcy54LCB0aGlzLnksIHRoaXMudywgdGhpcy5oKTsgfTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9jbG9zZVBhdGhcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIENsb3NlUGF0aFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdChHLkNsb3NlUGF0aCA9IGZ1bmN0aW9uKCkge1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHguY2xvc2VQYXRoKCk7IH07XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0IHRvIGJlZ2luIGEgbmV3IHBhdGguIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljc1wifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgQmVnaW5QYXRoXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0KEcuQmVnaW5QYXRoID0gZnVuY3Rpb24oKSB7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7IGN0eC5iZWdpblBhdGgoKTsgfTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkZpbGxcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIEZpbGxcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSBBIHZhbGlkIENvbnRleHQyRCBmaWxsU3R5bGUuXG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeFxuXHQgKiovXG5cdC8qKlxuXHQgKiBBIHZhbGlkIENvbnRleHQyRCBmaWxsU3R5bGUuXG5cdCAqIEBwcm9wZXJ0eSBzdHlsZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgbWF0cml4XG5cdCAqIEB0eXBlIE1hdHJpeDJEXG5cdCAqL1xuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdHAgPSAoRy5GaWxsID0gZnVuY3Rpb24oc3R5bGUsIG1hdHJpeCkge1xuXHRcdHRoaXMuc3R5bGUgPSBzdHlsZTtcblx0XHR0aGlzLm1hdHJpeCA9IG1hdHJpeDtcblx0fSkucHJvdG90eXBlO1xuXHRwLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHtcblx0XHRpZiAoIXRoaXMuc3R5bGUpIHsgcmV0dXJuOyB9XG5cdFx0Y3R4LmZpbGxTdHlsZSA9IHRoaXMuc3R5bGU7XG5cdFx0dmFyIG10eCA9IHRoaXMubWF0cml4O1xuXHRcdGlmIChtdHgpIHsgY3R4LnNhdmUoKTsgY3R4LnRyYW5zZm9ybShtdHguYSwgbXR4LmIsIG10eC5jLCBtdHguZCwgbXR4LnR4LCBtdHgudHkpOyB9XG5cdFx0Y3R4LmZpbGwoKTtcblx0XHRpZiAobXR4KSB7IGN0eC5yZXN0b3JlKCk7IH1cblx0fTtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBsaW5lYXIgZ3JhZGllbnQgc3R5bGUgYW5kIGFzc2lnbnMgaXQgdG8ge3sjY3Jvc3NMaW5rIFwiRmlsbC9zdHlsZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luTGluZWFyR3JhZGllbnRGaWxsXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAbWV0aG9kIGxpbmVhckdyYWRpZW50XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9yc1xuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MFxuXHQgKiBAcGFyYW0ge051bWJlcn0geDFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxXG5cdCAqIEByZXR1cm4ge0ZpbGx9IFJldHVybnMgdGhpcyBGaWxsIG9iamVjdCBmb3IgY2hhaW5pbmcgb3IgYXNzaWdubWVudC5cblx0ICovXG5cdHAubGluZWFyR3JhZGllbnQgPSBmdW5jdGlvbihjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCB4MSwgeTEpIHtcblx0XHR2YXIgbyA9IHRoaXMuc3R5bGUgPSAgR3JhcGhpY3MuX2N0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4MCwgeTAsIHgxLCB5MSk7XG5cdFx0Zm9yICh2YXIgaT0wLCBsPWNvbG9ycy5sZW5ndGg7IGk8bDsgaSsrKSB7IG8uYWRkQ29sb3JTdG9wKHJhdGlvc1tpXSwgY29sb3JzW2ldKTsgfVxuXHRcdG8ucHJvcHMgPSB7Y29sb3JzOmNvbG9ycywgcmF0aW9zOnJhdGlvcywgeDA6eDAsIHkwOnkwLCB4MTp4MSwgeTE6eTEsIHR5cGU6XCJsaW5lYXJcIn07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgcmFkaWFsIGdyYWRpZW50IHN0eWxlIGFuZCBhc3NpZ25zIGl0IHRvIHt7I2Nyb3NzTGluayBcIkZpbGwvc3R5bGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpblJhZGlhbEdyYWRpZW50RmlsbFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQG1ldGhvZCByYWRpYWxHcmFkaWVudFxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnNcblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MFxuXHQgKiBAcGFyYW0ge051bWJlcn0geTBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geTFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIxXG5cdCAqIEByZXR1cm4ge0ZpbGx9IFJldHVybnMgdGhpcyBGaWxsIG9iamVjdCBmb3IgY2hhaW5pbmcgb3IgYXNzaWdubWVudC5cblx0ICovXG5cdHAucmFkaWFsR3JhZGllbnQgPSBmdW5jdGlvbihjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCByMCwgeDEsIHkxLCByMSkge1xuXHRcdHZhciBvID0gdGhpcy5zdHlsZSA9ICBHcmFwaGljcy5fY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHgwLCB5MCwgcjAsIHgxLCB5MSwgcjEpO1xuXHRcdGZvciAodmFyIGk9MCwgbD1jb2xvcnMubGVuZ3RoOyBpPGw7IGkrKykgeyBvLmFkZENvbG9yU3RvcChyYXRpb3NbaV0sIGNvbG9yc1tpXSk7IH1cblx0XHRvLnByb3BzID0ge2NvbG9yczpjb2xvcnMsIHJhdGlvczpyYXRpb3MsIHgwOngwLCB5MDp5MCwgcjA6cjAsIHgxOngxLCB5MTp5MSwgcjE6cjEsIHR5cGU6XCJyYWRpYWxcIn07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgYml0bWFwIGZpbGwgc3R5bGUgYW5kIGFzc2lnbnMgaXQgdG8gdGhlIHt7I2Nyb3NzTGluayBcIkZpbGwvc3R5bGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkJpdG1hcEZpbGxcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBtZXRob2QgYml0bWFwXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudH0gaW1hZ2UgIE11c3QgYmUgbG9hZGVkIHByaW9yIHRvIGNyZWF0aW5nIGEgYml0bWFwIGZpbGwsIG9yIHRoZSBmaWxsIHdpbGwgYmUgZW1wdHkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcmVwZXRpdGlvbl0gT25lIG9mOiByZXBlYXQsIHJlcGVhdC14LCByZXBlYXQteSwgb3Igbm8tcmVwZWF0LlxuXHQgKiBAcmV0dXJuIHtGaWxsfSBSZXR1cm5zIHRoaXMgRmlsbCBvYmplY3QgZm9yIGNoYWluaW5nIG9yIGFzc2lnbm1lbnQuXG5cdCAqL1xuXHRwLmJpdG1hcCA9IGZ1bmN0aW9uKGltYWdlLCByZXBldGl0aW9uKSB7XG5cdFx0aWYgKGltYWdlLm5hdHVyYWxXaWR0aCB8fCBpbWFnZS5nZXRDb250ZXh0IHx8IGltYWdlLnJlYWR5U3RhdGUgPj0gMikge1xuXHRcdFx0dmFyIG8gPSB0aGlzLnN0eWxlID0gR3JhcGhpY3MuX2N0eC5jcmVhdGVQYXR0ZXJuKGltYWdlLCByZXBldGl0aW9uIHx8IFwiXCIpO1xuXHRcdFx0by5wcm9wcyA9IHtpbWFnZTogaW1hZ2UsIHJlcGV0aXRpb246IHJlcGV0aXRpb24sIHR5cGU6IFwiYml0bWFwXCJ9O1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0cC5wYXRoID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5TdHJva2VcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIFN0cm9rZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IHN0eWxlIEEgdmFsaWQgQ29udGV4dDJEIGZpbGxTdHlsZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVTY2FsZVxuXHQgKiovXG5cdC8qKlxuXHQgKiBBIHZhbGlkIENvbnRleHQyRCBzdHJva2VTdHlsZS5cblx0ICogQHByb3BlcnR5IHN0eWxlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBpZ25vcmVTY2FsZVxuXHQgKiBAdHlwZSBCb29sZWFuXG5cdCAqL1xuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdHAgPSAoRy5TdHJva2UgPSBmdW5jdGlvbihzdHlsZSwgaWdub3JlU2NhbGUpIHtcblx0XHR0aGlzLnN0eWxlID0gc3R5bGU7XG5cdFx0dGhpcy5pZ25vcmVTY2FsZSA9IGlnbm9yZVNjYWxlO1xuXHR9KS5wcm90b3R5cGU7XG5cdHAuZXhlYyA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGlmICghdGhpcy5zdHlsZSkgeyByZXR1cm47IH1cblx0XHRjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnN0eWxlO1xuXHRcdGlmICh0aGlzLmlnbm9yZVNjYWxlKSB7IGN0eC5zYXZlKCk7IGN0eC5zZXRUcmFuc2Zvcm0oMSwwLDAsMSwwLDApOyB9XG5cdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdGlmICh0aGlzLmlnbm9yZVNjYWxlKSB7IGN0eC5yZXN0b3JlKCk7IH1cblx0fTtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBsaW5lYXIgZ3JhZGllbnQgc3R5bGUgYW5kIGFzc2lnbnMgaXQgdG8ge3sjY3Jvc3NMaW5rIFwiU3Ryb2tlL3N0eWxlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5MaW5lYXJHcmFkaWVudFN0cm9rZVwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQG1ldGhvZCBsaW5lYXJHcmFkaWVudFxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnNcblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MFxuXHQgKiBAcGFyYW0ge051bWJlcn0geTBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuXHQgKiBAcmV0dXJuIHtGaWxsfSBSZXR1cm5zIHRoaXMgU3Ryb2tlIG9iamVjdCBmb3IgY2hhaW5pbmcgb3IgYXNzaWdubWVudC5cblx0ICovXG5cdHAubGluZWFyR3JhZGllbnQgPSBHLkZpbGwucHJvdG90eXBlLmxpbmVhckdyYWRpZW50O1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIHJhZGlhbCBncmFkaWVudCBzdHlsZSBhbmQgYXNzaWducyBpdCB0byB7eyNjcm9zc0xpbmsgXCJTdHJva2Uvc3R5bGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpblJhZGlhbEdyYWRpZW50U3Ryb2tlXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAbWV0aG9kIHJhZGlhbEdyYWRpZW50XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9yc1xuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjFcblx0ICogQHJldHVybiB7RmlsbH0gUmV0dXJucyB0aGlzIFN0cm9rZSBvYmplY3QgZm9yIGNoYWluaW5nIG9yIGFzc2lnbm1lbnQuXG5cdCAqL1xuXHRwLnJhZGlhbEdyYWRpZW50ID0gRy5GaWxsLnByb3RvdHlwZS5yYWRpYWxHcmFkaWVudDtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBiaXRtYXAgZmlsbCBzdHlsZSBhbmQgYXNzaWducyBpdCB0byB7eyNjcm9zc0xpbmsgXCJTdHJva2Uvc3R5bGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkJpdG1hcFN0cm9rZVwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQG1ldGhvZCBiaXRtYXBcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBpbWFnZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3JlcGV0aXRpb25dIE9uZSBvZjogcmVwZWF0LCByZXBlYXQteCwgcmVwZWF0LXksIG9yIG5vLXJlcGVhdC5cblx0ICogQHJldHVybiB7RmlsbH0gUmV0dXJucyB0aGlzIFN0cm9rZSBvYmplY3QgZm9yIGNoYWluaW5nIG9yIGFzc2lnbm1lbnQuXG5cdCAqL1xuXHRwLmJpdG1hcCA9IEcuRmlsbC5wcm90b3R5cGUuYml0bWFwO1xuXHRwLnBhdGggPSBmYWxzZTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9zZXRTdHJva2VTdHlsZVwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgU3Ryb2tlU3R5bGVcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2NhcHM9YnV0dF1cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtqb2ludHM9bWl0ZXJdXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbbWl0ZXJMaW1pdD0xMF1cblx0ICogQHBhcmFtIHtCb29sZWFufSBbaWdub3JlU2NhbGU9ZmFsc2VdXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB3aWR0aFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBPbmUgb2Y6IGJ1dHQsIHJvdW5kLCBzcXVhcmVcblx0ICogQHByb3BlcnR5IGNhcHNcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqL1xuXHQvKipcblx0ICogT25lIG9mOiByb3VuZCwgYmV2ZWwsIG1pdGVyXG5cdCAqIEBwcm9wZXJ0eSBqb2ludHNcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IG1pdGVyTGltaXRcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdHAgPSAoRy5TdHJva2VTdHlsZSA9IGZ1bmN0aW9uKHdpZHRoLCBjYXBzLCBqb2ludHMsIG1pdGVyTGltaXQsIGlnbm9yZVNjYWxlKSB7XG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuY2FwcyA9IGNhcHM7XG5cdFx0dGhpcy5qb2ludHMgPSBqb2ludHM7XG5cdFx0dGhpcy5taXRlckxpbWl0ID0gbWl0ZXJMaW1pdDtcblx0XHR0aGlzLmlnbm9yZVNjYWxlID0gaWdub3JlU2NhbGU7XG5cdH0pLnByb3RvdHlwZTtcblx0cC5leGVjID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0Y3R4LmxpbmVXaWR0aCA9ICh0aGlzLndpZHRoID09IG51bGwgPyBcIjFcIiA6IHRoaXMud2lkdGgpO1xuXHRcdGN0eC5saW5lQ2FwID0gKHRoaXMuY2FwcyA9PSBudWxsID8gXCJidXR0XCIgOiAoaXNOYU4odGhpcy5jYXBzKSA/IHRoaXMuY2FwcyA6IEdyYXBoaWNzLlNUUk9LRV9DQVBTX01BUFt0aGlzLmNhcHNdKSk7XG5cdFx0Y3R4LmxpbmVKb2luID0gKHRoaXMuam9pbnRzID09IG51bGwgPyBcIm1pdGVyXCIgOiAoaXNOYU4odGhpcy5qb2ludHMpID8gdGhpcy5qb2ludHMgOiBHcmFwaGljcy5TVFJPS0VfSk9JTlRTX01BUFt0aGlzLmpvaW50c10pKTtcblx0XHRjdHgubWl0ZXJMaW1pdCA9ICh0aGlzLm1pdGVyTGltaXQgPT0gbnVsbCA/IFwiMTBcIiA6IHRoaXMubWl0ZXJMaW1pdCk7XG5cdFx0Y3R4Lmlnbm9yZVNjYWxlID0gKHRoaXMuaWdub3JlU2NhbGUgPT0gbnVsbCA/IGZhbHNlIDogdGhpcy5pZ25vcmVTY2FsZSk7XG5cdH07XG5cdHAucGF0aCA9IGZhbHNlO1xuXHRcblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3Mvc2V0U3Ryb2tlRGFzaFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgU3Ryb2tlRGFzaFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtBcnJheX0gW3NlZ21lbnRzXVxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29mZnNldD0wXVxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgc2VnbWVudHNcblx0ICogQHR5cGUgQXJyYXlcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgb2Zmc2V0XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIEdyYXBoaWNzIGNvbW1hbmQgaW4gdGhlIHByb3ZpZGVkIENhbnZhcyBjb250ZXh0LlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHQoRy5TdHJva2VEYXNoID0gZnVuY3Rpb24oc2VnbWVudHMsIG9mZnNldCkge1xuXHRcdHRoaXMuc2VnbWVudHMgPSBzZWdtZW50cztcblx0XHR0aGlzLm9mZnNldCA9IG9mZnNldHx8MDtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHtcblx0XHRpZiAoY3R4LnNldExpbmVEYXNoKSB7IC8vIGZlYXR1cmUgZGV0ZWN0aW9uLlxuXHRcdFx0Y3R4LnNldExpbmVEYXNoKHRoaXMuc2VnbWVudHN8fCBHLlN0cm9rZURhc2guRU1QVFlfU0VHTUVOVFMpOyAvLyBpbnN0ZWFkIG9mIFtdIHRvIHJlZHVjZSBjaHVybi5cblx0XHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IHRoaXMub2Zmc2V0fHwwO1xuXHRcdH1cblx0fTtcblx0LyoqXG5cdCAqIFRoZSBkZWZhdWx0IHZhbHVlIGZvciBzZWdtZW50cyAoaWUuIG5vIGRhc2gpLlxuXHQgKiBAcHJvcGVydHkgRU1QVFlfU0VHTUVOVFNcblx0ICogQHN0YXRpY1xuXHQgKiBAZmluYWxcblx0ICogQHJlYWRvbmx5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiovXG5cdEcuU3Ryb2tlRGFzaC5FTVBUWV9TRUdNRU5UUyA9IFtdO1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdSb3VuZFJlY3RDb21wbGV4XCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBSb3VuZFJlY3Rcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNUTFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzVFJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c0JSXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNCTFxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgd1xuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgaFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcmFkaXVzVExcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHJhZGl1c1RSXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSByYWRpdXNCUlxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcmFkaXVzQkxcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdChHLlJvdW5kUmVjdCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgsIHJhZGl1c1RMLCByYWRpdXNUUiwgcmFkaXVzQlIsIHJhZGl1c0JMKSB7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0XHR0aGlzLncgPSB3OyB0aGlzLmggPSBoO1xuXHRcdHRoaXMucmFkaXVzVEwgPSByYWRpdXNUTDsgdGhpcy5yYWRpdXNUUiA9IHJhZGl1c1RSO1xuXHRcdHRoaXMucmFkaXVzQlIgPSByYWRpdXNCUjsgdGhpcy5yYWRpdXNCTCA9IHJhZGl1c0JMO1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdHZhciBtYXggPSAodzxoP3c6aCkvMjtcblx0XHR2YXIgbVRMPTAsIG1UUj0wLCBtQlI9MCwgbUJMPTA7XG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHcgPSB0aGlzLncsIGggPSB0aGlzLmg7XG5cdFx0dmFyIHJUTCA9IHRoaXMucmFkaXVzVEwsIHJUUiA9IHRoaXMucmFkaXVzVFIsIHJCUiA9IHRoaXMucmFkaXVzQlIsIHJCTCA9IHRoaXMucmFkaXVzQkw7XG5cblx0XHRpZiAoclRMIDwgMCkgeyByVEwgKj0gKG1UTD0tMSk7IH1cblx0XHRpZiAoclRMID4gbWF4KSB7IHJUTCA9IG1heDsgfVxuXHRcdGlmIChyVFIgPCAwKSB7IHJUUiAqPSAobVRSPS0xKTsgfVxuXHRcdGlmIChyVFIgPiBtYXgpIHsgclRSID0gbWF4OyB9XG5cdFx0aWYgKHJCUiA8IDApIHsgckJSICo9IChtQlI9LTEpOyB9XG5cdFx0aWYgKHJCUiA+IG1heCkgeyByQlIgPSBtYXg7IH1cblx0XHRpZiAockJMIDwgMCkgeyByQkwgKj0gKG1CTD0tMSk7IH1cblx0XHRpZiAockJMID4gbWF4KSB7IHJCTCA9IG1heDsgfVxuXG5cdFx0Y3R4Lm1vdmVUbyh4K3ctclRSLCB5KTtcblx0XHRjdHguYXJjVG8oeCt3K3JUUiptVFIsIHktclRSKm1UUiwgeCt3LCB5K3JUUiwgclRSKTtcblx0XHRjdHgubGluZVRvKHgrdywgeStoLXJCUik7XG5cdFx0Y3R4LmFyY1RvKHgrdytyQlIqbUJSLCB5K2grckJSKm1CUiwgeCt3LXJCUiwgeStoLCByQlIpO1xuXHRcdGN0eC5saW5lVG8oeCtyQkwsIHkraCk7XG5cdFx0Y3R4LmFyY1RvKHgtckJMKm1CTCwgeStoK3JCTCptQkwsIHgsIHkraC1yQkwsIHJCTCk7XG5cdFx0Y3R4LmxpbmVUbyh4LCB5K3JUTCk7XG5cdFx0Y3R4LmFyY1RvKHgtclRMKm1UTCwgeS1yVEwqbVRMLCB4K3JUTCwgeSwgclRMKTtcblx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd0NpcmNsZVwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgQ2lyY2xlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSByYWRpdXNcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdChHLkNpcmNsZSA9IGZ1bmN0aW9uKHgsIHksIHJhZGl1cykge1xuXHRcdHRoaXMueCA9IHg7IHRoaXMueSA9IHk7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7IGN0eC5hcmModGhpcy54LCB0aGlzLnksIHRoaXMucmFkaXVzLCAwLCBNYXRoLlBJKjIpOyB9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdFbGxpcHNlXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBFbGxpcHNlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gd1xuXHQgKiBAcGFyYW0ge051bWJlcn0gaFxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgd1xuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgaFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBHcmFwaGljcyBjb21tYW5kIGluIHRoZSBwcm92aWRlZCBDYW52YXMgY29udGV4dC5cblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0KEcuRWxsaXBzZSA9IGZ1bmN0aW9uKHgsIHksIHcsIGgpIHtcblx0XHR0aGlzLnggPSB4OyB0aGlzLnkgPSB5O1xuXHRcdHRoaXMudyA9IHc7IHRoaXMuaCA9IGg7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XG5cdFx0dmFyIHcgPSB0aGlzLncsIGggPSB0aGlzLmg7XG5cblx0XHR2YXIgayA9IDAuNTUyMjg0ODtcblx0XHR2YXIgb3ggPSAodyAvIDIpICogaztcblx0XHR2YXIgb3kgPSAoaCAvIDIpICogaztcblx0XHR2YXIgeGUgPSB4ICsgdztcblx0XHR2YXIgeWUgPSB5ICsgaDtcblx0XHR2YXIgeG0gPSB4ICsgdyAvIDI7XG5cdFx0dmFyIHltID0geSArIGggLyAyO1xuXG5cdFx0Y3R4Lm1vdmVUbyh4LCB5bSk7XG5cdFx0Y3R4LmJlemllckN1cnZlVG8oeCwgeW0tb3ksIHhtLW94LCB5LCB4bSwgeSk7XG5cdFx0Y3R4LmJlemllckN1cnZlVG8oeG0rb3gsIHksIHhlLCB5bS1veSwgeGUsIHltKTtcblx0XHRjdHguYmV6aWVyQ3VydmVUbyh4ZSwgeW0rb3ksIHhtK294LCB5ZSwgeG0sIHllKTtcblx0XHRjdHguYmV6aWVyQ3VydmVUbyh4bS1veCwgeWUsIHgsIHltK295LCB4LCB5bSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd1BvbHlTdGFyXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBQb2x5U3RhclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuXHQgKiBAcGFyYW0ge051bWJlcn0gc2lkZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvaW50U2l6ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW5nbGVcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHJhZGl1c1xuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgc2lkZXNcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHBvaW50U2l6ZVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgYW5nbGVcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogRXhlY3V0ZSB0aGUgR3JhcGhpY3MgY29tbWFuZCBpbiB0aGUgcHJvdmlkZWQgQ2FudmFzIGNvbnRleHQuXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdChHLlBvbHlTdGFyID0gZnVuY3Rpb24oeCwgeSwgcmFkaXVzLCBzaWRlcywgcG9pbnRTaXplLCBhbmdsZSkge1xuXHRcdHRoaXMueCA9IHg7IHRoaXMueSA9IHk7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdFx0dGhpcy5zaWRlcyA9IHNpZGVzO1xuXHRcdHRoaXMucG9pbnRTaXplID0gcG9pbnRTaXplO1xuXHRcdHRoaXMuYW5nbGUgPSBhbmdsZTtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHtcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcblx0XHR2YXIgcmFkaXVzID0gdGhpcy5yYWRpdXM7XG5cdFx0dmFyIGFuZ2xlID0gKHRoaXMuYW5nbGV8fDApLzE4MCpNYXRoLlBJO1xuXHRcdHZhciBzaWRlcyA9IHRoaXMuc2lkZXM7XG5cdFx0dmFyIHBzID0gMS0odGhpcy5wb2ludFNpemV8fDApO1xuXHRcdHZhciBhID0gTWF0aC5QSS9zaWRlcztcblxuXHRcdGN0eC5tb3ZlVG8oeCtNYXRoLmNvcyhhbmdsZSkqcmFkaXVzLCB5K01hdGguc2luKGFuZ2xlKSpyYWRpdXMpO1xuXHRcdGZvciAodmFyIGk9MDsgaTxzaWRlczsgaSsrKSB7XG5cdFx0XHRhbmdsZSArPSBhO1xuXHRcdFx0aWYgKHBzICE9IDEpIHtcblx0XHRcdFx0Y3R4LmxpbmVUbyh4K01hdGguY29zKGFuZ2xlKSpyYWRpdXMqcHMsIHkrTWF0aC5zaW4oYW5nbGUpKnJhZGl1cypwcyk7XG5cdFx0XHR9XG5cdFx0XHRhbmdsZSArPSBhO1xuXHRcdFx0Y3R4LmxpbmVUbyh4K01hdGguY29zKGFuZ2xlKSpyYWRpdXMsIHkrTWF0aC5zaW4oYW5nbGUpKnJhZGl1cyk7XG5cdFx0fVxuXHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0fTtcblxuXHQvLyBkb2NjZWQgYWJvdmUuXG5cdEdyYXBoaWNzLmJlZ2luQ21kID0gbmV3IEcuQmVnaW5QYXRoKCk7IC8vIHNvIHdlIGRvbid0IGhhdmUgdG8gaW5zdGFudGlhdGUgbXVsdGlwbGUgaW5zdGFuY2VzLlxuXG5cblx0Y3JlYXRlanMuR3JhcGhpY3MgPSBHcmFwaGljcztcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBEaXNwbGF5T2JqZWN0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogRGlzcGxheU9iamVjdCBpcyBhbiBhYnN0cmFjdCBjbGFzcyB0aGF0IHNob3VsZCBub3QgYmUgY29uc3RydWN0ZWQgZGlyZWN0bHkuIEluc3RlYWQgY29uc3RydWN0IHN1YmNsYXNzZXMgc3VjaCBhc1xuXHQgKiB7eyNjcm9zc0xpbmsgXCJDb250YWluZXJcIn19e3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIkJpdG1hcFwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHt7I2Nyb3NzTGluayBcIlNoYXBlXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBEaXNwbGF5T2JqZWN0IGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgZGlzcGxheSBjbGFzc2VzIGluIHRoZSBFYXNlbEpTIGxpYnJhcnkuIEl0IGRlZmluZXMgdGhlIGNvcmUgcHJvcGVydGllcyBhbmRcblx0ICogbWV0aG9kcyB0aGF0IGFyZSBzaGFyZWQgYmV0d2VlbiBhbGwgZGlzcGxheSBvYmplY3RzLCBzdWNoIGFzIHRyYW5zZm9ybWF0aW9uIHByb3BlcnRpZXMgKHgsIHksIHNjYWxlWCwgc2NhbGVZLCBldGMpLFxuXHQgKiBjYWNoaW5nLCBhbmQgbW91c2UgaGFuZGxlcnMuXG5cdCAqIEBjbGFzcyBEaXNwbGF5T2JqZWN0XG5cdCAqIEBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBEaXNwbGF5T2JqZWN0KCkge1xuXHRcdHRoaXMuRXZlbnREaXNwYXRjaGVyX2NvbnN0cnVjdG9yKCk7XG5cdFx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSBhbHBoYSAodHJhbnNwYXJlbmN5KSBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdC4gMCBpcyBmdWxseSB0cmFuc3BhcmVudCwgMSBpcyBmdWxseSBvcGFxdWUuXG5cdFx0ICogQHByb3BlcnR5IGFscGhhXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICoqL1xuXHRcdHRoaXMuYWxwaGEgPSAxO1xuXHRcblx0XHQvKipcblx0XHQgKiBJZiBhIGNhY2hlIGlzIGFjdGl2ZSwgdGhpcyByZXR1cm5zIHRoZSBjYW52YXMgdGhhdCBob2xkcyB0aGUgY2FjaGVkIHZlcnNpb24gb2YgdGhpcyBkaXNwbGF5IG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcImNhY2hlXCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdFx0ICogQHByb3BlcnR5IGNhY2hlQ2FudmFzXG5cdFx0ICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50IHwgT2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5jYWNoZUNhbnZhcyA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYW4gSUQgbnVtYmVyIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGUgY3VycmVudCBjYWNoZSBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZCB0b1xuXHRcdCAqIGRldGVybWluZSBpZiB0aGUgY2FjaGUgaGFzIGNoYW5nZWQgc2luY2UgYSBwcmV2aW91cyBjaGVjay5cblx0XHQgKiBAcHJvcGVydHkgY2FjaGVJRFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuY2FjaGVJRCA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFVuaXF1ZSBJRCBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdC4gTWFrZXMgZGlzcGxheSBvYmplY3RzIGVhc2llciBmb3Igc29tZSB1c2VzLlxuXHRcdCAqIEBwcm9wZXJ0eSBpZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgLTFcblx0XHQgKiovXG5cdFx0dGhpcy5pZCA9IGNyZWF0ZWpzLlVJRC5nZXQoKTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdG8gaW5jbHVkZSB0aGlzIG9iamVjdCB3aGVuIHJ1bm5pbmcgbW91c2UgaW50ZXJhY3Rpb25zLiBTZXR0aW5nIHRoaXMgdG8gYGZhbHNlYCBmb3IgY2hpbGRyZW5cblx0XHQgKiBvZiBhIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lclwifX17ey9jcm9zc0xpbmt9fSB3aWxsIGNhdXNlIGV2ZW50cyBvbiB0aGUgQ29udGFpbmVyIHRvIG5vdCBmaXJlIHdoZW4gdGhhdCBjaGlsZCBpc1xuXHRcdCAqIGNsaWNrZWQuIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSB0byBgZmFsc2VgIGRvZXMgbm90IHByZXZlbnQgdGhlIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lci9nZXRPYmplY3RzVW5kZXJQb2ludFwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIG1ldGhvZCBmcm9tIHJldHVybmluZyB0aGUgY2hpbGQuXG5cdFx0ICpcblx0XHQgKiA8c3Ryb25nPk5vdGU6PC9zdHJvbmc+IEluIEVhc2VsSlMgMC43LjAsIHRoZSBtb3VzZUVuYWJsZWQgcHJvcGVydHkgd2lsbCBub3Qgd29yayBwcm9wZXJseSB3aXRoIG5lc3RlZCBDb250YWluZXJzLiBQbGVhc2Vcblx0XHQgKiBjaGVjayBvdXQgdGhlIGxhdGVzdCBORVhUIHZlcnNpb24gaW4gPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9DcmVhdGVKUy9FYXNlbEpTL3RyZWUvbWFzdGVyL2xpYlwiPkdpdEh1YjwvYT4gZm9yIGFuIHVwZGF0ZWQgdmVyc2lvbiB3aXRoIHRoaXMgaXNzdWUgcmVzb2x2ZWQuIFRoZSBmaXggd2lsbCBiZVxuXHRcdCAqIHByb3ZpZGVkIGluIHRoZSBuZXh0IHJlbGVhc2Ugb2YgRWFzZWxKUy5cblx0XHQgKiBAcHJvcGVydHkgbW91c2VFbmFibGVkXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqKi9cblx0XHR0aGlzLm1vdXNlRW5hYmxlZCA9IHRydWU7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSWYgZmFsc2UsIHRoZSB0aWNrIHdpbGwgbm90IHJ1biBvbiB0aGlzIGRpc3BsYXkgb2JqZWN0IChvciBpdHMgY2hpbGRyZW4pLiBUaGlzIGNhbiBwcm92aWRlIHNvbWUgcGVyZm9ybWFuY2UgYmVuZWZpdHMuXG5cdFx0ICogSW4gYWRkaXRpb24gdG8gcHJldmVudGluZyB0aGUgXCJ0aWNrXCIgZXZlbnQgZnJvbSBiZWluZyBkaXNwYXRjaGVkLCBpdCB3aWxsIGFsc28gcHJldmVudCB0aWNrIHJlbGF0ZWQgdXBkYXRlc1xuXHRcdCAqIG9uIHNvbWUgZGlzcGxheSBvYmplY3RzIChleC4gU3ByaXRlICYgTW92aWVDbGlwIGZyYW1lIGFkdmFuY2luZywgRE9NRWxlbWVudCB2aXNpYmlsaXR5IGhhbmRsaW5nKS5cblx0XHQgKiBAcHJvcGVydHkgdGlja0VuYWJsZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqKi9cblx0XHR0aGlzLnRpY2tFbmFibGVkID0gdHJ1ZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQW4gb3B0aW9uYWwgbmFtZSBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdC4gSW5jbHVkZWQgaW4ge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC90b1N0cmluZ1wifX17ey9jcm9zc0xpbmt9fSAuIFVzZWZ1bCBmb3Jcblx0XHQgKiBkZWJ1Z2dpbmcuXG5cdFx0ICogQHByb3BlcnR5IG5hbWVcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiovXG5cdFx0dGhpcy5uYW1lID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQSByZWZlcmVuY2UgdG8gdGhlIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lclwifX17ey9jcm9zc0xpbmt9fSBvciB7eyNjcm9zc0xpbmsgXCJTdGFnZVwifX17ey9jcm9zc0xpbmt9fSBvYmplY3QgdGhhdFxuXHRcdCAqIGNvbnRhaW5zIHRoaXMgZGlzcGxheSBvYmplY3QsIG9yIG51bGwgaWYgaXQgaGFzIG5vdCBiZWVuIGFkZGVkXG5cdFx0ICogdG8gb25lLlxuXHRcdCAqIEBwcm9wZXJ0eSBwYXJlbnRcblx0XHQgKiBAZmluYWxcblx0XHQgKiBAdHlwZSB7Q29udGFpbmVyfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5wYXJlbnQgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgbGVmdCBvZmZzZXQgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QncyByZWdpc3RyYXRpb24gcG9pbnQuIEZvciBleGFtcGxlLCB0byBtYWtlIGEgMTAweDEwMHB4IEJpdG1hcCByb3RhdGVcblx0XHQgKiBhcm91bmQgaXRzIGNlbnRlciwgeW91IHdvdWxkIHNldCByZWdYIGFuZCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3JlZ1k6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gdG8gNTAuXG5cdFx0ICogQHByb3BlcnR5IHJlZ1hcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5yZWdYID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHkgb2Zmc2V0IGZvciB0aGlzIGRpc3BsYXkgb2JqZWN0J3MgcmVnaXN0cmF0aW9uIHBvaW50LiBGb3IgZXhhbXBsZSwgdG8gbWFrZSBhIDEwMHgxMDBweCBCaXRtYXAgcm90YXRlIGFyb3VuZFxuXHRcdCAqIGl0cyBjZW50ZXIsIHlvdSB3b3VsZCBzZXQge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9yZWdYOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGFuZCByZWdZIHRvIDUwLlxuXHRcdCAqIEBwcm9wZXJ0eSByZWdZXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMucmVnWSA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSByb3RhdGlvbiBpbiBkZWdyZWVzIGZvciB0aGlzIGRpc3BsYXkgb2JqZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSByb3RhdGlvblxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLnJvdGF0aW9uID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGZhY3RvciB0byBzdHJldGNoIHRoaXMgZGlzcGxheSBvYmplY3QgaG9yaXpvbnRhbGx5LiBGb3IgZXhhbXBsZSwgc2V0dGluZyBzY2FsZVggdG8gMiB3aWxsIHN0cmV0Y2ggdGhlIGRpc3BsYXlcblx0XHQgKiBvYmplY3QgdG8gdHdpY2UgaXRzIG5vbWluYWwgd2lkdGguIFRvIGhvcml6b250YWxseSBmbGlwIGFuIG9iamVjdCwgc2V0IHRoZSBzY2FsZSB0byBhIG5lZ2F0aXZlIG51bWJlci5cblx0XHQgKiBAcHJvcGVydHkgc2NhbGVYXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICoqL1xuXHRcdHRoaXMuc2NhbGVYID0gMTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGZhY3RvciB0byBzdHJldGNoIHRoaXMgZGlzcGxheSBvYmplY3QgdmVydGljYWxseS4gRm9yIGV4YW1wbGUsIHNldHRpbmcgc2NhbGVZIHRvIDAuNSB3aWxsIHN0cmV0Y2ggdGhlIGRpc3BsYXlcblx0XHQgKiBvYmplY3QgdG8gaGFsZiBpdHMgbm9taW5hbCBoZWlnaHQuIFRvIHZlcnRpY2FsbHkgZmxpcCBhbiBvYmplY3QsIHNldCB0aGUgc2NhbGUgdG8gYSBuZWdhdGl2ZSBudW1iZXIuXG5cdFx0ICogQHByb3BlcnR5IHNjYWxlWVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqKi9cblx0XHR0aGlzLnNjYWxlWSA9IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBmYWN0b3IgdG8gc2tldyB0aGlzIGRpc3BsYXkgb2JqZWN0IGhvcml6b250YWxseS5cblx0XHQgKiBAcHJvcGVydHkgc2tld1hcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5za2V3WCA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBmYWN0b3IgdG8gc2tldyB0aGlzIGRpc3BsYXkgb2JqZWN0IHZlcnRpY2FsbHkuXG5cdFx0ICogQHByb3BlcnR5IHNrZXdZXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMuc2tld1kgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBBIHNoYWRvdyBvYmplY3QgdGhhdCBkZWZpbmVzIHRoZSBzaGFkb3cgdG8gcmVuZGVyIG9uIHRoaXMgZGlzcGxheSBvYmplY3QuIFNldCB0byBgbnVsbGAgdG8gcmVtb3ZlIGEgc2hhZG93LiBJZlxuXHRcdCAqIG51bGwsIHRoaXMgcHJvcGVydHkgaXMgaW5oZXJpdGVkIGZyb20gdGhlIHBhcmVudCBjb250YWluZXIuXG5cdFx0ICogQHByb3BlcnR5IHNoYWRvd1xuXHRcdCAqIEB0eXBlIHtTaGFkb3d9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqKi9cblx0XHR0aGlzLnNoYWRvdyA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgZGlzcGxheSBvYmplY3Qgc2hvdWxkIGJlIHJlbmRlcmVkIHRvIHRoZSBjYW52YXMgYW5kIGluY2x1ZGVkIHdoZW4gcnVubmluZyB0aGUgU3RhZ2Vcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJTdGFnZS9nZXRPYmplY3RzVW5kZXJQb2ludFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG5cdFx0ICogQHByb3BlcnR5IHZpc2libGVcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICoqL1xuXHRcdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSB4IChob3Jpem9udGFsKSBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheSBvYmplY3QsIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQuXG5cdFx0ICogQHByb3BlcnR5IHhcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy54ID0gMDtcblx0XG5cdFx0LyoqIFRoZSB5ICh2ZXJ0aWNhbCkgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXkgb2JqZWN0LCByZWxhdGl2ZSB0byBpdHMgcGFyZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSB5XG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMueSA9IDA7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSWYgc2V0LCBkZWZpbmVzIHRoZSB0cmFuc2Zvcm1hdGlvbiBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdCwgb3ZlcnJpZGluZyBhbGwgb3RoZXIgdHJhbnNmb3JtYXRpb24gcHJvcGVydGllc1xuXHRcdCAqICh4LCB5LCByb3RhdGlvbiwgc2NhbGUsIHNrZXcpLlxuXHRcdCAqIEBwcm9wZXJ0eSB0cmFuc2Zvcm1NYXRyaXhcblx0XHQgKiBAdHlwZSB7TWF0cml4MkR9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqKi9cblx0XHR0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGNvbXBvc2l0ZSBvcGVyYXRpb24gaW5kaWNhdGVzIGhvdyB0aGUgcGl4ZWxzIG9mIHRoaXMgZGlzcGxheSBvYmplY3Qgd2lsbCBiZSBjb21wb3NpdGVkIHdpdGggdGhlIGVsZW1lbnRzXG5cdFx0ICogYmVoaW5kIGl0LiBJZiBgbnVsbGAsIHRoaXMgcHJvcGVydHkgaXMgaW5oZXJpdGVkIGZyb20gdGhlIHBhcmVudCBjb250YWluZXIuIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWFkIHRoZVxuXHRcdCAqIDxhIGhyZWY9XCJodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCNjb21wb3NpdGluZ1wiPlxuXHRcdCAqIHdoYXR3ZyBzcGVjIG9uIGNvbXBvc2l0aW5nPC9hPi5cblx0XHQgKiBAcHJvcGVydHkgY29tcG9zaXRlT3BlcmF0aW9uXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHNob3VsZCBiZSBkcmF3biB0byBhIHdob2xlIHBpeGVsIHdoZW5cblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJTdGFnZS9zbmFwVG9QaXhlbEVuYWJsZWRcIn19e3svY3Jvc3NMaW5rfX0gaXMgdHJ1ZS4gVG8gZW5hYmxlL2Rpc2FibGUgc25hcHBpbmcgb24gd2hvbGVcblx0XHQgKiBjYXRlZ29yaWVzIG9mIGRpc3BsYXkgb2JqZWN0cywgc2V0IHRoaXMgdmFsdWUgb24gdGhlIHByb3RvdHlwZSAoRXguIFRleHQucHJvdG90eXBlLnNuYXBUb1BpeGVsID0gdHJ1ZSkuXG5cdFx0ICogQHByb3BlcnR5IHNuYXBUb1BpeGVsXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqKi9cblx0XHR0aGlzLnNuYXBUb1BpeGVsID0gdHJ1ZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgb2YgRmlsdGVyIG9iamVjdHMgdG8gYXBwbHkgdG8gdGhpcyBkaXNwbGF5IG9iamVjdC4gRmlsdGVycyBhcmUgb25seSBhcHBsaWVkIC8gdXBkYXRlZCB3aGVuIHt7I2Nyb3NzTGluayBcImNhY2hlXCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogb3Ige3sjY3Jvc3NMaW5rIFwidXBkYXRlQ2FjaGVcIn19e3svY3Jvc3NMaW5rfX0gaXMgY2FsbGVkIG9uIHRoZSBkaXNwbGF5IG9iamVjdCwgYW5kIG9ubHkgYXBwbHkgdG8gdGhlIGFyZWEgdGhhdCBpc1xuXHRcdCAqIGNhY2hlZC5cblx0XHQgKiBAcHJvcGVydHkgZmlsdGVyc1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMuZmlsdGVycyA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQSBTaGFwZSBpbnN0YW5jZSB0aGF0IGRlZmluZXMgYSB2ZWN0b3IgbWFzayAoY2xpcHBpbmcgcGF0aCkgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QuICBUaGUgc2hhcGUncyB0cmFuc2Zvcm1hdGlvblxuXHRcdCAqIHdpbGwgYmUgYXBwbGllZCByZWxhdGl2ZSB0byB0aGUgZGlzcGxheSBvYmplY3QncyBwYXJlbnQgY29vcmRpbmF0ZXMgKGFzIGlmIGl0IHdlcmUgYSBjaGlsZCBvZiB0aGUgcGFyZW50KS5cblx0XHQgKiBAcHJvcGVydHkgbWFza1xuXHRcdCAqIEB0eXBlIHtTaGFwZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5tYXNrID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBBIGRpc3BsYXkgb2JqZWN0IHRoYXQgd2lsbCBiZSB0ZXN0ZWQgd2hlbiBjaGVja2luZyBtb3VzZSBpbnRlcmFjdGlvbnMgb3IgdGVzdGluZyB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvZ2V0T2JqZWN0c1VuZGVyUG9pbnRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogVGhlIGhpdCBhcmVhIHdpbGwgaGF2ZSBpdHMgdHJhbnNmb3JtYXRpb24gYXBwbGllZCByZWxhdGl2ZSB0byB0aGlzIGRpc3BsYXkgb2JqZWN0J3MgY29vcmRpbmF0ZSBzcGFjZSAoYXMgdGhvdWdoXG5cdFx0ICogdGhlIGhpdCB0ZXN0IG9iamVjdCB3ZXJlIGEgY2hpbGQgb2YgdGhpcyBkaXNwbGF5IG9iamVjdCBhbmQgcmVsYXRpdmUgdG8gaXRzIHJlZ1gvWSkuIFRoZSBoaXRBcmVhIHdpbGwgYmUgdGVzdGVkXG5cdFx0ICogdXNpbmcgb25seSBpdHMgb3duIGBhbHBoYWAgdmFsdWUgcmVnYXJkbGVzcyBvZiB0aGUgYWxwaGEgdmFsdWUgb24gdGhlIHRhcmdldCBkaXNwbGF5IG9iamVjdCwgb3IgdGhlIHRhcmdldCdzXG5cdFx0ICogYW5jZXN0b3JzIChwYXJlbnRzKS5cblx0XHQgKiBcblx0XHQgKiBJZiBzZXQgb24gYSB7eyNjcm9zc0xpbmsgXCJDb250YWluZXJcIn19e3svY3Jvc3NMaW5rfX0sIGNoaWxkcmVuIG9mIHRoZSBDb250YWluZXIgd2lsbCBub3QgcmVjZWl2ZSBtb3VzZSBldmVudHMuXG5cdFx0ICogVGhpcyBpcyBzaW1pbGFyIHRvIHNldHRpbmcge3sjY3Jvc3NMaW5rIFwibW91c2VDaGlsZHJlblwifX17ey9jcm9zc0xpbmt9fSB0byBmYWxzZS5cblx0XHQgKlxuXHRcdCAqIE5vdGUgdGhhdCBoaXRBcmVhIGlzIE5PVCBjdXJyZW50bHkgdXNlZCBieSB0aGUgYGhpdFRlc3QoKWAgbWV0aG9kLCBub3IgaXMgaXQgc3VwcG9ydGVkIGZvciB7eyNjcm9zc0xpbmsgXCJTdGFnZVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgaGl0QXJlYVxuXHRcdCAqIEB0eXBlIHtEaXNwbGF5T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmhpdEFyZWEgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEEgQ1NTIGN1cnNvciAoZXguIFwicG9pbnRlclwiLCBcImhlbHBcIiwgXCJ0ZXh0XCIsIGV0YykgdGhhdCB3aWxsIGJlIGRpc3BsYXllZCB3aGVuIHRoZSB1c2VyIGhvdmVycyBvdmVyIHRoaXMgZGlzcGxheVxuXHRcdCAqIG9iamVjdC4gWW91IG11c3QgZW5hYmxlIG1vdXNlb3ZlciBldmVudHMgdXNpbmcgdGhlIHt7I2Nyb3NzTGluayBcIlN0YWdlL2VuYWJsZU1vdXNlT3ZlclwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgdG9cblx0XHQgKiB1c2UgdGhpcyBwcm9wZXJ0eS4gU2V0dGluZyBhIG5vbi1udWxsIGN1cnNvciBvbiBhIENvbnRhaW5lciB3aWxsIG92ZXJyaWRlIHRoZSBjdXJzb3Igc2V0IG9uIGl0cyBkZXNjZW5kYW50cy5cblx0XHQgKiBAcHJvcGVydHkgY3Vyc29yXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5jdXJzb3IgPSBudWxsO1xuXHRcblx0XG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2NhY2hlT2Zmc2V0WFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5fY2FjaGVPZmZzZXRYID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9jYWNoZU9mZnNldFlcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2NhY2hlT2Zmc2V0WSA9IDA7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9maWx0ZXJPZmZzZXRYXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLl9maWx0ZXJPZmZzZXRYID0gMDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2ZpbHRlck9mZnNldFlcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2ZpbHRlck9mZnNldFkgPSAwO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfY2FjaGVTY2FsZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKiovXG5cdFx0dGhpcy5fY2FjaGVTY2FsZSA9IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCogQHByb3BlcnR5IF9jYWNoZURhdGFVUkxJRFxuXHRcdCogQHByb3RlY3RlZFxuXHRcdCogQHR5cGUge051bWJlcn1cblx0XHQqIEBkZWZhdWx0IDBcblx0XHQqL1xuXHRcdHRoaXMuX2NhY2hlRGF0YVVSTElEID0gMDtcblx0XHRcblx0XHQvKipcblx0XHQqIEBwcm9wZXJ0eSBfY2FjaGVEYXRhVVJMXG5cdFx0KiBAcHJvdGVjdGVkXG5cdFx0KiBAdHlwZSB7U3RyaW5nfVxuXHRcdCogQGRlZmF1bHQgbnVsbFxuXHRcdCovXG5cdFx0dGhpcy5fY2FjaGVEYXRhVVJMID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9wcm9wc1xuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7RGlzcGxheU9iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3Byb3BzID0gbmV3IGNyZWF0ZWpzLkRpc3BsYXlQcm9wcygpO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3JlY3RhbmdsZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7UmVjdGFuZ2xlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiovXG5cdFx0dGhpcy5fcmVjdGFuZ2xlID0gbmV3IGNyZWF0ZWpzLlJlY3RhbmdsZSgpO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2JvdW5kc1xuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7UmVjdGFuZ2xlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiovXG5cdFx0dGhpcy5fYm91bmRzID0gbnVsbDtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChEaXNwbGF5T2JqZWN0LCBjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXHRcbi8vIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogTGlzdGluZyBvZiBtb3VzZSBldmVudCBuYW1lcy4gVXNlZCBpbiBfaGFzTW91c2VFdmVudExpc3RlbmVyLlxuXHQgKiBAcHJvcGVydHkgX01PVVNFX0VWRU5UU1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiovXG5cdERpc3BsYXlPYmplY3QuX01PVVNFX0VWRU5UUyA9IFtcImNsaWNrXCIsXCJkYmxjbGlja1wiLFwibW91c2Vkb3duXCIsXCJtb3VzZW91dFwiLFwibW91c2VvdmVyXCIsXCJwcmVzc21vdmVcIixcInByZXNzdXBcIixcInJvbGxvdXRcIixcInJvbGxvdmVyXCJdO1xuXG5cdC8qKlxuXHQgKiBTdXBwcmVzc2VzIGVycm9ycyBnZW5lcmF0ZWQgd2hlbiB1c2luZyBmZWF0dXJlcyBsaWtlIGhpdFRlc3QsIG1vdXNlIGV2ZW50cywgYW5kIHt7I2Nyb3NzTGluayBcImdldE9iamVjdHNVbmRlclBvaW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdpdGggY3Jvc3MgZG9tYWluIGNvbnRlbnQuXG5cdCAqIEBwcm9wZXJ0eSBzdXBwcmVzc0Nyb3NzRG9tYWluRXJyb3JzXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBkZWZhdWx0IGZhbHNlXG5cdCAqKi9cblx0RGlzcGxheU9iamVjdC5zdXBwcmVzc0Nyb3NzRG9tYWluRXJyb3JzID0gZmFsc2U7XG5cdFxuXHQvKipcblx0ICogQHByb3BlcnR5IF9zbmFwVG9QaXhlbEVuYWJsZWRcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAZGVmYXVsdCBmYWxzZVxuXHQgKiovXG5cdERpc3BsYXlPYmplY3QuX3NuYXBUb1BpeGVsRW5hYmxlZCA9IGZhbHNlOyAvLyBzdGFnZS5zbmFwVG9QaXhlbEVuYWJsZWQgaXMgdGVtcG9yYXJpbHkgY29waWVkIGhlcmUgZHVyaW5nIGEgZHJhdyB0byBwcm92aWRlIGdsb2JhbCBhY2Nlc3MuXG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfaGl0VGVzdENhbnZhc1xuXHQgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnQgfCBPYmplY3R9XG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX2hpdFRlc3RDb250ZXh0XG5cdCAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHZhciBjYW52YXMgPSBjcmVhdGVqcy5jcmVhdGVDYW52YXM/Y3JlYXRlanMuY3JlYXRlQ2FudmFzKCk6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTsgLy8gcHJldmVudCBlcnJvcnMgb24gbG9hZCBpbiBicm93c2VycyB3aXRob3V0IGNhbnZhcy5cblx0aWYgKGNhbnZhcy5nZXRDb250ZXh0KSB7XG5cdFx0RGlzcGxheU9iamVjdC5faGl0VGVzdENhbnZhcyA9IGNhbnZhcztcblx0XHREaXNwbGF5T2JqZWN0Ll9oaXRUZXN0Q29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0Y2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDE7XG5cdH1cblxuXHQvKipcblx0ICogQHByb3BlcnR5IF9uZXh0Q2FjaGVJRFxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHREaXNwbGF5T2JqZWN0Ll9uZXh0Q2FjaGVJRCA9IDE7XG5cblxuLy8gZXZlbnRzOlxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgdGhlaXIgbGVmdCBtb3VzZSBidXR0b24gb3ZlciB0aGUgZGlzcGxheSBvYmplY3QuIFNlZSB0aGUgXG5cdCAqIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxuXHQgKiBAZXZlbnQgbW91c2Vkb3duXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgdGhlaXIgbGVmdCBtb3VzZSBidXR0b24gYW5kIHRoZW4gcmVsZWFzZXMgaXQgd2hpbGUgb3ZlciB0aGUgZGlzcGxheSBvYmplY3QuXG5cdCAqIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXG5cdCAqIEBldmVudCBjbGlja1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgdXNlciBkb3VibGUgY2xpY2tzIHRoZWlyIGxlZnQgbW91c2UgYnV0dG9uIG92ZXIgdGhpcyBkaXNwbGF5IG9iamVjdC5cblx0ICogU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cblx0ICogQGV2ZW50IGRibGNsaWNrXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSB1c2VyJ3MgbW91c2UgZW50ZXJzIHRoaXMgZGlzcGxheSBvYmplY3QuIFRoaXMgZXZlbnQgbXVzdCBiZSBlbmFibGVkIHVzaW5nIFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTdGFnZS9lbmFibGVNb3VzZU92ZXJcIn19e3svY3Jvc3NMaW5rfX0uIFNlZSBhbHNvIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3Qvcm9sbG92ZXI6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXG5cdCAqIEBldmVudCBtb3VzZW92ZXJcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHVzZXIncyBtb3VzZSBsZWF2ZXMgdGhpcyBkaXNwbGF5IG9iamVjdC4gVGhpcyBldmVudCBtdXN0IGJlIGVuYWJsZWQgdXNpbmcgXG5cdCAqIHt7I2Nyb3NzTGluayBcIlN0YWdlL2VuYWJsZU1vdXNlT3ZlclwifX17ey9jcm9zc0xpbmt9fS4gU2VlIGFsc28ge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9yb2xsb3V0OmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxuXHQgKiBAZXZlbnQgbW91c2VvdXRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBUaGlzIGV2ZW50IGlzIHNpbWlsYXIgdG8ge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9tb3VzZW92ZXI6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0sIHdpdGggdGhlIGZvbGxvd2luZ1xuXHQgKiBkaWZmZXJlbmNlczogaXQgZG9lcyBub3QgYnViYmxlLCBhbmQgaXQgY29uc2lkZXJzIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lclwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZXMgYXMgYW5cblx0ICogYWdncmVnYXRlIG9mIHRoZWlyIGNvbnRlbnQuXG5cdCAqIFxuXHQgKiBGb3IgZXhhbXBsZSwgbXlDb250YWluZXIgY29udGFpbnMgdHdvIG92ZXJsYXBwaW5nIGNoaWxkcmVuOiBzaGFwZUEgYW5kIHNoYXBlQi4gVGhlIHVzZXIgbW92ZXMgdGhlaXIgbW91c2Ugb3ZlclxuXHQgKiBzaGFwZUEgYW5kIHRoZW4gZGlyZWN0bHkgb24gdG8gc2hhcGVCLiBXaXRoIGEgbGlzdGVuZXIgZm9yIHt7I2Nyb3NzTGluayBcIm1vdXNlb3ZlcjpldmVudFwifX17ey9jcm9zc0xpbmt9fSBvblxuXHQgKiBteUNvbnRhaW5lciwgdHdvIGV2ZW50cyB3b3VsZCBiZSByZWNlaXZlZCwgZWFjaCB0YXJnZXRpbmcgYSBjaGlsZCBlbGVtZW50OjxPTD5cblx0ICogPExJPndoZW4gdGhlIG1vdXNlIGVudGVycyBzaGFwZUEgKHRhcmdldD1zaGFwZUEpPC9MST5cblx0ICogPExJPndoZW4gdGhlIG1vdXNlIGVudGVycyBzaGFwZUIgKHRhcmdldD1zaGFwZUIpPC9MST5cblx0ICogPC9PTD5cblx0ICogSG93ZXZlciwgd2l0aCBhIGxpc3RlbmVyIGZvciBcInJvbGxvdmVyXCIgaW5zdGVhZCwgb25seSBhIHNpbmdsZSBldmVudCBpcyByZWNlaXZlZCB3aGVuIHRoZSBtb3VzZSBmaXJzdCBlbnRlcnNcblx0ICogdGhlIGFnZ3JlZ2F0ZSBteUNvbnRhaW5lciBjb250ZW50ICh0YXJnZXQ9bXlDb250YWluZXIpLlxuXHQgKiBcblx0ICogVGhpcyBldmVudCBtdXN0IGJlIGVuYWJsZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvZW5hYmxlTW91c2VPdmVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxuXHQgKiBAZXZlbnQgcm9sbG92ZXJcblx0ICogQHNpbmNlIDAuNy4wXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBUaGlzIGV2ZW50IGlzIHNpbWlsYXIgdG8ge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9tb3VzZW91dDpldmVudFwifX17ey9jcm9zc0xpbmt9fSwgd2l0aCB0aGUgZm9sbG93aW5nXG5cdCAqIGRpZmZlcmVuY2VzOiBpdCBkb2VzIG5vdCBidWJibGUsIGFuZCBpdCBjb25zaWRlcnMge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlcyBhcyBhblxuXHQgKiBhZ2dyZWdhdGUgb2YgdGhlaXIgY29udGVudC5cblx0ICogXG5cdCAqIEZvciBleGFtcGxlLCBteUNvbnRhaW5lciBjb250YWlucyB0d28gb3ZlcmxhcHBpbmcgY2hpbGRyZW46IHNoYXBlQSBhbmQgc2hhcGVCLiBUaGUgdXNlciBtb3ZlcyB0aGVpciBtb3VzZSBvdmVyXG5cdCAqIHNoYXBlQSwgdGhlbiBkaXJlY3RseSBvbiB0byBzaGFwZUIsIHRoZW4gb2ZmIGJvdGguIFdpdGggYSBsaXN0ZW5lciBmb3Ige3sjY3Jvc3NMaW5rIFwibW91c2VvdXQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogb24gbXlDb250YWluZXIsIHR3byBldmVudHMgd291bGQgYmUgcmVjZWl2ZWQsIGVhY2ggdGFyZ2V0aW5nIGEgY2hpbGQgZWxlbWVudDo8T0w+XG5cdCAqIDxMST53aGVuIHRoZSBtb3VzZSBsZWF2ZXMgc2hhcGVBICh0YXJnZXQ9c2hhcGVBKTwvTEk+XG5cdCAqIDxMST53aGVuIHRoZSBtb3VzZSBsZWF2ZXMgc2hhcGVCICh0YXJnZXQ9c2hhcGVCKTwvTEk+XG5cdCAqIDwvT0w+XG5cdCAqIEhvd2V2ZXIsIHdpdGggYSBsaXN0ZW5lciBmb3IgXCJyb2xsb3V0XCIgaW5zdGVhZCwgb25seSBhIHNpbmdsZSBldmVudCBpcyByZWNlaXZlZCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXNcblx0ICogdGhlIGFnZ3JlZ2F0ZSBteUNvbnRhaW5lciBjb250ZW50ICh0YXJnZXQ9bXlDb250YWluZXIpLlxuXHQgKiBcblx0ICogVGhpcyBldmVudCBtdXN0IGJlIGVuYWJsZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvZW5hYmxlTW91c2VPdmVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxuXHQgKiBAZXZlbnQgcm9sbG91dFxuXHQgKiBAc2luY2UgMC43LjBcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIEFmdGVyIGEge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9tb3VzZWRvd246ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gb2NjdXJzIG9uIGEgZGlzcGxheSBvYmplY3QsIGEgcHJlc3Ntb3ZlXG5cdCAqIGV2ZW50IHdpbGwgYmUgZ2VuZXJhdGVkIG9uIHRoYXQgb2JqZWN0IHdoZW5ldmVyIHRoZSBtb3VzZSBtb3ZlcyB1bnRpbCB0aGUgbW91c2UgcHJlc3MgaXMgcmVsZWFzZWQuIFRoaXMgY2FuIGJlXG5cdCAqIHVzZWZ1bCBmb3IgZHJhZ2dpbmcgYW5kIHNpbWlsYXIgb3BlcmF0aW9ucy5cblx0ICogQGV2ZW50IHByZXNzbW92ZVxuXHQgKiBAc2luY2UgMC43LjBcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIEFmdGVyIGEge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9tb3VzZWRvd246ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gb2NjdXJzIG9uIGEgZGlzcGxheSBvYmplY3QsIGEgcHJlc3N1cCBldmVudFxuXHQgKiB3aWxsIGJlIGdlbmVyYXRlZCBvbiB0aGF0IG9iamVjdCB3aGVuIHRoYXQgbW91c2UgcHJlc3MgaXMgcmVsZWFzZWQuIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3IgZHJhZ2dpbmcgYW5kIHNpbWlsYXJcblx0ICogb3BlcmF0aW9ucy5cblx0ICogQGV2ZW50IHByZXNzdXBcblx0ICogQHNpbmNlIDAuNy4wXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIGRpc3BsYXkgb2JqZWN0IGlzIGFkZGVkIHRvIGEgcGFyZW50IGNvbnRhaW5lci5cblx0ICogQGV2ZW50IGFkZGVkXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIGRpc3BsYXkgb2JqZWN0IGlzIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50IGNvbnRhaW5lci5cblx0ICogQGV2ZW50IHJlbW92ZWRcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgb24gZWFjaCBkaXNwbGF5IG9iamVjdCBvbiBhIHN0YWdlIHdoZW5ldmVyIHRoZSBzdGFnZSB1cGRhdGVzLiBUaGlzIG9jY3VycyBpbW1lZGlhdGVseSBiZWZvcmUgdGhlXG5cdCAqIHJlbmRlcmluZyAoZHJhdykgcGFzcy4gV2hlbiB7eyNjcm9zc0xpbmsgXCJTdGFnZS91cGRhdGVcIn19e3svY3Jvc3NMaW5rfX0gaXMgY2FsbGVkLCBmaXJzdCBhbGwgZGlzcGxheSBvYmplY3RzIG9uXG5cdCAqIHRoZSBzdGFnZSBkaXNwYXRjaCB0aGUgdGljayBldmVudCwgdGhlbiBhbGwgb2YgdGhlIGRpc3BsYXkgb2JqZWN0cyBhcmUgZHJhd24gdG8gc3RhZ2UuIENoaWxkcmVuIHdpbGwgaGF2ZSB0aGVpclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJ0aWNrOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IGRpc3BhdGNoZWQgaW4gb3JkZXIgb2YgdGhlaXIgZGVwdGggcHJpb3IgdG8gdGhlIGV2ZW50IGJlaW5nXG5cdCAqIGRpc3BhdGNoZWQgb24gdGhlaXIgcGFyZW50LlxuXHQgKiBAZXZlbnQgdGlja1xuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBBbiBhcnJheSBjb250YWluaW5nIGFueSBhcmd1bWVudHMgdGhhdCB3ZXJlIHBhc3NlZCB0byB0aGUgU3RhZ2UudXBkYXRlKCkgbWV0aG9kLiBGb3Jcblx0ICogICAgICBleGFtcGxlIGlmIHlvdSBjYWxsZWQgc3RhZ2UudXBkYXRlKFwiaGVsbG9cIiksIHRoZW4gdGhlIHBhcmFtcyB3b3VsZCBiZSBbXCJoZWxsb1wiXS5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRcblx0XG4vLyBnZXR0ZXIgLyBzZXR0ZXJzOlxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3N0YWdlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2QgZ2V0U3RhZ2Vcblx0ICogQHJldHVybiB7U3RhZ2V9XG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0cC5nZXRTdGFnZSA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHVzZXMgZHluYW1pYyBhY2Nlc3MgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzO1xuXHRcdHZhciBvID0gdGhpcywgX1N0YWdlID0gY3JlYXRlanNbXCJTdGFnZVwiXTtcblx0XHR3aGlsZSAoby5wYXJlbnQpIHsgbyA9IG8ucGFyZW50OyB9XG5cdFx0aWYgKG8gaW5zdGFuY2VvZiBfU3RhZ2UpIHsgcmV0dXJuIG87IH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgU3RhZ2UgaW5zdGFuY2UgdGhhdCB0aGlzIGRpc3BsYXkgb2JqZWN0IHdpbGwgYmUgcmVuZGVyZWQgb24sIG9yIG51bGwgaWYgaXQgaGFzIG5vdCBiZWVuIGFkZGVkIHRvIG9uZS5cblx0ICogQHByb3BlcnR5IHN0YWdlXG5cdCAqIEB0eXBlIHtTdGFnZX1cblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cdFx0XHRzdGFnZTogeyBnZXQ6IHAuZ2V0U3RhZ2UgfVxuXHRcdH0pO1xuXHR9IGNhdGNoIChlKSB7fVxuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhcy5cblx0ICogVGhpcyBkb2VzIG5vdCBhY2NvdW50IGZvciB3aGV0aGVyIGl0IHdvdWxkIGJlIHZpc2libGUgd2l0aGluIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBzdGFnZS5cblx0ICpcblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGlzVmlzaWJsZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhc1xuXHQgKiovXG5cdHAuaXNWaXNpYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhKHRoaXMudmlzaWJsZSAmJiB0aGlzLmFscGhhID4gMCAmJiB0aGlzLnNjYWxlWCAhPSAwICYmIHRoaXMuc2NhbGVZICE9IDApO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyB0aGUgZGlzcGxheSBvYmplY3QgaW50byB0aGUgc3BlY2lmaWVkIGNvbnRleHQgaWdub3JpbmcgaXRzIHZpc2libGUsIGFscGhhLCBzaGFkb3csIGFuZCB0cmFuc2Zvcm0uXG5cdCAqIFJldHVybnMgPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhlIGRyYXcgd2FzIGhhbmRsZWQgKHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyBmdW5jdGlvbmFsaXR5KS5cblx0ICpcblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGRyYXdcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIGNvbnRleHQgb2JqZWN0IHRvIGRyYXcgaW50by5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbaWdub3JlQ2FjaGU9ZmFsc2VdIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkcmF3IG9wZXJhdGlvbiBzaG91bGQgaWdub3JlIGFueSBjdXJyZW50IGNhY2hlLiBGb3IgZXhhbXBsZSxcblx0ICogdXNlZCBmb3IgZHJhd2luZyB0aGUgY2FjaGUgKHRvIHByZXZlbnQgaXQgZnJvbSBzaW1wbHkgZHJhd2luZyBhbiBleGlzdGluZyBjYWNoZSBiYWNrIGludG8gaXRzZWxmKS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICoqL1xuXHRwLmRyYXcgPSBmdW5jdGlvbihjdHgsIGlnbm9yZUNhY2hlKSB7XG5cdFx0dmFyIGNhY2hlQ2FudmFzID0gdGhpcy5jYWNoZUNhbnZhcztcblx0XHRpZiAoaWdub3JlQ2FjaGUgfHwgIWNhY2hlQ2FudmFzKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHZhciBzY2FsZSA9IHRoaXMuX2NhY2hlU2NhbGU7XG5cdFx0Y3R4LmRyYXdJbWFnZShjYWNoZUNhbnZhcywgdGhpcy5fY2FjaGVPZmZzZXRYK3RoaXMuX2ZpbHRlck9mZnNldFgsIHRoaXMuX2NhY2hlT2Zmc2V0WSt0aGlzLl9maWx0ZXJPZmZzZXRZLCBjYWNoZUNhbnZhcy53aWR0aC9zY2FsZSwgY2FjaGVDYW52YXMuaGVpZ2h0L3NjYWxlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBBcHBsaWVzIHRoaXMgZGlzcGxheSBvYmplY3QncyB0cmFuc2Zvcm1hdGlvbiwgYWxwaGEsIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiwgY2xpcHBpbmcgcGF0aCAobWFzayksIGFuZCBzaGFkb3dcblx0ICogdG8gdGhlIHNwZWNpZmllZCBjb250ZXh0LiBUaGlzIGlzIHR5cGljYWxseSBjYWxsZWQgcHJpb3IgdG8ge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9kcmF3XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIHVwZGF0ZUNvbnRleHRcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIHRvIHVwZGF0ZS5cblx0ICoqL1xuXHRwLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihjdHgpIHtcblx0XHR2YXIgbz10aGlzLCBtYXNrPW8ubWFzaywgbXR4PSBvLl9wcm9wcy5tYXRyaXg7XG5cdFx0XG5cdFx0aWYgKG1hc2sgJiYgbWFzay5ncmFwaGljcyAmJiAhbWFzay5ncmFwaGljcy5pc0VtcHR5KCkpIHtcblx0XHRcdG1hc2suZ2V0TWF0cml4KG10eCk7XG5cdFx0XHRjdHgudHJhbnNmb3JtKG10eC5hLCAgbXR4LmIsIG10eC5jLCBtdHguZCwgbXR4LnR4LCBtdHgudHkpO1xuXHRcdFx0XG5cdFx0XHRtYXNrLmdyYXBoaWNzLmRyYXdBc1BhdGgoY3R4KTtcblx0XHRcdGN0eC5jbGlwKCk7XG5cdFx0XHRcblx0XHRcdG10eC5pbnZlcnQoKTtcblx0XHRcdGN0eC50cmFuc2Zvcm0obXR4LmEsICBtdHguYiwgbXR4LmMsIG10eC5kLCBtdHgudHgsIG10eC50eSk7XG5cdFx0fVxuXHRcdFxuXHRcdHRoaXMuZ2V0TWF0cml4KG10eCk7XG5cdFx0dmFyIHR4ID0gbXR4LnR4LCB0eSA9IG10eC50eTtcblx0XHRpZiAoRGlzcGxheU9iamVjdC5fc25hcFRvUGl4ZWxFbmFibGVkICYmIG8uc25hcFRvUGl4ZWwpIHtcblx0XHRcdHR4ID0gdHggKyAodHggPCAwID8gLTAuNSA6IDAuNSkgfCAwO1xuXHRcdFx0dHkgPSB0eSArICh0eSA8IDAgPyAtMC41IDogMC41KSB8IDA7XG5cdFx0fVxuXHRcdGN0eC50cmFuc2Zvcm0obXR4LmEsICBtdHguYiwgbXR4LmMsIG10eC5kLCB0eCwgdHkpO1xuXHRcdGN0eC5nbG9iYWxBbHBoYSAqPSBvLmFscGhhO1xuXHRcdGlmIChvLmNvbXBvc2l0ZU9wZXJhdGlvbikgeyBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gby5jb21wb3NpdGVPcGVyYXRpb247IH1cblx0XHRpZiAoby5zaGFkb3cpIHsgdGhpcy5fYXBwbHlTaGFkb3coY3R4LCBvLnNoYWRvdyk7IH1cblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgdGhlIGRpc3BsYXkgb2JqZWN0IGludG8gYSBuZXcgY2FudmFzLCB3aGljaCBpcyB0aGVuIHVzZWQgZm9yIHN1YnNlcXVlbnQgZHJhd3MuIEZvciBjb21wbGV4IGNvbnRlbnRcblx0ICogdGhhdCBkb2VzIG5vdCBjaGFuZ2UgZnJlcXVlbnRseSAoZXguIGEgQ29udGFpbmVyIHdpdGggbWFueSBjaGlsZHJlbiB0aGF0IGRvIG5vdCBtb3ZlLCBvciBhIGNvbXBsZXggdmVjdG9yIFNoYXBlKSxcblx0ICogdGhpcyBjYW4gcHJvdmlkZSBmb3IgbXVjaCBmYXN0ZXIgcmVuZGVyaW5nIGJlY2F1c2UgdGhlIGNvbnRlbnQgZG9lcyBub3QgbmVlZCB0byBiZSByZS1yZW5kZXJlZCBlYWNoIHRpY2suIFRoZVxuXHQgKiBjYWNoZWQgZGlzcGxheSBvYmplY3QgY2FuIGJlIG1vdmVkLCByb3RhdGVkLCBmYWRlZCwgZXRjIGZyZWVseSwgaG93ZXZlciBpZiBpdHMgY29udGVudCBjaGFuZ2VzLCB5b3UgbXVzdFxuXHQgKiBtYW51YWxseSB1cGRhdGUgdGhlIGNhY2hlIGJ5IGNhbGxpbmcgPGNvZGU+dXBkYXRlQ2FjaGUoKTwvY29kZT4gb3IgPGNvZGU+Y2FjaGUoKTwvY29kZT4gYWdhaW4uIFlvdSBtdXN0IHNwZWNpZnlcblx0ICogdGhlIGNhY2hlIGFyZWEgdmlhIHRoZSB4LCB5LCB3LCBhbmQgaCBwYXJhbWV0ZXJzLiBUaGlzIGRlZmluZXMgdGhlIHJlY3RhbmdsZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgYW5kIGNhY2hlZFxuXHQgKiB1c2luZyB0aGlzIGRpc3BsYXkgb2JqZWN0J3MgY29vcmRpbmF0ZXMuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogRm9yIGV4YW1wbGUgaWYgeW91IGRlZmluZWQgYSBTaGFwZSB0aGF0IGRyZXcgYSBjaXJjbGUgYXQgMCwgMCB3aXRoIGEgcmFkaXVzIG9mIDI1OlxuXHQgKlxuXHQgKiAgICAgIHZhciBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuXHQgKiAgICAgIHNoYXBlLmdyYXBoaWNzLmJlZ2luRmlsbChcIiNmZjAwMDBcIikuZHJhd0NpcmNsZSgwLCAwLCAyNSk7XG5cdCAqICAgICAgbXlTaGFwZS5jYWNoZSgtMjUsIC0yNSwgNTAsIDUwKTtcblx0ICpcblx0ICogTm90ZSB0aGF0IGZpbHRlcnMgbmVlZCB0byBiZSBkZWZpbmVkIDxlbT5iZWZvcmU8L2VtPiB0aGUgY2FjaGUgaXMgYXBwbGllZC4gQ2hlY2sgb3V0IHRoZSB7eyNjcm9zc0xpbmsgXCJGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogY2xhc3MgZm9yIG1vcmUgaW5mb3JtYXRpb24uIFNvbWUgZmlsdGVycyAoZXguIEJsdXJGaWx0ZXIpIHdpbGwgbm90IHdvcmsgYXMgZXhwZWN0ZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgc2NhbGUgcGFyYW0uXG5cdCAqIFxuXHQgKiBVc3VhbGx5LCB0aGUgcmVzdWx0aW5nIGNhY2hlQ2FudmFzIHdpbGwgaGF2ZSB0aGUgZGltZW5zaW9ucyB3aWR0aCpzY2FsZSBieSBoZWlnaHQqc2NhbGUsIGhvd2V2ZXIgc29tZSBmaWx0ZXJzIChleC4gQmx1ckZpbHRlcilcblx0ICogd2lsbCBhZGQgcGFkZGluZyB0byB0aGUgY2FudmFzIGRpbWVuc2lvbnMuXG5cdCAqXG5cdCAqIEBtZXRob2QgY2FjaGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggY29vcmRpbmF0ZSBvcmlnaW4gZm9yIHRoZSBjYWNoZSByZWdpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgb3JpZ2luIGZvciB0aGUgY2FjaGUgcmVnaW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSBjYWNoZSByZWdpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgY2FjaGUgcmVnaW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlPTFdIFRoZSBzY2FsZSBhdCB3aGljaCB0aGUgY2FjaGUgd2lsbCBiZSBjcmVhdGVkLiBGb3IgZXhhbXBsZSwgaWYgeW91IGNhY2hlIGEgdmVjdG9yIHNoYXBlIHVzaW5nXG5cdCAqIFx0bXlTaGFwZS5jYWNoZSgwLDAsMTAwLDEwMCwyKSB0aGVuIHRoZSByZXN1bHRpbmcgY2FjaGVDYW52YXMgd2lsbCBiZSAyMDB4MjAwIHB4LiBUaGlzIGxldHMgeW91IHNjYWxlIGFuZCByb3RhdGVcblx0ICogXHRjYWNoZWQgZWxlbWVudHMgd2l0aCBncmVhdGVyIGZpZGVsaXR5LiBEZWZhdWx0IGlzIDEuXG5cdCAqKi9cblx0cC5jYWNoZSA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQsIHNjYWxlKSB7XG5cdFx0Ly8gZHJhdyB0byBjYW52YXMuXG5cdFx0c2NhbGUgPSBzY2FsZXx8MTtcblx0XHRpZiAoIXRoaXMuY2FjaGVDYW52YXMpIHsgdGhpcy5jYWNoZUNhbnZhcyA9IGNyZWF0ZWpzLmNyZWF0ZUNhbnZhcz9jcmVhdGVqcy5jcmVhdGVDYW52YXMoKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpOyB9XG5cdFx0dGhpcy5fY2FjaGVXaWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuX2NhY2hlSGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHRoaXMuX2NhY2hlT2Zmc2V0WCA9IHg7XG5cdFx0dGhpcy5fY2FjaGVPZmZzZXRZID0geTtcblx0XHR0aGlzLl9jYWNoZVNjYWxlID0gc2NhbGU7XG5cdFx0dGhpcy51cGRhdGVDYWNoZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZWRyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCB0byBpdHMgY2FjaGUuIENhbGxpbmcgdXBkYXRlQ2FjaGUgd2l0aG91dCBhbiBhY3RpdmUgY2FjaGUgd2lsbCB0aHJvdyBhbiBlcnJvci5cblx0ICogSWYgY29tcG9zaXRlT3BlcmF0aW9uIGlzIG51bGwgdGhlIGN1cnJlbnQgY2FjaGUgd2lsbCBiZSBjbGVhcmVkIHByaW9yIHRvIGRyYXdpbmcuIE90aGVyd2lzZSB0aGUgZGlzcGxheSBvYmplY3Rcblx0ICogd2lsbCBiZSBkcmF3biBvdmVyIHRoZSBleGlzdGluZyBjYWNoZSB1c2luZyB0aGUgc3BlY2lmaWVkIGNvbXBvc2l0ZU9wZXJhdGlvbi5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBDbGVhciB0aGUgY3VycmVudCBncmFwaGljcyBvZiBhIGNhY2hlZCBzaGFwZSwgZHJhdyBzb21lIG5ldyBpbnN0cnVjdGlvbnMsIGFuZCB0aGVuIHVwZGF0ZSB0aGUgY2FjaGUuIFRoZSBuZXcgbGluZVxuXHQgKiB3aWxsIGJlIGRyYXduIG9uIHRvcCBvZiB0aGUgb2xkIG9uZS5cblx0ICpcblx0ICogICAgICAvLyBOb3Qgc2hvd246IENyZWF0aW5nIHRoZSBzaGFwZSwgYW5kIGNhY2hpbmcgaXQuXG5cdCAqICAgICAgc2hhcGVJbnN0YW5jZS5jbGVhcigpO1xuXHQgKiAgICAgIHNoYXBlSW5zdGFuY2Uuc2V0U3Ryb2tlU3R5bGUoMykuYmVnaW5TdHJva2UoXCIjZmYwMDAwXCIpLm1vdmVUbygxMDAsIDEwMCkubGluZVRvKDIwMCwyMDApO1xuXHQgKiAgICAgIHNoYXBlSW5zdGFuY2UudXBkYXRlQ2FjaGUoKTtcblx0ICpcblx0ICogQG1ldGhvZCB1cGRhdGVDYWNoZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9zaXRlT3BlcmF0aW9uIFRoZSBjb21wb3NpdGVPcGVyYXRpb24gdG8gdXNlLCBvciBudWxsIHRvIGNsZWFyIHRoZSBjYWNoZSBhbmQgcmVkcmF3IGl0LlxuXHQgKiA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjY29tcG9zaXRpbmdcIj5cblx0ICogd2hhdHdnIHNwZWMgb24gY29tcG9zaXRpbmc8L2E+LlxuXHQgKiovXG5cdHAudXBkYXRlQ2FjaGUgPSBmdW5jdGlvbihjb21wb3NpdGVPcGVyYXRpb24pIHtcblx0XHR2YXIgY2FjaGVDYW52YXMgPSB0aGlzLmNhY2hlQ2FudmFzO1xuXHRcdGlmICghY2FjaGVDYW52YXMpIHsgdGhyb3cgXCJjYWNoZSgpIG11c3QgYmUgY2FsbGVkIGJlZm9yZSB1cGRhdGVDYWNoZSgpXCI7IH1cblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9jYWNoZVNjYWxlLCBvZmZYID0gdGhpcy5fY2FjaGVPZmZzZXRYKnNjYWxlLCBvZmZZID0gdGhpcy5fY2FjaGVPZmZzZXRZKnNjYWxlO1xuXHRcdHZhciB3ID0gdGhpcy5fY2FjaGVXaWR0aCwgaCA9IHRoaXMuX2NhY2hlSGVpZ2h0LCBjdHggPSBjYWNoZUNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0XG5cdFx0dmFyIGZCb3VuZHMgPSB0aGlzLl9nZXRGaWx0ZXJCb3VuZHMoKTtcblx0XHRvZmZYICs9ICh0aGlzLl9maWx0ZXJPZmZzZXRYID0gZkJvdW5kcy54KTtcblx0XHRvZmZZICs9ICh0aGlzLl9maWx0ZXJPZmZzZXRZID0gZkJvdW5kcy55KTtcblx0XHRcblx0XHR3ID0gTWF0aC5jZWlsKHcqc2NhbGUpICsgZkJvdW5kcy53aWR0aDtcblx0XHRoID0gTWF0aC5jZWlsKGgqc2NhbGUpICsgZkJvdW5kcy5oZWlnaHQ7XG5cdFx0aWYgKHcgIT0gY2FjaGVDYW52YXMud2lkdGggfHwgaCAhPSBjYWNoZUNhbnZhcy5oZWlnaHQpIHtcblx0XHRcdC8vIFRPRE86IGl0IHdvdWxkIGJlIG5pY2UgdG8gcHJlc2VydmUgdGhlIGNvbnRlbnQgaWYgdGhlcmUgaXMgYSBjb21wb3NpdGVPcGVyYXRpb24uXG5cdFx0XHRjYWNoZUNhbnZhcy53aWR0aCA9IHc7XG5cdFx0XHRjYWNoZUNhbnZhcy5oZWlnaHQgPSBoO1xuXHRcdH0gZWxzZSBpZiAoIWNvbXBvc2l0ZU9wZXJhdGlvbikge1xuXHRcdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCB3KzEsIGgrMSk7XG5cdFx0fVxuXHRcdFxuXHRcdGN0eC5zYXZlKCk7XG5cdFx0Y3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGNvbXBvc2l0ZU9wZXJhdGlvbjtcblx0XHRjdHguc2V0VHJhbnNmb3JtKHNjYWxlLCAwLCAwLCBzY2FsZSwgLW9mZlgsIC1vZmZZKTtcblx0XHR0aGlzLmRyYXcoY3R4LCB0cnVlKTtcblx0XHQvLyBUT0RPOiBmaWx0ZXJzIGFuZCBjYWNoZSBzY2FsZSBkb24ndCBwbGF5IHdlbGwgdG9nZXRoZXIgYXQgcHJlc2VudC5cblx0XHR0aGlzLl9hcHBseUZpbHRlcnMoKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdHRoaXMuY2FjaGVJRCA9IERpc3BsYXlPYmplY3QuX25leHRDYWNoZUlEKys7XG5cdH07XG5cblx0LyoqXG5cdCAqIENsZWFycyB0aGUgY3VycmVudCBjYWNoZS4gU2VlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvY2FjaGVcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBtZXRob2QgdW5jYWNoZVxuXHQgKiovXG5cdHAudW5jYWNoZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2NhY2hlRGF0YVVSTCA9IHRoaXMuY2FjaGVDYW52YXMgPSBudWxsO1xuXHRcdHRoaXMuY2FjaGVJRCA9IHRoaXMuX2NhY2hlT2Zmc2V0WCA9IHRoaXMuX2NhY2hlT2Zmc2V0WSA9IHRoaXMuX2ZpbHRlck9mZnNldFggPSB0aGlzLl9maWx0ZXJPZmZzZXRZID0gMDtcblx0XHR0aGlzLl9jYWNoZVNjYWxlID0gMTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgZGF0YSBVUkwgZm9yIHRoZSBjYWNoZSwgb3IgbnVsbCBpZiB0aGlzIGRpc3BsYXkgb2JqZWN0IGlzIG5vdCBjYWNoZWQuXG5cdCAqIFVzZXMgY2FjaGVJRCB0byBlbnN1cmUgYSBuZXcgZGF0YSBVUkwgaXMgbm90IGdlbmVyYXRlZCBpZiB0aGUgY2FjaGUgaGFzIG5vdCBjaGFuZ2VkLlxuXHQgKiBAbWV0aG9kIGdldENhY2hlRGF0YVVSTFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBpbWFnZSBkYXRhIHVybCBmb3IgdGhlIGNhY2hlLlxuXHQgKiovXG5cdHAuZ2V0Q2FjaGVEYXRhVVJMID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmNhY2hlQ2FudmFzKSB7IHJldHVybiBudWxsOyB9XG5cdFx0aWYgKHRoaXMuY2FjaGVJRCAhPSB0aGlzLl9jYWNoZURhdGFVUkxJRCkgeyB0aGlzLl9jYWNoZURhdGFVUkwgPSB0aGlzLmNhY2hlQ2FudmFzLnRvRGF0YVVSTCgpOyB9XG5cdFx0cmV0dXJuIHRoaXMuX2NhY2hlRGF0YVVSTDtcblx0fTtcblxuXHQvKipcblx0ICogVHJhbnNmb3JtcyB0aGUgc3BlY2lmaWVkIHggYW5kIHkgcG9zaXRpb24gZnJvbSB0aGUgY29vcmRpbmF0ZSBzcGFjZSBvZiB0aGUgZGlzcGxheSBvYmplY3Rcblx0ICogdG8gdGhlIGdsb2JhbCAoc3RhZ2UpIGNvb3JkaW5hdGUgc3BhY2UuIEZvciBleGFtcGxlLCB0aGlzIGNvdWxkIGJlIHVzZWQgdG8gcG9zaXRpb24gYW4gSFRNTCBsYWJlbFxuXHQgKiBvdmVyIGEgc3BlY2lmaWMgcG9pbnQgb24gYSBuZXN0ZWQgZGlzcGxheSBvYmplY3QuIFJldHVybnMgYSBQb2ludCBpbnN0YW5jZSB3aXRoIHggYW5kIHkgcHJvcGVydGllc1xuXHQgKiBjb3JyZWxhdGluZyB0byB0aGUgdHJhbnNmb3JtZWQgY29vcmRpbmF0ZXMgb24gdGhlIHN0YWdlLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC54ID0gMzAwO1xuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QueSA9IDIwMDtcblx0ICogICAgICBzdGFnZS5hZGRDaGlsZChkaXNwbGF5T2JqZWN0KTtcblx0ICogICAgICB2YXIgcG9pbnQgPSBkaXNwbGF5T2JqZWN0LmxvY2FsVG9HbG9iYWwoMTAwLCAxMDApO1xuXHQgKiAgICAgIC8vIFJlc3VsdHMgaW4geD00MDAsIHk9MzAwXG5cdCAqXG5cdCAqIEBtZXRob2QgbG9jYWxUb0dsb2JhbFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBwb3NpdGlvbiBpbiB0aGUgc291cmNlIGRpc3BsYXkgb2JqZWN0IHRvIHRyYW5zZm9ybS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSBkaXNwbGF5IG9iamVjdCB0byB0cmFuc2Zvcm0uXG5cdCAqIEBwYXJhbSB7UG9pbnQgfCBPYmplY3R9IFtwdF0gQW4gb2JqZWN0IHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvLiBJZiBvbWl0dGVkIGEgbmV3IFBvaW50IG9iamVjdCB3aXRoIHgveSBwcm9wZXJ0aWVzIHdpbGwgYmUgcmV0dXJuZWQuIFxuXHQgKiBAcmV0dXJuIHtQb2ludH0gQSBQb2ludCBpbnN0YW5jZSB3aXRoIHggYW5kIHkgcHJvcGVydGllcyBjb3JyZWxhdGluZyB0byB0aGUgdHJhbnNmb3JtZWQgY29vcmRpbmF0ZXNcblx0ICogb24gdGhlIHN0YWdlLlxuXHQgKiovXG5cdHAubG9jYWxUb0dsb2JhbCA9IGZ1bmN0aW9uKHgsIHksIHB0KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q29uY2F0ZW5hdGVkTWF0cml4KHRoaXMuX3Byb3BzLm1hdHJpeCkudHJhbnNmb3JtUG9pbnQoeCx5LCBwdHx8bmV3IGNyZWF0ZWpzLlBvaW50KCkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUcmFuc2Zvcm1zIHRoZSBzcGVjaWZpZWQgeCBhbmQgeSBwb3NpdGlvbiBmcm9tIHRoZSBnbG9iYWwgKHN0YWdlKSBjb29yZGluYXRlIHNwYWNlIHRvIHRoZVxuXHQgKiBjb29yZGluYXRlIHNwYWNlIG9mIHRoZSBkaXNwbGF5IG9iamVjdC4gRm9yIGV4YW1wbGUsIHRoaXMgY291bGQgYmUgdXNlZCB0byBkZXRlcm1pbmVcblx0ICogdGhlIGN1cnJlbnQgbW91c2UgcG9zaXRpb24gd2l0aGluIHRoZSBkaXNwbGF5IG9iamVjdC4gUmV0dXJucyBhIFBvaW50IGluc3RhbmNlIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzXG5cdCAqIGNvcnJlbGF0aW5nIHRvIHRoZSB0cmFuc2Zvcm1lZCBwb3NpdGlvbiBpbiB0aGUgZGlzcGxheSBvYmplY3QncyBjb29yZGluYXRlIHNwYWNlLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC54ID0gMzAwO1xuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QueSA9IDIwMDtcblx0ICogICAgICBzdGFnZS5hZGRDaGlsZChkaXNwbGF5T2JqZWN0KTtcblx0ICogICAgICB2YXIgcG9pbnQgPSBkaXNwbGF5T2JqZWN0Lmdsb2JhbFRvTG9jYWwoMTAwLCAxMDApO1xuXHQgKiAgICAgIC8vIFJlc3VsdHMgaW4geD0tMjAwLCB5PS0xMDBcblx0ICpcblx0ICogQG1ldGhvZCBnbG9iYWxUb0xvY2FsXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIG9uIHRoZSBzdGFnZSB0byB0cmFuc2Zvcm0uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uIG9uIHRoZSBzdGFnZSB0byB0cmFuc2Zvcm0uXG5cdCAqIEBwYXJhbSB7UG9pbnQgfCBPYmplY3R9IFtwdF0gQW4gb2JqZWN0IHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvLiBJZiBvbWl0dGVkIGEgbmV3IFBvaW50IG9iamVjdCB3aXRoIHgveSBwcm9wZXJ0aWVzIHdpbGwgYmUgcmV0dXJuZWQuIFxuXHQgKiBAcmV0dXJuIHtQb2ludH0gQSBQb2ludCBpbnN0YW5jZSB3aXRoIHggYW5kIHkgcHJvcGVydGllcyBjb3JyZWxhdGluZyB0byB0aGUgdHJhbnNmb3JtZWQgcG9zaXRpb24gaW4gdGhlXG5cdCAqIGRpc3BsYXkgb2JqZWN0J3MgY29vcmRpbmF0ZSBzcGFjZS5cblx0ICoqL1xuXHRwLmdsb2JhbFRvTG9jYWwgPSBmdW5jdGlvbih4LCB5LCBwdCkge1xuXHRcdHJldHVybiB0aGlzLmdldENvbmNhdGVuYXRlZE1hdHJpeCh0aGlzLl9wcm9wcy5tYXRyaXgpLmludmVydCgpLnRyYW5zZm9ybVBvaW50KHgseSwgcHR8fG5ldyBjcmVhdGVqcy5Qb2ludCgpKTtcblx0fTtcblxuXHQvKipcblx0ICogVHJhbnNmb3JtcyB0aGUgc3BlY2lmaWVkIHggYW5kIHkgcG9zaXRpb24gZnJvbSB0aGUgY29vcmRpbmF0ZSBzcGFjZSBvZiB0aGlzIGRpc3BsYXkgb2JqZWN0IHRvIHRoZSBjb29yZGluYXRlXG5cdCAqIHNwYWNlIG9mIHRoZSB0YXJnZXQgZGlzcGxheSBvYmplY3QuIFJldHVybnMgYSBQb2ludCBpbnN0YW5jZSB3aXRoIHggYW5kIHkgcHJvcGVydGllcyBjb3JyZWxhdGluZyB0byB0aGVcblx0ICogdHJhbnNmb3JtZWQgcG9zaXRpb24gaW4gdGhlIHRhcmdldCdzIGNvb3JkaW5hdGUgc3BhY2UuIEVmZmVjdGl2ZWx5IHRoZSBzYW1lIGFzIHVzaW5nIHRoZSBmb2xsb3dpbmcgY29kZSB3aXRoXG5cdCAqIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbG9jYWxUb0dsb2JhbFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9nbG9iYWxUb0xvY2FsXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiAgICAgIHZhciBwdCA9IHRoaXMubG9jYWxUb0dsb2JhbCh4LCB5KTtcblx0ICogICAgICBwdCA9IHRhcmdldC5nbG9iYWxUb0xvY2FsKHB0LngsIHB0LnkpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIGxvY2FsVG9Mb2NhbFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBwb3NpdGlvbiBpbiB0aGUgc291cmNlIGRpc3BsYXkgb2JqZWN0IHRvIHRyYW5zZm9ybS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24gb24gdGhlIHNvdXJjZSBkaXNwbGF5IG9iamVjdCB0byB0cmFuc2Zvcm0uXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gdGFyZ2V0IFRoZSB0YXJnZXQgZGlzcGxheSBvYmplY3QgdG8gd2hpY2ggdGhlIGNvb3JkaW5hdGVzIHdpbGwgYmUgdHJhbnNmb3JtZWQuXG5cdCAqIEBwYXJhbSB7UG9pbnQgfCBPYmplY3R9IFtwdF0gQW4gb2JqZWN0IHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvLiBJZiBvbWl0dGVkIGEgbmV3IFBvaW50IG9iamVjdCB3aXRoIHgveSBwcm9wZXJ0aWVzIHdpbGwgYmUgcmV0dXJuZWQuIFxuXHQgKiBAcmV0dXJuIHtQb2ludH0gUmV0dXJucyBhIFBvaW50IGluc3RhbmNlIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzIGNvcnJlbGF0aW5nIHRvIHRoZSB0cmFuc2Zvcm1lZCBwb3NpdGlvblxuXHQgKiBpbiB0aGUgdGFyZ2V0J3MgY29vcmRpbmF0ZSBzcGFjZS5cblx0ICoqL1xuXHRwLmxvY2FsVG9Mb2NhbCA9IGZ1bmN0aW9uKHgsIHksIHRhcmdldCwgcHQpIHtcblx0XHRwdCA9IHRoaXMubG9jYWxUb0dsb2JhbCh4LCB5LCBwdCk7XG5cdFx0cmV0dXJuIHRhcmdldC5nbG9iYWxUb0xvY2FsKHB0LngsIHB0LnksIHB0KTtcblx0fTtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgbWV0aG9kIHRvIHF1aWNrbHkgc2V0IHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcyBvbiB0aGUgZGlzcGxheSBvYmplY3QuIEFsbCBwYXJhbWV0ZXJzIGFyZSBvcHRpb25hbC5cblx0ICogT21pdHRlZCBwYXJhbWV0ZXJzIHdpbGwgaGF2ZSB0aGUgZGVmYXVsdCB2YWx1ZSBzZXQuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnNldFRyYW5zZm9ybSgxMDAsIDEwMCwgMiwgMik7XG5cdCAqXG5cdCAqIEBtZXRob2Qgc2V0VHJhbnNmb3JtXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSBUaGUgaG9yaXpvbnRhbCB0cmFuc2xhdGlvbiAoeCBwb3NpdGlvbikgaW4gcGl4ZWxzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSBUaGUgdmVydGljYWwgdHJhbnNsYXRpb24gKHkgcG9zaXRpb24pIGluIHBpeGVsc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlWD0xXSBUaGUgaG9yaXpvbnRhbCBzY2FsZSwgYXMgYSBwZXJjZW50YWdlIG9mIDFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZVk9MV0gdGhlIHZlcnRpY2FsIHNjYWxlLCBhcyBhIHBlcmNlbnRhZ2Ugb2YgMVxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3JvdGF0aW9uPTBdIFRoZSByb3RhdGlvbiwgaW4gZGVncmVlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NrZXdYPTBdIFRoZSBob3Jpem9udGFsIHNrZXcgZmFjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2tld1k9MF0gVGhlIHZlcnRpY2FsIHNrZXcgZmFjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcmVnWD0wXSBUaGUgaG9yaXpvbnRhbCByZWdpc3RyYXRpb24gcG9pbnQgaW4gcGl4ZWxzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcmVnWT0wXSBUaGUgdmVydGljYWwgcmVnaXN0cmF0aW9uIHBvaW50IGluIHBpeGVsc1xuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBSZXR1cm5zIHRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgY29tbWFuZHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbih4LCB5LCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHNrZXdYLCBza2V3WSwgcmVnWCwgcmVnWSkge1xuXHRcdHRoaXMueCA9IHggfHwgMDtcblx0XHR0aGlzLnkgPSB5IHx8IDA7XG5cdFx0dGhpcy5zY2FsZVggPSBzY2FsZVggPT0gbnVsbCA/IDEgOiBzY2FsZVg7XG5cdFx0dGhpcy5zY2FsZVkgPSBzY2FsZVkgPT0gbnVsbCA/IDEgOiBzY2FsZVk7XG5cdFx0dGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uIHx8IDA7XG5cdFx0dGhpcy5za2V3WCA9IHNrZXdYIHx8IDA7XG5cdFx0dGhpcy5za2V3WSA9IHNrZXdZIHx8IDA7XG5cdFx0dGhpcy5yZWdYID0gcmVnWCB8fCAwO1xuXHRcdHRoaXMucmVnWSA9IHJlZ1kgfHwgMDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbWF0cml4IGJhc2VkIG9uIHRoaXMgb2JqZWN0J3MgY3VycmVudCB0cmFuc2Zvcm0uXG5cdCAqIEBtZXRob2QgZ2V0TWF0cml4XG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeCBPcHRpb25hbC4gQSBNYXRyaXgyRCBvYmplY3QgdG8gcG9wdWxhdGUgd2l0aCB0aGUgY2FsY3VsYXRlZCB2YWx1ZXMuIElmIG51bGwsIGEgbmV3XG5cdCAqIE1hdHJpeCBvYmplY3QgaXMgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBBIG1hdHJpeCByZXByZXNlbnRpbmcgdGhpcyBkaXNwbGF5IG9iamVjdCdzIHRyYW5zZm9ybS5cblx0ICoqL1xuXHRwLmdldE1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHZhciBvID0gdGhpcywgbXR4ID0gbWF0cml4JiZtYXRyaXguaWRlbnRpdHkoKSB8fCBuZXcgY3JlYXRlanMuTWF0cml4MkQoKTtcblx0XHRyZXR1cm4gby50cmFuc2Zvcm1NYXRyaXggPyAgbXR4LmNvcHkoby50cmFuc2Zvcm1NYXRyaXgpIDogbXR4LmFwcGVuZFRyYW5zZm9ybShvLngsIG8ueSwgby5zY2FsZVgsIG8uc2NhbGVZLCBvLnJvdGF0aW9uLCBvLnNrZXdYLCBvLnNrZXdZLCBvLnJlZ1gsIG8ucmVnWSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogR2VuZXJhdGVzIGEgTWF0cml4MkQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY29tYmluZWQgdHJhbnNmb3JtIG9mIHRoZSBkaXNwbGF5IG9iamVjdCBhbmQgYWxsIG9mIGl0c1xuXHQgKiBwYXJlbnQgQ29udGFpbmVycyB1cCB0byB0aGUgaGlnaGVzdCBsZXZlbCBhbmNlc3RvciAodXN1YWxseSB0aGUge3sjY3Jvc3NMaW5rIFwiU3RhZ2VcIn19e3svY3Jvc3NMaW5rfX0pLiBUaGlzIGNhblxuXHQgKiBiZSB1c2VkIHRvIHRyYW5zZm9ybSBwb3NpdGlvbnMgYmV0d2VlbiBjb29yZGluYXRlIHNwYWNlcywgc3VjaCBhcyB3aXRoIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbG9jYWxUb0dsb2JhbFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBhbmQge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9nbG9iYWxUb0xvY2FsXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGdldENvbmNhdGVuYXRlZE1hdHJpeFxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBbbWF0cml4XSBBIHt7I2Nyb3NzTGluayBcIk1hdHJpeDJEXCJ9fXt7L2Nyb3NzTGlua319IG9iamVjdCB0byBwb3B1bGF0ZSB3aXRoIHRoZSBjYWxjdWxhdGVkIHZhbHVlcy5cblx0ICogSWYgbnVsbCwgYSBuZXcgTWF0cml4MkQgb2JqZWN0IGlzIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhlIGNvbWJpbmVkIG1hdHJpeC5cblx0ICoqL1xuXHRwLmdldENvbmNhdGVuYXRlZE1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHZhciBvID0gdGhpcywgbXR4ID0gdGhpcy5nZXRNYXRyaXgobWF0cml4KTtcblx0XHR3aGlsZSAobyA9IG8ucGFyZW50KSB7XG5cdFx0XHRtdHgucHJlcGVuZE1hdHJpeChvLmdldE1hdHJpeChvLl9wcm9wcy5tYXRyaXgpKTtcblx0XHR9XG5cdFx0cmV0dXJuIG10eDtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgYSBEaXNwbGF5UHJvcHMgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY29tYmluZWQgZGlzcGxheSBwcm9wZXJ0aWVzIG9mIHRoZSAgb2JqZWN0IGFuZCBhbGwgb2YgaXRzXG5cdCAqIHBhcmVudCBDb250YWluZXJzIHVwIHRvIHRoZSBoaWdoZXN0IGxldmVsIGFuY2VzdG9yICh1c3VhbGx5IHRoZSB7eyNjcm9zc0xpbmsgXCJTdGFnZVwifX17ey9jcm9zc0xpbmt9fSkuXG5cdCAqIEBtZXRob2QgZ2V0Q29uY2F0ZW5hdGVkRGlzcGxheVByb3BzXG5cdCAqIEBwYXJhbSB7RGlzcGxheVByb3BzfSBbcHJvcHNdIEEge3sjY3Jvc3NMaW5rIFwiRGlzcGxheVByb3BzXCJ9fXt7L2Nyb3NzTGlua319IG9iamVjdCB0byBwb3B1bGF0ZSB3aXRoIHRoZSBjYWxjdWxhdGVkIHZhbHVlcy5cblx0ICogSWYgbnVsbCwgYSBuZXcgRGlzcGxheVByb3BzIG9iamVjdCBpcyByZXR1cm5lZC5cblx0ICogQHJldHVybiB7RGlzcGxheVByb3BzfSBUaGUgY29tYmluZWQgZGlzcGxheSBwcm9wZXJ0aWVzLlxuXHQgKiovXG5cdHAuZ2V0Q29uY2F0ZW5hdGVkRGlzcGxheVByb3BzID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRwcm9wcyA9IHByb3BzID8gcHJvcHMuaWRlbnRpdHkoKSA6IG5ldyBjcmVhdGVqcy5EaXNwbGF5UHJvcHMoKTtcblx0XHR2YXIgbyA9IHRoaXMsIG10eCA9IG8uZ2V0TWF0cml4KHByb3BzLm1hdHJpeCk7IFxuXHRcdGRvIHtcblx0XHRcdHByb3BzLnByZXBlbmQoby52aXNpYmxlLCBvLmFscGhhLCBvLnNoYWRvdywgby5jb21wb3NpdGVPcGVyYXRpb24pO1xuXHRcdFx0XG5cdFx0XHQvLyB3ZSBkbyB0aGlzIHRvIGF2b2lkIHByb2JsZW1zIHdpdGggdGhlIG1hdHJpeCBiZWluZyB1c2VkIGZvciBib3RoIG9wZXJhdGlvbnMgd2hlbiBvLl9wcm9wcy5tYXRyaXggaXMgcGFzc2VkIGluIGFzIHRoZSBwcm9wcyBwYXJhbS5cblx0XHRcdC8vIHRoaXMgY291bGQgYmUgc2ltcGxpZmllZCAoaWUuIGp1c3QgZG9uZSBhcyBwYXJ0IG9mIHRoZSBwcmVwZW5kIGFib3ZlKSBpZiB3ZSBzd2l0Y2hlZCB0byB1c2luZyBhIHBvb2wuXG5cdFx0XHRpZiAobyAhPSB0aGlzKSB7IG10eC5wcmVwZW5kTWF0cml4KG8uZ2V0TWF0cml4KG8uX3Byb3BzLm1hdHJpeCkpOyB9XG5cdFx0fSB3aGlsZSAobyA9IG8ucGFyZW50KTtcblx0XHRyZXR1cm4gcHJvcHM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRlc3RzIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IGludGVyc2VjdHMgdGhlIHNwZWNpZmllZCBwb2ludCBpbiA8ZW0+bG9jYWw8L2VtPiBjb29yZGluYXRlcyAoaWUuIGRyYXdzIGEgcGl4ZWxcblx0ICogd2l0aCBhbHBoYSA+IDAgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbikuIFRoaXMgaWdub3JlcyB0aGUgYWxwaGEsIHNoYWRvdywgaGl0QXJlYSwgbWFzaywgYW5kIGNvbXBvc2l0ZU9wZXJhdGlvblxuXHQgKiBvZiB0aGUgZGlzcGxheSBvYmplY3QuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogXHRcdHZhciBteVNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG5cdCAqIFx0XHRteVNoYXBlLmdyYXBoaWNzLmJlZ2luRmlsbChcInJlZFwiKS5kcmF3UmVjdCgxMDAsIDEwMCwgMjAsIDUwKTtcblx0ICpcblx0ICogXHRcdGNvbnNvbGUubG9nKG15U2hhcGUuaGl0VGVzdCgxMCwxMCk7IC8vIGZhbHNlXG5cdCAqIFx0XHRjb25zb2xlLmxvZyhteVNoYXBlLmhpdFRlc3QoMTEwLCAyNSk7IC8vIHRydWVcblx0ICpcblx0ICogTm90ZSB0aGF0IHRvIHVzZSBTdGFnZSBjb29yZGluYXRlcyAoc3VjaCBhcyB7eyNjcm9zc0xpbmsgXCJTdGFnZS9tb3VzZVg6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0pLCB0aGV5IG11c3Rcblx0ICogZmlyc3QgYmUgY29udmVydGVkIHRvIGxvY2FsIGNvb3JkaW5hdGVzOlxuXHQgKlxuXHQgKiAgICAgIHN0YWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJzdGFnZW1vdXNlZG93blwiLCBoYW5kbGVNb3VzZURvd24pO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuXHQgKiAgICAgIFx0dmFyIHAgPSBteVNoYXBlLmdsb2JhbFRvTG9jYWwoc3RhZ2UubW91c2VYLCBzdGFnZS5tb3VzZVkpO1xuXHQgKiAgICAgICAgICB2YXIgaGl0ID0gbXlTaGFwZS5oaXRUZXN0KHAueCwgcC55KTtcblx0ICogICAgICB9XG5cdCAqXG5cdCAqIFNoYXBlLXRvLXNoYXBlIGNvbGxpc2lvbiBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSBFYXNlbEpTLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGhpdFRlc3Rcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gdG8gY2hlY2sgaW4gdGhlIGRpc3BsYXkgb2JqZWN0J3MgbG9jYWwgY29vcmRpbmF0ZXMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uIHRvIGNoZWNrIGluIHRoZSBkaXNwbGF5IG9iamVjdCdzIGxvY2FsIGNvb3JkaW5hdGVzLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGEgdmlzaWJsZSBwb3J0aW9uIG9mIHRoZSBEaXNwbGF5T2JqZWN0IGludGVyc2VjdCB0aGUgc3BlY2lmaWVkXG5cdCAqIGxvY2FsIFBvaW50LlxuXHQqL1xuXHRwLmhpdFRlc3QgPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0dmFyIGN0eCA9IERpc3BsYXlPYmplY3QuX2hpdFRlc3RDb250ZXh0O1xuXHRcdGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgLXgsIC15KTtcblx0XHR0aGlzLmRyYXcoY3R4KTtcblxuXHRcdHZhciBoaXQgPSB0aGlzLl90ZXN0SGl0KGN0eCk7XG5cdFx0Y3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIDIsIDIpO1xuXHRcdHJldHVybiBoaXQ7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUHJvdmlkZXMgYSBjaGFpbmFibGUgc2hvcnRjdXQgbWV0aG9kIGZvciBzZXR0aW5nIGEgbnVtYmVyIG9mIHByb3BlcnRpZXMgb24gdGhlIGluc3RhbmNlLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIG15R3JhcGhpY3MgPSBuZXcgY3JlYXRlanMuR3JhcGhpY3MoKS5iZWdpbkZpbGwoXCIjZmYwMDAwXCIpLmRyYXdDaXJjbGUoMCwgMCwgMjUpO1xuXHQgKiAgICAgIHZhciBzaGFwZSA9IHN0YWdlLmFkZENoaWxkKG5ldyBjcmVhdGVqcy5TaGFwZSgpKS5zZXQoe2dyYXBoaWNzOm15R3JhcGhpY3MsIHg6MTAwLCB5OjEwMCwgYWxwaGE6MC41fSk7XG5cdCAqXG5cdCAqIEBtZXRob2Qgc2V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBBIGdlbmVyaWMgb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBjb3B5IHRvIHRoZSBEaXNwbGF5T2JqZWN0IGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBSZXR1cm5zIHRoZSBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5zZXQgPSBmdW5jdGlvbihwcm9wcykge1xuXHRcdGZvciAodmFyIG4gaW4gcHJvcHMpIHsgdGhpc1tuXSA9IHByb3BzW25dOyB9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIHJlY3RhbmdsZSByZXByZXNlbnRpbmcgdGhpcyBvYmplY3QncyBib3VuZHMgaW4gaXRzIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtIChpZS4gd2l0aCBubyB0cmFuc2Zvcm1hdGlvbikuXG5cdCAqIE9iamVjdHMgdGhhdCBoYXZlIGJlZW4gY2FjaGVkIHdpbGwgcmV0dXJuIHRoZSBib3VuZHMgb2YgdGhlIGNhY2hlLlxuXHQgKiBcblx0ICogTm90IGFsbCBkaXNwbGF5IG9iamVjdHMgY2FuIGNhbGN1bGF0ZSB0aGVpciBvd24gYm91bmRzIChleC4gU2hhcGUpLiBGb3IgdGhlc2Ugb2JqZWN0cywgeW91IGNhbiB1c2UgXG5cdCAqIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3Qvc2V0Qm91bmRzXCJ9fXt7L2Nyb3NzTGlua319IHNvIHRoYXQgdGhleSBhcmUgaW5jbHVkZWQgd2hlbiBjYWxjdWxhdGluZyBDb250YWluZXJcblx0ICogYm91bmRzLlxuXHQgKiBcblx0ICogPHRhYmxlPlxuXHQgKiBcdDx0cj48dGQ+PGI+QWxsPC9iPjwvdGQ+PHRkPlxuXHQgKiBcdFx0QWxsIGRpc3BsYXkgb2JqZWN0cyBzdXBwb3J0IHNldHRpbmcgYm91bmRzIG1hbnVhbGx5IHVzaW5nIHNldEJvdW5kcygpLiBMaWtld2lzZSwgZGlzcGxheSBvYmplY3RzIHRoYXRcblx0ICogXHRcdGhhdmUgYmVlbiBjYWNoZWQgdXNpbmcgY2FjaGUoKSB3aWxsIHJldHVybiB0aGUgYm91bmRzIG9mIHRoZWlyIGNhY2hlLiBNYW51YWwgYW5kIGNhY2hlIGJvdW5kcyB3aWxsIG92ZXJyaWRlXG5cdCAqIFx0XHR0aGUgYXV0b21hdGljIGNhbGN1bGF0aW9ucyBsaXN0ZWQgYmVsb3cuXG5cdCAqIFx0PC90ZD48L3RyPlxuXHQgKiBcdDx0cj48dGQ+PGI+Qml0bWFwPC9iPjwvdGQ+PHRkPlxuXHQgKiBcdFx0UmV0dXJucyB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgc291cmNlUmVjdCAoaWYgc3BlY2lmaWVkKSBvciBpbWFnZSwgZXh0ZW5kaW5nIGZyb20gKHg9MCx5PTApLlxuXHQgKiBcdDwvdGQ+PC90cj5cblx0ICogXHQ8dHI+PHRkPjxiPlNwcml0ZTwvYj48L3RkPjx0ZD5cblx0ICogXHRcdFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgY3VycmVudCBmcmFtZS4gTWF5IGhhdmUgbm9uLXplcm8geC95IGlmIGEgZnJhbWUgcmVnaXN0cmF0aW9uIHBvaW50IHdhcyBzcGVjaWZpZWRcblx0ICogXHRcdGluIHRoZSBzcHJpdGVzaGVldCBkYXRhLiBTZWUgYWxzbyB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldC9nZXRGcmFtZUJvdW5kc1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBcdDwvdGQ+PC90cj5cblx0ICogXHQ8dHI+PHRkPjxiPkNvbnRhaW5lcjwvYj48L3RkPjx0ZD5cblx0ICogXHRcdFJldHVybnMgdGhlIGFnZ3JlZ2F0ZSAoY29tYmluZWQpIGJvdW5kcyBvZiBhbGwgY2hpbGRyZW4gdGhhdCByZXR1cm4gYSBub24tbnVsbCB2YWx1ZSBmcm9tIGdldEJvdW5kcygpLlxuXHQgKiBcdDwvdGQ+PC90cj5cblx0ICogXHQ8dHI+PHRkPjxiPlNoYXBlPC9iPjwvdGQ+PHRkPlxuXHQgKiBcdFx0RG9lcyBub3QgY3VycmVudGx5IHN1cHBvcnQgYXV0b21hdGljIGJvdW5kcyBjYWxjdWxhdGlvbnMuIFVzZSBzZXRCb3VuZHMoKSB0byBtYW51YWxseSBkZWZpbmUgYm91bmRzLlxuXHQgKiBcdDwvdGQ+PC90cj5cblx0ICogXHQ8dHI+PHRkPjxiPlRleHQ8L2I+PC90ZD48dGQ+XG5cdCAqIFx0XHRSZXR1cm5zIGFwcHJveGltYXRlIGJvdW5kcy4gSG9yaXpvbnRhbCB2YWx1ZXMgKHgvd2lkdGgpIGFyZSBxdWl0ZSBhY2N1cmF0ZSwgYnV0IHZlcnRpY2FsIHZhbHVlcyAoeS9oZWlnaHQpIGFyZVxuXHQgKiBcdFx0bm90LCBlc3BlY2lhbGx5IHdoZW4gdXNpbmcgdGV4dEJhc2VsaW5lIHZhbHVlcyBvdGhlciB0aGFuIFwidG9wXCIuXG5cdCAqIFx0PC90ZD48L3RyPlxuXHQgKiBcdDx0cj48dGQ+PGI+Qml0bWFwVGV4dDwvYj48L3RkPjx0ZD5cblx0ICogXHRcdFJldHVybnMgYXBwcm94aW1hdGUgYm91bmRzLiBWYWx1ZXMgd2lsbCBiZSBtb3JlIGFjY3VyYXRlIGlmIHNwcml0ZXNoZWV0IGZyYW1lIHJlZ2lzdHJhdGlvbiBwb2ludHMgYXJlIGNsb3NlXG5cdCAqIFx0XHR0byAoeD0wLHk9MCkuXG5cdCAqIFx0PC90ZD48L3RyPlxuXHQqIDwvdGFibGU+XG5cdCAqIFxuXHQgKiBCb3VuZHMgY2FuIGJlIGV4cGVuc2l2ZSB0byBjYWxjdWxhdGUgZm9yIHNvbWUgb2JqZWN0cyAoZXguIHRleHQsIG9yIGNvbnRhaW5lcnMgd2l0aCBtYW55IGNoaWxkcmVuKSwgYW5kXG5cdCAqIGFyZSByZWNhbGN1bGF0ZWQgZWFjaCB0aW1lIHlvdSBjYWxsIGdldEJvdW5kcygpLiBZb3UgY2FuIHByZXZlbnQgcmVjYWxjdWxhdGlvbiBvbiBzdGF0aWMgb2JqZWN0cyBieSBzZXR0aW5nIHRoZVxuXHQgKiBib3VuZHMgZXhwbGljaXRseTpcblx0ICogXG5cdCAqIFx0dmFyIGJvdW5kcyA9IG9iai5nZXRCb3VuZHMoKTtcblx0ICogXHRvYmouc2V0Qm91bmRzKGJvdW5kcy54LCBib3VuZHMueSwgYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0KTtcblx0ICogXHQvLyBnZXRCb3VuZHMgd2lsbCBub3cgdXNlIHRoZSBzZXQgdmFsdWVzLCBpbnN0ZWFkIG9mIHJlY2FsY3VsYXRpbmdcblx0ICogXG5cdCAqIFRvIHJlZHVjZSBtZW1vcnkgaW1wYWN0LCB0aGUgcmV0dXJuZWQgUmVjdGFuZ2xlIGluc3RhbmNlIG1heSBiZSByZXVzZWQgaW50ZXJuYWxseTsgY2xvbmUgdGhlIGluc3RhbmNlIG9yIGNvcHkgaXRzXG5cdCAqIHZhbHVlcyBpZiB5b3UgbmVlZCB0byByZXRhaW4gaXQuXG5cdCAqIFxuXHQgKiBcdHZhciBteUJvdW5kcyA9IG9iai5nZXRCb3VuZHMoKS5jbG9uZSgpO1xuXHQgKiBcdC8vIE9SOlxuXHQgKiBcdG15UmVjdC5jb3B5KG9iai5nZXRCb3VuZHMoKSk7XG5cdCAqIFxuXHQgKiBAbWV0aG9kIGdldEJvdW5kc1xuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IEEgUmVjdGFuZ2xlIGluc3RhbmNlIHJlcHJlc2VudGluZyB0aGUgYm91bmRzLCBvciBudWxsIGlmIGJvdW5kcyBhcmUgbm90IGF2YWlsYWJsZSBmb3IgdGhpc1xuXHQgKiBvYmplY3QuXG5cdCAqKi9cblx0cC5nZXRCb3VuZHMgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fYm91bmRzKSB7IHJldHVybiB0aGlzLl9yZWN0YW5nbGUuY29weSh0aGlzLl9ib3VuZHMpOyB9XG5cdFx0dmFyIGNhY2hlQ2FudmFzID0gdGhpcy5jYWNoZUNhbnZhcztcblx0XHRpZiAoY2FjaGVDYW52YXMpIHtcblx0XHRcdHZhciBzY2FsZSA9IHRoaXMuX2NhY2hlU2NhbGU7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVjdGFuZ2xlLnNldFZhbHVlcyh0aGlzLl9jYWNoZU9mZnNldFgsIHRoaXMuX2NhY2hlT2Zmc2V0WSwgY2FjaGVDYW52YXMud2lkdGgvc2NhbGUsIGNhY2hlQ2FudmFzLmhlaWdodC9zY2FsZSk7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSByZWN0YW5nbGUgcmVwcmVzZW50aW5nIHRoaXMgb2JqZWN0J3MgYm91bmRzIGluIGl0cyBwYXJlbnQncyBjb29yZGluYXRlIHN5c3RlbSAoaWUuIHdpdGggdHJhbnNmb3JtYXRpb25zIGFwcGxpZWQpLlxuXHQgKiBPYmplY3RzIHRoYXQgaGF2ZSBiZWVuIGNhY2hlZCB3aWxsIHJldHVybiB0aGUgdHJhbnNmb3JtZWQgYm91bmRzIG9mIHRoZSBjYWNoZS5cblx0ICogXG5cdCAqIE5vdCBhbGwgZGlzcGxheSBvYmplY3RzIGNhbiBjYWxjdWxhdGUgdGhlaXIgb3duIGJvdW5kcyAoZXguIFNoYXBlKS4gRm9yIHRoZXNlIG9iamVjdHMsIHlvdSBjYW4gdXNlIFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3NldEJvdW5kc1wifX17ey9jcm9zc0xpbmt9fSBzbyB0aGF0IHRoZXkgYXJlIGluY2x1ZGVkIHdoZW4gY2FsY3VsYXRpbmcgQ29udGFpbmVyXG5cdCAqIGJvdW5kcy5cblx0ICogXG5cdCAqIFRvIHJlZHVjZSBtZW1vcnkgaW1wYWN0LCB0aGUgcmV0dXJuZWQgUmVjdGFuZ2xlIGluc3RhbmNlIG1heSBiZSByZXVzZWQgaW50ZXJuYWxseTsgY2xvbmUgdGhlIGluc3RhbmNlIG9yIGNvcHkgaXRzXG5cdCAqIHZhbHVlcyBpZiB5b3UgbmVlZCB0byByZXRhaW4gaXQuXG5cdCAqIFxuXHQgKiBDb250YWluZXIgaW5zdGFuY2VzIGNhbGN1bGF0ZSBhZ2dyZWdhdGUgYm91bmRzIGZvciBhbGwgY2hpbGRyZW4gdGhhdCByZXR1cm4gYm91bmRzIHZpYSBnZXRCb3VuZHMuXG5cdCAqIEBtZXRob2QgZ2V0VHJhbnNmb3JtZWRCb3VuZHNcblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBBIFJlY3RhbmdsZSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlIGJvdW5kcywgb3IgbnVsbCBpZiBib3VuZHMgYXJlIG5vdCBhdmFpbGFibGUgZm9yIHRoaXMgb2JqZWN0LlxuXHQgKiovXG5cdHAuZ2V0VHJhbnNmb3JtZWRCb3VuZHMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0Qm91bmRzKCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQWxsb3dzIHlvdSB0byBtYW51YWxseSBzcGVjaWZ5IHRoZSBib3VuZHMgb2YgYW4gb2JqZWN0IHRoYXQgZWl0aGVyIGNhbm5vdCBjYWxjdWxhdGUgdGhlaXIgb3duIGJvdW5kcyAoZXguIFNoYXBlICZcblx0ICogVGV4dCkgZm9yIGZ1dHVyZSByZWZlcmVuY2UsIG9yIHNvIHRoZSBvYmplY3QgY2FuIGJlIGluY2x1ZGVkIGluIENvbnRhaW5lciBib3VuZHMuIE1hbnVhbGx5IHNldCBib3VuZHMgd2lsbCBhbHdheXNcblx0ICogb3ZlcnJpZGUgY2FsY3VsYXRlZCBib3VuZHMuXG5cdCAqIFxuXHQgKiBUaGUgYm91bmRzIHNob3VsZCBiZSBzcGVjaWZpZWQgaW4gdGhlIG9iamVjdCdzIGxvY2FsICh1bnRyYW5zZm9ybWVkKSBjb29yZGluYXRlcy4gRm9yIGV4YW1wbGUsIGEgU2hhcGUgaW5zdGFuY2Vcblx0ICogd2l0aCBhIDI1cHggcmFkaXVzIGNpcmNsZSBjZW50ZXJlZCBhdCAwLDAgd291bGQgaGF2ZSBib3VuZHMgb2YgKC0yNSwgLTI1LCA1MCwgNTApLlxuXHQgKiBAbWV0aG9kIHNldEJvdW5kc1xuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBvcmlnaW4gb2YgdGhlIGJvdW5kcy4gUGFzcyBudWxsIHRvIHJlbW92ZSB0aGUgbWFudWFsIGJvdW5kcy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgb3JpZ2luIG9mIHRoZSBib3VuZHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIGJvdW5kcy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBib3VuZHMuXG5cdCAqKi9cblx0cC5zZXRCb3VuZHMgPSBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0aWYgKHggPT0gbnVsbCkgeyB0aGlzLl9ib3VuZHMgPSB4OyB9XG5cdFx0dGhpcy5fYm91bmRzID0gKHRoaXMuX2JvdW5kcyB8fCBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKCkpLnNldFZhbHVlcyh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgRGlzcGxheU9iamVjdC4gU29tZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIHNwZWNpZmljIHRvIHRoaXMgaW5zdGFuY2UncyBjdXJyZW50IGNvbnRleHQgYXJlXG5cdCAqIHJldmVydGVkIHRvIHRoZWlyIGRlZmF1bHRzIChmb3IgZXhhbXBsZSAucGFyZW50KS4gQ2FjaGVzIGFyZSBub3QgbWFpbnRhaW5lZCBhY3Jvc3MgY2xvbmVzLCBhbmQgc29tZSBlbGVtZW50c1xuXHQgKiBhcmUgY29waWVkIGJ5IHJlZmVyZW5jZSAobWFza3MsIGluZGl2aWR1YWwgZmlsdGVyIGluc3RhbmNlcywgaGl0IGFyZWEpXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7RGlzcGxheU9iamVjdH0gQSBjbG9uZSBvZiB0aGUgY3VycmVudCBEaXNwbGF5T2JqZWN0IGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmVQcm9wcyhuZXcgRGlzcGxheU9iamVjdCgpKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0Rpc3BsYXlPYmplY3QgKG5hbWU9XCIrICB0aGlzLm5hbWUgK1wiKV1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8vIHNlcGFyYXRlZCBzbyBpdCBjYW4gYmUgdXNlZCBtb3JlIGVhc2lseSBpbiBzdWJjbGFzc2VzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfY2xvbmVQcm9wc1xuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IG8gVGhlIERpc3BsYXlPYmplY3QgaW5zdGFuY2Ugd2hpY2ggd2lsbCBoYXZlIHByb3BlcnRpZXMgZnJvbSB0aGUgY3VycmVudCBEaXNwbGF5T2JqZWN0XG5cdCAqIGluc3RhbmNlIGNvcGllZCBpbnRvLlxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBvXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9jbG9uZVByb3BzID0gZnVuY3Rpb24obykge1xuXHRcdG8uYWxwaGEgPSB0aGlzLmFscGhhO1xuXHRcdG8ubW91c2VFbmFibGVkID0gdGhpcy5tb3VzZUVuYWJsZWQ7XG5cdFx0by50aWNrRW5hYmxlZCA9IHRoaXMudGlja0VuYWJsZWQ7XG5cdFx0by5uYW1lID0gdGhpcy5uYW1lO1xuXHRcdG8ucmVnWCA9IHRoaXMucmVnWDtcblx0XHRvLnJlZ1kgPSB0aGlzLnJlZ1k7XG5cdFx0by5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XG5cdFx0by5zY2FsZVggPSB0aGlzLnNjYWxlWDtcblx0XHRvLnNjYWxlWSA9IHRoaXMuc2NhbGVZO1xuXHRcdG8uc2hhZG93ID0gdGhpcy5zaGFkb3c7XG5cdFx0by5za2V3WCA9IHRoaXMuc2tld1g7XG5cdFx0by5za2V3WSA9IHRoaXMuc2tld1k7XG5cdFx0by52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuXHRcdG8ueCAgPSB0aGlzLng7XG5cdFx0by55ID0gdGhpcy55O1xuXHRcdG8uY29tcG9zaXRlT3BlcmF0aW9uID0gdGhpcy5jb21wb3NpdGVPcGVyYXRpb247XG5cdFx0by5zbmFwVG9QaXhlbCA9IHRoaXMuc25hcFRvUGl4ZWw7XG5cdFx0by5maWx0ZXJzID0gdGhpcy5maWx0ZXJzPT1udWxsP251bGw6dGhpcy5maWx0ZXJzLnNsaWNlKDApO1xuXHRcdG8ubWFzayA9IHRoaXMubWFzaztcblx0XHRvLmhpdEFyZWEgPSB0aGlzLmhpdEFyZWE7XG5cdFx0by5jdXJzb3IgPSB0aGlzLmN1cnNvcjtcblx0XHRvLl9ib3VuZHMgPSB0aGlzLl9ib3VuZHM7XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2FwcGx5U2hhZG93XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKiBAcGFyYW0ge1NoYWRvd30gc2hhZG93XG5cdCAqKi9cblx0cC5fYXBwbHlTaGFkb3cgPSBmdW5jdGlvbihjdHgsIHNoYWRvdykge1xuXHRcdHNoYWRvdyA9IHNoYWRvdyB8fCBTaGFkb3cuaWRlbnRpdHk7XG5cdFx0Y3R4LnNoYWRvd0NvbG9yID0gc2hhZG93LmNvbG9yO1xuXHRcdGN0eC5zaGFkb3dPZmZzZXRYID0gc2hhZG93Lm9mZnNldFg7XG5cdFx0Y3R4LnNoYWRvd09mZnNldFkgPSBzaGFkb3cub2Zmc2V0WTtcblx0XHRjdHguc2hhZG93Qmx1ciA9IHNoYWRvdy5ibHVyO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF90aWNrXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldnRPYmogQW4gZXZlbnQgb2JqZWN0IHRoYXQgd2lsbCBiZSBkaXNwYXRjaGVkIHRvIGFsbCB0aWNrIGxpc3RlbmVycy4gVGhpcyBvYmplY3QgaXMgcmV1c2VkIGJldHdlZW4gZGlzcGF0Y2hlcnMgdG8gcmVkdWNlIGNvbnN0cnVjdGlvbiAmIEdDIGNvc3RzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fdGljayA9IGZ1bmN0aW9uKGV2dE9iaikge1xuXHRcdC8vIGJlY2F1c2UgdGljayBjYW4gYmUgcmVhbGx5IHBlcmZvcm1hbmNlIHNlbnNpdGl2ZSwgY2hlY2sgZm9yIGxpc3RlbmVycyBiZWZvcmUgY2FsbGluZyBkaXNwYXRjaEV2ZW50LlxuXHRcdHZhciBscyA9IHRoaXMuX2xpc3RlbmVycztcblx0XHRpZiAobHMgJiYgbHNbXCJ0aWNrXCJdKSB7XG5cdFx0XHQvLyByZXNldCAmIHJldXNlIHRoZSBldmVudCBvYmplY3QgdG8gYXZvaWQgY29uc3RydWN0aW9uIC8gR0MgY29zdHM6XG5cdFx0XHRldnRPYmoudGFyZ2V0ID0gbnVsbDtcblx0XHRcdGV2dE9iai5wcm9wYWdhdGlvblN0b3BwZWQgPSBldnRPYmouaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0T2JqKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3Rlc3RIaXRcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqKi9cblx0cC5fdGVzdEhpdCA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdHRyeSB7XG5cdFx0XHR2YXIgaGl0ID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhWzNdID4gMTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRpZiAoIURpc3BsYXlPYmplY3Quc3VwcHJlc3NDcm9zc0RvbWFpbkVycm9ycykge1xuXHRcdFx0XHR0aHJvdyBcIkFuIGVycm9yIGhhcyBvY2N1cnJlZC4gVGhpcyBpcyBtb3N0IGxpa2VseSBkdWUgdG8gc2VjdXJpdHkgcmVzdHJpY3Rpb25zIG9uIHJlYWRpbmcgY2FudmFzIHBpeGVsIGRhdGEgd2l0aCBsb2NhbCBvciBjcm9zcy1kb21haW4gaW1hZ2VzLlwiO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gaGl0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9hcHBseUZpbHRlcnNcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2FwcGx5RmlsdGVycyA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5maWx0ZXJzIHx8IHRoaXMuZmlsdGVycy5sZW5ndGggPT0gMCB8fCAhdGhpcy5jYWNoZUNhbnZhcykgeyByZXR1cm47IH1cblx0XHR2YXIgbCA9IHRoaXMuZmlsdGVycy5sZW5ndGg7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY2FjaGVDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdHZhciB3ID0gdGhpcy5jYWNoZUNhbnZhcy53aWR0aDtcblx0XHR2YXIgaCA9IHRoaXMuY2FjaGVDYW52YXMuaGVpZ2h0O1xuXHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKyspIHtcblx0XHRcdHRoaXMuZmlsdGVyc1tpXS5hcHBseUZpbHRlcihjdHgsIDAsIDAsIHcsIGgpO1xuXHRcdH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRGaWx0ZXJCb3VuZHNcblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ2V0RmlsdGVyQm91bmRzID0gZnVuY3Rpb24ocmVjdCkge1xuXHRcdHZhciBsLCBmaWx0ZXJzID0gdGhpcy5maWx0ZXJzLCBib3VuZHMgPSB0aGlzLl9yZWN0YW5nbGUuc2V0VmFsdWVzKDAsMCwwLDApO1xuXHRcdGlmICghZmlsdGVycyB8fCAhKGw9ZmlsdGVycy5sZW5ndGgpKSB7IHJldHVybiBib3VuZHM7IH1cblx0XHRcblx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7XG5cdFx0XHR2YXIgZiA9IHRoaXMuZmlsdGVyc1tpXTtcblx0XHRcdGYuZ2V0Qm91bmRzJiZmLmdldEJvdW5kcyhib3VuZHMpO1xuXHRcdH1cblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldEJvdW5kc1xuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXhcblx0ICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVUcmFuc2Zvcm0gSWYgdHJ1ZSwgZG9lcyBub3QgYXBwbHkgdGhpcyBvYmplY3QncyB0cmFuc2Zvcm0uXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dldEJvdW5kcyA9IGZ1bmN0aW9uKG1hdHJpeCwgaWdub3JlVHJhbnNmb3JtKXtcblx0XHRyZXR1cm4gdGhpcy5fdHJhbnNmb3JtQm91bmRzKHRoaXMuZ2V0Qm91bmRzKCksIG1hdHJpeCwgaWdub3JlVHJhbnNmb3JtKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF90cmFuc2Zvcm1Cb3VuZHNcblx0ICogQHBhcmFtIHtSZWN0YW5nbGV9IGJvdW5kc1xuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXhcblx0ICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVUcmFuc2Zvcm1cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fdHJhbnNmb3JtQm91bmRzID0gZnVuY3Rpb24oYm91bmRzLCBtYXRyaXgsIGlnbm9yZVRyYW5zZm9ybSkge1xuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBib3VuZHM7IH1cblx0XHR2YXIgeCA9IGJvdW5kcy54LCB5ID0gYm91bmRzLnksIHdpZHRoID0gYm91bmRzLndpZHRoLCBoZWlnaHQgPSBib3VuZHMuaGVpZ2h0LCBtdHggPSB0aGlzLl9wcm9wcy5tYXRyaXg7XG5cdFx0bXR4ID0gaWdub3JlVHJhbnNmb3JtID8gbXR4LmlkZW50aXR5KCkgOiB0aGlzLmdldE1hdHJpeChtdHgpO1xuXHRcdFxuXHRcdGlmICh4IHx8IHkpIHsgbXR4LmFwcGVuZFRyYW5zZm9ybSgwLDAsMSwxLDAsMCwwLC14LC15KTsgfSAvLyBUT0RPOiBzaW1wbGlmeSB0aGlzLlxuXHRcdGlmIChtYXRyaXgpIHsgbXR4LnByZXBlbmRNYXRyaXgobWF0cml4KTsgfVxuXHRcdFxuXHRcdHZhciB4X2EgPSB3aWR0aCptdHguYSwgeF9iID0gd2lkdGgqbXR4LmI7XG5cdFx0dmFyIHlfYyA9IGhlaWdodCptdHguYywgeV9kID0gaGVpZ2h0Km10eC5kO1xuXHRcdHZhciB0eCA9IG10eC50eCwgdHkgPSBtdHgudHk7XG5cdFx0XG5cdFx0dmFyIG1pblggPSB0eCwgbWF4WCA9IHR4LCBtaW5ZID0gdHksIG1heFkgPSB0eTtcblxuXHRcdGlmICgoeCA9IHhfYSArIHR4KSA8IG1pblgpIHsgbWluWCA9IHg7IH0gZWxzZSBpZiAoeCA+IG1heFgpIHsgbWF4WCA9IHg7IH1cblx0XHRpZiAoKHggPSB4X2EgKyB5X2MgKyB0eCkgPCBtaW5YKSB7IG1pblggPSB4OyB9IGVsc2UgaWYgKHggPiBtYXhYKSB7IG1heFggPSB4OyB9XG5cdFx0aWYgKCh4ID0geV9jICsgdHgpIDwgbWluWCkgeyBtaW5YID0geDsgfSBlbHNlIGlmICh4ID4gbWF4WCkgeyBtYXhYID0geDsgfVxuXHRcdFxuXHRcdGlmICgoeSA9IHhfYiArIHR5KSA8IG1pblkpIHsgbWluWSA9IHk7IH0gZWxzZSBpZiAoeSA+IG1heFkpIHsgbWF4WSA9IHk7IH1cblx0XHRpZiAoKHkgPSB4X2IgKyB5X2QgKyB0eSkgPCBtaW5ZKSB7IG1pblkgPSB5OyB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7IG1heFkgPSB5OyB9XG5cdFx0aWYgKCh5ID0geV9kICsgdHkpIDwgbWluWSkgeyBtaW5ZID0geTsgfSBlbHNlIGlmICh5ID4gbWF4WSkgeyBtYXhZID0geTsgfVxuXHRcdFxuXHRcdHJldHVybiBib3VuZHMuc2V0VmFsdWVzKG1pblgsIG1pblksIG1heFgtbWluWCwgbWF4WS1taW5ZKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3QgaGFzIGFueSBtb3VzZSBldmVudCBsaXN0ZW5lcnMgb3IgYSBjdXJzb3IuXG5cdCAqIEBtZXRob2QgX2lzTW91c2VPcGFxdWVcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2hhc01vdXNlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBldnRzID0gRGlzcGxheU9iamVjdC5fTU9VU0VfRVZFTlRTO1xuXHRcdGZvciAodmFyIGk9IDAsIGw9ZXZ0cy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHRpZiAodGhpcy5oYXNFdmVudExpc3RlbmVyKGV2dHNbaV0pKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0fVxuXHRcdHJldHVybiAhIXRoaXMuY3Vyc29yO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkRpc3BsYXlPYmplY3QgPSBjcmVhdGVqcy5wcm9tb3RlKERpc3BsYXlPYmplY3QsIFwiRXZlbnREaXNwYXRjaGVyXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIENvbnRhaW5lci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cbi8vIGNvbnN0cnVjdG9yOlxuLyoqXG4gKiBBIENvbnRhaW5lciBpcyBhIG5lc3RhYmxlIGRpc3BsYXkgbGlzdCB0aGF0IGFsbG93cyB5b3UgdG8gd29yayB3aXRoIGNvbXBvdW5kIGRpc3BsYXkgZWxlbWVudHMuIEZvciAgZXhhbXBsZSB5b3UgY291bGRcbiAqIGdyb3VwIGFybSwgbGVnLCB0b3JzbyBhbmQgaGVhZCB7eyNjcm9zc0xpbmsgXCJCaXRtYXBcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2VzIHRvZ2V0aGVyIGludG8gYSBQZXJzb24gQ29udGFpbmVyLCBhbmRcbiAqIHRyYW5zZm9ybSB0aGVtIGFzIGEgZ3JvdXAsIHdoaWxlIHN0aWxsIGJlaW5nIGFibGUgdG8gbW92ZSB0aGUgaW5kaXZpZHVhbCBwYXJ0cyByZWxhdGl2ZSB0byBlYWNoIG90aGVyLiBDaGlsZHJlbiBvZlxuICogY29udGFpbmVycyBoYXZlIHRoZWlyIDxjb2RlPnRyYW5zZm9ybTwvY29kZT4gYW5kIDxjb2RlPmFscGhhPC9jb2RlPiBwcm9wZXJ0aWVzIGNvbmNhdGVuYXRlZCB3aXRoIHRoZWlyIHBhcmVudFxuICogQ29udGFpbmVyLlxuICpcbiAqIEZvciBleGFtcGxlLCBhIHt7I2Nyb3NzTGluayBcIlNoYXBlXCJ9fXt7L2Nyb3NzTGlua319IHdpdGggeD0xMDAgYW5kIGFscGhhPTAuNSwgcGxhY2VkIGluIGEgQ29udGFpbmVyIHdpdGggPGNvZGU+eD01MDwvY29kZT5cbiAqIGFuZCA8Y29kZT5hbHBoYT0wLjc8L2NvZGU+IHdpbGwgYmUgcmVuZGVyZWQgdG8gdGhlIGNhbnZhcyBhdCA8Y29kZT54PTE1MDwvY29kZT4gYW5kIDxjb2RlPmFscGhhPTAuMzU8L2NvZGU+LlxuICogQ29udGFpbmVycyBoYXZlIHNvbWUgb3ZlcmhlYWQsIHNvIHlvdSBnZW5lcmFsbHkgc2hvdWxkbid0IGNyZWF0ZSBhIENvbnRhaW5lciB0byBob2xkIGEgc2luZ2xlIGNoaWxkLlxuICpcbiAqIDxoND5FeGFtcGxlPC9oND5cbiAqXG4gKiAgICAgIHZhciBjb250YWluZXIgPSBuZXcgY3JlYXRlanMuQ29udGFpbmVyKCk7XG4gKiAgICAgIGNvbnRhaW5lci5hZGRDaGlsZChiaXRtYXBJbnN0YW5jZSwgc2hhcGVJbnN0YW5jZSk7XG4gKiAgICAgIGNvbnRhaW5lci54ID0gMTAwO1xuICpcbiAqIEBjbGFzcyBDb250YWluZXJcbiAqIEBleHRlbmRzIERpc3BsYXlPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICoqL1xuXHRmdW5jdGlvbiBDb250YWluZXIoKSB7XG5cdFx0dGhpcy5EaXNwbGF5T2JqZWN0X2NvbnN0cnVjdG9yKCk7XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSBhcnJheSBvZiBjaGlsZHJlbiBpbiB0aGUgZGlzcGxheSBsaXN0LiBZb3Ugc2hvdWxkIHVzdWFsbHkgdXNlIHRoZSBjaGlsZCBtYW5hZ2VtZW50IG1ldGhvZHMgc3VjaCBhc1xuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lci9hZGRDaGlsZFwifX17ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyL3JlbW92ZUNoaWxkXCJ9fXt7L2Nyb3NzTGlua319LFxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lci9zd2FwQ2hpbGRyZW5cIn19e3svY3Jvc3NMaW5rfX0sIGV0YywgcmF0aGVyIHRoYW4gYWNjZXNzaW5nIHRoaXMgZGlyZWN0bHksIGJ1dCBpdCBpc1xuXHRcdCAqIGluY2x1ZGVkIGZvciBhZHZhbmNlZCB1c2VzLlxuXHRcdCAqIEBwcm9wZXJ0eSBjaGlsZHJlblxuXHRcdCAqIEB0eXBlIEFycmF5XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqKi9cblx0XHR0aGlzLmNoaWxkcmVuID0gW107XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNoaWxkcmVuIG9mIHRoaXMgY29udGFpbmVyIGFyZSBpbmRlcGVuZGVudGx5IGVuYWJsZWQgZm9yIG1vdXNlL3BvaW50ZXIgaW50ZXJhY3Rpb24uXG5cdFx0ICogSWYgZmFsc2UsIHRoZSBjaGlsZHJlbiB3aWxsIGJlIGFnZ3JlZ2F0ZWQgdW5kZXIgdGhlIGNvbnRhaW5lciAtIGZvciBleGFtcGxlLCBhIGNsaWNrIG9uIGEgY2hpbGQgc2hhcGUgd291bGRcblx0XHQgKiB0cmlnZ2VyIGEgY2xpY2sgZXZlbnQgb24gdGhlIGNvbnRhaW5lci5cblx0XHQgKiBAcHJvcGVydHkgbW91c2VDaGlsZHJlblxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICoqL1xuXHRcdHRoaXMubW91c2VDaGlsZHJlbiA9IHRydWU7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSWYgZmFsc2UsIHRoZSB0aWNrIHdpbGwgbm90IGJlIHByb3BhZ2F0ZWQgdG8gY2hpbGRyZW4gb2YgdGhpcyBDb250YWluZXIuIFRoaXMgY2FuIHByb3ZpZGUgc29tZSBwZXJmb3JtYW5jZSBiZW5lZml0cy5cblx0XHQgKiBJbiBhZGRpdGlvbiB0byBwcmV2ZW50aW5nIHRoZSBcInRpY2tcIiBldmVudCBmcm9tIGJlaW5nIGRpc3BhdGNoZWQsIGl0IHdpbGwgYWxzbyBwcmV2ZW50IHRpY2sgcmVsYXRlZCB1cGRhdGVzXG5cdFx0ICogb24gc29tZSBkaXNwbGF5IG9iamVjdHMgKGV4LiBTcHJpdGUgJiBNb3ZpZUNsaXAgZnJhbWUgYWR2YW5jaW5nLCBET01FbGVtZW50IHZpc2liaWxpdHkgaGFuZGxpbmcpLlxuXHRcdCAqIEBwcm9wZXJ0eSB0aWNrQ2hpbGRyZW5cblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqKi9cblx0XHR0aGlzLnRpY2tDaGlsZHJlbiA9IHRydWU7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQ29udGFpbmVyLCBjcmVhdGVqcy5EaXNwbGF5T2JqZWN0KTtcblx0XG5cdFxuLy8gZ2V0dGVyIC8gc2V0dGVyczpcblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyL251bUNoaWxkcmVuOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2QgZ2V0TnVtQ2hpbGRyZW5cblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdHAuZ2V0TnVtQ2hpbGRyZW4gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGUgY29udGFpbmVyLlxuXHQgKiBAcHJvcGVydHkgbnVtQ2hpbGRyZW5cblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cdFx0XHRudW1DaGlsZHJlbjogeyBnZXQ6IHAuZ2V0TnVtQ2hpbGRyZW4gfVxuXHRcdH0pO1xuXHR9IGNhdGNoIChlKSB7fVxuXHRcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RvciBhbGlhcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIFRoaXMgbWV0aG9kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMuXG5cdCAqIFN1YmNsYXNzZXMgc2hvdWxkIGJlIHVwZGF0ZWQgdG8gdXNlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRzXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIGBjcmVhdGVqcy5wcm9tb3RlKClgXG5cdCAqKi9cblx0cC5pbml0aWFsaXplID0gQ29udGFpbmVyOyAvLyBUT0RPOiBkZXByZWNhdGVkLlxuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXMuXG5cdCAqIFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3Igd2hldGhlciBpdCB3b3VsZCBiZSB2aXNpYmxlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgc3RhZ2UuXG5cdCAqXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBpc1Zpc2libGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXNcblx0ICoqL1xuXHRwLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYXNDb250ZW50ID0gdGhpcy5jYWNoZUNhbnZhcyB8fCB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcblx0XHRyZXR1cm4gISEodGhpcy52aXNpYmxlICYmIHRoaXMuYWxwaGEgPiAwICYmIHRoaXMuc2NhbGVYICE9IDAgJiYgdGhpcy5zY2FsZVkgIT0gMCAmJiBoYXNDb250ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgdGhlIGRpc3BsYXkgb2JqZWN0IGludG8gdGhlIHNwZWNpZmllZCBjb250ZXh0IGlnbm9yaW5nIGl0cyB2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBhbmQgdHJhbnNmb3JtLlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRyYXcgd2FzIGhhbmRsZWQgKHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyBmdW5jdGlvbmFsaXR5KS5cblx0ICpcblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGRyYXdcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIGNvbnRleHQgb2JqZWN0IHRvIGRyYXcgaW50by5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbaWdub3JlQ2FjaGU9ZmFsc2VdIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkcmF3IG9wZXJhdGlvbiBzaG91bGQgaWdub3JlIGFueSBjdXJyZW50IGNhY2hlLlxuXHQgKiBGb3IgZXhhbXBsZSwgdXNlZCBmb3IgZHJhd2luZyB0aGUgY2FjaGUgKHRvIHByZXZlbnQgaXQgZnJvbSBzaW1wbHkgZHJhd2luZyBhbiBleGlzdGluZyBjYWNoZSBiYWNrXG5cdCAqIGludG8gaXRzZWxmKS5cblx0ICoqL1xuXHRwLmRyYXcgPSBmdW5jdGlvbihjdHgsIGlnbm9yZUNhY2hlKSB7XG5cdFx0aWYgKHRoaXMuRGlzcGxheU9iamVjdF9kcmF3KGN0eCwgaWdub3JlQ2FjaGUpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0XG5cdFx0Ly8gdGhpcyBlbnN1cmVzIHdlIGRvbid0IGhhdmUgaXNzdWVzIHdpdGggZGlzcGxheSBsaXN0IGNoYW5nZXMgdGhhdCBvY2N1ciBkdXJpbmcgYSBkcmF3OlxuXHRcdHZhciBsaXN0ID0gdGhpcy5jaGlsZHJlbi5zbGljZSgpO1xuXHRcdGZvciAodmFyIGk9MCxsPWxpc3QubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gbGlzdFtpXTtcblx0XHRcdGlmICghY2hpbGQuaXNWaXNpYmxlKCkpIHsgY29udGludWU7IH1cblx0XHRcdFxuXHRcdFx0Ly8gZHJhdyB0aGUgY2hpbGQ6XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0Y2hpbGQudXBkYXRlQ29udGV4dChjdHgpO1xuXHRcdFx0Y2hpbGQuZHJhdyhjdHgpO1xuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQWRkcyBhIGNoaWxkIHRvIHRoZSB0b3Agb2YgdGhlIGRpc3BsYXkgbGlzdC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiBcdFx0Y29udGFpbmVyLmFkZENoaWxkKGJpdG1hcEluc3RhbmNlKTtcblx0ICpcblx0ICogWW91IGNhbiBhbHNvIGFkZCBtdWx0aXBsZSBjaGlsZHJlbiBhdCBvbmNlOlxuXHQgKlxuXHQgKiBcdFx0Y29udGFpbmVyLmFkZENoaWxkKGJpdG1hcEluc3RhbmNlLCBzaGFwZUluc3RhbmNlLCB0ZXh0SW5zdGFuY2UpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIGFkZENoaWxkXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gY2hpbGQgVGhlIGRpc3BsYXkgb2JqZWN0IHRvIGFkZC5cblx0ICogQHJldHVybiB7RGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIHRoYXQgd2FzIGFkZGVkLCBvciB0aGUgbGFzdCBjaGlsZCBpZiBtdWx0aXBsZSBjaGlsZHJlbiB3ZXJlIGFkZGVkLlxuXHQgKiovXG5cdHAuYWRkQ2hpbGQgPSBmdW5jdGlvbihjaGlsZCkge1xuXHRcdGlmIChjaGlsZCA9PSBudWxsKSB7IHJldHVybiBjaGlsZDsgfVxuXHRcdHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRpZiAobCA+IDEpIHtcblx0XHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKyspIHsgdGhpcy5hZGRDaGlsZChhcmd1bWVudHNbaV0pOyB9XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzW2wtMV07XG5cdFx0fVxuXHRcdGlmIChjaGlsZC5wYXJlbnQpIHsgY2hpbGQucGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTsgfVxuXHRcdGNoaWxkLnBhcmVudCA9IHRoaXM7XG5cdFx0dGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcblx0XHRjaGlsZC5kaXNwYXRjaEV2ZW50KFwiYWRkZWRcIik7XG5cdFx0cmV0dXJuIGNoaWxkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGRzIGEgY2hpbGQgdG8gdGhlIGRpc3BsYXkgbGlzdCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LCBidW1waW5nIGNoaWxkcmVuIGF0IGVxdWFsIG9yIGdyZWF0ZXIgaW5kZXhlcyB1cCBvbmUsIGFuZFxuXHQgKiBzZXR0aW5nIGl0cyBwYXJlbnQgdG8gdGhpcyBDb250YWluZXIuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBhZGRDaGlsZEF0KGNoaWxkMSwgaW5kZXgpO1xuXHQgKlxuXHQgKiBZb3UgY2FuIGFsc28gYWRkIG11bHRpcGxlIGNoaWxkcmVuLCBzdWNoIGFzOlxuXHQgKlxuXHQgKiAgICAgIGFkZENoaWxkQXQoY2hpbGQxLCBjaGlsZDIsIC4uLiwgaW5kZXgpO1xuXHQgKlxuXHQgKiBUaGUgaW5kZXggbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIG51bUNoaWxkcmVuLiBGb3IgZXhhbXBsZSwgdG8gYWRkIG15U2hhcGUgdW5kZXIgb3RoZXJTaGFwZSBpbiB0aGUgZGlzcGxheSBsaXN0LFxuXHQgKiB5b3UgY291bGQgdXNlOlxuXHQgKlxuXHQgKiAgICAgIGNvbnRhaW5lci5hZGRDaGlsZEF0KG15U2hhcGUsIGNvbnRhaW5lci5nZXRDaGlsZEluZGV4KG90aGVyU2hhcGUpKTtcblx0ICpcblx0ICogVGhpcyB3b3VsZCBhbHNvIGJ1bXAgb3RoZXJTaGFwZSdzIGluZGV4IHVwIGJ5IG9uZS4gRmFpbHMgc2lsZW50bHkgaWYgdGhlIGluZGV4IGlzIG91dCBvZiByYW5nZS5cblx0ICpcblx0ICogQG1ldGhvZCBhZGRDaGlsZEF0XG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gY2hpbGQgVGhlIGRpc3BsYXkgb2JqZWN0IHRvIGFkZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCB0byBhZGQgdGhlIGNoaWxkIGF0LlxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBSZXR1cm5zIHRoZSBsYXN0IGNoaWxkIHRoYXQgd2FzIGFkZGVkLCBvciB0aGUgbGFzdCBjaGlsZCBpZiBtdWx0aXBsZSBjaGlsZHJlbiB3ZXJlIGFkZGVkLlxuXHQgKiovXG5cdHAuYWRkQ2hpbGRBdCA9IGZ1bmN0aW9uKGNoaWxkLCBpbmRleCkge1xuXHRcdHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHR2YXIgaW5keCA9IGFyZ3VtZW50c1tsLTFdOyAvLyBjYW4ndCB1c2UgdGhlIHNhbWUgbmFtZSBhcyB0aGUgaW5kZXggcGFyYW0gb3IgaXQgcmVwbGFjZXMgYXJndW1lbnRzWzFdXG5cdFx0aWYgKGluZHggPCAwIHx8IGluZHggPiB0aGlzLmNoaWxkcmVuLmxlbmd0aCkgeyByZXR1cm4gYXJndW1lbnRzW2wtMl07IH1cblx0XHRpZiAobCA+IDIpIHtcblx0XHRcdGZvciAodmFyIGk9MDsgaTxsLTE7IGkrKykgeyB0aGlzLmFkZENoaWxkQXQoYXJndW1lbnRzW2ldLCBpbmR4K2kpOyB9XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzW2wtMl07XG5cdFx0fVxuXHRcdGlmIChjaGlsZC5wYXJlbnQpIHsgY2hpbGQucGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTsgfVxuXHRcdGNoaWxkLnBhcmVudCA9IHRoaXM7XG5cdFx0dGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcblx0XHRjaGlsZC5kaXNwYXRjaEV2ZW50KFwiYWRkZWRcIik7XG5cdFx0cmV0dXJuIGNoaWxkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgY2hpbGQgZnJvbSB0aGUgZGlzcGxheSBsaXN0LiBOb3RlIHRoYXQgaXQgaXMgZmFzdGVyIHRvIHVzZSByZW1vdmVDaGlsZEF0KCkgaWYgdGhlIGluZGV4IGlzXG5cdCAqIGFscmVhZHkga25vd24uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuXHQgKlxuXHQgKiBZb3UgY2FuIGFsc28gcmVtb3ZlIG11bHRpcGxlIGNoaWxkcmVuOlxuXHQgKlxuXHQgKiAgICAgIHJlbW92ZUNoaWxkKGNoaWxkMSwgY2hpbGQyLCAuLi4pO1xuXHQgKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNoaWxkIChvciBjaGlsZHJlbikgd2FzIHJlbW92ZWQsIG9yIGZhbHNlIGlmIGl0IHdhcyBub3QgaW4gdGhlIGRpc3BsYXkgbGlzdC5cblx0ICogQG1ldGhvZCByZW1vdmVDaGlsZFxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IGNoaWxkIFRoZSBjaGlsZCB0byByZW1vdmUuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGNoaWxkIChvciBjaGlsZHJlbikgd2FzIHJlbW92ZWQsIG9yIGZhbHNlIGlmIGl0IHdhcyBub3QgaW4gdGhlIGRpc3BsYXkgbGlzdC5cblx0ICoqL1xuXHRwLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24oY2hpbGQpIHtcblx0XHR2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0aWYgKGwgPiAxKSB7XG5cdFx0XHR2YXIgZ29vZCA9IHRydWU7XG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7IGdvb2QgPSBnb29kICYmIHRoaXMucmVtb3ZlQ2hpbGQoYXJndW1lbnRzW2ldKTsgfVxuXHRcdFx0cmV0dXJuIGdvb2Q7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnJlbW92ZUNoaWxkQXQoY3JlYXRlanMuaW5kZXhPZih0aGlzLmNoaWxkcmVuLCBjaGlsZCkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBjaGlsZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IGZyb20gdGhlIGRpc3BsYXkgbGlzdCwgYW5kIHNldHMgaXRzIHBhcmVudCB0byBudWxsLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkQXQoMik7XG5cdCAqXG5cdCAqIFlvdSBjYW4gYWxzbyByZW1vdmUgbXVsdGlwbGUgY2hpbGRyZW46XG5cdCAqXG5cdCAqICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKDIsIDcsIC4uLilcblx0ICpcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBjaGlsZCAob3IgY2hpbGRyZW4pIHdhcyByZW1vdmVkLCBvciBmYWxzZSBpZiBhbnkgaW5kZXggd2FzIG91dCBvZiByYW5nZS5cblx0ICogQG1ldGhvZCByZW1vdmVDaGlsZEF0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGNoaWxkIHRvIHJlbW92ZS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2hpbGQgKG9yIGNoaWxkcmVuKSB3YXMgcmVtb3ZlZCwgb3IgZmFsc2UgaWYgYW55IGluZGV4IHdhcyBvdXQgb2YgcmFuZ2UuXG5cdCAqKi9cblx0cC5yZW1vdmVDaGlsZEF0ID0gZnVuY3Rpb24oaW5kZXgpIHtcblx0XHR2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0aWYgKGwgPiAxKSB7XG5cdFx0XHR2YXIgYSA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykgeyBhW2ldID0gYXJndW1lbnRzW2ldOyB9XG5cdFx0XHRhLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYi1hOyB9KTtcblx0XHRcdHZhciBnb29kID0gdHJ1ZTtcblx0XHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKyspIHsgZ29vZCA9IGdvb2QgJiYgdGhpcy5yZW1vdmVDaGlsZEF0KGFbaV0pOyB9XG5cdFx0XHRyZXR1cm4gZ29vZDtcblx0XHR9XG5cdFx0aWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMuY2hpbGRyZW4ubGVuZ3RoLTEpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpbmRleF07XG5cdFx0aWYgKGNoaWxkKSB7IGNoaWxkLnBhcmVudCA9IG51bGw7IH1cblx0XHR0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG5cdFx0Y2hpbGQuZGlzcGF0Y2hFdmVudChcInJlbW92ZWRcIik7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYWxsIGNoaWxkcmVuIGZyb20gdGhlIGRpc3BsYXkgbGlzdC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiBcdGNvbnRhaW5lci5yZW1vdmVBbGxDaGlsZHJlbigpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHJlbW92ZUFsbENoaWxkcmVuXG5cdCAqKi9cblx0cC5yZW1vdmVBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBraWRzID0gdGhpcy5jaGlsZHJlbjtcblx0XHR3aGlsZSAoa2lkcy5sZW5ndGgpIHsgdGhpcy5yZW1vdmVDaGlsZEF0KDApOyB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGNoaWxkIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBjb250YWluZXIuZ2V0Q2hpbGRBdCgyKTtcblx0ICpcblx0ICogQG1ldGhvZCBnZXRDaGlsZEF0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGNoaWxkIHRvIHJldHVybi5cblx0ICogQHJldHVybiB7RGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguIFJldHVybnMgbnVsbCBpZiB0aGVyZSBpcyBubyBjaGlsZCBhdCB0aGUgaW5kZXguXG5cdCAqKi9cblx0cC5nZXRDaGlsZEF0ID0gZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5jaGlsZHJlbltpbmRleF07XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY2hpbGQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXG5cdCAqIEBtZXRob2QgZ2V0Q2hpbGRCeU5hbWVcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNoaWxkIHRvIHJldHVybi5cblx0ICogQHJldHVybiB7RGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxuXHQgKiovXG5cdHAuZ2V0Q2hpbGRCeU5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG5cdFx0dmFyIGtpZHMgPSB0aGlzLmNoaWxkcmVuO1xuXHRcdGZvciAodmFyIGk9MCxsPWtpZHMubGVuZ3RoO2k8bDtpKyspIHtcblx0XHRcdGlmKGtpZHNbaV0ubmFtZSA9PSBuYW1lKSB7IHJldHVybiBraWRzW2ldOyB9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQZXJmb3JtcyBhbiBhcnJheSBzb3J0IG9wZXJhdGlvbiBvbiB0aGUgY2hpbGQgbGlzdC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU6IERpc3BsYXkgY2hpbGRyZW4gd2l0aCBhIGhpZ2hlciB5IGluIGZyb250LjwvaDQ+XG5cdCAqIFxuXHQgKiAgICAgIHZhciBzb3J0RnVuY3Rpb24gPSBmdW5jdGlvbihvYmoxLCBvYmoyLCBvcHRpb25zKSB7XG5cdCAqICAgICAgICAgIGlmIChvYmoxLnkgPiBvYmoyLnkpIHsgcmV0dXJuIDE7IH1cblx0ICogICAgICAgICAgaWYgKG9iajEueSA8IG9iajIueSkgeyByZXR1cm4gLTE7IH1cblx0ICogICAgICAgICAgcmV0dXJuIDA7XG5cdCAqICAgICAgfVxuXHQgKiAgICAgIGNvbnRhaW5lci5zb3J0Q2hpbGRyZW4oc29ydEZ1bmN0aW9uKTtcblx0ICpcblx0ICogQG1ldGhvZCBzb3J0Q2hpbGRyZW5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gc29ydEZ1bmN0aW9uIHRoZSBmdW5jdGlvbiB0byB1c2UgdG8gc29ydCB0aGUgY2hpbGQgbGlzdC4gU2VlIEphdmFTY3JpcHQncyA8Y29kZT5BcnJheS5zb3J0PC9jb2RlPlxuXHQgKiBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLlxuXHQgKiovXG5cdHAuc29ydENoaWxkcmVuID0gZnVuY3Rpb24oc29ydEZ1bmN0aW9uKSB7XG5cdFx0dGhpcy5jaGlsZHJlbi5zb3J0KHNvcnRGdW5jdGlvbik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBzcGVjaWZpZWQgY2hpbGQgaW4gdGhlIGRpc3BsYXkgbGlzdCwgb3IgLTEgaWYgaXQgaXMgbm90IGluIHRoZSBkaXNwbGF5IGxpc3QuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgaW5kZXggPSBjb250YWluZXIuZ2V0Q2hpbGRJbmRleChjaGlsZCk7XG5cdCAqXG5cdCAqIEBtZXRob2QgZ2V0Q2hpbGRJbmRleFxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IGNoaWxkIFRoZSBjaGlsZCB0byByZXR1cm4gdGhlIGluZGV4IG9mLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgc3BlY2lmaWVkIGNoaWxkLiAtMSBpZiB0aGUgY2hpbGQgaXMgbm90IGZvdW5kLlxuXHQgKiovXG5cdHAuZ2V0Q2hpbGRJbmRleCA9IGZ1bmN0aW9uKGNoaWxkKSB7XG5cdFx0cmV0dXJuIGNyZWF0ZWpzLmluZGV4T2YodGhpcy5jaGlsZHJlbiwgY2hpbGQpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFN3YXBzIHRoZSBjaGlsZHJlbiBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXMuIEZhaWxzIHNpbGVudGx5IGlmIGVpdGhlciBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG5cdCAqIEBtZXRob2Qgc3dhcENoaWxkcmVuQXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4MVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXgyXG5cdCAqKi9cblx0cC5zd2FwQ2hpbGRyZW5BdCA9IGZ1bmN0aW9uKGluZGV4MSwgaW5kZXgyKSB7XG5cdFx0dmFyIGtpZHMgPSB0aGlzLmNoaWxkcmVuO1xuXHRcdHZhciBvMSA9IGtpZHNbaW5kZXgxXTtcblx0XHR2YXIgbzIgPSBraWRzW2luZGV4Ml07XG5cdFx0aWYgKCFvMSB8fCAhbzIpIHsgcmV0dXJuOyB9XG5cdFx0a2lkc1tpbmRleDFdID0gbzI7XG5cdFx0a2lkc1tpbmRleDJdID0gbzE7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU3dhcHMgdGhlIHNwZWNpZmllZCBjaGlsZHJlbidzIGRlcHRoIGluIHRoZSBkaXNwbGF5IGxpc3QuIEZhaWxzIHNpbGVudGx5IGlmIGVpdGhlciBjaGlsZCBpcyBub3QgYSBjaGlsZCBvZiB0aGlzXG5cdCAqIENvbnRhaW5lci5cblx0ICogQG1ldGhvZCBzd2FwQ2hpbGRyZW5cblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBjaGlsZDFcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBjaGlsZDJcblx0ICoqL1xuXHRwLnN3YXBDaGlsZHJlbiA9IGZ1bmN0aW9uKGNoaWxkMSwgY2hpbGQyKSB7XG5cdFx0dmFyIGtpZHMgPSB0aGlzLmNoaWxkcmVuO1xuXHRcdHZhciBpbmRleDEsaW5kZXgyO1xuXHRcdGZvciAodmFyIGk9MCxsPWtpZHMubGVuZ3RoO2k8bDtpKyspIHtcblx0XHRcdGlmIChraWRzW2ldID09IGNoaWxkMSkgeyBpbmRleDEgPSBpOyB9XG5cdFx0XHRpZiAoa2lkc1tpXSA9PSBjaGlsZDIpIHsgaW5kZXgyID0gaTsgfVxuXHRcdFx0aWYgKGluZGV4MSAhPSBudWxsICYmIGluZGV4MiAhPSBudWxsKSB7IGJyZWFrOyB9XG5cdFx0fVxuXHRcdGlmIChpPT1sKSB7IHJldHVybjsgfSAvLyBUT0RPOiB0aHJvdyBlcnJvcj9cblx0XHRraWRzW2luZGV4MV0gPSBjaGlsZDI7XG5cdFx0a2lkc1tpbmRleDJdID0gY2hpbGQxO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENoYW5nZXMgdGhlIGRlcHRoIG9mIHRoZSBzcGVjaWZpZWQgY2hpbGQuIEZhaWxzIHNpbGVudGx5IGlmIHRoZSBjaGlsZCBpcyBub3QgYSBjaGlsZCBvZiB0aGlzIGNvbnRhaW5lciwgb3IgdGhlIGluZGV4IGlzIG91dCBvZiByYW5nZS5cblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBjaGlsZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggIFxuXHQgKiBAbWV0aG9kIHNldENoaWxkSW5kZXhcblx0ICoqL1xuXHRwLnNldENoaWxkSW5kZXggPSBmdW5jdGlvbihjaGlsZCwgaW5kZXgpIHtcblx0XHR2YXIga2lkcyA9IHRoaXMuY2hpbGRyZW4sIGw9a2lkcy5sZW5ndGg7XG5cdFx0aWYgKGNoaWxkLnBhcmVudCAhPSB0aGlzIHx8IGluZGV4IDwgMCB8fCBpbmRleCA+PSBsKSB7IHJldHVybjsgfVxuXHRcdGZvciAodmFyIGk9MDtpPGw7aSsrKSB7XG5cdFx0XHRpZiAoa2lkc1tpXSA9PSBjaGlsZCkgeyBicmVhazsgfVxuXHRcdH1cblx0XHRpZiAoaT09bCB8fCBpID09IGluZGV4KSB7IHJldHVybjsgfVxuXHRcdGtpZHMuc3BsaWNlKGksMSk7XG5cdFx0a2lkcy5zcGxpY2UoaW5kZXgsMCxjaGlsZCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGRpc3BsYXkgb2JqZWN0IGVpdGhlciBpcyB0aGlzIGNvbnRhaW5lciBvciBpcyBhIGRlc2NlbmRlbnQgKGNoaWxkLCBncmFuZGNoaWxkLCBldGMpXG5cdCAqIG9mIHRoaXMgY29udGFpbmVyLlxuXHQgKiBAbWV0aG9kIGNvbnRhaW5zXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gY2hpbGQgVGhlIERpc3BsYXlPYmplY3QgdG8gYmUgY2hlY2tlZC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGRpc3BsYXkgb2JqZWN0IGVpdGhlciBpcyB0aGlzIGNvbnRhaW5lciBvciBpcyBhIGRlc2NlbmRlbnQuXG5cdCAqKi9cblx0cC5jb250YWlucyA9IGZ1bmN0aW9uKGNoaWxkKSB7XG5cdFx0d2hpbGUgKGNoaWxkKSB7XG5cdFx0XHRpZiAoY2hpbGQgPT0gdGhpcykgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdFx0Y2hpbGQgPSBjaGlsZC5wYXJlbnQ7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHQvKipcblx0ICogVGVzdHMgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3QgaW50ZXJzZWN0cyB0aGUgc3BlY2lmaWVkIGxvY2FsIHBvaW50IChpZS4gZHJhd3MgYSBwaXhlbCB3aXRoIGFscGhhID4gMCBhdCB0aGVcblx0ICogc3BlY2lmaWVkIHBvc2l0aW9uKS4gVGhpcyBpZ25vcmVzIHRoZSBhbHBoYSwgc2hhZG93IGFuZCBjb21wb3NpdGVPcGVyYXRpb24gb2YgdGhlIGRpc3BsYXkgb2JqZWN0LCBhbmQgYWxsXG5cdCAqIHRyYW5zZm9ybSBwcm9wZXJ0aWVzIGluY2x1ZGluZyByZWdYL1kuXG5cdCAqIEBtZXRob2QgaGl0VGVzdFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBwb3NpdGlvbiB0byBjaGVjayBpbiB0aGUgZGlzcGxheSBvYmplY3QncyBsb2NhbCBjb29yZGluYXRlcy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24gdG8gY2hlY2sgaW4gdGhlIGRpc3BsYXkgb2JqZWN0J3MgbG9jYWwgY29vcmRpbmF0ZXMuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlcmUgaXMgYSB2aXNpYmxlIHNlY3Rpb24gb2YgYSBEaXNwbGF5T2JqZWN0IHRoYXQgb3ZlcmxhcHMgdGhlIHNwZWNpZmllZFxuXHQgKiBjb29yZGluYXRlcy5cblx0ICoqL1xuXHRwLmhpdFRlc3QgPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0Ly8gVE9ETzogb3B0aW1pemUgdG8gdXNlIHRoZSBmYXN0IGNhY2hlIGNoZWNrIHdoZXJlIHBvc3NpYmxlLlxuXHRcdHJldHVybiAodGhpcy5nZXRPYmplY3RVbmRlclBvaW50KHgsIHkpICE9IG51bGwpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBkaXNwbGF5IG9iamVjdHMgdW5kZXIgdGhlIHNwZWNpZmllZCBjb29yZGluYXRlcyB0aGF0IGFyZSBpbiB0aGlzIGNvbnRhaW5lcidzIGRpc3BsYXlcblx0ICogbGlzdC4gVGhpcyByb3V0aW5lIGlnbm9yZXMgYW55IGRpc3BsYXkgb2JqZWN0cyB3aXRoIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbW91c2VFbmFibGVkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHNldCB0byBgZmFsc2VgLiBUaGUgYXJyYXkgd2lsbCBiZSBzb3J0ZWQgaW4gb3JkZXIgb2YgdmlzdWFsIGRlcHRoLCB3aXRoIHRoZSB0b3AtbW9zdCBkaXNwbGF5IG9iamVjdCBhdCBpbmRleCAwLlxuXHQgKiBUaGlzIHVzZXMgc2hhcGUgYmFzZWQgaGl0IGRldGVjdGlvbiwgYW5kIGNhbiBiZSBhbiBleHBlbnNpdmUgb3BlcmF0aW9uIHRvIHJ1biwgc28gaXQgaXMgYmVzdCB0byB1c2UgaXQgY2FyZWZ1bGx5LlxuXHQgKiBGb3IgZXhhbXBsZSwgaWYgdGVzdGluZyBmb3Igb2JqZWN0cyB1bmRlciB0aGUgbW91c2UsIHRlc3Qgb24gdGljayAoaW5zdGVhZCBvZiBvbiB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21vdXNlbW92ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fSksXG5cdCAqIGFuZCBvbmx5IGlmIHRoZSBtb3VzZSdzIHBvc2l0aW9uIGhhcyBjaGFuZ2VkLlxuXHQgKiBcblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPkJ5IGRlZmF1bHQgKG1vZGU9MCkgdGhpcyBtZXRob2QgZXZhbHVhdGVzIGFsbCBkaXNwbGF5IG9iamVjdHMuPC9saT5cblx0ICogICAgIDxsaT5CeSBzZXR0aW5nIHRoZSBgbW9kZWAgcGFyYW1ldGVyIHRvIGAxYCwgdGhlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbW91c2VFbmFibGVkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIFx0XHRhbmQge3sjY3Jvc3NMaW5rIFwibW91c2VDaGlsZHJlbjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0aWVzIHdpbGwgYmUgcmVzcGVjdGVkLjwvbGk+XG5cdCAqIFx0ICAgPGxpPlNldHRpbmcgdGhlIGBtb2RlYCB0byBgMmAgYWRkaXRpb25hbGx5IGV4Y2x1ZGVzIGRpc3BsYXkgb2JqZWN0cyB0aGF0IGRvIG5vdCBoYXZlIGFjdGl2ZSBtb3VzZSBldmVudFxuXHQgKiBcdCAgIFx0bGlzdGVuZXJzIG9yIGEge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdDpjdXJzb3I6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkuIFRoYXQgaXMsIG9ubHkgb2JqZWN0c1xuXHQgKiBcdCAgIFx0dGhhdCB3b3VsZCBub3JtYWxseSBpbnRlcmNlcHQgbW91c2UgaW50ZXJhY3Rpb24gd2lsbCBiZSBpbmNsdWRlZC4gVGhpcyBjYW4gc2lnbmlmaWNhbnRseSBpbXByb3ZlIHBlcmZvcm1hbmNlXG5cdCAqIFx0ICAgXHRpbiBzb21lIGNhc2VzIGJ5IHJlZHVjaW5nIHRoZSBudW1iZXIgb2YgZGlzcGxheSBvYmplY3RzIHRoYXQgbmVlZCB0byBiZSB0ZXN0ZWQuPC9saT5cblx0ICogPC9saT5cblx0ICogXG5cdCAqIFRoaXMgbWV0aG9kIGFjY291bnRzIGZvciBib3RoIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvaGl0QXJlYTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9tYXNrOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGdldE9iamVjdHNVbmRlclBvaW50XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIGluIHRoZSBjb250YWluZXIgdG8gdGVzdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24gaW4gdGhlIGNvbnRhaW5lciB0byB0ZXN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW21vZGU9MF0gVGhlIG1vZGUgdG8gdXNlIHRvIGRldGVybWluZSB3aGljaCBkaXNwbGF5IG9iamVjdHMgdG8gaW5jbHVkZS4gMC1hbGwsIDEtcmVzcGVjdCBtb3VzZUVuYWJsZWQvbW91c2VDaGlsZHJlbiwgMi1vbmx5IG1vdXNlIG9wYXF1ZSBvYmplY3RzLlxuXHQgKiBAcmV0dXJuIHtBcnJheX0gQW4gQXJyYXkgb2YgRGlzcGxheU9iamVjdHMgdW5kZXIgdGhlIHNwZWNpZmllZCBjb29yZGluYXRlcy5cblx0ICoqL1xuXHRwLmdldE9iamVjdHNVbmRlclBvaW50ID0gZnVuY3Rpb24oeCwgeSwgbW9kZSkge1xuXHRcdHZhciBhcnIgPSBbXTtcblx0XHR2YXIgcHQgPSB0aGlzLmxvY2FsVG9HbG9iYWwoeCwgeSk7XG5cdFx0dGhpcy5fZ2V0T2JqZWN0c1VuZGVyUG9pbnQocHQueCwgcHQueSwgYXJyLCBtb2RlPjAsIG1vZGU9PTEpO1xuXHRcdHJldHVybiBhcnI7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNpbWlsYXIgdG8ge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyL2dldE9iamVjdHNVbmRlclBvaW50XCJ9fXt7L2Nyb3NzTGlua319LCBidXQgcmV0dXJucyBvbmx5IHRoZSB0b3AtbW9zdCBkaXNwbGF5XG5cdCAqIG9iamVjdC4gVGhpcyBydW5zIHNpZ25pZmljYW50bHkgZmFzdGVyIHRoYW4gPGNvZGU+Z2V0T2JqZWN0c1VuZGVyUG9pbnQoKTwvY29kZT4sIGJ1dCBpcyBzdGlsbCBwb3RlbnRpYWxseSBhbiBleHBlbnNpdmVcblx0ICogb3BlcmF0aW9uLiBTZWUge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyL2dldE9iamVjdHNVbmRlclBvaW50XCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAbWV0aG9kIGdldE9iamVjdFVuZGVyUG9pbnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gaW4gdGhlIGNvbnRhaW5lciB0byB0ZXN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiBpbiB0aGUgY29udGFpbmVyIHRvIHRlc3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtb2RlIFRoZSBtb2RlIHRvIHVzZSB0byBkZXRlcm1pbmUgd2hpY2ggZGlzcGxheSBvYmplY3RzIHRvIGluY2x1ZGUuICAwLWFsbCwgMS1yZXNwZWN0IG1vdXNlRW5hYmxlZC9tb3VzZUNoaWxkcmVuLCAyLW9ubHkgbW91c2Ugb3BhcXVlIG9iamVjdHMuXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IFRoZSB0b3AtbW9zdCBkaXNwbGF5IG9iamVjdCB1bmRlciB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGVzLlxuXHQgKiovXG5cdHAuZ2V0T2JqZWN0VW5kZXJQb2ludCA9IGZ1bmN0aW9uKHgsIHksIG1vZGUpIHtcblx0XHR2YXIgcHQgPSB0aGlzLmxvY2FsVG9HbG9iYWwoeCwgeSk7XG5cdFx0cmV0dXJuIHRoaXMuX2dldE9iamVjdHNVbmRlclBvaW50KHB0LngsIHB0LnksIG51bGwsIG1vZGU+MCwgbW9kZT09MSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogRG9jY2VkIGluIHN1cGVyY2xhc3MuXG5cdCAqL1xuXHRwLmdldEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9nZXRCb3VuZHMobnVsbCwgdHJ1ZSk7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIERvY2NlZCBpbiBzdXBlcmNsYXNzLlxuXHQgKi9cblx0cC5nZXRUcmFuc2Zvcm1lZEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9nZXRCb3VuZHMoKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgQ29udGFpbmVyLiBTb21lIHByb3BlcnRpZXMgdGhhdCBhcmUgc3BlY2lmaWMgdG8gdGhpcyBpbnN0YW5jZSdzIGN1cnJlbnQgY29udGV4dCBhcmVcblx0ICogcmV2ZXJ0ZWQgdG8gdGhlaXIgZGVmYXVsdHMgKGZvciBleGFtcGxlIC5wYXJlbnQpLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlY3Vyc2l2ZT1mYWxzZV0gSWYgdHJ1ZSwgYWxsIG9mIHRoZSBkZXNjZW5kYW50cyBvZiB0aGlzIGNvbnRhaW5lciB3aWxsIGJlIGNsb25lZCByZWN1cnNpdmVseS4gSWYgZmFsc2UsIHRoZVxuXHQgKiBwcm9wZXJ0aWVzIG9mIHRoZSBjb250YWluZXIgd2lsbCBiZSBjbG9uZWQsIGJ1dCB0aGUgbmV3IGluc3RhbmNlIHdpbGwgbm90IGhhdmUgYW55IGNoaWxkcmVuLlxuXHQgKiBAcmV0dXJuIHtDb250YWluZXJ9IEEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgQ29udGFpbmVyIGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbihyZWN1cnNpdmUpIHtcblx0XHR2YXIgbyA9IHRoaXMuX2Nsb25lUHJvcHMobmV3IENvbnRhaW5lcigpKTtcblx0XHRpZiAocmVjdXJzaXZlKSB7IHRoaXMuX2Nsb25lQ2hpbGRyZW4obyk7IH1cblx0XHRyZXR1cm4gbztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0NvbnRhaW5lciAobmFtZT1cIisgIHRoaXMubmFtZSArXCIpXVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX3RpY2tcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2dE9iaiBBbiBldmVudCBvYmplY3QgdGhhdCB3aWxsIGJlIGRpc3BhdGNoZWQgdG8gYWxsIHRpY2sgbGlzdGVuZXJzLiBUaGlzIG9iamVjdCBpcyByZXVzZWQgYmV0d2VlbiBkaXNwYXRjaGVycyB0byByZWR1Y2UgY29uc3RydWN0aW9uICYgR0MgY29zdHMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl90aWNrID0gZnVuY3Rpb24oZXZ0T2JqKSB7XG5cdFx0aWYgKHRoaXMudGlja0NoaWxkcmVuKSB7XG5cdFx0XHRmb3IgKHZhciBpPXRoaXMuY2hpbGRyZW4ubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuXHRcdFx0XHRpZiAoY2hpbGQudGlja0VuYWJsZWQgJiYgY2hpbGQuX3RpY2spIHsgY2hpbGQuX3RpY2soZXZ0T2JqKTsgfVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLkRpc3BsYXlPYmplY3RfX3RpY2soZXZ0T2JqKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZWN1cnNpdmVseSBjbG9uZXMgYWxsIGNoaWxkcmVuIG9mIHRoaXMgY29udGFpbmVyLCBhbmQgYWRkcyB0aGVtIHRvIHRoZSB0YXJnZXQgY29udGFpbmVyLlxuXHQgKiBAbWV0aG9kIGNsb25lQ2hpbGRyZW5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge0NvbnRhaW5lcn0gbyBUaGUgdGFyZ2V0IGNvbnRhaW5lci5cblx0ICoqL1xuXHRwLl9jbG9uZUNoaWxkcmVuID0gZnVuY3Rpb24obykge1xuXHRcdGlmIChvLmNoaWxkcmVuLmxlbmd0aCkgeyBvLnJlbW92ZUFsbENoaWxkcmVuKCk7IH1cblx0XHR2YXIgYXJyID0gby5jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpPTAsIGw9dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHR2YXIgY2xvbmUgPSB0aGlzLmNoaWxkcmVuW2ldLmNsb25lKHRydWUpO1xuXHRcdFx0Y2xvbmUucGFyZW50ID0gbztcblx0XHRcdGFyci5wdXNoKGNsb25lKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldE9iamVjdHNVbmRlclBvaW50XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFyclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IG1vdXNlIElmIHRydWUsIGl0IHdpbGwgcmVzcGVjdCBtb3VzZSBpbnRlcmFjdGlvbiBwcm9wZXJ0aWVzIGxpa2UgbW91c2VFbmFibGVkLCBtb3VzZUNoaWxkcmVuLCBhbmQgYWN0aXZlIGxpc3RlbmVycy5cblx0ICogQHBhcmFtIHtCb29sZWFufSBhY3RpdmVMaXN0ZW5lciBJZiB0cnVlLCB0aGVyZSBpcyBhbiBhY3RpdmUgbW91c2UgZXZlbnQgbGlzdGVuZXIgb24gYSBwYXJlbnQgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3VycmVudERlcHRoIEluZGljYXRlcyB0aGUgY3VycmVudCBkZXB0aCBvZiB0aGUgc2VhcmNoLlxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ2V0T2JqZWN0c1VuZGVyUG9pbnQgPSBmdW5jdGlvbih4LCB5LCBhcnIsIG1vdXNlLCBhY3RpdmVMaXN0ZW5lciwgY3VycmVudERlcHRoKSB7XG5cdFx0Y3VycmVudERlcHRoID0gY3VycmVudERlcHRoIHx8IDA7XG5cdFx0aWYgKCFjdXJyZW50RGVwdGggJiYgIXRoaXMuX3Rlc3RNYXNrKHRoaXMsIHgsIHkpKSB7IHJldHVybiBudWxsOyB9XG5cdFx0dmFyIG10eCwgY3R4ID0gY3JlYXRlanMuRGlzcGxheU9iamVjdC5faGl0VGVzdENvbnRleHQ7XG5cdFx0YWN0aXZlTGlzdGVuZXIgPSBhY3RpdmVMaXN0ZW5lciB8fCAobW91c2UmJnRoaXMuX2hhc01vdXNlRXZlbnRMaXN0ZW5lcigpKTtcblxuXHRcdC8vIGRyYXcgY2hpbGRyZW4gb25lIGF0IGEgdGltZSwgYW5kIGNoZWNrIGlmIHdlIGdldCBhIGhpdDpcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLCBsID0gY2hpbGRyZW4ubGVuZ3RoO1xuXHRcdGZvciAodmFyIGk9bC0xOyBpPj0wOyBpLS0pIHtcblx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0dmFyIGhpdEFyZWEgPSBjaGlsZC5oaXRBcmVhO1xuXHRcdFx0aWYgKCFjaGlsZC52aXNpYmxlIHx8ICghaGl0QXJlYSAmJiAhY2hpbGQuaXNWaXNpYmxlKCkpIHx8IChtb3VzZSAmJiAhY2hpbGQubW91c2VFbmFibGVkKSkgeyBjb250aW51ZTsgfVxuXHRcdFx0aWYgKCFoaXRBcmVhICYmICF0aGlzLl90ZXN0TWFzayhjaGlsZCwgeCwgeSkpIHsgY29udGludWU7IH1cblx0XHRcdFxuXHRcdFx0Ly8gaWYgYSBjaGlsZCBjb250YWluZXIgaGFzIGEgaGl0QXJlYSB0aGVuIHdlIG9ubHkgbmVlZCB0byBjaGVjayBpdHMgaGl0QXJlYSwgc28gd2UgY2FuIHRyZWF0IGl0IGFzIGEgbm9ybWFsIERPOlxuXHRcdFx0aWYgKCFoaXRBcmVhICYmIGNoaWxkIGluc3RhbmNlb2YgQ29udGFpbmVyKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBjaGlsZC5fZ2V0T2JqZWN0c1VuZGVyUG9pbnQoeCwgeSwgYXJyLCBtb3VzZSwgYWN0aXZlTGlzdGVuZXIsIGN1cnJlbnREZXB0aCsxKTtcblx0XHRcdFx0aWYgKCFhcnIgJiYgcmVzdWx0KSB7IHJldHVybiAobW91c2UgJiYgIXRoaXMubW91c2VDaGlsZHJlbikgPyB0aGlzIDogcmVzdWx0OyB9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAobW91c2UgJiYgIWFjdGl2ZUxpc3RlbmVyICYmICFjaGlsZC5faGFzTW91c2VFdmVudExpc3RlbmVyKCkpIHsgY29udGludWU7IH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vIFRPRE86IGNhbiB3ZSBwYXNzIGRpc3BsYXlQcm9wcyBmb3J3YXJkLCB0byBhdm9pZCBoYXZpbmcgdG8gY2FsY3VsYXRlIHRoaXMgYmFja3dhcmRzIGV2ZXJ5IHRpbWU/IEl0J3Mga2luZCBvZiBhIG1peGVkIGJhZy4gV2hlbiB3ZSdyZSBvbmx5IGh1bnRpbmcgZm9yIERPcyB3aXRoIGV2ZW50IGxpc3RlbmVycywgaXQgbWF5IG5vdCBtYWtlIHNlbnNlLlxuXHRcdFx0XHR2YXIgcHJvcHMgPSBjaGlsZC5nZXRDb25jYXRlbmF0ZWREaXNwbGF5UHJvcHMoY2hpbGQuX3Byb3BzKTtcblx0XHRcdFx0bXR4ID0gcHJvcHMubWF0cml4O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGhpdEFyZWEpIHtcblx0XHRcdFx0XHRtdHguYXBwZW5kTWF0cml4KGhpdEFyZWEuZ2V0TWF0cml4KGhpdEFyZWEuX3Byb3BzLm1hdHJpeCkpO1xuXHRcdFx0XHRcdHByb3BzLmFscGhhID0gaGl0QXJlYS5hbHBoYTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gcHJvcHMuYWxwaGE7XG5cdFx0XHRcdGN0eC5zZXRUcmFuc2Zvcm0obXR4LmEsICBtdHguYiwgbXR4LmMsIG10eC5kLCBtdHgudHgteCwgbXR4LnR5LXkpO1xuXHRcdFx0XHQoaGl0QXJlYXx8Y2hpbGQpLmRyYXcoY3R4KTtcblx0XHRcdFx0aWYgKCF0aGlzLl90ZXN0SGl0KGN0eCkpIHsgY29udGludWU7IH1cblx0XHRcdFx0Y3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblx0XHRcdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCAyLCAyKTtcblx0XHRcdFx0aWYgKGFycikgeyBhcnIucHVzaChjaGlsZCk7IH1cblx0XHRcdFx0ZWxzZSB7IHJldHVybiAobW91c2UgJiYgIXRoaXMubW91c2VDaGlsZHJlbikgPyB0aGlzIDogY2hpbGQ7IH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfdGVzdE1hc2tcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSB0YXJnZXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHgveSBpcyB3aXRoaW4gdGhlIG1hc2tlZCByZWdpb24uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl90ZXN0TWFzayA9IGZ1bmN0aW9uKHRhcmdldCwgeCwgeSkge1xuXHRcdHZhciBtYXNrID0gdGFyZ2V0Lm1hc2s7XG5cdFx0aWYgKCFtYXNrIHx8ICFtYXNrLmdyYXBoaWNzIHx8IG1hc2suZ3JhcGhpY3MuaXNFbXB0eSgpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0XG5cdFx0dmFyIG10eCA9IHRoaXMuX3Byb3BzLm1hdHJpeCwgcGFyZW50ID0gdGFyZ2V0LnBhcmVudDtcblx0XHRtdHggPSBwYXJlbnQgPyBwYXJlbnQuZ2V0Q29uY2F0ZW5hdGVkTWF0cml4KG10eCkgOiBtdHguaWRlbnRpdHkoKTtcblx0XHRtdHggPSBtYXNrLmdldE1hdHJpeChtYXNrLl9wcm9wcy5tYXRyaXgpLnByZXBlbmRNYXRyaXgobXR4KTtcblx0XHRcblx0XHR2YXIgY3R4ID0gY3JlYXRlanMuRGlzcGxheU9iamVjdC5faGl0VGVzdENvbnRleHQ7XG5cdFx0Y3R4LnNldFRyYW5zZm9ybShtdHguYSwgIG10eC5iLCBtdHguYywgbXR4LmQsIG10eC50eC14LCBtdHgudHkteSk7XG5cdFx0XG5cdFx0Ly8gZHJhdyB0aGUgbWFzayBhcyBhIHNvbGlkIGZpbGw6XG5cdFx0bWFzay5ncmFwaGljcy5kcmF3QXNQYXRoKGN0eCk7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9IFwiIzAwMFwiO1xuXHRcdGN0eC5maWxsKCk7XG5cdFx0XG5cdFx0aWYgKCF0aGlzLl90ZXN0SGl0KGN0eCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Y3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIDIsIDIpO1xuXHRcdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldEJvdW5kc1xuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXhcblx0ICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVUcmFuc2Zvcm0gSWYgdHJ1ZSwgZG9lcyBub3QgYXBwbHkgdGhpcyBvYmplY3QncyB0cmFuc2Zvcm0uXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dldEJvdW5kcyA9IGZ1bmN0aW9uKG1hdHJpeCwgaWdub3JlVHJhbnNmb3JtKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuRGlzcGxheU9iamVjdF9nZXRCb3VuZHMoKTtcblx0XHRpZiAoYm91bmRzKSB7IHJldHVybiB0aGlzLl90cmFuc2Zvcm1Cb3VuZHMoYm91bmRzLCBtYXRyaXgsIGlnbm9yZVRyYW5zZm9ybSk7IH1cblx0XHRcblx0XHR2YXIgbXR4ID0gdGhpcy5fcHJvcHMubWF0cml4O1xuXHRcdG10eCA9IGlnbm9yZVRyYW5zZm9ybSA/IG10eC5pZGVudGl0eSgpIDogdGhpcy5nZXRNYXRyaXgobXR4KTtcblx0XHRpZiAobWF0cml4KSB7IG10eC5wcmVwZW5kTWF0cml4KG1hdHJpeCk7IH1cblx0XHRcblx0XHR2YXIgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoLCByZWN0PW51bGw7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcblx0XHRcdGlmICghY2hpbGQudmlzaWJsZSB8fCAhKGJvdW5kcyA9IGNoaWxkLl9nZXRCb3VuZHMobXR4KSkpIHsgY29udGludWU7IH1cblx0XHRcdGlmIChyZWN0KSB7IHJlY3QuZXh0ZW5kKGJvdW5kcy54LCBib3VuZHMueSwgYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0KTsgfVxuXHRcdFx0ZWxzZSB7IHJlY3QgPSBib3VuZHMuY2xvbmUoKTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gcmVjdDtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLkNvbnRhaW5lciA9IGNyZWF0ZWpzLnByb21vdGUoQ29udGFpbmVyLCBcIkRpc3BsYXlPYmplY3RcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU3RhZ2UuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBBIHN0YWdlIGlzIHRoZSByb290IGxldmVsIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lclwifX17ey9jcm9zc0xpbmt9fSBmb3IgYSBkaXNwbGF5IGxpc3QuIEVhY2ggdGltZSBpdHMge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdGlja1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QgaXMgY2FsbGVkLCBpdCB3aWxsIHJlbmRlciBpdHMgZGlzcGxheSBsaXN0IHRvIGl0cyB0YXJnZXQgY2FudmFzLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIFRoaXMgZXhhbXBsZSBjcmVhdGVzIGEgc3RhZ2UsIGFkZHMgYSBjaGlsZCB0byBpdCwgdGhlbiB1c2VzIHt7I2Nyb3NzTGluayBcIlRpY2tlclwifX17ey9jcm9zc0xpbmt9fSB0byB1cGRhdGUgdGhlIGNoaWxkXG5cdCAqIGFuZCByZWRyYXcgdGhlIHN0YWdlIHVzaW5nIHt7I2Nyb3NzTGluayBcIlN0YWdlL3VwZGF0ZVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogICAgICB2YXIgc3RhZ2UgPSBuZXcgY3JlYXRlanMuU3RhZ2UoXCJjYW52YXNFbGVtZW50SWRcIik7XG5cdCAqICAgICAgdmFyIGltYWdlID0gbmV3IGNyZWF0ZWpzLkJpdG1hcChcImltYWdlUGF0aC5wbmdcIik7XG5cdCAqICAgICAgc3RhZ2UuYWRkQ2hpbGQoaW1hZ2UpO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlRpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBoYW5kbGVUaWNrKTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVUaWNrKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIGltYWdlLnggKz0gMTA7XG5cdCAqICAgICAgICAgIHN0YWdlLnVwZGF0ZSgpO1xuXHQgKiAgICAgIH1cblx0ICpcblx0ICogQGNsYXNzIFN0YWdlXG5cdCAqIEBleHRlbmRzIENvbnRhaW5lclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudCB8IFN0cmluZyB8IE9iamVjdH0gY2FudmFzIEEgY2FudmFzIG9iamVjdCB0aGF0IHRoZSBTdGFnZSB3aWxsIHJlbmRlciB0bywgb3IgdGhlIHN0cmluZyBpZFxuXHQgKiBvZiBhIGNhbnZhcyBvYmplY3QgaW4gdGhlIGN1cnJlbnQgZG9jdW1lbnQuXG5cdCAqKi9cblx0ZnVuY3Rpb24gU3RhZ2UoY2FudmFzKSB7XG5cdFx0dGhpcy5Db250YWluZXJfY29uc3RydWN0b3IoKTtcblx0XG5cdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3RhZ2Ugc2hvdWxkIGF1dG9tYXRpY2FsbHkgY2xlYXIgdGhlIGNhbnZhcyBiZWZvcmUgZWFjaCByZW5kZXIuIFlvdSBjYW4gc2V0IHRoaXMgdG8gPGNvZGU+ZmFsc2U8L2NvZGU+XG5cdFx0ICogdG8gbWFudWFsbHkgY29udHJvbCBjbGVhcmluZyAoZm9yIGdlbmVyYXRpdmUgYXJ0LCBvciB3aGVuIHBvaW50aW5nIG11bHRpcGxlIHN0YWdlcyBhdCB0aGUgc2FtZSBjYW52YXMgZm9yXG5cdFx0ICogZXhhbXBsZSkuXG5cdFx0ICpcblx0XHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdFx0ICpcblx0XHQgKiAgICAgIHZhciBzdGFnZSA9IG5ldyBjcmVhdGVqcy5TdGFnZShcImNhbnZhc0lkXCIpO1xuXHRcdCAqICAgICAgc3RhZ2UuYXV0b0NsZWFyID0gZmFsc2U7XG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgYXV0b0NsZWFyXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKiovXG5cdFx0dGhpcy5hdXRvQ2xlYXIgPSB0cnVlO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY2FudmFzIHRoZSBzdGFnZSB3aWxsIHJlbmRlciB0by4gTXVsdGlwbGUgc3RhZ2VzIGNhbiBzaGFyZSBhIHNpbmdsZSBjYW52YXMsIGJ1dCB5b3UgbXVzdCBkaXNhYmxlIGF1dG9DbGVhciBmb3IgYWxsIGJ1dCB0aGVcblx0XHQgKiBmaXJzdCBzdGFnZSB0aGF0IHdpbGwgYmUgdGlja2VkIChvciB0aGV5IHdpbGwgY2xlYXIgZWFjaCBvdGhlcidzIHJlbmRlcikuXG5cdFx0ICpcblx0XHQgKiBXaGVuIGNoYW5naW5nIHRoZSBjYW52YXMgcHJvcGVydHkgeW91IG11c3QgZGlzYWJsZSB0aGUgZXZlbnRzIG9uIHRoZSBvbGQgY2FudmFzLCBhbmQgZW5hYmxlIGV2ZW50cyBvbiB0aGVcblx0XHQgKiBuZXcgY2FudmFzIG9yIG1vdXNlIGV2ZW50cyB3aWxsIG5vdCB3b3JrIGFzIGV4cGVjdGVkLiBGb3IgZXhhbXBsZTpcblx0XHQgKlxuXHRcdCAqICAgICAgbXlTdGFnZS5lbmFibGVET01FdmVudHMoZmFsc2UpO1xuXHRcdCAqICAgICAgbXlTdGFnZS5jYW52YXMgPSBhbm90aGVyQ2FudmFzO1xuXHRcdCAqICAgICAgbXlTdGFnZS5lbmFibGVET01FdmVudHModHJ1ZSk7XG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgY2FudmFzXG5cdFx0ICogQHR5cGUgSFRNTENhbnZhc0VsZW1lbnQgfCBPYmplY3Rcblx0XHQgKiovXG5cdFx0dGhpcy5jYW52YXMgPSAodHlwZW9mIGNhbnZhcyA9PSBcInN0cmluZ1wiKSA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhcykgOiBjYW52YXM7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IG1vdXNlIFggcG9zaXRpb24gb24gdGhlIGNhbnZhcy4gSWYgdGhlIG1vdXNlIGxlYXZlcyB0aGUgY2FudmFzLCB0aGlzIHdpbGwgaW5kaWNhdGUgdGhlIG1vc3QgcmVjZW50XG5cdFx0ICogcG9zaXRpb24gb3ZlciB0aGUgY2FudmFzLCBhbmQgbW91c2VJbkJvdW5kcyB3aWxsIGJlIHNldCB0byBmYWxzZS5cblx0XHQgKiBAcHJvcGVydHkgbW91c2VYXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMubW91c2VYID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgbW91c2UgWSBwb3NpdGlvbiBvbiB0aGUgY2FudmFzLiBJZiB0aGUgbW91c2UgbGVhdmVzIHRoZSBjYW52YXMsIHRoaXMgd2lsbCBpbmRpY2F0ZSB0aGUgbW9zdCByZWNlbnRcblx0XHQgKiBwb3NpdGlvbiBvdmVyIHRoZSBjYW52YXMsIGFuZCBtb3VzZUluQm91bmRzIHdpbGwgYmUgc2V0IHRvIGZhbHNlLlxuXHRcdCAqIEBwcm9wZXJ0eSBtb3VzZVlcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5tb3VzZVkgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBTcGVjaWZpZXMgdGhlIGFyZWEgb2YgdGhlIHN0YWdlIHRvIGFmZmVjdCB3aGVuIGNhbGxpbmcgdXBkYXRlLiBUaGlzIGNhbiBiZSB1c2UgdG8gc2VsZWN0aXZlbHlcblx0XHQgKiByZS1kcmF3IHNwZWNpZmljIHJlZ2lvbnMgb2YgdGhlIGNhbnZhcy4gSWYgbnVsbCwgdGhlIHdob2xlIGNhbnZhcyBhcmVhIGlzIGRyYXduLlxuXHRcdCAqIEBwcm9wZXJ0eSBkcmF3UmVjdFxuXHRcdCAqIEB0eXBlIHtSZWN0YW5nbGV9XG5cdFx0ICovXG5cdFx0dGhpcy5kcmF3UmVjdCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIGRpc3BsYXkgb2JqZWN0cyBzaG91bGQgYmUgcmVuZGVyZWQgb24gd2hvbGUgcGl4ZWxzLiBZb3UgY2FuIHNldCB0aGVcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3NuYXBUb1BpeGVsXCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IG9mXG5cdFx0ICogZGlzcGxheSBvYmplY3RzIHRvIGZhbHNlIHRvIGVuYWJsZS9kaXNhYmxlIHRoaXMgYmVoYXZpb3VyIG9uIGEgcGVyIGluc3RhbmNlIGJhc2lzLlxuXHRcdCAqIEBwcm9wZXJ0eSBzbmFwVG9QaXhlbEVuYWJsZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiovXG5cdFx0dGhpcy5zbmFwVG9QaXhlbEVuYWJsZWQgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG1vdXNlIGlzIGN1cnJlbnRseSB3aXRoaW4gdGhlIGJvdW5kcyBvZiB0aGUgY2FudmFzLlxuXHRcdCAqIEBwcm9wZXJ0eSBtb3VzZUluQm91bmRzXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICoqL1xuXHRcdHRoaXMubW91c2VJbkJvdW5kcyA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBJZiB0cnVlLCB0aWNrIGNhbGxiYWNrcyB3aWxsIGJlIGNhbGxlZCBvbiBhbGwgZGlzcGxheSBvYmplY3RzIG9uIHRoZSBzdGFnZSBwcmlvciB0byByZW5kZXJpbmcgdG8gdGhlIGNhbnZhcy5cblx0XHQgKiBAcHJvcGVydHkgdGlja09uVXBkYXRlXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKiovXG5cdFx0dGhpcy50aWNrT25VcGRhdGUgPSB0cnVlO1xuXHRcblx0XHQvKipcblx0XHQgKiBJZiB0cnVlLCBtb3VzZSBtb3ZlIGV2ZW50cyB3aWxsIGNvbnRpbnVlIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIHRhcmdldCBjYW52YXMuIFNlZVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIlN0YWdlL21vdXNlSW5Cb3VuZHM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0sIGFuZCB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogeC95L3Jhd1gvcmF3WS5cblx0XHQgKiBAcHJvcGVydHkgbW91c2VNb3ZlT3V0c2lkZVxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqKi9cblx0XHR0aGlzLm1vdXNlTW92ZU91dHNpZGUgPSBmYWxzZTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBQcmV2ZW50cyBzZWxlY3Rpb24gb2Ygb3RoZXIgZWxlbWVudHMgaW4gdGhlIGh0bWwgcGFnZSBpZiB0aGUgdXNlciBjbGlja3MgYW5kIGRyYWdzLCBvciBkb3VibGUgY2xpY2tzIG9uIHRoZSBjYW52YXMuXG5cdFx0ICogVGhpcyB3b3JrcyBieSBjYWxsaW5nIGBwcmV2ZW50RGVmYXVsdCgpYCBvbiBhbnkgbW91c2Vkb3duIGV2ZW50cyAob3IgdG91Y2ggZXF1aXZhbGVudCkgb3JpZ2luYXRpbmcgb24gdGhlIGNhbnZhcy5cblx0XHQgKiBAcHJvcGVydHkgcHJldmVudFNlbGVjdGlvblxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICoqL1xuXHRcdHRoaXMucHJldmVudFNlbGVjdGlvbiA9IHRydWU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBoaXRBcmVhIHByb3BlcnR5IGlzIG5vdCBzdXBwb3J0ZWQgZm9yIFN0YWdlLlxuXHRcdCAqIEBwcm9wZXJ0eSBoaXRBcmVhXG5cdFx0ICogQHR5cGUge0Rpc3BsYXlPYmplY3R9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdCBcblx0XHQgXG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBIb2xkcyBvYmplY3RzIHdpdGggZGF0YSBmb3IgZWFjaCBhY3RpdmUgcG9pbnRlciBpZC4gRWFjaCBvYmplY3QgaGFzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcblx0XHQgKiB4LCB5LCBldmVudCwgdGFyZ2V0LCBvdmVyVGFyZ2V0LCBvdmVyWCwgb3ZlclksIGluQm91bmRzLCBwb3NFdnRPYmogKG5hdGl2ZSBldmVudCB0aGF0IGxhc3QgdXBkYXRlZCBwb3NpdGlvbilcblx0XHQgKiBAcHJvcGVydHkgX3BvaW50ZXJEYXRhXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3BvaW50ZXJEYXRhID0ge307XG5cdFxuXHRcdC8qKlxuXHRcdCAqIE51bWJlciBvZiBhY3RpdmUgcG9pbnRlcnMuXG5cdFx0ICogQHByb3BlcnR5IF9wb2ludGVyQ291bnRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcG9pbnRlckNvdW50ID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIElEIG9mIHRoZSBwcmltYXJ5IHBvaW50ZXIuXG5cdFx0ICogQHByb3BlcnR5IF9wcmltYXJ5UG9pbnRlcklEXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3ByaW1hcnlQb2ludGVySUQgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX21vdXNlT3ZlckludGVydmFsSURcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX21vdXNlT3ZlckludGVydmFsSUQgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfbmV4dFN0YWdlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIFN0YWdlXG5cdFx0ICoqL1xuXHRcdHRoaXMuX25leHRTdGFnZSA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9wcmV2U3RhZ2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgU3RhZ2Vcblx0XHQgKiovXG5cdFx0dGhpcy5fcHJldlN0YWdlID0gbnVsbDtcblx0XHRcblx0XHRcblx0Ly8gaW5pdGlhbGl6ZTpcblx0XHR0aGlzLmVuYWJsZURPTUV2ZW50cyh0cnVlKTtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChTdGFnZSwgY3JlYXRlanMuQ29udGFpbmVyKTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblxuLy8gZXZlbnRzOlxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSB1c2VyIG1vdmVzIHRoZSBtb3VzZSBvdmVyIHRoZSBjYW52YXMuXG5cdCAqIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXG5cdCAqIEBldmVudCBzdGFnZW1vdXNlbW92ZVxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIHRoZWlyIGxlZnQgbW91c2UgYnV0dG9uIG9uIHRoZSBjYW52YXMuIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXG5cdCAqIEBldmVudCBzdGFnZW1vdXNlZG93blxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgdXNlciB0aGUgdXNlciBwcmVzc2VzIHNvbWV3aGVyZSBvbiB0aGUgc3RhZ2UsIHRoZW4gcmVsZWFzZXMgdGhlIG1vdXNlIGJ1dHRvbiBhbnl3aGVyZSB0aGF0IHRoZSBwYWdlIGNhbiBkZXRlY3QgaXQgKHRoaXMgdmFyaWVzIHNsaWdodGx5IGJldHdlZW4gYnJvd3NlcnMpLlxuXHQgKiBZb3UgY2FuIHVzZSB7eyNjcm9zc0xpbmsgXCJTdGFnZS9tb3VzZUluQm91bmRzOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHRvIGNoZWNrIHdoZXRoZXIgdGhlIG1vdXNlIGlzIGN1cnJlbnRseSB3aXRoaW4gdGhlIHN0YWdlIGJvdW5kcy5cblx0ICogU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cblx0ICogQGV2ZW50IHN0YWdlbW91c2V1cFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgbW91c2UgbW92ZXMgZnJvbSB3aXRoaW4gdGhlIGNhbnZhcyBhcmVhIChtb3VzZUluQm91bmRzID09IHRydWUpIHRvIG91dHNpZGUgaXQgKG1vdXNlSW5Cb3VuZHMgPT0gZmFsc2UpLlxuXHQgKiBUaGlzIGlzIGN1cnJlbnRseSBvbmx5IGRpc3BhdGNoZWQgZm9yIG1vdXNlIGlucHV0IChub3QgdG91Y2gpLiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxuXHQgKiBAZXZlbnQgbW91c2VsZWF2ZVxuXHQgKiBAc2luY2UgMC43LjBcblx0ICovXG5cblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgbW91c2UgbW92ZXMgaW50byB0aGUgY2FudmFzIGFyZWEgKG1vdXNlSW5Cb3VuZHMgPT0gZmFsc2UpIGZyb20gb3V0c2lkZSBpdCAobW91c2VJbkJvdW5kcyA9PSB0cnVlKS5cblx0ICogVGhpcyBpcyBjdXJyZW50bHkgb25seSBkaXNwYXRjaGVkIGZvciBtb3VzZSBpbnB1dCAobm90IHRvdWNoKS4gU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cblx0ICogQGV2ZW50IG1vdXNlZW50ZXJcblx0ICogQHNpbmNlIDAuNy4wXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIGVhY2ggdXBkYXRlIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgdGljayBldmVudCBpcyBwcm9wYWdhdGVkIHRocm91Z2ggdGhlIGRpc3BsYXkgbGlzdC5cblx0ICogWW91IGNhbiBjYWxsIHByZXZlbnREZWZhdWx0IG9uIHRoZSBldmVudCBvYmplY3QgdG8gY2FuY2VsIHByb3BhZ2F0aW5nIHRoZSB0aWNrIGV2ZW50LlxuXHQgKiBAZXZlbnQgdGlja3N0YXJ0XG5cdCAqIEBzaW5jZSAwLjcuMFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCBlYWNoIHVwZGF0ZSBpbW1lZGlhdGVseSBhZnRlciB0aGUgdGljayBldmVudCBpcyBwcm9wYWdhdGVkIHRocm91Z2ggdGhlIGRpc3BsYXkgbGlzdC4gRG9lcyBub3QgZmlyZSBpZlxuXHQgKiB0aWNrT25VcGRhdGUgaXMgZmFsc2UuIFByZWNlZGVzIHRoZSBcImRyYXdzdGFydFwiIGV2ZW50LlxuXHQgKiBAZXZlbnQgdGlja2VuZFxuXHQgKiBAc2luY2UgMC43LjBcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgZWFjaCB1cGRhdGUgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBjYW52YXMgaXMgY2xlYXJlZCBhbmQgdGhlIGRpc3BsYXkgbGlzdCBpcyBkcmF3biB0byBpdC5cblx0ICogWW91IGNhbiBjYWxsIHByZXZlbnREZWZhdWx0IG9uIHRoZSBldmVudCBvYmplY3QgdG8gY2FuY2VsIHRoZSBkcmF3LlxuXHQgKiBAZXZlbnQgZHJhd3N0YXJ0XG5cdCAqIEBzaW5jZSAwLjcuMFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCBlYWNoIHVwZGF0ZSBpbW1lZGlhdGVseSBhZnRlciB0aGUgZGlzcGxheSBsaXN0IGlzIGRyYXduIHRvIHRoZSBjYW52YXMgYW5kIHRoZSBjYW52YXMgY29udGV4dCBpcyByZXN0b3JlZC5cblx0ICogQGV2ZW50IGRyYXdlbmRcblx0ICogQHNpbmNlIDAuNy4wXG5cdCAqL1xuXG5cdCBcbi8vIGdldHRlciAvIHNldHRlcnM6XG5cdC8qKlxuXHQgKiBTcGVjaWZpZXMgYSB0YXJnZXQgc3RhZ2UgdGhhdCB3aWxsIGhhdmUgbW91c2UgLyB0b3VjaCBpbnRlcmFjdGlvbnMgcmVsYXllZCB0byBpdCBhZnRlciB0aGlzIHN0YWdlIGhhbmRsZXMgdGhlbS5cblx0ICogVGhpcyBjYW4gYmUgdXNlZnVsIGluIGNhc2VzIHdoZXJlIHlvdSBoYXZlIG11bHRpcGxlIGxheWVyZWQgY2FudmFzZXMgYW5kIHdhbnQgdXNlciBpbnRlcmFjdGlvbnNcblx0ICogZXZlbnRzIHRvIHBhc3MgdGhyb3VnaC4gRm9yIGV4YW1wbGUsIHRoaXMgd291bGQgcmVsYXkgbW91c2UgZXZlbnRzIGZyb20gdG9wU3RhZ2UgdG8gYm90dG9tU3RhZ2U6XG5cdCAqXG5cdCAqICAgICAgdG9wU3RhZ2UubmV4dFN0YWdlID0gYm90dG9tU3RhZ2U7XG5cdCAqXG5cdCAqIFRvIGRpc2FibGUgcmVsYXlpbmcsIHNldCBuZXh0U3RhZ2UgdG8gbnVsbC5cblx0ICogXG5cdCAqIE1vdXNlT3ZlciwgTW91c2VPdXQsIFJvbGxPdmVyLCBhbmQgUm9sbE91dCBpbnRlcmFjdGlvbnMgYXJlIGFsc28gcGFzc2VkIHRocm91Z2ggdXNpbmcgdGhlIG1vdXNlIG92ZXIgc2V0dGluZ3Ncblx0ICogb2YgdGhlIHRvcC1tb3N0IHN0YWdlLCBidXQgYXJlIG9ubHkgcHJvY2Vzc2VkIGlmIHRoZSB0YXJnZXQgc3RhZ2UgaGFzIG1vdXNlIG92ZXIgaW50ZXJhY3Rpb25zIGVuYWJsZWQuXG5cdCAqIENvbnNpZGVyYXRpb25zIHdoZW4gdXNpbmcgcm9sbCBvdmVyIGluIHJlbGF5IHRhcmdldHM6PE9MPlxuXHQgKiA8TEk+IFRoZSB0b3AtbW9zdCAoZmlyc3QpIHN0YWdlIG11c3QgaGF2ZSBtb3VzZSBvdmVyIGludGVyYWN0aW9ucyBlbmFibGVkICh2aWEgZW5hYmxlTW91c2VPdmVyKTwvTEk+XG5cdCAqIDxMST4gQWxsIHN0YWdlcyB0aGF0IHdpc2ggdG8gcGFydGljaXBhdGUgaW4gbW91c2Ugb3ZlciBpbnRlcmFjdGlvbiBtdXN0IGVuYWJsZSB0aGVtIHZpYSBlbmFibGVNb3VzZU92ZXI8L0xJPlxuXHQgKiA8TEk+IEFsbCByZWxheSB0YXJnZXRzIHdpbGwgc2hhcmUgdGhlIGZyZXF1ZW5jeSB2YWx1ZSBvZiB0aGUgdG9wLW1vc3Qgc3RhZ2U8L0xJPlxuXHQgKiA8L09MPlxuXHQgKiBUbyBpbGx1c3RyYXRlLCBpbiB0aGlzIGV4YW1wbGUgdGhlIHRhcmdldFN0YWdlIHdvdWxkIHByb2Nlc3MgbW91c2Ugb3ZlciBpbnRlcmFjdGlvbnMgYXQgMTBoeiAoZGVzcGl0ZSBwYXNzaW5nXG5cdCAqIDMwIGFzIGl0J3MgZGVzaXJlZCBmcmVxdWVuY3kpOlxuXHQgKiBcdHRvcFN0YWdlLm5leHRTdGFnZSA9IHRhcmdldFN0YWdlO1xuXHQgKiBcdHRvcFN0YWdlLmVuYWJsZU1vdXNlT3ZlcigxMCk7XG5cdCAqIFx0dGFyZ2V0U3RhZ2UuZW5hYmxlTW91c2VPdmVyKDMwKTtcblx0ICogXG5cdCAqIElmIHRoZSB0YXJnZXQgc3RhZ2UncyBjYW52YXMgaXMgY29tcGxldGVseSBjb3ZlcmVkIGJ5IHRoaXMgc3RhZ2UncyBjYW52YXMsIHlvdSBtYXkgYWxzbyB3YW50IHRvIGRpc2FibGUgaXRzXG5cdCAqIERPTSBldmVudHMgdXNpbmc6XG5cdCAqIFxuXHQgKlx0dGFyZ2V0U3RhZ2UuZW5hYmxlRE9NRXZlbnRzKGZhbHNlKTtcblx0ICogXG5cdCAqIEBwcm9wZXJ0eSBuZXh0U3RhZ2Vcblx0ICogQHR5cGUge1N0YWdlfVxuXHQgKiovXG5cdHAuX2dldF9uZXh0U3RhZ2UgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbmV4dFN0YWdlO1xuXHR9O1xuXHRwLl9zZXRfbmV4dFN0YWdlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAodGhpcy5fbmV4dFN0YWdlKSB7IHRoaXMuX25leHRTdGFnZS5fcHJldlN0YWdlID0gbnVsbDsgfVxuXHRcdGlmICh2YWx1ZSkgeyB2YWx1ZS5fcHJldlN0YWdlID0gdGhpczsgfVxuXHRcdHRoaXMuX25leHRTdGFnZSA9IHZhbHVlO1xuXHR9O1xuXHRcblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cdFx0XHRuZXh0U3RhZ2U6IHsgZ2V0OiBwLl9nZXRfbmV4dFN0YWdlLCBzZXQ6IHAuX3NldF9uZXh0U3RhZ2UgfVxuXHRcdH0pO1xuXHR9IGNhdGNoIChlKSB7fSAvLyBUT0RPOiB1c2UgTG9nXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBFYWNoIHRpbWUgdGhlIHVwZGF0ZSBtZXRob2QgaXMgY2FsbGVkLCB0aGUgc3RhZ2Ugd2lsbCBjYWxsIHt7I2Nyb3NzTGluayBcIlN0YWdlL3RpY2tcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogdW5sZXNzIHt7I2Nyb3NzTGluayBcIlN0YWdlL3RpY2tPblVwZGF0ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpcyBzZXQgdG8gZmFsc2UsXG5cdCAqIGFuZCB0aGVuIHJlbmRlciB0aGUgZGlzcGxheSBsaXN0IHRvIHRoZSBjYW52YXMuXG5cdCAqXG5cdCAqIEBtZXRob2QgdXBkYXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIFByb3BzIG9iamVjdCB0byBwYXNzIHRvIGB0aWNrKClgLiBTaG91bGQgdXN1YWxseSBiZSBhIHt7I2Nyb3NzTGluayBcIlRpY2tlclwifX17ey9jcm9zc0xpbmt9fSBldmVudCBvYmplY3QsIG9yIHNpbWlsYXIgb2JqZWN0IHdpdGggYSBkZWx0YSBwcm9wZXJ0eS5cblx0ICoqL1xuXHRwLnVwZGF0ZSA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0aWYgKCF0aGlzLmNhbnZhcykgeyByZXR1cm47IH1cblx0XHRpZiAodGhpcy50aWNrT25VcGRhdGUpIHsgdGhpcy50aWNrKHByb3BzKTsgfVxuXHRcdGlmICh0aGlzLmRpc3BhdGNoRXZlbnQoXCJkcmF3c3RhcnRcIiwgZmFsc2UsIHRydWUpID09PSBmYWxzZSkgeyByZXR1cm47IH1cblx0XHRjcmVhdGVqcy5EaXNwbGF5T2JqZWN0Ll9zbmFwVG9QaXhlbEVuYWJsZWQgPSB0aGlzLnNuYXBUb1BpeGVsRW5hYmxlZDtcblx0XHR2YXIgciA9IHRoaXMuZHJhd1JlY3QsIGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHRjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdGlmICh0aGlzLmF1dG9DbGVhcikge1xuXHRcdFx0aWYgKHIpIHsgY3R4LmNsZWFyUmVjdChyLngsIHIueSwgci53aWR0aCwgci5oZWlnaHQpOyB9XG5cdFx0XHRlbHNlIHsgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCsxLCB0aGlzLmNhbnZhcy5oZWlnaHQrMSk7IH1cblx0XHR9XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRpZiAodGhpcy5kcmF3UmVjdCkge1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Y3R4LnJlY3Qoci54LCByLnksIHIud2lkdGgsIHIuaGVpZ2h0KTtcblx0XHRcdGN0eC5jbGlwKCk7XG5cdFx0fVxuXHRcdHRoaXMudXBkYXRlQ29udGV4dChjdHgpO1xuXHRcdHRoaXMuZHJhdyhjdHgsIGZhbHNlKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcImRyYXdlbmRcIik7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUHJvcGFnYXRlcyBhIHRpY2sgZXZlbnQgdGhyb3VnaCB0aGUgZGlzcGxheSBsaXN0LiBUaGlzIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIGJ5IHt7I2Nyb3NzTGluayBcIlN0YWdlL3VwZGF0ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB1bmxlc3Mge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdGlja09uVXBkYXRlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlzIHNldCB0byBmYWxzZS5cblx0ICpcblx0ICogSWYgYSBwcm9wcyBvYmplY3QgaXMgcGFzc2VkIHRvIGB0aWNrKClgLCB0aGVuIGFsbCBvZiBpdHMgcHJvcGVydGllcyB3aWxsIGJlIGNvcGllZCB0byB0aGUgZXZlbnQgb2JqZWN0IHRoYXQgaXNcblx0ICogcHJvcGFnYXRlZCB0byBsaXN0ZW5lcnMuXG5cdCAqXG5cdCAqIFNvbWUgdGltZS1iYXNlZCBmZWF0dXJlcyBpbiBFYXNlbEpTIChmb3IgZXhhbXBsZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZnJhbWVyYXRlXCJ9fXt7L2Nyb3NzTGlua319IHJlcXVpcmUgdGhhdFxuXHQgKiBhIHt7I2Nyb3NzTGluayBcIlRpY2tlci90aWNrOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IG9iamVjdCAob3IgZXF1aXZhbGVudCBvYmplY3Qgd2l0aCBhIGRlbHRhIHByb3BlcnR5KSBiZVxuXHQgKiBwYXNzZWQgYXMgdGhlIGBwcm9wc2AgcGFyYW1ldGVyIHRvIGB0aWNrKClgLiBGb3IgZXhhbXBsZTpcblx0ICpcblx0ICogXHRUaWNrZXIub24oXCJ0aWNrXCIsIGhhbmRsZVRpY2spO1xuXHQgKiBcdGZ1bmN0aW9uIGhhbmRsZVRpY2soZXZ0T2JqKSB7XG5cdCAqIFx0XHQvLyBjbG9uZSB0aGUgZXZlbnQgb2JqZWN0IGZyb20gVGlja2VyLCBhbmQgYWRkIHNvbWUgY3VzdG9tIGRhdGEgdG8gaXQ6XG5cdCAqIFx0XHR2YXIgZXZ0ID0gZXZ0T2JqLmNsb25lKCkuc2V0KHtncmVldGluZzpcImhlbGxvXCIsIG5hbWU6XCJ3b3JsZFwifSk7XG5cdCAqIFx0XHRcblx0ICogXHRcdC8vIHBhc3MgaXQgdG8gc3RhZ2UudXBkYXRlKCk6XG5cdCAqIFx0XHRteVN0YWdlLnVwZGF0ZShldnQpOyAvLyBzdWJzZXF1ZW50bHkgY2FsbHMgdGljaygpIHdpdGggdGhlIHNhbWUgcGFyYW1cblx0ICogXHR9XG5cdCAqIFx0XG5cdCAqIFx0Ly8gLi4uXG5cdCAqIFx0bXlEaXNwbGF5T2JqZWN0Lm9uKFwidGlja1wiLCBoYW5kbGVEaXNwbGF5T2JqZWN0VGljayk7XG5cdCAqIFx0ZnVuY3Rpb24gaGFuZGxlRGlzcGxheU9iamVjdFRpY2soZXZ0KSB7XG5cdCAqIFx0XHRjb25zb2xlLmxvZyhldnQuZGVsdGEpOyAvLyB0aGUgZGVsdGEgcHJvcGVydHkgZnJvbSB0aGUgVGlja2VyIHRpY2sgZXZlbnQgb2JqZWN0XG5cdCAqIFx0XHRjb25zb2xlLmxvZyhldnQuZ3JlZXRpbmcsIGV2dC5uYW1lKTsgLy8gY3VzdG9tIGRhdGE6IFwiaGVsbG8gd29ybGRcIlxuXHQgKiBcdH1cblx0ICogXG5cdCAqIEBtZXRob2QgdGlja1xuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzXSBBbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIGNvcGllZCB0byB0aGUgZXZlbnQgb2JqZWN0LiBTaG91bGQgdXN1YWxseSBiZSBhIFRpY2tlciBldmVudCBvYmplY3QsIG9yIHNpbWlsYXIgb2JqZWN0IHdpdGggYSBkZWx0YSBwcm9wZXJ0eS5cblx0ICoqL1xuXHRwLnRpY2sgPSBmdW5jdGlvbihwcm9wcykge1xuXHRcdGlmICghdGhpcy50aWNrRW5hYmxlZCB8fCB0aGlzLmRpc3BhdGNoRXZlbnQoXCJ0aWNrc3RhcnRcIiwgZmFsc2UsIHRydWUpID09PSBmYWxzZSkgeyByZXR1cm47IH1cblx0XHR2YXIgZXZ0T2JqID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwidGlja1wiKTtcblx0XHRpZiAocHJvcHMpIHtcblx0XHRcdGZvciAodmFyIG4gaW4gcHJvcHMpIHtcblx0XHRcdFx0aWYgKHByb3BzLmhhc093blByb3BlcnR5KG4pKSB7IGV2dE9ialtuXSA9IHByb3BzW25dOyB9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX3RpY2soZXZ0T2JqKTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJ0aWNrZW5kXCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZWZhdWx0IGV2ZW50IGhhbmRsZXIgdGhhdCBjYWxscyB0aGUgU3RhZ2Uge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdXBkYXRlXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCB3aGVuIGEge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC90aWNrOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IGlzIHJlY2VpdmVkLiBUaGlzIGFsbG93cyB5b3UgdG8gcmVnaXN0ZXIgYSBTdGFnZSBpbnN0YW5jZSBhcyBhIGV2ZW50IGxpc3RlbmVyIG9uIHt7I2Nyb3NzTGluayBcIlRpY2tlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBkaXJlY3RseSwgdXNpbmc6XG5cdCAqXG5cdCAqICAgICAgVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIG15U3RhZ2VcIik7XG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBpZiB5b3Ugc3Vic2NyaWJlIHRvIHRpY2tzIHVzaW5nIHRoaXMgcGF0dGVybiwgdGhlbiB0aGUgdGljayBldmVudCBvYmplY3Qgd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB0b1xuXHQgKiBkaXNwbGF5IG9iamVjdCB0aWNrIGhhbmRsZXJzLCBpbnN0ZWFkIG9mIDxjb2RlPmRlbHRhPC9jb2RlPiBhbmQgPGNvZGU+cGF1c2VkPC9jb2RlPiBwYXJhbWV0ZXJzLlxuXHQgKiBAcHJvcGVydHkgaGFuZGxlRXZlbnRcblx0ICogQHR5cGUgRnVuY3Rpb25cblx0ICoqL1xuXHRwLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24oZXZ0KSB7XG5cdFx0aWYgKGV2dC50eXBlID09IFwidGlja1wiKSB7IHRoaXMudXBkYXRlKGV2dCk7IH1cblx0fTtcblxuXHQvKipcblx0ICogQ2xlYXJzIHRoZSB0YXJnZXQgY2FudmFzLiBVc2VmdWwgaWYge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvYXV0b0NsZWFyOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlzIHNldCB0byBgZmFsc2VgLlxuXHQgKiBAbWV0aG9kIGNsZWFyXG5cdCAqKi9cblx0cC5jbGVhciA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5jYW52YXMpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHRjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgrMSwgdGhpcy5jYW52YXMuaGVpZ2h0KzEpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgZGF0YSB1cmwgdGhhdCBjb250YWlucyBhIEJhc2U2NC1lbmNvZGVkIGltYWdlIG9mIHRoZSBjb250ZW50cyBvZiB0aGUgc3RhZ2UuIFRoZSByZXR1cm5lZCBkYXRhIHVybCBjYW5cblx0ICogYmUgc3BlY2lmaWVkIGFzIHRoZSBzcmMgdmFsdWUgb2YgYW4gaW1hZ2UgZWxlbWVudC5cblx0ICogQG1ldGhvZCB0b0RhdGFVUkxcblx0ICogQHBhcmFtIHtTdHJpbmd9IFtiYWNrZ3JvdW5kQ29sb3JdIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIHRvIGJlIHVzZWQgZm9yIHRoZSBnZW5lcmF0ZWQgaW1hZ2UuIEFueSB2YWxpZCBDU1MgY29sb3Jcblx0ICogdmFsdWUgaXMgYWxsb3dlZC4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYSB0cmFuc3BhcmVudCBiYWNrZ3JvdW5kLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW21pbWVUeXBlPVwiaW1hZ2UvcG5nXCJdIFRoZSBNSU1FIHR5cGUgb2YgdGhlIGltYWdlIGZvcm1hdCB0byBiZSBjcmVhdGUuIFRoZSBkZWZhdWx0IGlzIFwiaW1hZ2UvcG5nXCIuIElmIGFuIHVua25vd24gTUlNRSB0eXBlXG5cdCAqIGlzIHBhc3NlZCBpbiwgb3IgaWYgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgc3BlY2lmaWVkIE1JTUUgdHlwZSwgdGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSB1c2VkLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgQmFzZTY0IGVuY29kZWQgaW1hZ2UuXG5cdCAqKi9cblx0cC50b0RhdGFVUkwgPSBmdW5jdGlvbihiYWNrZ3JvdW5kQ29sb3IsIG1pbWVUeXBlKSB7XG5cdFx0dmFyIGRhdGEsIGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyksIHcgPSB0aGlzLmNhbnZhcy53aWR0aCwgaCA9IHRoaXMuY2FudmFzLmhlaWdodDtcblxuXHRcdGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcblx0XHRcdGRhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHcsIGgpO1xuXHRcdFx0dmFyIGNvbXBvc2l0ZU9wZXJhdGlvbiA9IGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG5cdFx0XHRjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1vdmVyXCI7XG5cdFx0XHRcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG5cdFx0XHRjdHguZmlsbFJlY3QoMCwgMCwgdywgaCk7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFVUkwgPSB0aGlzLmNhbnZhcy50b0RhdGFVUkwobWltZVR5cGV8fFwiaW1hZ2UvcG5nXCIpO1xuXG5cdFx0aWYoYmFja2dyb3VuZENvbG9yKSB7XG5cdFx0XHRjdHgucHV0SW1hZ2VEYXRhKGRhdGEsIDAsIDApO1xuXHRcdFx0Y3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGNvbXBvc2l0ZU9wZXJhdGlvbjtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YVVSTDtcblx0fTtcblxuXHQvKipcblx0ICogRW5hYmxlcyBvciBkaXNhYmxlcyAoYnkgcGFzc2luZyBhIGZyZXF1ZW5jeSBvZiAwKSBtb3VzZSBvdmVyICh7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21vdXNlb3ZlcjpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBhbmQge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9tb3VzZW91dDpldmVudFwifX17ey9jcm9zc0xpbmt9fSkgYW5kIHJvbGwgb3ZlciBldmVudHMgKHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3Qvcm9sbG92ZXI6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogYW5kIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3Qvcm9sbG91dDpldmVudFwifX17ey9jcm9zc0xpbmt9fSkgZm9yIHRoaXMgc3RhZ2UncyBkaXNwbGF5IGxpc3QuIFRoZXNlIGV2ZW50cyBjYW5cblx0ICogYmUgZXhwZW5zaXZlIHRvIGdlbmVyYXRlLCBzbyB0aGV5IGFyZSBkaXNhYmxlZCBieSBkZWZhdWx0LiBUaGUgZnJlcXVlbmN5IG9mIHRoZSBldmVudHMgY2FuIGJlIGNvbnRyb2xsZWRcblx0ICogaW5kZXBlbmRlbnRseSBvZiBtb3VzZSBtb3ZlIGV2ZW50cyB2aWEgdGhlIG9wdGlvbmFsIGBmcmVxdWVuY3lgIHBhcmFtZXRlci5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBzdGFnZSA9IG5ldyBjcmVhdGVqcy5TdGFnZShcImNhbnZhc0lkXCIpO1xuXHQgKiAgICAgIHN0YWdlLmVuYWJsZU1vdXNlT3ZlcigxMCk7IC8vIDEwIHVwZGF0ZXMgcGVyIHNlY29uZFxuXHQgKlxuXHQgKiBAbWV0aG9kIGVuYWJsZU1vdXNlT3ZlclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2ZyZXF1ZW5jeT0yMF0gT3B0aW9uYWwgcGFyYW0gc3BlY2lmeWluZyB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGltZXMgcGVyIHNlY29uZCB0byBicm9hZGNhc3Rcblx0ICogbW91c2Ugb3Zlci9vdXQgZXZlbnRzLiBTZXQgdG8gMCB0byBkaXNhYmxlIG1vdXNlIG92ZXIgZXZlbnRzIGNvbXBsZXRlbHkuIE1heGltdW0gaXMgNTAuIEEgbG93ZXIgZnJlcXVlbmN5IGlzIGxlc3Ncblx0ICogcmVzcG9uc2l2ZSwgYnV0IHVzZXMgbGVzcyBDUFUuXG5cdCAqKi9cblx0cC5lbmFibGVNb3VzZU92ZXIgPSBmdW5jdGlvbihmcmVxdWVuY3kpIHtcblx0XHRpZiAodGhpcy5fbW91c2VPdmVySW50ZXJ2YWxJRCkge1xuXHRcdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLl9tb3VzZU92ZXJJbnRlcnZhbElEKTtcblx0XHRcdHRoaXMuX21vdXNlT3ZlckludGVydmFsSUQgPSBudWxsO1xuXHRcdFx0aWYgKGZyZXF1ZW5jeSA9PSAwKSB7XG5cdFx0XHRcdHRoaXMuX3Rlc3RNb3VzZU92ZXIodHJ1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChmcmVxdWVuY3kgPT0gbnVsbCkgeyBmcmVxdWVuY3kgPSAyMDsgfVxuXHRcdGVsc2UgaWYgKGZyZXF1ZW5jeSA8PSAwKSB7IHJldHVybjsgfVxuXHRcdHZhciBvID0gdGhpcztcblx0XHR0aGlzLl9tb3VzZU92ZXJJbnRlcnZhbElEID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXsgby5fdGVzdE1vdXNlT3ZlcigpOyB9LCAxMDAwL01hdGgubWluKDUwLGZyZXF1ZW5jeSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbmFibGVzIG9yIGRpc2FibGVzIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCBzdGFnZSBhZGRzIHRvIERPTSBlbGVtZW50cyAod2luZG93LCBkb2N1bWVudCBhbmQgY2FudmFzKS4gSXQgaXMgZ29vZFxuXHQgKiBwcmFjdGljZSB0byBkaXNhYmxlIGV2ZW50cyB3aGVuIGRpc3Bvc2luZyBvZiBhIFN0YWdlIGluc3RhbmNlLCBvdGhlcndpc2UgdGhlIHN0YWdlIHdpbGwgY29udGludWUgdG8gcmVjZWl2ZVxuXHQgKiBldmVudHMgZnJvbSB0aGUgcGFnZS5cblx0ICpcblx0ICogV2hlbiBjaGFuZ2luZyB0aGUgY2FudmFzIHByb3BlcnR5IHlvdSBtdXN0IGRpc2FibGUgdGhlIGV2ZW50cyBvbiB0aGUgb2xkIGNhbnZhcywgYW5kIGVuYWJsZSBldmVudHMgb24gdGhlXG5cdCAqIG5ldyBjYW52YXMgb3IgbW91c2UgZXZlbnRzIHdpbGwgbm90IHdvcmsgYXMgZXhwZWN0ZWQuIEZvciBleGFtcGxlOlxuXHQgKlxuXHQgKiAgICAgIG15U3RhZ2UuZW5hYmxlRE9NRXZlbnRzKGZhbHNlKTtcblx0ICogICAgICBteVN0YWdlLmNhbnZhcyA9IGFub3RoZXJDYW52YXM7XG5cdCAqICAgICAgbXlTdGFnZS5lbmFibGVET01FdmVudHModHJ1ZSk7XG5cdCAqXG5cdCAqIEBtZXRob2QgZW5hYmxlRE9NRXZlbnRzXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2VuYWJsZT10cnVlXSBJbmRpY2F0ZXMgd2hldGhlciB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgZXZlbnRzLiBEZWZhdWx0IGlzIHRydWUuXG5cdCAqKi9cblx0cC5lbmFibGVET01FdmVudHMgPSBmdW5jdGlvbihlbmFibGUpIHtcblx0XHRpZiAoZW5hYmxlID09IG51bGwpIHsgZW5hYmxlID0gdHJ1ZTsgfVxuXHRcdHZhciBuLCBvLCBscyA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzO1xuXHRcdGlmICghZW5hYmxlICYmIGxzKSB7XG5cdFx0XHRmb3IgKG4gaW4gbHMpIHtcblx0XHRcdFx0byA9IGxzW25dO1xuXHRcdFx0XHRvLnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihuLCBvLmYsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2V2ZW50TGlzdGVuZXJzID0gbnVsbDtcblx0XHR9IGVsc2UgaWYgKGVuYWJsZSAmJiAhbHMgJiYgdGhpcy5jYW52YXMpIHtcblx0XHRcdHZhciB0ID0gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPyB3aW5kb3cgOiBkb2N1bWVudDtcblx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0XHRscyA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzID0ge307XG5cdFx0XHRsc1tcIm1vdXNldXBcIl0gPSB7dDp0LCBmOmZ1bmN0aW9uKGUpIHsgX3RoaXMuX2hhbmRsZU1vdXNlVXAoZSl9IH07XG5cdFx0XHRsc1tcIm1vdXNlbW92ZVwiXSA9IHt0OnQsIGY6ZnVuY3Rpb24oZSkgeyBfdGhpcy5faGFuZGxlTW91c2VNb3ZlKGUpfSB9O1xuXHRcdFx0bHNbXCJkYmxjbGlja1wiXSA9IHt0OnRoaXMuY2FudmFzLCBmOmZ1bmN0aW9uKGUpIHsgX3RoaXMuX2hhbmRsZURvdWJsZUNsaWNrKGUpfSB9O1xuXHRcdFx0bHNbXCJtb3VzZWRvd25cIl0gPSB7dDp0aGlzLmNhbnZhcywgZjpmdW5jdGlvbihlKSB7IF90aGlzLl9oYW5kbGVNb3VzZURvd24oZSl9IH07XG5cblx0XHRcdGZvciAobiBpbiBscykge1xuXHRcdFx0XHRvID0gbHNbbl07XG5cdFx0XHRcdG8udC5hZGRFdmVudExpc3RlbmVyKG4sIG8uZiwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogU3RhZ2UgaW5zdGFuY2VzIGNhbm5vdCBiZSBjbG9uZWQuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3coXCJTdGFnZSBjYW5ub3QgYmUgY2xvbmVkLlwiKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1N0YWdlIChuYW1lPVwiKyAgdGhpcy5uYW1lICtcIildXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0RWxlbWVudFJlY3Rcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlXG5cdCAqKi9cblx0cC5fZ2V0RWxlbWVudFJlY3QgPSBmdW5jdGlvbihlKSB7XG5cdFx0dmFyIGJvdW5kcztcblx0XHR0cnkgeyBib3VuZHMgPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyB9IC8vIHRoaXMgY2FuIGZhaWwgb24gZGlzY29ubmVjdGVkIERPTSBlbGVtZW50cyBpbiBJRTlcblx0XHRjYXRjaCAoZXJyKSB7IGJvdW5kcyA9IHt0b3A6IGUub2Zmc2V0VG9wLCBsZWZ0OiBlLm9mZnNldExlZnQsIHdpZHRoOmUub2Zmc2V0V2lkdGgsIGhlaWdodDplLm9mZnNldEhlaWdodH07IH1cblxuXHRcdHZhciBvZmZYID0gKHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5zY3JvbGxMZWZ0IHx8IDApIC0gKGRvY3VtZW50LmNsaWVudExlZnQgfHwgZG9jdW1lbnQuYm9keS5jbGllbnRMZWZ0IHx8IDApO1xuXHRcdHZhciBvZmZZID0gKHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5zY3JvbGxUb3AgfHwgMCkgLSAoZG9jdW1lbnQuY2xpZW50VG9wICB8fCBkb2N1bWVudC5ib2R5LmNsaWVudFRvcCAgfHwgMCk7XG5cblx0XHR2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgPyBnZXRDb21wdXRlZFN0eWxlKGUsbnVsbCkgOiBlLmN1cnJlbnRTdHlsZTsgLy8gSUUgPDkgY29tcGF0aWJpbGl0eS5cblx0XHR2YXIgcGFkTCA9IHBhcnNlSW50KHN0eWxlcy5wYWRkaW5nTGVmdCkrcGFyc2VJbnQoc3R5bGVzLmJvcmRlckxlZnRXaWR0aCk7XG5cdFx0dmFyIHBhZFQgPSBwYXJzZUludChzdHlsZXMucGFkZGluZ1RvcCkrcGFyc2VJbnQoc3R5bGVzLmJvcmRlclRvcFdpZHRoKTtcblx0XHR2YXIgcGFkUiA9IHBhcnNlSW50KHN0eWxlcy5wYWRkaW5nUmlnaHQpK3BhcnNlSW50KHN0eWxlcy5ib3JkZXJSaWdodFdpZHRoKTtcblx0XHR2YXIgcGFkQiA9IHBhcnNlSW50KHN0eWxlcy5wYWRkaW5nQm90dG9tKStwYXJzZUludChzdHlsZXMuYm9yZGVyQm90dG9tV2lkdGgpO1xuXG5cdFx0Ly8gbm90ZTogaW4gc29tZSBicm93c2VycyBib3VuZHMgcHJvcGVydGllcyBhcmUgcmVhZCBvbmx5LlxuXHRcdHJldHVybiB7XG5cdFx0XHRsZWZ0OiBib3VuZHMubGVmdCtvZmZYK3BhZEwsXG5cdFx0XHRyaWdodDogYm91bmRzLnJpZ2h0K29mZlgtcGFkUixcblx0XHRcdHRvcDogYm91bmRzLnRvcCtvZmZZK3BhZFQsXG5cdFx0XHRib3R0b206IGJvdW5kcy5ib3R0b20rb2ZmWS1wYWRCXG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRQb2ludGVyRGF0YVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpZFxuXHQgKiovXG5cdHAuX2dldFBvaW50ZXJEYXRhID0gZnVuY3Rpb24oaWQpIHtcblx0XHR2YXIgZGF0YSA9IHRoaXMuX3BvaW50ZXJEYXRhW2lkXTtcblx0XHRpZiAoIWRhdGEpIHsgZGF0YSA9IHRoaXMuX3BvaW50ZXJEYXRhW2lkXSA9IHt4OjAseTowfTsgfVxuXHRcdHJldHVybiBkYXRhO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNb3VzZU1vdmVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcblx0ICoqL1xuXHRwLl9oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbihlKSB7XG5cdFx0aWYoIWUpeyBlID0gd2luZG93LmV2ZW50OyB9XG5cdFx0dGhpcy5faGFuZGxlUG9pbnRlck1vdmUoLTEsIGUsIGUucGFnZVgsIGUucGFnZVkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVQb2ludGVyTW92ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwYWdlWFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcGFnZVlcblx0ICogQHBhcmFtIHtTdGFnZX0gb3duZXIgSW5kaWNhdGVzIHRoYXQgdGhlIGV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gY2FwdHVyZWQgJiBoYW5kbGVkIGJ5IHRoZSBpbmRpY2F0ZWQgc3RhZ2UuXG5cdCAqKi9cblx0cC5faGFuZGxlUG9pbnRlck1vdmUgPSBmdW5jdGlvbihpZCwgZSwgcGFnZVgsIHBhZ2VZLCBvd25lcikge1xuXHRcdGlmICh0aGlzLl9wcmV2U3RhZ2UgJiYgb3duZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm47IH0gLy8gcmVkdW5kYW50IGxpc3RlbmVyLlxuXHRcdGlmICghdGhpcy5jYW52YXMpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIG5leHRTdGFnZT10aGlzLl9uZXh0U3RhZ2UsIG89dGhpcy5fZ2V0UG9pbnRlckRhdGEoaWQpO1xuXG5cdFx0dmFyIGluQm91bmRzID0gby5pbkJvdW5kcztcblx0XHR0aGlzLl91cGRhdGVQb2ludGVyUG9zaXRpb24oaWQsIGUsIHBhZ2VYLCBwYWdlWSk7XG5cdFx0aWYgKGluQm91bmRzIHx8IG8uaW5Cb3VuZHMgfHwgdGhpcy5tb3VzZU1vdmVPdXRzaWRlKSB7XG5cdFx0XHRpZiAoaWQgPT09IC0xICYmIG8uaW5Cb3VuZHMgPT0gIWluQm91bmRzKSB7XG5cdFx0XHRcdHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudCh0aGlzLCAoaW5Cb3VuZHMgPyBcIm1vdXNlbGVhdmVcIiA6IFwibW91c2VlbnRlclwiKSwgZmFsc2UsIGlkLCBvLCBlKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRoaXMsIFwic3RhZ2Vtb3VzZW1vdmVcIiwgZmFsc2UsIGlkLCBvLCBlKTtcblx0XHRcdHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudChvLnRhcmdldCwgXCJwcmVzc21vdmVcIiwgdHJ1ZSwgaWQsIG8sIGUpO1xuXHRcdH1cblx0XHRcblx0XHRuZXh0U3RhZ2UmJm5leHRTdGFnZS5faGFuZGxlUG9pbnRlck1vdmUoaWQsIGUsIHBhZ2VYLCBwYWdlWSwgbnVsbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3VwZGF0ZVBvaW50ZXJQb3NpdGlvblxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwYWdlWFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcGFnZVlcblx0ICoqL1xuXHRwLl91cGRhdGVQb2ludGVyUG9zaXRpb24gPSBmdW5jdGlvbihpZCwgZSwgcGFnZVgsIHBhZ2VZKSB7XG5cdFx0dmFyIHJlY3QgPSB0aGlzLl9nZXRFbGVtZW50UmVjdCh0aGlzLmNhbnZhcyk7XG5cdFx0cGFnZVggLT0gcmVjdC5sZWZ0O1xuXHRcdHBhZ2VZIC09IHJlY3QudG9wO1xuXG5cdFx0dmFyIHcgPSB0aGlzLmNhbnZhcy53aWR0aDtcblx0XHR2YXIgaCA9IHRoaXMuY2FudmFzLmhlaWdodDtcblx0XHRwYWdlWCAvPSAocmVjdC5yaWdodC1yZWN0LmxlZnQpL3c7XG5cdFx0cGFnZVkgLz0gKHJlY3QuYm90dG9tLXJlY3QudG9wKS9oO1xuXHRcdHZhciBvID0gdGhpcy5fZ2V0UG9pbnRlckRhdGEoaWQpO1xuXHRcdGlmIChvLmluQm91bmRzID0gKHBhZ2VYID49IDAgJiYgcGFnZVkgPj0gMCAmJiBwYWdlWCA8PSB3LTEgJiYgcGFnZVkgPD0gaC0xKSkge1xuXHRcdFx0by54ID0gcGFnZVg7XG5cdFx0XHRvLnkgPSBwYWdlWTtcblx0XHR9IGVsc2UgaWYgKHRoaXMubW91c2VNb3ZlT3V0c2lkZSkge1xuXHRcdFx0by54ID0gcGFnZVggPCAwID8gMCA6IChwYWdlWCA+IHctMSA/IHctMSA6IHBhZ2VYKTtcblx0XHRcdG8ueSA9IHBhZ2VZIDwgMCA/IDAgOiAocGFnZVkgPiBoLTEgPyBoLTEgOiBwYWdlWSk7XG5cdFx0fVxuXG5cdFx0by5wb3NFdnRPYmogPSBlO1xuXHRcdG8ucmF3WCA9IHBhZ2VYO1xuXHRcdG8ucmF3WSA9IHBhZ2VZO1xuXG5cdFx0aWYgKGlkID09PSB0aGlzLl9wcmltYXJ5UG9pbnRlcklEIHx8IGlkID09PSAtMSkge1xuXHRcdFx0dGhpcy5tb3VzZVggPSBvLng7XG5cdFx0XHR0aGlzLm1vdXNlWSA9IG8ueTtcblx0XHRcdHRoaXMubW91c2VJbkJvdW5kcyA9IG8uaW5Cb3VuZHM7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNb3VzZVVwXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlXG5cdCAqKi9cblx0cC5faGFuZGxlTW91c2VVcCA9IGZ1bmN0aW9uKGUpIHtcblx0XHR0aGlzLl9oYW5kbGVQb2ludGVyVXAoLTEsIGUsIGZhbHNlKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlUG9pbnRlclVwXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGlkXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGVcblx0ICogQHBhcmFtIHtCb29sZWFufSBjbGVhclxuXHQgKiBAcGFyYW0ge1N0YWdlfSBvd25lciBJbmRpY2F0ZXMgdGhhdCB0aGUgZXZlbnQgaGFzIGFscmVhZHkgYmVlbiBjYXB0dXJlZCAmIGhhbmRsZWQgYnkgdGhlIGluZGljYXRlZCBzdGFnZS5cblx0ICoqL1xuXHRwLl9oYW5kbGVQb2ludGVyVXAgPSBmdW5jdGlvbihpZCwgZSwgY2xlYXIsIG93bmVyKSB7XG5cdFx0dmFyIG5leHRTdGFnZSA9IHRoaXMuX25leHRTdGFnZSwgbyA9IHRoaXMuX2dldFBvaW50ZXJEYXRhKGlkKTtcblx0XHRpZiAodGhpcy5fcHJldlN0YWdlICYmIG93bmVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9IC8vIHJlZHVuZGFudCBsaXN0ZW5lci5cblx0XHRcblx0XHR2YXIgdGFyZ2V0PW51bGwsIG9UYXJnZXQgPSBvLnRhcmdldDtcblx0XHRpZiAoIW93bmVyICYmIChvVGFyZ2V0IHx8IG5leHRTdGFnZSkpIHsgdGFyZ2V0ID0gdGhpcy5fZ2V0T2JqZWN0c1VuZGVyUG9pbnQoby54LCBvLnksIG51bGwsIHRydWUpOyB9XG5cdFx0XG5cdFx0aWYgKG8uZG93bikgeyB0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQodGhpcywgXCJzdGFnZW1vdXNldXBcIiwgZmFsc2UsIGlkLCBvLCBlLCB0YXJnZXQpOyBvLmRvd24gPSBmYWxzZTsgfVxuXHRcdFxuXHRcdGlmICh0YXJnZXQgPT0gb1RhcmdldCkgeyB0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQob1RhcmdldCwgXCJjbGlja1wiLCB0cnVlLCBpZCwgbywgZSk7IH1cblx0XHR0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQob1RhcmdldCwgXCJwcmVzc3VwXCIsIHRydWUsIGlkLCBvLCBlKTtcblx0XHRcblx0XHRpZiAoY2xlYXIpIHtcblx0XHRcdGlmIChpZD09dGhpcy5fcHJpbWFyeVBvaW50ZXJJRCkgeyB0aGlzLl9wcmltYXJ5UG9pbnRlcklEID0gbnVsbDsgfVxuXHRcdFx0ZGVsZXRlKHRoaXMuX3BvaW50ZXJEYXRhW2lkXSk7XG5cdFx0fSBlbHNlIHsgby50YXJnZXQgPSBudWxsOyB9XG5cdFx0XG5cdFx0bmV4dFN0YWdlJiZuZXh0U3RhZ2UuX2hhbmRsZVBvaW50ZXJVcChpZCwgZSwgY2xlYXIsIG93bmVyIHx8IHRhcmdldCAmJiB0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlTW91c2VEb3duXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlXG5cdCAqKi9cblx0cC5faGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24oZSkge1xuXHRcdHRoaXMuX2hhbmRsZVBvaW50ZXJEb3duKC0xLCBlLCBlLnBhZ2VYLCBlLnBhZ2VZKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlUG9pbnRlckRvd25cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaWRcblx0ICogQHBhcmFtIHtFdmVudH0gZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcGFnZVhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhZ2VZXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IG93bmVyIEluZGljYXRlcyB0aGF0IHRoZSBldmVudCBoYXMgYWxyZWFkeSBiZWVuIGNhcHR1cmVkICYgaGFuZGxlZCBieSB0aGUgaW5kaWNhdGVkIHN0YWdlLlxuXHQgKiovXG5cdHAuX2hhbmRsZVBvaW50ZXJEb3duID0gZnVuY3Rpb24oaWQsIGUsIHBhZ2VYLCBwYWdlWSwgb3duZXIpIHtcblx0XHRpZiAodGhpcy5wcmV2ZW50U2VsZWN0aW9uKSB7IGUucHJldmVudERlZmF1bHQoKTsgfVxuXHRcdGlmICh0aGlzLl9wcmltYXJ5UG9pbnRlcklEID09IG51bGwgfHwgaWQgPT09IC0xKSB7IHRoaXMuX3ByaW1hcnlQb2ludGVySUQgPSBpZDsgfSAvLyBtb3VzZSBhbHdheXMgdGFrZXMgb3Zlci5cblx0XHRcblx0XHRpZiAocGFnZVkgIT0gbnVsbCkgeyB0aGlzLl91cGRhdGVQb2ludGVyUG9zaXRpb24oaWQsIGUsIHBhZ2VYLCBwYWdlWSk7IH1cblx0XHR2YXIgdGFyZ2V0ID0gbnVsbCwgbmV4dFN0YWdlID0gdGhpcy5fbmV4dFN0YWdlLCBvID0gdGhpcy5fZ2V0UG9pbnRlckRhdGEoaWQpO1xuXHRcdGlmICghb3duZXIpIHsgdGFyZ2V0ID0gby50YXJnZXQgPSB0aGlzLl9nZXRPYmplY3RzVW5kZXJQb2ludChvLngsIG8ueSwgbnVsbCwgdHJ1ZSk7IH1cblxuXHRcdGlmIChvLmluQm91bmRzKSB7IHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudCh0aGlzLCBcInN0YWdlbW91c2Vkb3duXCIsIGZhbHNlLCBpZCwgbywgZSwgdGFyZ2V0KTsgby5kb3duID0gdHJ1ZTsgfVxuXHRcdHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudCh0YXJnZXQsIFwibW91c2Vkb3duXCIsIHRydWUsIGlkLCBvLCBlKTtcblx0XHRcblx0XHRuZXh0U3RhZ2UmJm5leHRTdGFnZS5faGFuZGxlUG9pbnRlckRvd24oaWQsIGUsIHBhZ2VYLCBwYWdlWSwgb3duZXIgfHwgdGFyZ2V0ICYmIHRoaXMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF90ZXN0TW91c2VPdmVyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xlYXIgSWYgdHJ1ZSwgY2xlYXJzIHRoZSBtb3VzZW92ZXIgLyByb2xsb3ZlciAoaWUuIG5vIHRhcmdldClcblx0ICogQHBhcmFtIHtTdGFnZX0gb3duZXIgSW5kaWNhdGVzIHRoYXQgdGhlIGV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gY2FwdHVyZWQgJiBoYW5kbGVkIGJ5IHRoZSBpbmRpY2F0ZWQgc3RhZ2UuXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IGV2ZW50VGFyZ2V0IFRoZSBzdGFnZSB0aGF0IHRoZSBjdXJzb3IgaXMgYWN0aXZlbHkgb3Zlci5cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3Rlc3RNb3VzZU92ZXIgPSBmdW5jdGlvbihjbGVhciwgb3duZXIsIGV2ZW50VGFyZ2V0KSB7XG5cdFx0aWYgKHRoaXMuX3ByZXZTdGFnZSAmJiBvd25lciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybjsgfSAvLyByZWR1bmRhbnQgbGlzdGVuZXIuXG5cdFx0XG5cdFx0dmFyIG5leHRTdGFnZSA9IHRoaXMuX25leHRTdGFnZTtcblx0XHRpZiAoIXRoaXMuX21vdXNlT3ZlckludGVydmFsSUQpIHtcblx0XHRcdC8vIG5vdCBlbmFibGVkIGZvciBtb3VzZW92ZXIsIGJ1dCBzaG91bGQgc3RpbGwgcmVsYXkgdGhlIGV2ZW50LlxuXHRcdFx0bmV4dFN0YWdlJiZuZXh0U3RhZ2UuX3Rlc3RNb3VzZU92ZXIoY2xlYXIsIG93bmVyLCBldmVudFRhcmdldCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBvID0gdGhpcy5fZ2V0UG9pbnRlckRhdGEoLTEpO1xuXHRcdC8vIG9ubHkgdXBkYXRlIGlmIHRoZSBtb3VzZSBwb3NpdGlvbiBoYXMgY2hhbmdlZC4gVGhpcyBwcm92aWRlcyBhIGxvdCBvZiBvcHRpbWl6YXRpb24sIGJ1dCBoYXMgc29tZSB0cmFkZS1vZmZzLlxuXHRcdGlmICghbyB8fCAoIWNsZWFyICYmIHRoaXMubW91c2VYID09IHRoaXMuX21vdXNlT3ZlclggJiYgdGhpcy5tb3VzZVkgPT0gdGhpcy5fbW91c2VPdmVyWSAmJiB0aGlzLm1vdXNlSW5Cb3VuZHMpKSB7IHJldHVybjsgfVxuXHRcdFxuXHRcdHZhciBlID0gby5wb3NFdnRPYmo7XG5cdFx0dmFyIGlzRXZlbnRUYXJnZXQgPSBldmVudFRhcmdldCB8fCBlJiYoZS50YXJnZXQgPT0gdGhpcy5jYW52YXMpO1xuXHRcdHZhciB0YXJnZXQ9bnVsbCwgY29tbW9uID0gLTEsIGN1cnNvcj1cIlwiLCB0LCBpLCBsO1xuXHRcdFxuXHRcdGlmICghb3duZXIgJiYgKGNsZWFyIHx8IHRoaXMubW91c2VJbkJvdW5kcyAmJiBpc0V2ZW50VGFyZ2V0KSkge1xuXHRcdFx0dGFyZ2V0ID0gdGhpcy5fZ2V0T2JqZWN0c1VuZGVyUG9pbnQodGhpcy5tb3VzZVgsIHRoaXMubW91c2VZLCBudWxsLCB0cnVlKTtcblx0XHRcdHRoaXMuX21vdXNlT3ZlclggPSB0aGlzLm1vdXNlWDtcblx0XHRcdHRoaXMuX21vdXNlT3ZlclkgPSB0aGlzLm1vdXNlWTtcblx0XHR9XG5cblx0XHR2YXIgb2xkTGlzdCA9IHRoaXMuX21vdXNlT3ZlclRhcmdldHx8W107XG5cdFx0dmFyIG9sZFRhcmdldCA9IG9sZExpc3Rbb2xkTGlzdC5sZW5ndGgtMV07XG5cdFx0dmFyIGxpc3QgPSB0aGlzLl9tb3VzZU92ZXJUYXJnZXQgPSBbXTtcblxuXHRcdC8vIGdlbmVyYXRlIGFuY2VzdG9yIGxpc3QgYW5kIGNoZWNrIGZvciBjdXJzb3I6XG5cdFx0dCA9IHRhcmdldDtcblx0XHR3aGlsZSAodCkge1xuXHRcdFx0bGlzdC51bnNoaWZ0KHQpO1xuXHRcdFx0aWYgKCFjdXJzb3IpIHsgY3Vyc29yID0gdC5jdXJzb3I7IH1cblx0XHRcdHQgPSB0LnBhcmVudDtcblx0XHR9XG5cdFx0dGhpcy5jYW52YXMuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuXHRcdGlmICghb3duZXIgJiYgZXZlbnRUYXJnZXQpIHsgZXZlbnRUYXJnZXQuY2FudmFzLnN0eWxlLmN1cnNvciA9IGN1cnNvcjsgfVxuXG5cdFx0Ly8gZmluZCBjb21tb24gYW5jZXN0b3I6XG5cdFx0Zm9yIChpPTAsbD1saXN0Lmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdGlmIChsaXN0W2ldICE9IG9sZExpc3RbaV0pIHsgYnJlYWs7IH1cblx0XHRcdGNvbW1vbiA9IGk7XG5cdFx0fVxuXG5cdFx0aWYgKG9sZFRhcmdldCAhPSB0YXJnZXQpIHtcblx0XHRcdHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudChvbGRUYXJnZXQsIFwibW91c2VvdXRcIiwgdHJ1ZSwgLTEsIG8sIGUsIHRhcmdldCk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpPW9sZExpc3QubGVuZ3RoLTE7IGk+Y29tbW9uOyBpLS0pIHtcblx0XHRcdHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudChvbGRMaXN0W2ldLCBcInJvbGxvdXRcIiwgZmFsc2UsIC0xLCBvLCBlLCB0YXJnZXQpO1xuXHRcdH1cblxuXHRcdGZvciAoaT1saXN0Lmxlbmd0aC0xOyBpPmNvbW1vbjsgaS0tKSB7XG5cdFx0XHR0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQobGlzdFtpXSwgXCJyb2xsb3ZlclwiLCBmYWxzZSwgLTEsIG8sIGUsIG9sZFRhcmdldCk7XG5cdFx0fVxuXG5cdFx0aWYgKG9sZFRhcmdldCAhPSB0YXJnZXQpIHtcblx0XHRcdHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudCh0YXJnZXQsIFwibW91c2VvdmVyXCIsIHRydWUsIC0xLCBvLCBlLCBvbGRUYXJnZXQpO1xuXHRcdH1cblx0XHRcblx0XHRuZXh0U3RhZ2UmJm5leHRTdGFnZS5fdGVzdE1vdXNlT3ZlcihjbGVhciwgb3duZXIgfHwgdGFyZ2V0ICYmIHRoaXMsIGV2ZW50VGFyZ2V0IHx8IGlzRXZlbnRUYXJnZXQgJiYgdGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZURvdWJsZUNsaWNrXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IG93bmVyIEluZGljYXRlcyB0aGF0IHRoZSBldmVudCBoYXMgYWxyZWFkeSBiZWVuIGNhcHR1cmVkICYgaGFuZGxlZCBieSB0aGUgaW5kaWNhdGVkIHN0YWdlLlxuXHQgKiovXG5cdHAuX2hhbmRsZURvdWJsZUNsaWNrID0gZnVuY3Rpb24oZSwgb3duZXIpIHtcblx0XHR2YXIgdGFyZ2V0PW51bGwsIG5leHRTdGFnZT10aGlzLl9uZXh0U3RhZ2UsIG89dGhpcy5fZ2V0UG9pbnRlckRhdGEoLTEpO1xuXHRcdGlmICghb3duZXIpIHtcblx0XHRcdHRhcmdldCA9IHRoaXMuX2dldE9iamVjdHNVbmRlclBvaW50KG8ueCwgby55LCBudWxsLCB0cnVlKTtcblx0XHRcdHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudCh0YXJnZXQsIFwiZGJsY2xpY2tcIiwgdHJ1ZSwgLTEsIG8sIGUpO1xuXHRcdH1cblx0XHRuZXh0U3RhZ2UmJm5leHRTdGFnZS5faGFuZGxlRG91YmxlQ2xpY2soZSwgb3duZXIgfHwgdGFyZ2V0ICYmIHRoaXMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9kaXNwYXRjaE1vdXNlRXZlbnRcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IHRhcmdldFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGJ1YmJsZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvaW50ZXJJZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb1xuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IFtuYXRpdmVFdmVudF1cblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBbcmVsYXRlZFRhcmdldF1cblx0ICoqL1xuXHRwLl9kaXNwYXRjaE1vdXNlRXZlbnQgPSBmdW5jdGlvbih0YXJnZXQsIHR5cGUsIGJ1YmJsZXMsIHBvaW50ZXJJZCwgbywgbmF0aXZlRXZlbnQsIHJlbGF0ZWRUYXJnZXQpIHtcblx0XHQvLyBUT0RPOiBtaWdodCBiZSB3b3J0aCBlaXRoZXIgcmV1c2luZyBNb3VzZUV2ZW50IGluc3RhbmNlcywgb3IgYWRkaW5nIGEgd2lsbFRyaWdnZXIgbWV0aG9kIHRvIGF2b2lkIEdDLlxuXHRcdGlmICghdGFyZ2V0IHx8ICghYnViYmxlcyAmJiAhdGFyZ2V0Lmhhc0V2ZW50TGlzdGVuZXIodHlwZSkpKSB7IHJldHVybjsgfVxuXHRcdC8qXG5cdFx0Ly8gVE9ETzogYWNjb3VudCBmb3Igc3RhZ2UgdHJhbnNmb3JtYXRpb25zP1xuXHRcdHRoaXMuX210eCA9IHRoaXMuZ2V0Q29uY2F0ZW5hdGVkTWF0cml4KHRoaXMuX210eCkuaW52ZXJ0KCk7XG5cdFx0dmFyIHB0ID0gdGhpcy5fbXR4LnRyYW5zZm9ybVBvaW50KG8ueCwgby55KTtcblx0XHR2YXIgZXZ0ID0gbmV3IGNyZWF0ZWpzLk1vdXNlRXZlbnQodHlwZSwgYnViYmxlcywgZmFsc2UsIHB0LngsIHB0LnksIG5hdGl2ZUV2ZW50LCBwb2ludGVySWQsIHBvaW50ZXJJZD09dGhpcy5fcHJpbWFyeVBvaW50ZXJJRCB8fCBwb2ludGVySWQ9PS0xLCBvLnJhd1gsIG8ucmF3WSk7XG5cdFx0Ki9cblx0XHR2YXIgZXZ0ID0gbmV3IGNyZWF0ZWpzLk1vdXNlRXZlbnQodHlwZSwgYnViYmxlcywgZmFsc2UsIG8ueCwgby55LCBuYXRpdmVFdmVudCwgcG9pbnRlcklkLCBwb2ludGVySWQgPT09IHRoaXMuX3ByaW1hcnlQb2ludGVySUQgfHwgcG9pbnRlcklkID09PSAtMSwgby5yYXdYLCBvLnJhd1ksIHJlbGF0ZWRUYXJnZXQpO1xuXHRcdHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5TdGFnZSA9IGNyZWF0ZWpzLnByb21vdGUoU3RhZ2UsIFwiQ29udGFpbmVyXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEJpdG1hcC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcblx0LyoqXG5cdCAqIEEgQml0bWFwIHJlcHJlc2VudHMgYW4gSW1hZ2UsIENhbnZhcywgb3IgVmlkZW8gaW4gdGhlIGRpc3BsYXkgbGlzdC4gQSBCaXRtYXAgY2FuIGJlIGluc3RhbnRpYXRlZCB1c2luZyBhbiBleGlzdGluZ1xuXHQgKiBIVE1MIGVsZW1lbnQsIG9yIGEgc3RyaW5nLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIGJpdG1hcCA9IG5ldyBjcmVhdGVqcy5CaXRtYXAoXCJpbWFnZVBhdGguanBnXCIpO1xuXHQgKlxuXHQgKiA8c3Ryb25nPk5vdGVzOjwvc3Ryb25nPlxuXHQgKiA8b2w+XG5cdCAqICAgICA8bGk+V2hlbiBhIHN0cmluZyBwYXRoIG9yIGltYWdlIHRhZyB0aGF0IGlzIG5vdCB5ZXQgbG9hZGVkIGlzIHVzZWQsIHRoZSBzdGFnZSBtYXkgbmVlZCB0byBiZSByZWRyYXduIGJlZm9yZSBpdFxuXHQgKiAgICAgIHdpbGwgYmUgZGlzcGxheWVkLjwvbGk+XG5cdCAqICAgICA8bGk+Qml0bWFwcyB3aXRoIGFuIFNWRyBzb3VyY2UgY3VycmVudGx5IHdpbGwgbm90IHJlc3BlY3QgYW4gYWxwaGEgdmFsdWUgb3RoZXIgdGhhbiAwIG9yIDEuIFRvIGdldCBhcm91bmQgdGhpcyxcblx0ICogICAgIHRoZSBCaXRtYXAgY2FuIGJlIGNhY2hlZC48L2xpPlxuXHQgKiAgICAgPGxpPkJpdG1hcHMgd2l0aCBhbiBTVkcgc291cmNlIHdpbGwgdGFpbnQgdGhlIGNhbnZhcyB3aXRoIGNyb3NzLW9yaWdpbiBkYXRhLCB3aGljaCBwcmV2ZW50cyBpbnRlcmFjdGl2aXR5LiBUaGlzXG5cdCAqICAgICBoYXBwZW5zIGluIGFsbCBicm93c2VycyBleGNlcHQgcmVjZW50IEZpcmVmb3ggYnVpbGRzLjwvbGk+XG5cdCAqICAgICA8bGk+SW1hZ2VzIGxvYWRlZCBjcm9zcy1vcmlnaW4gd2lsbCB0aHJvdyBjcm9zcy1vcmlnaW4gc2VjdXJpdHkgZXJyb3JzIHdoZW4gaW50ZXJhY3RlZCB3aXRoIHVzaW5nIGEgbW91c2UsIHVzaW5nXG5cdCAqICAgICBtZXRob2RzIHN1Y2ggYXMgYGdldE9iamVjdFVuZGVyUG9pbnRgLCBvciB1c2luZyBmaWx0ZXJzLCBvciBjYWNoaW5nLiBZb3UgY2FuIGdldCBhcm91bmQgdGhpcyBieSBzZXR0aW5nXG5cdCAqICAgICBgY3Jvc3NPcmlnaW5gIGZsYWdzIG9uIHlvdXIgaW1hZ2VzIGJlZm9yZSBwYXNzaW5nIHRoZW0gdG8gRWFzZWxKUywgZWc6IGBpbWcuY3Jvc3NPcmlnaW49XCJBbm9ueW1vdXNcIjtgPC9saT5cblx0ICogPC9vbD5cblx0ICpcblx0ICogQGNsYXNzIEJpdG1hcFxuXHQgKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnQgfCBTdHJpbmd9IGltYWdlT3JVcmkgVGhlIHNvdXJjZSBvYmplY3Qgb3IgVVJJIHRvIGFuIGltYWdlIHRvXG5cdCAqIGRpc3BsYXkuIFRoaXMgY2FuIGJlIGVpdGhlciBhbiBJbWFnZSwgQ2FudmFzLCBvciBWaWRlbyBvYmplY3QsIG9yIGEgc3RyaW5nIFVSSSB0byBhbiBpbWFnZSBmaWxlIHRvIGxvYWQgYW5kIHVzZS5cblx0ICogSWYgaXQgaXMgYSBVUkksIGEgbmV3IEltYWdlIG9iamVjdCB3aWxsIGJlIGNvbnN0cnVjdGVkIGFuZCBhc3NpZ25lZCB0byB0aGUgLmltYWdlIHByb3BlcnR5LlxuXHQgKiovXG5cdGZ1bmN0aW9uIEJpdG1hcChpbWFnZU9yVXJpKSB7XG5cdFx0dGhpcy5EaXNwbGF5T2JqZWN0X2NvbnN0cnVjdG9yKCk7XG5cdFx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSBpbWFnZSB0byByZW5kZXIuIFRoaXMgY2FuIGJlIGFuIEltYWdlLCBhIENhbnZhcywgb3IgYSBWaWRlby4gTm90IGFsbCBicm93c2VycyAoZXNwZWNpYWxseVxuXHRcdCAqIG1vYmlsZSBicm93c2Vycykgc3VwcG9ydCBkcmF3aW5nIHZpZGVvIHRvIGEgY2FudmFzLlxuXHRcdCAqIEBwcm9wZXJ0eSBpbWFnZVxuXHRcdCAqIEB0eXBlIEhUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnRcblx0XHQgKiovXG5cdFx0aWYgKHR5cGVvZiBpbWFnZU9yVXJpID09IFwic3RyaW5nXCIpIHtcblx0XHRcdHRoaXMuaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuXHRcdFx0dGhpcy5pbWFnZS5zcmMgPSBpbWFnZU9yVXJpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmltYWdlID0gaW1hZ2VPclVyaTtcblx0XHR9XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNwZWNpZmllcyBhbiBhcmVhIG9mIHRoZSBzb3VyY2UgaW1hZ2UgdG8gZHJhdy4gSWYgb21pdHRlZCwgdGhlIHdob2xlIGltYWdlIHdpbGwgYmUgZHJhd24uXG5cdFx0ICogTm90ZSB0aGF0IHZpZGVvIHNvdXJjZXMgbXVzdCBoYXZlIGEgd2lkdGggLyBoZWlnaHQgc2V0IHRvIHdvcmsgY29ycmVjdGx5IHdpdGggYHNvdXJjZVJlY3RgLlxuXHRcdCAqIEBwcm9wZXJ0eSBzb3VyY2VSZWN0XG5cdFx0ICogQHR5cGUgUmVjdGFuZ2xlXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuc291cmNlUmVjdCA9IG51bGw7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQml0bWFwLCBjcmVhdGVqcy5EaXNwbGF5T2JqZWN0KTtcblx0XG5cdFxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RvciBhbGlhcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIFRoaXMgbWV0aG9kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMuXG5cdCAqIFN1YmNsYXNzZXMgc2hvdWxkIGJlIHVwZGF0ZWQgdG8gdXNlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRzXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIGBjcmVhdGVqcy5wcm9tb3RlKClgXG5cdCAqKi9cblx0cC5pbml0aWFsaXplID0gQml0bWFwOyAvLyBUT0RPOiBkZXByZWNhdGVkLlxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxuXHQgKiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHdoZXRoZXIgaXQgd291bGQgYmUgdmlzaWJsZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHN0YWdlLlxuXHQgKlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzXG5cdCAqKi9cblx0cC5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xuXHRcdHZhciBoYXNDb250ZW50ID0gdGhpcy5jYWNoZUNhbnZhcyB8fCAoaW1hZ2UgJiYgKGltYWdlLm5hdHVyYWxXaWR0aCB8fCBpbWFnZS5nZXRDb250ZXh0IHx8IGltYWdlLnJlYWR5U3RhdGUgPj0gMikpO1xuXHRcdHJldHVybiAhISh0aGlzLnZpc2libGUgJiYgdGhpcy5hbHBoYSA+IDAgJiYgdGhpcy5zY2FsZVggIT0gMCAmJiB0aGlzLnNjYWxlWSAhPSAwICYmIGhhc0NvbnRlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyB0aGUgZGlzcGxheSBvYmplY3QgaW50byB0aGUgc3BlY2lmaWVkIGNvbnRleHQgaWdub3JpbmcgaXRzIHZpc2libGUsIGFscGhhLCBzaGFkb3csIGFuZCB0cmFuc2Zvcm0uXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZHJhdyB3YXMgaGFuZGxlZCAodXNlZnVsIGZvciBvdmVycmlkaW5nIGZ1bmN0aW9uYWxpdHkpLlxuXHQgKlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgZHJhd1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtpZ25vcmVDYWNoZT1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRyYXcgb3BlcmF0aW9uIHNob3VsZCBpZ25vcmUgYW55IGN1cnJlbnQgY2FjaGUuXG5cdCAqIEZvciBleGFtcGxlLCB1c2VkIGZvciBkcmF3aW5nIHRoZSBjYWNoZSAodG8gcHJldmVudCBpdCBmcm9tIHNpbXBseSBkcmF3aW5nIGFuIGV4aXN0aW5nIGNhY2hlIGJhY2tcblx0ICogaW50byBpdHNlbGYpLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiovXG5cdHAuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgaWdub3JlQ2FjaGUpIHtcblx0XHRpZiAodGhpcy5EaXNwbGF5T2JqZWN0X2RyYXcoY3R4LCBpZ25vcmVDYWNoZSkgfHwgIXRoaXMuaW1hZ2UpIHsgcmV0dXJuIHRydWU7IH1cblx0XHR2YXIgaW1nID0gdGhpcy5pbWFnZSwgcmVjdCA9IHRoaXMuc291cmNlUmVjdDtcblx0XHRpZiAocmVjdCkge1xuXHRcdFx0Ly8gc29tZSBicm93c2VycyBjaG9rZSBvbiBvdXQgb2YgYm91bmQgdmFsdWVzLCBzbyB3ZSdsbCBmaXggdGhlbTpcblx0XHRcdHZhciB4MSA9IHJlY3QueCwgeTEgPSByZWN0LnksIHgyID0geDEgKyByZWN0LndpZHRoLCB5MiA9IHkxICsgcmVjdC5oZWlnaHQsIHggPSAwLCB5ID0gMCwgdyA9IGltZy53aWR0aCwgaCA9IGltZy5oZWlnaHQ7XG5cdFx0XHRpZiAoeDEgPCAwKSB7IHggLT0geDE7IHgxID0gMDsgfVxuXHRcdFx0aWYgKHgyID4gdykgeyB4MiA9IHc7IH1cblx0XHRcdGlmICh5MSA8IDApIHsgeSAtPSB5MTsgeTEgPSAwOyB9XG5cdFx0XHRpZiAoeTIgPiBoKSB7IHkyID0gaDsgfVxuXHRcdFx0Y3R4LmRyYXdJbWFnZShpbWcsIHgxLCB5MSwgeDIteDEsIHkyLXkxLCB4LCB5LCB4Mi14MSwgeTIteTEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdHguZHJhd0ltYWdlKGltZywgMCwgMCk7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHRcblx0Ly9Ob3RlLCB0aGUgZG9jIHNlY3Rpb25zIGJlbG93IGRvY3VtZW50IHVzaW5nIHRoZSBzcGVjaWZpZWQgQVBJcyAoZnJvbSBEaXNwbGF5T2JqZWN0KSAgZnJvbVxuXHQvL0JpdG1hcC4gVGhpcyBpcyB3aHkgdGhleSBoYXZlIG5vIG1ldGhvZCBpbXBsZW1lbnRhdGlvbnMuXG5cdFxuXHQvKipcblx0ICogQmVjYXVzZSB0aGUgY29udGVudCBvZiBhIEJpdG1hcCBpcyBhbHJlYWR5IGluIGEgc2ltcGxlIGZvcm1hdCwgY2FjaGUgaXMgdW5uZWNlc3NhcnkgZm9yIEJpdG1hcCBpbnN0YW5jZXMuXG5cdCAqIFlvdSBzaG91bGQgPGI+bm90PC9iPiBjYWNoZSBCaXRtYXAgaW5zdGFuY2VzIGFzIGl0IGNhbiBkZWdyYWRlIHBlcmZvcm1hbmNlLlxuXHQgKlxuXHQgKiA8c3Ryb25nPkhvd2V2ZXI6IElmIHlvdSB3YW50IHRvIHVzZSBhIGZpbHRlciBvbiBhIEJpdG1hcCwgeW91IDxlbT5NVVNUPC9lbT4gY2FjaGUgaXQsIG9yIGl0IHdpbGwgbm90IHdvcmsuPC9zdHJvbmc+XG5cdCAqIFRvIHNlZSB0aGUgQVBJIGZvciBjYWNoaW5nLCBwbGVhc2UgdmlzaXQgdGhlIERpc3BsYXlPYmplY3Qge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9jYWNoZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuXG5cdCAqIEBtZXRob2QgY2FjaGVcblx0ICoqL1xuXHRcblx0LyoqXG5cdCAqIEJlY2F1c2UgdGhlIGNvbnRlbnQgb2YgYSBCaXRtYXAgaXMgYWxyZWFkeSBpbiBhIHNpbXBsZSBmb3JtYXQsIGNhY2hlIGlzIHVubmVjZXNzYXJ5IGZvciBCaXRtYXAgaW5zdGFuY2VzLlxuXHQgKiBZb3Ugc2hvdWxkIDxiPm5vdDwvYj4gY2FjaGUgQml0bWFwIGluc3RhbmNlcyBhcyBpdCBjYW4gZGVncmFkZSBwZXJmb3JtYW5jZS5cblx0ICpcblx0ICogPHN0cm9uZz5Ib3dldmVyOiBJZiB5b3Ugd2FudCB0byB1c2UgYSBmaWx0ZXIgb24gYSBCaXRtYXAsIHlvdSA8ZW0+TVVTVDwvZW0+IGNhY2hlIGl0LCBvciBpdCB3aWxsIG5vdCB3b3JrLjwvc3Ryb25nPlxuXHQgKiBUbyBzZWUgdGhlIEFQSSBmb3IgY2FjaGluZywgcGxlYXNlIHZpc2l0IHRoZSBEaXNwbGF5T2JqZWN0IHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvY2FjaGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLlxuXHQgKiBAbWV0aG9kIHVwZGF0ZUNhY2hlXG5cdCAqKi9cblx0XG5cdC8qKlxuXHQgKiBCZWNhdXNlIHRoZSBjb250ZW50IG9mIGEgQml0bWFwIGlzIGFscmVhZHkgaW4gYSBzaW1wbGUgZm9ybWF0LCBjYWNoZSBpcyB1bm5lY2Vzc2FyeSBmb3IgQml0bWFwIGluc3RhbmNlcy5cblx0ICogWW91IHNob3VsZCA8Yj5ub3Q8L2I+IGNhY2hlIEJpdG1hcCBpbnN0YW5jZXMgYXMgaXQgY2FuIGRlZ3JhZGUgcGVyZm9ybWFuY2UuXG5cdCAqXG5cdCAqIDxzdHJvbmc+SG93ZXZlcjogSWYgeW91IHdhbnQgdG8gdXNlIGEgZmlsdGVyIG9uIGEgQml0bWFwLCB5b3UgPGVtPk1VU1Q8L2VtPiBjYWNoZSBpdCwgb3IgaXQgd2lsbCBub3Qgd29yay48L3N0cm9uZz5cblx0ICogVG8gc2VlIHRoZSBBUEkgZm9yIGNhY2hpbmcsIHBsZWFzZSB2aXNpdCB0aGUgRGlzcGxheU9iamVjdCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2NhY2hlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZC5cblx0ICogQG1ldGhvZCB1bmNhY2hlXG5cdCAqKi9cblxuXHQvKipcblx0ICogRG9jY2VkIGluIHN1cGVyY2xhc3MuXG5cdCAqL1xuXHRwLmdldEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gdGhpcy5EaXNwbGF5T2JqZWN0X2dldEJvdW5kcygpO1xuXHRcdGlmIChyZWN0KSB7IHJldHVybiByZWN0OyB9XG5cdFx0dmFyIGltYWdlID0gdGhpcy5pbWFnZSwgbyA9IHRoaXMuc291cmNlUmVjdCB8fCBpbWFnZTtcblx0XHR2YXIgaGFzQ29udGVudCA9IChpbWFnZSAmJiAoaW1hZ2UubmF0dXJhbFdpZHRoIHx8IGltYWdlLmdldENvbnRleHQgfHwgaW1hZ2UucmVhZHlTdGF0ZSA+PSAyKSk7XG5cdFx0cmV0dXJuIGhhc0NvbnRlbnQgPyB0aGlzLl9yZWN0YW5nbGUuc2V0VmFsdWVzKDAsIDAsIG8ud2lkdGgsIG8uaGVpZ2h0KSA6IG51bGw7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBCaXRtYXAgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7Qml0bWFwfSBhIGNsb25lIG9mIHRoZSBCaXRtYXAgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvID0gbmV3IEJpdG1hcCh0aGlzLmltYWdlKTtcblx0XHRpZiAodGhpcy5zb3VyY2VSZWN0KSB7IG8uc291cmNlUmVjdCA9IHRoaXMuc291cmNlUmVjdC5jbG9uZSgpOyB9XG5cdFx0dGhpcy5fY2xvbmVQcm9wcyhvKTtcblx0XHRyZXR1cm4gbztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbQml0bWFwIChuYW1lPVwiKyAgdGhpcy5uYW1lICtcIildXCI7XG5cdH07XG5cblx0XG5cdGNyZWF0ZWpzLkJpdG1hcCA9IGNyZWF0ZWpzLnByb21vdGUoQml0bWFwLCBcIkRpc3BsYXlPYmplY3RcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU3ByaXRlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogRGlzcGxheXMgYSBmcmFtZSBvciBzZXF1ZW5jZSBvZiBmcmFtZXMgKGllLiBhbiBhbmltYXRpb24pIGZyb20gYSBTcHJpdGVTaGVldCBpbnN0YW5jZS4gQSBzcHJpdGUgc2hlZXQgaXMgYSBzZXJpZXMgb2Zcblx0ICogaW1hZ2VzICh1c3VhbGx5IGFuaW1hdGlvbiBmcmFtZXMpIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgaW1hZ2UuIEZvciBleGFtcGxlLCBhbiBhbmltYXRpb24gY29uc2lzdGluZyBvZiA4IDEwMHgxMDBcblx0ICogaW1hZ2VzIGNvdWxkIGJlIGNvbWJpbmVkIGludG8gYSA0MDB4MjAwIHNwcml0ZSBzaGVldCAoNCBmcmFtZXMgYWNyb3NzIGJ5IDIgaGlnaCkuIFlvdSBjYW4gZGlzcGxheSBpbmRpdmlkdWFsIGZyYW1lcyxcblx0ICogcGxheSBmcmFtZXMgYXMgYW4gYW5pbWF0aW9uLCBhbmQgZXZlbiBzZXF1ZW5jZSBhbmltYXRpb25zIHRvZ2V0aGVyLlxuXHQgKlxuXHQgKiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHNldHRpbmcgdXAgZnJhbWVzIGFuZCBhbmltYXRpb25zLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIGluc3RhbmNlID0gbmV3IGNyZWF0ZWpzLlNwcml0ZShzcHJpdGVTaGVldCk7XG5cdCAqICAgICAgaW5zdGFuY2UuZ290b0FuZFN0b3AoXCJmcmFtZU5hbWVcIik7XG5cdCAqXG5cdCAqIFVudGlsIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9nb3RvQW5kU3RvcFwifX17ey9jcm9zc0xpbmt9fSBvciB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX0gaXMgY2FsbGVkLFxuXHQgKiBvbmx5IHRoZSBmaXJzdCBkZWZpbmVkIGZyYW1lIGRlZmluZWQgaW4gdGhlIHNwcml0ZSBzaGVldCB3aWxsIGJlIGRpc3BsYXllZC5cblx0ICpcblx0ICogQGNsYXNzIFNwcml0ZVxuXHQgKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge1Nwcml0ZVNoZWV0fSBzcHJpdGVTaGVldCBUaGUgU3ByaXRlU2hlZXQgaW5zdGFuY2UgdG8gcGxheSBiYWNrLiBUaGlzIGluY2x1ZGVzIHRoZSBzb3VyY2UgaW1hZ2UocyksIGZyYW1lXG5cdCAqIGRpbWVuc2lvbnMsIGFuZCBmcmFtZSBkYXRhLiBTZWUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gW2ZyYW1lT3JBbmltYXRpb25dIFRoZSBmcmFtZSBudW1iZXIgb3IgYW5pbWF0aW9uIHRvIHBsYXkgaW5pdGlhbGx5LlxuXHQgKiovXG5cdGZ1bmN0aW9uIFNwcml0ZShzcHJpdGVTaGVldCwgZnJhbWVPckFuaW1hdGlvbikge1xuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9jb25zdHJ1Y3RvcigpO1xuXHRcdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgZnJhbWUgaW5kZXggdGhhdCB3aWxsIGJlIGRyYXduIHdoZW4gZHJhdyBpcyBjYWxsZWQuIE5vdGUgdGhhdCB3aXRoIHNvbWUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBkZWZpbml0aW9ucywgdGhpcyB3aWxsIGFkdmFuY2Ugbm9uLXNlcXVlbnRpYWxseS4gVGhpcyB3aWxsIGFsd2F5cyBiZSBhbiBpbnRlZ2VyIHZhbHVlLlxuXHRcdCAqIEBwcm9wZXJ0eSBjdXJyZW50RnJhbWVcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5jdXJyZW50RnJhbWUgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHkgcGxheWluZyBhbmltYXRpb24uXG5cdFx0ICogQHByb3BlcnR5IGN1cnJlbnRBbmltYXRpb25cblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBmaW5hbFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBQcmV2ZW50cyB0aGUgYW5pbWF0aW9uIGZyb20gYWR2YW5jaW5nIGVhY2ggdGljayBhdXRvbWF0aWNhbGx5LiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIGNyZWF0ZSBhIHNwcml0ZVxuXHRcdCAqIHNoZWV0IG9mIGljb25zLCBzZXQgcGF1c2VkIHRvIHRydWUsIGFuZCBkaXNwbGF5IHRoZSBhcHByb3ByaWF0ZSBpY29uIGJ5IHNldHRpbmcgPGNvZGU+Y3VycmVudEZyYW1lPC9jb2RlPi5cblx0XHQgKiBAcHJvcGVydHkgcGF1c2VkXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiovXG5cdFx0dGhpcy5wYXVzZWQgPSB0cnVlO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgU3ByaXRlU2hlZXQgaW5zdGFuY2UgdG8gcGxheSBiYWNrLiBUaGlzIGluY2x1ZGVzIHRoZSBzb3VyY2UgaW1hZ2UsIGZyYW1lIGRpbWVuc2lvbnMsIGFuZCBmcmFtZVxuXHRcdCAqIGRhdGEuIFNlZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgc3ByaXRlU2hlZXRcblx0XHQgKiBAdHlwZSB7U3ByaXRlU2hlZXR9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMuc3ByaXRlU2hlZXQgPSBzcHJpdGVTaGVldDtcblx0XG5cdFx0LyoqXG5cdFx0ICogU3BlY2lmaWVzIHRoZSBjdXJyZW50IGZyYW1lIGluZGV4IHdpdGhpbiB0aGUgY3VycmVudGx5IHBsYXlpbmcgYW5pbWF0aW9uLiBXaGVuIHBsYXlpbmcgbm9ybWFsbHksIHRoaXMgd2lsbCBpbmNyZWFzZVxuXHRcdCAqIGZyb20gMCB0byBuLTEsIHdoZXJlIG4gaXMgdGhlIG51bWJlciBvZiBmcmFtZXMgaW4gdGhlIGN1cnJlbnQgYW5pbWF0aW9uLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBjb3VsZCBiZSBhIG5vbi1pbnRlZ2VyIHZhbHVlIGlmXG5cdFx0ICogdXNpbmcgdGltZS1iYXNlZCBwbGF5YmFjayAoc2VlIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9mcmFtZXJhdGVcIn19e3svY3Jvc3NMaW5rfX0sIG9yIGlmIHRoZSBhbmltYXRpb24ncyBzcGVlZCBpc1xuXHRcdCAqIG5vdCBhbiBpbnRlZ2VyLlxuXHRcdCAqIEBwcm9wZXJ0eSBjdXJyZW50QW5pbWF0aW9uRnJhbWVcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWUgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBCeSBkZWZhdWx0IFNwcml0ZSBpbnN0YW5jZXMgYWR2YW5jZSBvbmUgZnJhbWUgcGVyIHRpY2suIFNwZWNpZnlpbmcgYSBmcmFtZXJhdGUgZm9yIHRoZSBTcHJpdGUgKG9yIGl0cyByZWxhdGVkXG5cdFx0ICogU3ByaXRlU2hlZXQpIHdpbGwgY2F1c2UgaXQgdG8gYWR2YW5jZSBiYXNlZCBvbiBlbGFwc2VkIHRpbWUgYmV0d2VlbiB0aWNrcyBhcyBhcHByb3ByaWF0ZSB0byBtYWludGFpbiB0aGUgdGFyZ2V0XG5cdFx0ICogZnJhbWVyYXRlLlxuXHRcdCAqXG5cdFx0ICogRm9yIGV4YW1wbGUsIGlmIGEgU3ByaXRlIHdpdGggYSBmcmFtZXJhdGUgb2YgMTAgaXMgcGxhY2VkIG9uIGEgU3RhZ2UgYmVpbmcgdXBkYXRlZCBhdCA0MGZwcywgdGhlbiB0aGUgU3ByaXRlIHdpbGxcblx0XHQgKiBhZHZhbmNlIHJvdWdobHkgb25lIGZyYW1lIGV2ZXJ5IDQgdGlja3MuIFRoaXMgd2lsbCBub3QgYmUgZXhhY3QsIGJlY2F1c2UgdGhlIHRpbWUgYmV0d2VlbiBlYWNoIHRpY2sgd2lsbFxuXHRcdCAqIHZhcnkgc2xpZ2h0bHkgYmV0d2VlbiBmcmFtZXMuXG5cdFx0ICpcblx0XHQgKiBUaGlzIGZlYXR1cmUgaXMgZGVwZW5kZW50IG9uIHRoZSB0aWNrIGV2ZW50IG9iamVjdCAob3IgYW4gb2JqZWN0IHdpdGggYW4gYXBwcm9wcmlhdGUgXCJkZWx0YVwiIHByb3BlcnR5KSBiZWluZ1xuXHRcdCAqIHBhc3NlZCBpbnRvIHt7I2Nyb3NzTGluayBcIlN0YWdlL3VwZGF0ZVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgZnJhbWVyYXRlXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMuZnJhbWVyYXRlID0gMDtcblx0XG5cdFxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQ3VycmVudCBhbmltYXRpb24gb2JqZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBfYW5pbWF0aW9uXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqKi9cblx0XHR0aGlzLl9hbmltYXRpb24gPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBDdXJyZW50IGZyYW1lIGluZGV4LlxuXHRcdCAqIEBwcm9wZXJ0eSBfY3VycmVudEZyYW1lXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqKi9cblx0XHR0aGlzLl9jdXJyZW50RnJhbWUgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNraXBzIHRoZSBuZXh0IGF1dG8gYWR2YW5jZS4gVXNlZCBieSBnb3RvQW5kUGxheSB0byBhdm9pZCBpbW1lZGlhdGVseSBqdW1waW5nIHRvIHRoZSBuZXh0IGZyYW1lXG5cdFx0ICogQHByb3BlcnR5IF9za2lwQWR2YW5jZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqKi9cblx0XHR0aGlzLl9za2lwQWR2YW5jZSA9IGZhbHNlO1xuXHRcdFxuXHRcdFxuXHRcdGlmIChmcmFtZU9yQW5pbWF0aW9uICE9IG51bGwpIHsgdGhpcy5nb3RvQW5kUGxheShmcmFtZU9yQW5pbWF0aW9uKTsgfVxuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFNwcml0ZSwgY3JlYXRlanMuRGlzcGxheU9iamVjdCk7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdG9yIGFsaWFzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gVGhpcyBtZXRob2Qgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSB2ZXJzaW9ucy5cblx0ICogU3ViY2xhc3NlcyBzaG91bGQgYmUgdXBkYXRlZCB0byB1c2Uge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZHNcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAZGVwcmVjYXRlZCBpbiBmYXZvdXIgb2YgYGNyZWF0ZWpzLnByb21vdGUoKWBcblx0ICoqL1xuXHRwLmluaXRpYWxpemUgPSBTcHJpdGU7IC8vIFRPRE86IERlcHJlY2F0ZWQuIFRoaXMgaXMgZm9yIGJhY2t3YXJkcyBzdXBwb3J0IG9mIEZsYXNoQ0Mgc3ByaXRlc2hlZXQgZXhwb3J0LlxuXG5cbi8vIGV2ZW50czpcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiBhbiBhbmltYXRpb24gcmVhY2hlcyBpdHMgZW5kcy5cblx0ICogQGV2ZW50IGFuaW1hdGlvbmVuZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdGhhdCBqdXN0IGVuZGVkLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmV4dCBUaGUgbmFtZSBvZiB0aGUgbmV4dCBhbmltYXRpb24gdGhhdCB3aWxsIGJlIHBsYXllZCwgb3IgbnVsbC4gVGhpcyB3aWxsIGJlIHRoZSBzYW1lIGFzIG5hbWUgaWYgdGhlIGFuaW1hdGlvbiBpcyBsb29waW5nLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgYW55IHRpbWUgdGhlIGN1cnJlbnQgZnJhbWUgY2hhbmdlcy4gRm9yIGV4YW1wbGUsIHRoaXMgY291bGQgYmUgZHVlIHRvIGF1dG9tYXRpYyBhZHZhbmNlbWVudCBvbiBhIHRpY2ssXG5cdCAqIG9yIGNhbGxpbmcgZ290b0FuZFBsYXkoKSBvciBnb3RvQW5kU3RvcCgpLlxuXHQgKiBAZXZlbnQgY2hhbmdlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICovXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxuXHQgKiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHdoZXRoZXIgaXQgd291bGQgYmUgdmlzaWJsZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHN0YWdlLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzXG5cdCAqKi9cblx0cC5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGFzQ29udGVudCA9IHRoaXMuY2FjaGVDYW52YXMgfHwgdGhpcy5zcHJpdGVTaGVldC5jb21wbGV0ZTtcblx0XHRyZXR1cm4gISEodGhpcy52aXNpYmxlICYmIHRoaXMuYWxwaGEgPiAwICYmIHRoaXMuc2NhbGVYICE9IDAgJiYgdGhpcy5zY2FsZVkgIT0gMCAmJiBoYXNDb250ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgdGhlIGRpc3BsYXkgb2JqZWN0IGludG8gdGhlIHNwZWNpZmllZCBjb250ZXh0IGlnbm9yaW5nIGl0cyB2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBhbmQgdHJhbnNmb3JtLlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRyYXcgd2FzIGhhbmRsZWQgKHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyBmdW5jdGlvbmFsaXR5KS5cblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGRyYXdcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIGNvbnRleHQgb2JqZWN0IHRvIGRyYXcgaW50by5cblx0ICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVDYWNoZSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZHJhdyBvcGVyYXRpb24gc2hvdWxkIGlnbm9yZSBhbnkgY3VycmVudCBjYWNoZS5cblx0ICogRm9yIGV4YW1wbGUsIHVzZWQgZm9yIGRyYXdpbmcgdGhlIGNhY2hlICh0byBwcmV2ZW50IGl0IGZyb20gc2ltcGx5IGRyYXdpbmcgYW4gZXhpc3RpbmcgY2FjaGUgYmFja1xuXHQgKiBpbnRvIGl0c2VsZikuXG5cdCAqKi9cblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBpZ25vcmVDYWNoZSkge1xuXHRcdGlmICh0aGlzLkRpc3BsYXlPYmplY3RfZHJhdyhjdHgsIGlnbm9yZUNhY2hlKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdHRoaXMuX25vcm1hbGl6ZUZyYW1lKCk7XG5cdFx0dmFyIG8gPSB0aGlzLnNwcml0ZVNoZWV0LmdldEZyYW1lKHRoaXMuX2N1cnJlbnRGcmFtZXwwKTtcblx0XHRpZiAoIW8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0dmFyIHJlY3QgPSBvLnJlY3Q7XG5cdFx0aWYgKHJlY3Qud2lkdGggJiYgcmVjdC5oZWlnaHQpIHsgY3R4LmRyYXdJbWFnZShvLmltYWdlLCByZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQsIC1vLnJlZ1gsIC1vLnJlZ1ksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTsgfVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8vTm90ZSwgdGhlIGRvYyBzZWN0aW9ucyBiZWxvdyBkb2N1bWVudCB1c2luZyB0aGUgc3BlY2lmaWVkIEFQSXMgKGZyb20gRGlzcGxheU9iamVjdCkgIGZyb21cblx0Ly9CaXRtYXAuIFRoaXMgaXMgd2h5IHRoZXkgaGF2ZSBubyBtZXRob2QgaW1wbGVtZW50YXRpb25zLlxuXG5cdC8qKlxuXHQgKiBCZWNhdXNlIHRoZSBjb250ZW50IG9mIGEgU3ByaXRlIGlzIGFscmVhZHkgaW4gYSByYXN0ZXIgZm9ybWF0LCBjYWNoZSBpcyB1bm5lY2Vzc2FyeSBmb3IgU3ByaXRlIGluc3RhbmNlcy5cblx0ICogWW91IHNob3VsZCBub3QgY2FjaGUgU3ByaXRlIGluc3RhbmNlcyBhcyBpdCBjYW4gZGVncmFkZSBwZXJmb3JtYW5jZS5cblx0ICogQG1ldGhvZCBjYWNoZVxuXHQgKiovXG5cblx0LyoqXG5cdCAqIEJlY2F1c2UgdGhlIGNvbnRlbnQgb2YgYSBTcHJpdGUgaXMgYWxyZWFkeSBpbiBhIHJhc3RlciBmb3JtYXQsIGNhY2hlIGlzIHVubmVjZXNzYXJ5IGZvciBTcHJpdGUgaW5zdGFuY2VzLlxuXHQgKiBZb3Ugc2hvdWxkIG5vdCBjYWNoZSBTcHJpdGUgaW5zdGFuY2VzIGFzIGl0IGNhbiBkZWdyYWRlIHBlcmZvcm1hbmNlLlxuXHQgKiBAbWV0aG9kIHVwZGF0ZUNhY2hlXG5cdCAqKi9cblxuXHQvKipcblx0ICogQmVjYXVzZSB0aGUgY29udGVudCBvZiBhIFNwcml0ZSBpcyBhbHJlYWR5IGluIGEgcmFzdGVyIGZvcm1hdCwgY2FjaGUgaXMgdW5uZWNlc3NhcnkgZm9yIFNwcml0ZSBpbnN0YW5jZXMuXG5cdCAqIFlvdSBzaG91bGQgbm90IGNhY2hlIFNwcml0ZSBpbnN0YW5jZXMgYXMgaXQgY2FuIGRlZ3JhZGUgcGVyZm9ybWFuY2UuXG5cdCAqIEBtZXRob2QgdW5jYWNoZVxuXHQgKiovXG5cblx0LyoqXG5cdCAqIFBsYXkgKHVucGF1c2UpIHRoZSBjdXJyZW50IGFuaW1hdGlvbi4gVGhlIFNwcml0ZSB3aWxsIGJlIHBhdXNlZCBpZiBlaXRoZXIge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL3N0b3BcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogb3Ige3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2dvdG9BbmRTdG9wXCJ9fXt7L2Nyb3NzTGlua319IGlzIGNhbGxlZC4gU2luZ2xlIGZyYW1lIGFuaW1hdGlvbnMgd2lsbCByZW1haW5cblx0ICogdW5jaGFuZ2VkLlxuXHQgKiBAbWV0aG9kIHBsYXlcblx0ICoqL1xuXHRwLnBsYXkgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnBhdXNlZCA9IGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdG9wIHBsYXlpbmcgYSBydW5uaW5nIGFuaW1hdGlvbi4gVGhlIFNwcml0ZSB3aWxsIGJlIHBsYXlpbmcgaWYge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2dvdG9BbmRQbGF5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGlzIGNhbGxlZC4gTm90ZSB0aGF0IGNhbGxpbmcge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2dvdG9BbmRQbGF5XCJ9fXt7L2Nyb3NzTGlua319IG9yIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9wbGF5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdpbGwgcmVzdW1lIHBsYXliYWNrLlxuXHQgKiBAbWV0aG9kIHN0b3Bcblx0ICoqL1xuXHRwLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnBhdXNlZCA9IHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgcGF1c2VkIHRvIGZhbHNlIGFuZCBwbGF5cyB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbiBuYW1lLCBuYW1lZCBmcmFtZSwgb3IgZnJhbWUgbnVtYmVyLlxuXHQgKiBAbWV0aG9kIGdvdG9BbmRQbGF5XG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gZnJhbWVPckFuaW1hdGlvbiBUaGUgZnJhbWUgbnVtYmVyIG9yIGFuaW1hdGlvbiBuYW1lIHRoYXQgdGhlIHBsYXloZWFkIHNob3VsZCBtb3ZlIHRvXG5cdCAqIGFuZCBiZWdpbiBwbGF5aW5nLlxuXHQgKiovXG5cdHAuZ290b0FuZFBsYXkgPSBmdW5jdGlvbihmcmFtZU9yQW5pbWF0aW9uKSB7XG5cdFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9za2lwQWR2YW5jZSA9IHRydWU7XG5cdFx0dGhpcy5fZ290byhmcmFtZU9yQW5pbWF0aW9uKTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyBwYXVzZWQgdG8gdHJ1ZSBhbmQgc2Vla3MgdG8gdGhlIHNwZWNpZmllZCBhbmltYXRpb24gbmFtZSwgbmFtZWQgZnJhbWUsIG9yIGZyYW1lIG51bWJlci5cblx0ICogQG1ldGhvZCBnb3RvQW5kU3RvcFxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGZyYW1lT3JBbmltYXRpb24gVGhlIGZyYW1lIG51bWJlciBvciBhbmltYXRpb24gbmFtZSB0aGF0IHRoZSBwbGF5aGVhZCBzaG91bGQgbW92ZSB0b1xuXHQgKiBhbmQgc3RvcC5cblx0ICoqL1xuXHRwLmdvdG9BbmRTdG9wID0gZnVuY3Rpb24oZnJhbWVPckFuaW1hdGlvbikge1xuXHRcdHRoaXMucGF1c2VkID0gdHJ1ZTtcblx0XHR0aGlzLl9nb3RvKGZyYW1lT3JBbmltYXRpb24pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZHZhbmNlcyB0aGUgcGxheWhlYWQuIFRoaXMgb2NjdXJzIGF1dG9tYXRpY2FsbHkgZWFjaCB0aWNrIGJ5IGRlZmF1bHQuXG5cdCAqIEBwYXJhbSBbdGltZV0ge051bWJlcn0gVGhlIGFtb3VudCBvZiB0aW1lIGluIG1zIHRvIGFkdmFuY2UgYnkuIE9ubHkgYXBwbGljYWJsZSBpZiBmcmFtZXJhdGUgaXMgc2V0IG9uIHRoZSBTcHJpdGVcblx0ICogb3IgaXRzIFNwcml0ZVNoZWV0LlxuXHQgKiBAbWV0aG9kIGFkdmFuY2Vcblx0Ki9cblx0cC5hZHZhbmNlID0gZnVuY3Rpb24odGltZSkge1xuXHRcdHZhciBmcHMgPSB0aGlzLmZyYW1lcmF0ZSB8fCB0aGlzLnNwcml0ZVNoZWV0LmZyYW1lcmF0ZTtcblx0XHR2YXIgdCA9IChmcHMgJiYgdGltZSAhPSBudWxsKSA/IHRpbWUvKDEwMDAvZnBzKSA6IDE7XG5cdFx0dGhpcy5fbm9ybWFsaXplRnJhbWUodCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIHt7I2Nyb3NzTGluayBcIlJlY3RhbmdsZVwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZSBkZWZpbmluZyB0aGUgYm91bmRzIG9mIHRoZSBjdXJyZW50IGZyYW1lIHJlbGF0aXZlIHRvXG5cdCAqIHRoZSBvcmlnaW4uIEZvciBleGFtcGxlLCBhIDkwIHggNzAgZnJhbWUgd2l0aCA8Y29kZT5yZWdYPTUwPC9jb2RlPiBhbmQgPGNvZGU+cmVnWT00MDwvY29kZT4gd291bGQgcmV0dXJuIGFcblx0ICogcmVjdGFuZ2xlIHdpdGggW3g9LTUwLCB5PS00MCwgd2lkdGg9OTAsIGhlaWdodD03MF0uIFRoaXMgaWdub3JlcyB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGRpc3BsYXkgb2JqZWN0LlxuXHQgKlxuXHQgKiBBbHNvIHNlZSB0aGUgU3ByaXRlU2hlZXQge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXQvZ2V0RnJhbWVCb3VuZHNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuXHQgKiBAbWV0aG9kIGdldEJvdW5kc1xuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IEEgUmVjdGFuZ2xlIGluc3RhbmNlLiBSZXR1cm5zIG51bGwgaWYgdGhlIGZyYW1lIGRvZXMgbm90IGV4aXN0LCBvciB0aGUgaW1hZ2UgaXMgbm90IGZ1bGx5XG5cdCAqIGxvYWRlZC5cblx0ICoqL1xuXHRwLmdldEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFRPRE86IHNob3VsZCB0aGlzIG5vcm1hbGl6ZUZyYW1lP1xuXHRcdHJldHVybiB0aGlzLkRpc3BsYXlPYmplY3RfZ2V0Qm91bmRzKCkgfHwgdGhpcy5zcHJpdGVTaGVldC5nZXRGcmFtZUJvdW5kcyh0aGlzLmN1cnJlbnRGcmFtZSwgdGhpcy5fcmVjdGFuZ2xlKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBTcHJpdGUgaW5zdGFuY2UuIE5vdGUgdGhhdCB0aGUgc2FtZSBTcHJpdGVTaGVldCBpcyBzaGFyZWQgYmV0d2VlbiBjbG9uZWRcblx0ICogaW5zdGFuY2VzLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge1Nwcml0ZX0gYSBjbG9uZSBvZiB0aGUgU3ByaXRlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmVQcm9wcyhuZXcgU3ByaXRlKHRoaXMuc3ByaXRlU2hlZXQpKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1Nwcml0ZSAobmFtZT1cIisgIHRoaXMubmFtZSArXCIpXVwiO1xuXHR9O1xuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9jbG9uZVByb3BzXG5cdCAqIEBwYXJhbSB7U3ByaXRlfSBvXG5cdCAqIEByZXR1cm4ge1Nwcml0ZX0gb1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fY2xvbmVQcm9wcyA9IGZ1bmN0aW9uKG8pIHtcblx0XHR0aGlzLkRpc3BsYXlPYmplY3RfX2Nsb25lUHJvcHMobyk7XG5cdFx0by5jdXJyZW50RnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcblx0XHRvLmN1cnJlbnRBbmltYXRpb24gPSB0aGlzLmN1cnJlbnRBbmltYXRpb247XG5cdFx0by5wYXVzZWQgPSB0aGlzLnBhdXNlZDtcblx0XHRvLmN1cnJlbnRBbmltYXRpb25GcmFtZSA9IHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lO1xuXHRcdG8uZnJhbWVyYXRlID0gdGhpcy5mcmFtZXJhdGU7XG5cdFx0XG5cdFx0by5fYW5pbWF0aW9uID0gdGhpcy5fYW5pbWF0aW9uO1xuXHRcdG8uX2N1cnJlbnRGcmFtZSA9IHRoaXMuX2N1cnJlbnRGcmFtZTtcblx0XHRvLl9za2lwQWR2YW5jZSA9IHRoaXMuX3NraXBBZHZhbmNlO1xuXHRcdHJldHVybiBvO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoZSA8Y29kZT5jdXJyZW50RnJhbWU8L2NvZGU+IGlmIHBhdXNlZCBpcyBub3QgdHJ1ZS4gVGhpcyBpcyBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSB7eyNjcm9zc0xpbmsgXCJTdGFnZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB0aWNrcy5cblx0ICogQHBhcmFtIHtPYmplY3R9IGV2dE9iaiBBbiBldmVudCBvYmplY3QgdGhhdCB3aWxsIGJlIGRpc3BhdGNoZWQgdG8gYWxsIHRpY2sgbGlzdGVuZXJzLiBUaGlzIG9iamVjdCBpcyByZXVzZWQgYmV0d2VlbiBkaXNwYXRjaGVycyB0byByZWR1Y2UgY29uc3RydWN0aW9uICYgR0MgY29zdHMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQG1ldGhvZCBfdGlja1xuXHQgKiovXG5cdHAuX3RpY2sgPSBmdW5jdGlvbihldnRPYmopIHtcblx0XHRpZiAoIXRoaXMucGF1c2VkKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3NraXBBZHZhbmNlKSB7IHRoaXMuYWR2YW5jZShldnRPYmomJmV2dE9iai5kZWx0YSk7IH1cblx0XHRcdHRoaXMuX3NraXBBZHZhbmNlID0gZmFsc2U7XG5cdFx0fVxuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9fdGljayhldnRPYmopO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE5vcm1hbGl6ZXMgdGhlIGN1cnJlbnQgZnJhbWUsIGFkdmFuY2luZyBhbmltYXRpb25zIGFuZCBkaXNwYXRjaGluZyBjYWxsYmFja3MgYXMgYXBwcm9wcmlhdGUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQG1ldGhvZCBfbm9ybWFsaXplRnJhbWVcblx0ICoqL1xuXHRwLl9ub3JtYWxpemVGcmFtZSA9IGZ1bmN0aW9uKGZyYW1lRGVsdGEpIHtcblx0XHRmcmFtZURlbHRhID0gZnJhbWVEZWx0YSB8fCAwO1xuXHRcdHZhciBhbmltYXRpb24gPSB0aGlzLl9hbmltYXRpb247XG5cdFx0dmFyIHBhdXNlZCA9IHRoaXMucGF1c2VkO1xuXHRcdHZhciBmcmFtZSA9IHRoaXMuX2N1cnJlbnRGcmFtZTtcblx0XHR2YXIgbDtcblx0XHRcblx0XHRpZiAoYW5pbWF0aW9uKSB7XG5cdFx0XHR2YXIgc3BlZWQgPSBhbmltYXRpb24uc3BlZWQgfHwgMTtcblx0XHRcdHZhciBhbmltRnJhbWUgPSB0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZTtcblx0XHRcdGwgPSBhbmltYXRpb24uZnJhbWVzLmxlbmd0aDtcblx0XHRcdGlmIChhbmltRnJhbWUgKyBmcmFtZURlbHRhICogc3BlZWQgPj0gbCkge1xuXHRcdFx0XHR2YXIgbmV4dCA9IGFuaW1hdGlvbi5uZXh0O1xuXHRcdFx0XHRpZiAodGhpcy5fZGlzcGF0Y2hBbmltYXRpb25FbmQoYW5pbWF0aW9uLCBmcmFtZSwgcGF1c2VkLCBuZXh0LCBsIC0gMSkpIHtcblx0XHRcdFx0XHQvLyBzb21ldGhpbmcgY2hhbmdlZCBpbiB0aGUgZXZlbnQgc3RhY2ssIHNvIHdlIHNob3VsZG4ndCBtYWtlIGFueSBtb3JlIGNoYW5nZXMgaGVyZS5cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH0gZWxzZSBpZiAobmV4dCkge1xuXHRcdFx0XHRcdC8vIHNlcXVlbmNlLiBBdXRvbWF0aWNhbGx5IGNhbGxzIF9ub3JtYWxpemVGcmFtZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgZnJhbWVzLlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9nb3RvKG5leHQsIGZyYW1lRGVsdGEgLSAobCAtIGFuaW1GcmFtZSkgLyBzcGVlZCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gZW5kLlxuXHRcdFx0XHRcdHRoaXMucGF1c2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRhbmltRnJhbWUgPSBhbmltYXRpb24uZnJhbWVzLmxlbmd0aCAtIDE7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFuaW1GcmFtZSArPSBmcmFtZURlbHRhICogc3BlZWQ7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZSA9IGFuaW1GcmFtZTtcblx0XHRcdHRoaXMuX2N1cnJlbnRGcmFtZSA9IGFuaW1hdGlvbi5mcmFtZXNbYW5pbUZyYW1lIHwgMF1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZnJhbWUgPSAodGhpcy5fY3VycmVudEZyYW1lICs9IGZyYW1lRGVsdGEpO1xuXHRcdFx0bCA9IHRoaXMuc3ByaXRlU2hlZXQuZ2V0TnVtRnJhbWVzKCk7XG5cdFx0XHRpZiAoZnJhbWUgPj0gbCAmJiBsID4gMCkge1xuXHRcdFx0XHRpZiAoIXRoaXMuX2Rpc3BhdGNoQW5pbWF0aW9uRW5kKGFuaW1hdGlvbiwgZnJhbWUsIHBhdXNlZCwgbCAtIDEpKSB7XG5cdFx0XHRcdFx0Ly8gbG9vcGVkLlxuXHRcdFx0XHRcdGlmICgodGhpcy5fY3VycmVudEZyYW1lIC09IGwpID49IGwpIHsgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZUZyYW1lKCk7IH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRmcmFtZSA9IHRoaXMuX2N1cnJlbnRGcmFtZSB8IDA7XG5cdFx0aWYgKHRoaXMuY3VycmVudEZyYW1lICE9IGZyYW1lKSB7XG5cdFx0XHR0aGlzLmN1cnJlbnRGcmFtZSA9IGZyYW1lO1xuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiY2hhbmdlXCIpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRGlzcGF0Y2hlcyB0aGUgXCJhbmltYXRpb25lbmRcIiBldmVudC4gUmV0dXJucyB0cnVlIGlmIGEgaGFuZGxlciBjaGFuZ2VkIHRoZSBhbmltYXRpb24gKGV4LiBjYWxsaW5nIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9zdG9wXCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX0sIGV0Yy4pXG5cdCAqIEBwcm9wZXJ0eSBfZGlzcGF0Y2hBbmltYXRpb25FbmRcblx0ICogQHByaXZhdGVcblx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHQgKiovXG5cdHAuX2Rpc3BhdGNoQW5pbWF0aW9uRW5kID0gZnVuY3Rpb24oYW5pbWF0aW9uLCBmcmFtZSwgcGF1c2VkLCBuZXh0LCBlbmQpIHtcblx0XHR2YXIgbmFtZSA9IGFuaW1hdGlvbiA/IGFuaW1hdGlvbi5uYW1lIDogbnVsbDtcblx0XHRpZiAodGhpcy5oYXNFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIpKSB7XG5cdFx0XHR2YXIgZXZ0ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiYW5pbWF0aW9uZW5kXCIpO1xuXHRcdFx0ZXZ0Lm5hbWUgPSBuYW1lO1xuXHRcdFx0ZXZ0Lm5leHQgPSBuZXh0O1xuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cdFx0fVxuXHRcdC8vIGRpZCB0aGUgYW5pbWF0aW9uIGdldCBjaGFuZ2VkIGluIHRoZSBldmVudCBzdGFjaz86XG5cdFx0dmFyIGNoYW5nZWQgPSAodGhpcy5fYW5pbWF0aW9uICE9IGFuaW1hdGlvbiB8fCB0aGlzLl9jdXJyZW50RnJhbWUgIT0gZnJhbWUpO1xuXHRcdC8vIGlmIHRoZSBhbmltYXRpb24gaGFzbid0IGNoYW5nZWQsIGJ1dCB0aGUgc3ByaXRlIHdhcyBwYXVzZWQsIHRoZW4gd2Ugd2FudCB0byBzdGljayB0byB0aGUgbGFzdCBmcmFtZTpcblx0XHRpZiAoIWNoYW5nZWQgJiYgIXBhdXNlZCAmJiB0aGlzLnBhdXNlZCkgeyB0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZSA9IGVuZDsgY2hhbmdlZCA9IHRydWU7IH1cblx0XHRyZXR1cm4gY2hhbmdlZDtcblx0fTtcblxuXHQvKipcblx0ICogTW92ZXMgdGhlIHBsYXloZWFkIHRvIHRoZSBzcGVjaWZpZWQgZnJhbWUgbnVtYmVyIG9yIGFuaW1hdGlvbi5cblx0ICogQG1ldGhvZCBfZ290b1xuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGZyYW1lT3JBbmltYXRpb24gVGhlIGZyYW1lIG51bWJlciBvciBhbmltYXRpb24gdGhhdCB0aGUgcGxheWhlYWQgc2hvdWxkIG1vdmUgdG8uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZyYW1lXSBUaGUgZnJhbWUgb2YgdGhlIGFuaW1hdGlvbiB0byBnbyB0by4gRGVmYXVsdHMgdG8gMC5cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dvdG8gPSBmdW5jdGlvbihmcmFtZU9yQW5pbWF0aW9uLCBmcmFtZSkge1xuXHRcdHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lID0gMDtcblx0XHRpZiAoaXNOYU4oZnJhbWVPckFuaW1hdGlvbikpIHtcblx0XHRcdHZhciBkYXRhID0gdGhpcy5zcHJpdGVTaGVldC5nZXRBbmltYXRpb24oZnJhbWVPckFuaW1hdGlvbik7XG5cdFx0XHRpZiAoZGF0YSkge1xuXHRcdFx0XHR0aGlzLl9hbmltYXRpb24gPSBkYXRhO1xuXHRcdFx0XHR0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBmcmFtZU9yQW5pbWF0aW9uO1xuXHRcdFx0XHR0aGlzLl9ub3JtYWxpemVGcmFtZShmcmFtZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IHRoaXMuX2FuaW1hdGlvbiA9IG51bGw7XG5cdFx0XHR0aGlzLl9jdXJyZW50RnJhbWUgPSBmcmFtZU9yQW5pbWF0aW9uO1xuXHRcdFx0dGhpcy5fbm9ybWFsaXplRnJhbWUoKTtcblx0XHR9XG5cdH07XG5cblxuXHRjcmVhdGVqcy5TcHJpdGUgPSBjcmVhdGVqcy5wcm9tb3RlKFNwcml0ZSwgXCJEaXNwbGF5T2JqZWN0XCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNoYXBlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogQSBTaGFwZSBhbGxvd3MgeW91IHRvIGRpc3BsYXkgdmVjdG9yIGFydCBpbiB0aGUgZGlzcGxheSBsaXN0LiBJdCBjb21wb3NpdGVzIGEge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3NcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaW5zdGFuY2Ugd2hpY2ggZXhwb3NlcyBhbGwgb2YgdGhlIHZlY3RvciBkcmF3aW5nIG1ldGhvZHMuIFRoZSBHcmFwaGljcyBpbnN0YW5jZSBjYW4gYmUgc2hhcmVkIGJldHdlZW4gbXVsdGlwbGUgU2hhcGVcblx0ICogaW5zdGFuY2VzIHRvIGRpc3BsYXkgdGhlIHNhbWUgdmVjdG9yIGdyYXBoaWNzIHdpdGggZGlmZmVyZW50IHBvc2l0aW9ucyBvciB0cmFuc2Zvcm1zLlxuXHQgKlxuXHQgKiBJZiB0aGUgdmVjdG9yIGFydCB3aWxsIG5vdFxuXHQgKiBjaGFuZ2UgYmV0d2VlbiBkcmF3cywgeW91IG1heSB3YW50IHRvIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9jYWNoZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgdG8gcmVkdWNlIHRoZVxuXHQgKiByZW5kZXJpbmcgY29zdC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBjcmVhdGVqcy5HcmFwaGljcygpLmJlZ2luRmlsbChcIiNmZjAwMDBcIikuZHJhd1JlY3QoMCwgMCwgMTAwLCAxMDApO1xuXHQgKiAgICAgIHZhciBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZShncmFwaGljcyk7XG5cdCAqXG5cdCAqICAgICAgLy9BbHRlcm5hdGl2ZWx5IHVzZSBjYW4gYWxzbyB1c2UgdGhlIGdyYXBoaWNzIHByb3BlcnR5IG9mIHRoZSBTaGFwZSBjbGFzcyB0byByZW5kZXJlciB0aGUgc2FtZSBhcyBhYm92ZS5cblx0ICogICAgICB2YXIgc2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcblx0ICogICAgICBzaGFwZS5ncmFwaGljcy5iZWdpbkZpbGwoXCIjZmYwMDAwXCIpLmRyYXdSZWN0KDAsIDAsIDEwMCwgMTAwKTtcblx0ICpcblx0ICogQGNsYXNzIFNoYXBlXG5cdCAqIEBleHRlbmRzIERpc3BsYXlPYmplY3Rcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7R3JhcGhpY3N9IGdyYXBoaWNzIE9wdGlvbmFsLiBUaGUgZ3JhcGhpY3MgaW5zdGFuY2UgdG8gZGlzcGxheS4gSWYgbnVsbCwgYSBuZXcgR3JhcGhpY3MgaW5zdGFuY2Ugd2lsbCBiZSBjcmVhdGVkLlxuXHQgKiovXG5cdGZ1bmN0aW9uIFNoYXBlKGdyYXBoaWNzKSB7XG5cdFx0dGhpcy5EaXNwbGF5T2JqZWN0X2NvbnN0cnVjdG9yKCk7XG5cdFx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSBncmFwaGljcyBpbnN0YW5jZSB0byBkaXNwbGF5LlxuXHRcdCAqIEBwcm9wZXJ0eSBncmFwaGljc1xuXHRcdCAqIEB0eXBlIEdyYXBoaWNzXG5cdFx0ICoqL1xuXHRcdHRoaXMuZ3JhcGhpY3MgPSBncmFwaGljcyA/IGdyYXBoaWNzIDogbmV3IGNyZWF0ZWpzLkdyYXBoaWNzKCk7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoU2hhcGUsIGNyZWF0ZWpzLkRpc3BsYXlPYmplY3QpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGluZGljYXRpbmcgd2hldGhlciB0aGUgU2hhcGUgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhcy5cblx0ICogVGhpcyBkb2VzIG5vdCBhY2NvdW50IGZvciB3aGV0aGVyIGl0IHdvdWxkIGJlIHZpc2libGUgd2l0aGluIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBzdGFnZS5cblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGlzVmlzaWJsZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgU2hhcGUgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhc1xuXHQgKiovXG5cdHAuaXNWaXNpYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhhc0NvbnRlbnQgPSB0aGlzLmNhY2hlQ2FudmFzIHx8ICh0aGlzLmdyYXBoaWNzICYmICF0aGlzLmdyYXBoaWNzLmlzRW1wdHkoKSk7XG5cdFx0cmV0dXJuICEhKHRoaXMudmlzaWJsZSAmJiB0aGlzLmFscGhhID4gMCAmJiB0aGlzLnNjYWxlWCAhPSAwICYmIHRoaXMuc2NhbGVZICE9IDAgJiYgaGFzQ29udGVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIHRoZSBTaGFwZSBpbnRvIHRoZSBzcGVjaWZpZWQgY29udGV4dCBpZ25vcmluZyBpdHMgdmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgYW5kIHRyYW5zZm9ybS4gUmV0dXJucyB0cnVlIGlmXG5cdCAqIHRoZSBkcmF3IHdhcyBoYW5kbGVkICh1c2VmdWwgZm9yIG92ZXJyaWRpbmcgZnVuY3Rpb25hbGl0eSkuXG5cdCAqXG5cdCAqIDxpPk5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy48L2k+XG5cdCAqIEBtZXRob2QgZHJhd1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtpZ25vcmVDYWNoZT1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRyYXcgb3BlcmF0aW9uIHNob3VsZCBpZ25vcmUgYW55IGN1cnJlbnQgY2FjaGUuIEZvciBleGFtcGxlLFxuXHQgKiB1c2VkIGZvciBkcmF3aW5nIHRoZSBjYWNoZSAodG8gcHJldmVudCBpdCBmcm9tIHNpbXBseSBkcmF3aW5nIGFuIGV4aXN0aW5nIGNhY2hlIGJhY2sgaW50byBpdHNlbGYpLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiovXG5cdHAuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgaWdub3JlQ2FjaGUpIHtcblx0XHRpZiAodGhpcy5EaXNwbGF5T2JqZWN0X2RyYXcoY3R4LCBpZ25vcmVDYWNoZSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHR0aGlzLmdyYXBoaWNzLmRyYXcoY3R4LCB0aGlzKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgU2hhcGUuIFNvbWUgcHJvcGVydGllcyB0aGF0IGFyZSBzcGVjaWZpYyB0byB0aGlzIGluc3RhbmNlJ3MgY3VycmVudCBjb250ZXh0IGFyZSByZXZlcnRlZCB0b1xuXHQgKiB0aGVpciBkZWZhdWx0cyAoZm9yIGV4YW1wbGUgLnBhcmVudCkuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHBhcmFtIHtCb29sZWFufSByZWN1cnNpdmUgSWYgdHJ1ZSwgdGhpcyBTaGFwZSdzIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlIHdpbGwgYWxzbyBiZVxuXHQgKiBjbG9uZWQuIElmIGZhbHNlLCB0aGUgR3JhcGhpY3MgaW5zdGFuY2Ugd2lsbCBiZSBzaGFyZWQgd2l0aCB0aGUgbmV3IFNoYXBlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbihyZWN1cnNpdmUpIHtcblx0XHR2YXIgZyA9IChyZWN1cnNpdmUgJiYgdGhpcy5ncmFwaGljcykgPyB0aGlzLmdyYXBoaWNzLmNsb25lKCkgOiB0aGlzLmdyYXBoaWNzO1xuXHRcdHJldHVybiAgdGhpcy5fY2xvbmVQcm9wcyhuZXcgU2hhcGUoZykpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbU2hhcGUgKG5hbWU9XCIrICB0aGlzLm5hbWUgK1wiKV1cIjtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLlNoYXBlID0gY3JlYXRlanMucHJvbW90ZShTaGFwZSwgXCJEaXNwbGF5T2JqZWN0XCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFRleHQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBEaXNwbGF5IG9uZSBvciBtb3JlIGxpbmVzIG9mIGR5bmFtaWMgdGV4dCAobm90IHVzZXIgZWRpdGFibGUpIGluIHRoZSBkaXNwbGF5IGxpc3QuIExpbmUgd3JhcHBpbmcgc3VwcG9ydCAodXNpbmcgdGhlXG5cdCAqIGxpbmVXaWR0aCkgaXMgdmVyeSBiYXNpYywgd3JhcHBpbmcgb24gc3BhY2VzIGFuZCB0YWJzIG9ubHkuIE5vdGUgdGhhdCBhcyBhbiBhbHRlcm5hdGl2ZSB0byBUZXh0LCB5b3UgY2FuIHBvc2l0aW9uIEhUTUxcblx0ICogdGV4dCBhYm92ZSBvciBiZWxvdyB0aGUgY2FudmFzIHJlbGF0aXZlIHRvIGl0ZW1zIGluIHRoZSBkaXNwbGF5IGxpc3QgdXNpbmcgdGhlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbG9jYWxUb0dsb2JhbFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QsIG9yIHVzaW5nIHt7I2Nyb3NzTGluayBcIkRPTUVsZW1lbnRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIDxiPlBsZWFzZSBub3RlIHRoYXQgVGV4dCBkb2VzIG5vdCBzdXBwb3J0IEhUTUwgdGV4dCwgYW5kIGNhbiBvbmx5IGRpc3BsYXkgb25lIGZvbnQgc3R5bGUgYXQgYSB0aW1lLjwvYj4gVG8gdXNlXG5cdCAqIG11bHRpcGxlIGZvbnQgc3R5bGVzLCB5b3Ugd2lsbCBuZWVkIHRvIGNyZWF0ZSBtdWx0aXBsZSB0ZXh0IGluc3RhbmNlcywgYW5kIHBvc2l0aW9uIHRoZW0gbWFudWFsbHkuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgdGV4dCA9IG5ldyBjcmVhdGVqcy5UZXh0KFwiSGVsbG8gV29ybGRcIiwgXCIyMHB4IEFyaWFsXCIsIFwiI2ZmNzcwMFwiKTtcblx0ICogICAgICB0ZXh0LnggPSAxMDA7XG5cdCAqICAgICAgdGV4dC50ZXh0QmFzZWxpbmUgPSBcImFscGhhYmV0aWNcIjtcblx0ICpcblx0ICogQ3JlYXRlSlMgVGV4dCBzdXBwb3J0cyB3ZWIgZm9udHMgKHRoZSBzYW1lIHJ1bGVzIGFzIENhbnZhcykuIFRoZSBmb250IG11c3QgYmUgbG9hZGVkIGFuZCBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXJcblx0ICogYmVmb3JlIGl0IGNhbiBiZSBkaXNwbGF5ZWQuXG5cdCAqXG5cdCAqIDxzdHJvbmc+Tm90ZTo8L3N0cm9uZz4gVGV4dCBjYW4gYmUgZXhwZW5zaXZlIHRvIGdlbmVyYXRlLCBzbyBjYWNoZSBpbnN0YW5jZXMgd2hlcmUgcG9zc2libGUuIEJlIGF3YXJlIHRoYXQgbm90IGFsbFxuXHQgKiBicm93c2VycyB3aWxsIHJlbmRlciBUZXh0IGV4YWN0bHkgdGhlIHNhbWUuXG5cdCAqIEBjbGFzcyBUZXh0XG5cdCAqIEBleHRlbmRzIERpc3BsYXlPYmplY3Rcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbdGV4dF0gVGhlIHRleHQgdG8gZGlzcGxheS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtmb250XSBUaGUgZm9udCBzdHlsZSB0byB1c2UuIEFueSB2YWxpZCB2YWx1ZSBmb3IgdGhlIENTUyBmb250IGF0dHJpYnV0ZSBpcyBhY2NlcHRhYmxlIChleC4gXCJib2xkXG5cdCAqIDM2cHggQXJpYWxcIikuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbY29sb3JdIFRoZSBjb2xvciB0byBkcmF3IHRoZSB0ZXh0IGluLiBBbnkgdmFsaWQgdmFsdWUgZm9yIHRoZSBDU1MgY29sb3IgYXR0cmlidXRlIGlzIGFjY2VwdGFibGUgKGV4LlxuXHQgKiBcIiNGMDBcIiwgXCJyZWRcIiwgb3IgXCIjRkYwMDAwXCIpLlxuXHQgKiovXG5cdGZ1bmN0aW9uIFRleHQodGV4dCwgZm9udCwgY29sb3IpIHtcblx0XHR0aGlzLkRpc3BsYXlPYmplY3RfY29uc3RydWN0b3IoKTtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIHRleHQgdG8gZGlzcGxheS5cblx0XHQgKiBAcHJvcGVydHkgdGV4dFxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqKi9cblx0XHR0aGlzLnRleHQgPSB0ZXh0O1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgZm9udCBzdHlsZSB0byB1c2UuIEFueSB2YWxpZCB2YWx1ZSBmb3IgdGhlIENTUyBmb250IGF0dHJpYnV0ZSBpcyBhY2NlcHRhYmxlIChleC4gXCJib2xkIDM2cHggQXJpYWxcIikuXG5cdFx0ICogQHByb3BlcnR5IGZvbnRcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiovXG5cdFx0dGhpcy5mb250ID0gZm9udDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGNvbG9yIHRvIGRyYXcgdGhlIHRleHQgaW4uIEFueSB2YWxpZCB2YWx1ZSBmb3IgdGhlIENTUyBjb2xvciBhdHRyaWJ1dGUgaXMgYWNjZXB0YWJsZSAoZXguIFwiI0YwMFwiKS4gRGVmYXVsdCBpcyBcIiMwMDBcIi5cblx0XHQgKiBJdCB3aWxsIGFsc28gYWNjZXB0IHZhbGlkIGNhbnZhcyBmaWxsU3R5bGUgdmFsdWVzLlxuXHRcdCAqIEBwcm9wZXJ0eSBjb2xvclxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqKi9cblx0XHR0aGlzLmNvbG9yID0gY29sb3I7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBob3Jpem9udGFsIHRleHQgYWxpZ25tZW50LiBBbnkgb2YgXCJzdGFydFwiLCBcImVuZFwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBhbmQgXCJjZW50ZXJcIi4gRm9yIGRldGFpbGVkXG5cdFx0ICogaW5mb3JtYXRpb24gdmlldyB0aGVcblx0XHQgKiA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjdGV4dC1zdHlsZXNcIj5cblx0XHQgKiB3aGF0d2cgc3BlYzwvYT4uIERlZmF1bHQgaXMgXCJsZWZ0XCIuXG5cdFx0ICogQHByb3BlcnR5IHRleHRBbGlnblxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqKi9cblx0XHR0aGlzLnRleHRBbGlnbiA9IFwibGVmdFwiO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgdmVydGljYWwgYWxpZ25tZW50IHBvaW50IG9uIHRoZSBmb250LiBBbnkgb2YgXCJ0b3BcIiwgXCJoYW5naW5nXCIsIFwibWlkZGxlXCIsIFwiYWxwaGFiZXRpY1wiLCBcImlkZW9ncmFwaGljXCIsIG9yXG5cdFx0ICogXCJib3R0b21cIi4gRm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIHZpZXcgdGhlIDxhIGhyZWY9XCJodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCN0ZXh0LXN0eWxlc1wiPlxuXHRcdCAqIHdoYXR3ZyBzcGVjPC9hPi4gRGVmYXVsdCBpcyBcInRvcFwiLlxuXHRcdCAqIEBwcm9wZXJ0eSB0ZXh0QmFzZWxpbmVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQqL1xuXHRcdHRoaXMudGV4dEJhc2VsaW5lID0gXCJ0b3BcIjtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIG1heGltdW0gd2lkdGggdG8gZHJhdyB0aGUgdGV4dC4gSWYgbWF4V2lkdGggaXMgc3BlY2lmaWVkIChub3QgbnVsbCksIHRoZSB0ZXh0IHdpbGwgYmUgY29uZGVuc2VkIG9yXG5cdFx0ICogc2hydW5rIHRvIG1ha2UgaXQgZml0IGluIHRoaXMgd2lkdGguIEZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiB2aWV3IHRoZVxuXHRcdCAqIDxhIGhyZWY9XCJodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCN0ZXh0LXN0eWxlc1wiPlxuXHRcdCAqIHdoYXR3ZyBzcGVjPC9hPi5cblx0XHQgKiBAcHJvcGVydHkgbWF4V2lkdGhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQqL1xuXHRcdHRoaXMubWF4V2lkdGggPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBJZiBncmVhdGVyIHRoYW4gMCwgdGhlIHRleHQgd2lsbCBiZSBkcmF3biBhcyBhIHN0cm9rZSAob3V0bGluZSkgb2YgdGhlIHNwZWNpZmllZCB3aWR0aC5cblx0XHQgKiBAcHJvcGVydHkgb3V0bGluZVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLm91dGxpbmUgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgdGhlIGxpbmUgaGVpZ2h0ICh2ZXJ0aWNhbCBkaXN0YW5jZSBiZXR3ZWVuIGJhc2VsaW5lcykgZm9yIG11bHRpLWxpbmUgdGV4dC4gSWYgbnVsbCBvciAwLFxuXHRcdCAqIHRoZSB2YWx1ZSBvZiBnZXRNZWFzdXJlZExpbmVIZWlnaHQgaXMgdXNlZC5cblx0XHQgKiBAcHJvcGVydHkgbGluZUhlaWdodFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLmxpbmVIZWlnaHQgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgdGhlIG1heGltdW0gd2lkdGggZm9yIGEgbGluZSBvZiB0ZXh0IGJlZm9yZSBpdCBpcyB3cmFwcGVkIHRvIG11bHRpcGxlIGxpbmVzLiBJZiBudWxsLFxuXHRcdCAqIHRoZSB0ZXh0IHdpbGwgbm90IGJlIHdyYXBwZWQuXG5cdFx0ICogQHByb3BlcnR5IGxpbmVXaWR0aFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLmxpbmVXaWR0aCA9IG51bGw7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoVGV4dCwgY3JlYXRlanMuRGlzcGxheU9iamVjdCk7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblx0XG4vLyBzdGF0aWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfd29ya2luZ0NvbnRleHRcblx0ICogQHR5cGUgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXG5cdCAqIEBwcml2YXRlXG5cdCAqKi9cblx0dmFyIGNhbnZhcyA9IChjcmVhdGVqcy5jcmVhdGVDYW52YXM/Y3JlYXRlanMuY3JlYXRlQ2FudmFzKCk6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSk7XG5cdGlmIChjYW52YXMuZ2V0Q29udGV4dCkgeyBUZXh0Ll93b3JraW5nQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7IGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAxOyB9XG5cdFxuXHRcbi8vIGNvbnN0YW50czpcblx0LyoqXG5cdCAqIExvb2t1cCB0YWJsZSBmb3IgdGhlIHJhdGlvIHRvIG9mZnNldCBib3VuZHMgeCBjYWxjdWxhdGlvbnMgYmFzZWQgb24gdGhlIHRleHRBbGlnbiBwcm9wZXJ0eS5cblx0ICogQHByb3BlcnR5IEhfT0ZGU0VUU1xuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VGV4dC5IX09GRlNFVFMgPSB7c3RhcnQ6IDAsIGxlZnQ6IDAsIGNlbnRlcjogLTAuNSwgZW5kOiAtMSwgcmlnaHQ6IC0xfTtcblx0XG5cdC8qKlxuXHQgKiBMb29rdXAgdGFibGUgZm9yIHRoZSByYXRpbyB0byBvZmZzZXQgYm91bmRzIHkgY2FsY3VsYXRpb25zIGJhc2VkIG9uIHRoZSB0ZXh0QmFzZWxpbmUgcHJvcGVydHkuXG5cdCAqIEBwcm9wZXJ0eSBIX09GRlNFVFNcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRleHQuVl9PRkZTRVRTID0ge3RvcDogMCwgaGFuZ2luZzogLTAuMDEsIG1pZGRsZTogLTAuNCwgYWxwaGFiZXRpYzogLTAuOCwgaWRlb2dyYXBoaWM6IC0wLjg1LCBib3R0b206IC0xfTtcblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXMuXG5cdCAqIFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3Igd2hldGhlciBpdCB3b3VsZCBiZSB2aXNpYmxlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgc3RhZ2UuXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBpc1Zpc2libGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhc1xuXHQgKiovXG5cdHAuaXNWaXNpYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhhc0NvbnRlbnQgPSB0aGlzLmNhY2hlQ2FudmFzIHx8ICh0aGlzLnRleHQgIT0gbnVsbCAmJiB0aGlzLnRleHQgIT09IFwiXCIpO1xuXHRcdHJldHVybiAhISh0aGlzLnZpc2libGUgJiYgdGhpcy5hbHBoYSA+IDAgJiYgdGhpcy5zY2FsZVggIT0gMCAmJiB0aGlzLnNjYWxlWSAhPSAwICYmIGhhc0NvbnRlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyB0aGUgVGV4dCBpbnRvIHRoZSBzcGVjaWZpZWQgY29udGV4dCBpZ25vcmluZyBpdHMgdmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgYW5kIHRyYW5zZm9ybS5cblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBkcmF3IHdhcyBoYW5kbGVkICh1c2VmdWwgZm9yIG92ZXJyaWRpbmcgZnVuY3Rpb25hbGl0eSkuXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBkcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlQ2FjaGUgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRyYXcgb3BlcmF0aW9uIHNob3VsZCBpZ25vcmUgYW55IGN1cnJlbnQgY2FjaGUuXG5cdCAqIEZvciBleGFtcGxlLCB1c2VkIGZvciBkcmF3aW5nIHRoZSBjYWNoZSAodG8gcHJldmVudCBpdCBmcm9tIHNpbXBseSBkcmF3aW5nIGFuIGV4aXN0aW5nIGNhY2hlIGJhY2tcblx0ICogaW50byBpdHNlbGYpLlxuXHQgKiovXG5cdHAuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgaWdub3JlQ2FjaGUpIHtcblx0XHRpZiAodGhpcy5EaXNwbGF5T2JqZWN0X2RyYXcoY3R4LCBpZ25vcmVDYWNoZSkpIHsgcmV0dXJuIHRydWU7IH1cblxuXHRcdHZhciBjb2wgPSB0aGlzLmNvbG9yIHx8IFwiIzAwMFwiO1xuXHRcdGlmICh0aGlzLm91dGxpbmUpIHsgY3R4LnN0cm9rZVN0eWxlID0gY29sOyBjdHgubGluZVdpZHRoID0gdGhpcy5vdXRsaW5lKjE7IH1cblx0XHRlbHNlIHsgY3R4LmZpbGxTdHlsZSA9IGNvbDsgfVxuXHRcdFxuXHRcdHRoaXMuX2RyYXdUZXh0KHRoaXMuX3ByZXBDb250ZXh0KGN0eCkpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBtZWFzdXJlZCwgdW50cmFuc2Zvcm1lZCB3aWR0aCBvZiB0aGUgdGV4dCB3aXRob3V0IHdyYXBwaW5nLiBVc2UgZ2V0Qm91bmRzIGZvciBhIG1vcmUgcm9idXN0IHZhbHVlLlxuXHQgKiBAbWV0aG9kIGdldE1lYXN1cmVkV2lkdGhcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgbWVhc3VyZWQsIHVudHJhbnNmb3JtZWQgd2lkdGggb2YgdGhlIHRleHQuXG5cdCAqKi9cblx0cC5nZXRNZWFzdXJlZFdpZHRoID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldE1lYXN1cmVkV2lkdGgodGhpcy50ZXh0KTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBhcHByb3hpbWF0ZSBsaW5lIGhlaWdodCBvZiB0aGUgdGV4dCwgaWdub3JpbmcgdGhlIGxpbmVIZWlnaHQgcHJvcGVydHkuIFRoaXMgaXMgYmFzZWQgb24gdGhlIG1lYXN1cmVkXG5cdCAqIHdpZHRoIG9mIGEgXCJNXCIgY2hhcmFjdGVyIG11bHRpcGxpZWQgYnkgMS4yLCB3aGljaCBwcm92aWRlcyBhbiBhcHByb3hpbWF0ZSBsaW5lIGhlaWdodCBmb3IgbW9zdCBmb250cy5cblx0ICogQG1ldGhvZCBnZXRNZWFzdXJlZExpbmVIZWlnaHRcblx0ICogQHJldHVybiB7TnVtYmVyfSBhbiBhcHByb3hpbWF0ZSBsaW5lIGhlaWdodCBvZiB0aGUgdGV4dCwgaWdub3JpbmcgdGhlIGxpbmVIZWlnaHQgcHJvcGVydHkuIFRoaXMgaXNcblx0ICogYmFzZWQgb24gdGhlIG1lYXN1cmVkIHdpZHRoIG9mIGEgXCJNXCIgY2hhcmFjdGVyIG11bHRpcGxpZWQgYnkgMS4yLCB3aGljaCBhcHByb3hpbWF0ZXMgZW0gZm9yIG1vc3QgZm9udHMuXG5cdCAqKi9cblx0cC5nZXRNZWFzdXJlZExpbmVIZWlnaHQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0TWVhc3VyZWRXaWR0aChcIk1cIikqMS4yO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhcHByb3hpbWF0ZSBoZWlnaHQgb2YgbXVsdGktbGluZSB0ZXh0IGJ5IG11bHRpcGx5aW5nIHRoZSBudW1iZXIgb2YgbGluZXMgYWdhaW5zdCBlaXRoZXIgdGhlXG5cdCAqIDxjb2RlPmxpbmVIZWlnaHQ8L2NvZGU+IChpZiBzcGVjaWZpZWQpIG9yIHt7I2Nyb3NzTGluayBcIlRleHQvZ2V0TWVhc3VyZWRMaW5lSGVpZ2h0XCJ9fXt7L2Nyb3NzTGlua319LiBOb3RlIHRoYXRcblx0ICogdGhpcyBvcGVyYXRpb24gcmVxdWlyZXMgdGhlIHRleHQgZmxvd2luZyBsb2dpYyB0byBydW4sIHdoaWNoIGhhcyBhbiBhc3NvY2lhdGVkIENQVSBjb3N0LlxuXHQgKiBAbWV0aG9kIGdldE1lYXN1cmVkSGVpZ2h0XG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGFwcHJveGltYXRlIGhlaWdodCBvZiB0aGUgdW50cmFuc2Zvcm1lZCBtdWx0aS1saW5lIHRleHQuXG5cdCAqKi9cblx0cC5nZXRNZWFzdXJlZEhlaWdodCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmF3VGV4dChudWxsLHt9KS5oZWlnaHQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIERvY2NlZCBpbiBzdXBlcmNsYXNzLlxuXHQgKi9cblx0cC5nZXRCb3VuZHMgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IHRoaXMuRGlzcGxheU9iamVjdF9nZXRCb3VuZHMoKTtcblx0XHRpZiAocmVjdCkgeyByZXR1cm4gcmVjdDsgfVxuXHRcdGlmICh0aGlzLnRleHQgPT0gbnVsbCB8fCB0aGlzLnRleHQgPT09IFwiXCIpIHsgcmV0dXJuIG51bGw7IH1cblx0XHR2YXIgbyA9IHRoaXMuX2RyYXdUZXh0KG51bGwsIHt9KTtcblx0XHR2YXIgdyA9ICh0aGlzLm1heFdpZHRoICYmIHRoaXMubWF4V2lkdGggPCBvLndpZHRoKSA/IHRoaXMubWF4V2lkdGggOiBvLndpZHRoO1xuXHRcdHZhciB4ID0gdyAqIFRleHQuSF9PRkZTRVRTW3RoaXMudGV4dEFsaWdufHxcImxlZnRcIl07XG5cdFx0dmFyIGxpbmVIZWlnaHQgPSB0aGlzLmxpbmVIZWlnaHR8fHRoaXMuZ2V0TWVhc3VyZWRMaW5lSGVpZ2h0KCk7XG5cdFx0dmFyIHkgPSBsaW5lSGVpZ2h0ICogVGV4dC5WX09GRlNFVFNbdGhpcy50ZXh0QmFzZWxpbmV8fFwidG9wXCJdO1xuXHRcdHJldHVybiB0aGlzLl9yZWN0YW5nbGUuc2V0VmFsdWVzKHgsIHksIHcsIG8uaGVpZ2h0KTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHdpZHRoLCBoZWlnaHQsIGFuZCBsaW5lcyBwcm9wZXJ0aWVzLiBUaGUgd2lkdGggYW5kIGhlaWdodCBhcmUgdGhlIHZpc3VhbCB3aWR0aCBhbmQgaGVpZ2h0XG5cdCAqIG9mIHRoZSBkcmF3biB0ZXh0LiBUaGUgbGluZXMgcHJvcGVydHkgY29udGFpbnMgYW4gYXJyYXkgb2Ygc3RyaW5ncywgb25lIGZvclxuXHQgKiBlYWNoIGxpbmUgb2YgdGV4dCB0aGF0IHdpbGwgYmUgZHJhd24sIGFjY291bnRpbmcgZm9yIGxpbmUgYnJlYWtzIGFuZCB3cmFwcGluZy4gVGhlc2Ugc3RyaW5ncyBoYXZlIHRyYWlsaW5nXG5cdCAqIHdoaXRlc3BhY2UgcmVtb3ZlZC5cblx0ICogQG1ldGhvZCBnZXRNZXRyaWNzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggd2lkdGgsIGhlaWdodCwgYW5kIGxpbmVzIHByb3BlcnRpZXMuXG5cdCAqKi9cblx0cC5nZXRNZXRyaWNzID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG8gPSB7bGluZXM6W119O1xuXHRcdG8ubGluZUhlaWdodCA9IHRoaXMubGluZUhlaWdodCB8fCB0aGlzLmdldE1lYXN1cmVkTGluZUhlaWdodCgpO1xuXHRcdG8udk9mZnNldCA9IG8ubGluZUhlaWdodCAqIFRleHQuVl9PRkZTRVRTW3RoaXMudGV4dEJhc2VsaW5lfHxcInRvcFwiXTtcblx0XHRyZXR1cm4gdGhpcy5fZHJhd1RleHQobnVsbCwgbywgby5saW5lcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgVGV4dCBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtUZXh0fSBhIGNsb25lIG9mIHRoZSBUZXh0IGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmVQcm9wcyhuZXcgVGV4dCh0aGlzLnRleHQsIHRoaXMuZm9udCwgdGhpcy5jb2xvcikpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbVGV4dCAodGV4dD1cIisgICh0aGlzLnRleHQubGVuZ3RoID4gMjAgPyB0aGlzLnRleHQuc3Vic3RyKDAsIDE3KStcIi4uLlwiIDogdGhpcy50ZXh0KSArXCIpXVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX2Nsb25lUHJvcHNcblx0ICogQHBhcmFtIHtUZXh0fSBvXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7VGV4dH0gb1xuXHQgKiovXG5cdHAuX2Nsb25lUHJvcHMgPSBmdW5jdGlvbihvKSB7XG5cdFx0dGhpcy5EaXNwbGF5T2JqZWN0X19jbG9uZVByb3BzKG8pO1xuXHRcdG8udGV4dEFsaWduID0gdGhpcy50ZXh0QWxpZ247XG5cdFx0by50ZXh0QmFzZWxpbmUgPSB0aGlzLnRleHRCYXNlbGluZTtcblx0XHRvLm1heFdpZHRoID0gdGhpcy5tYXhXaWR0aDtcblx0XHRvLm91dGxpbmUgPSB0aGlzLm91dGxpbmU7XG5cdFx0by5saW5lSGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0O1xuXHRcdG8ubGluZVdpZHRoID0gdGhpcy5saW5lV2lkdGg7XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldFdvcmtpbmdDb250ZXh0XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICogQHJldHVybiB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fcHJlcENvbnRleHQgPSBmdW5jdGlvbihjdHgpIHtcblx0XHRjdHguZm9udCA9IHRoaXMuZm9udHx8XCIxMHB4IHNhbnMtc2VyaWZcIjtcblx0XHRjdHgudGV4dEFsaWduID0gdGhpcy50ZXh0QWxpZ258fFwibGVmdFwiO1xuXHRcdGN0eC50ZXh0QmFzZWxpbmUgPSB0aGlzLnRleHRCYXNlbGluZXx8XCJ0b3BcIjtcblx0XHRyZXR1cm4gY3R4O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBtdWx0aWxpbmUgdGV4dC5cblx0ICogQG1ldGhvZCBfZHJhd1RleHRcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb1xuXHQgKiBAcGFyYW0ge0FycmF5fSBsaW5lc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9kcmF3VGV4dCA9IGZ1bmN0aW9uKGN0eCwgbywgbGluZXMpIHtcblx0XHR2YXIgcGFpbnQgPSAhIWN0eDtcblx0XHRpZiAoIXBhaW50KSB7XG5cdFx0XHRjdHggPSBUZXh0Ll93b3JraW5nQ29udGV4dDtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHR0aGlzLl9wcmVwQ29udGV4dChjdHgpO1xuXHRcdH1cblx0XHR2YXIgbGluZUhlaWdodCA9IHRoaXMubGluZUhlaWdodHx8dGhpcy5nZXRNZWFzdXJlZExpbmVIZWlnaHQoKTtcblx0XHRcblx0XHR2YXIgbWF4VyA9IDAsIGNvdW50ID0gMDtcblx0XHR2YXIgaGFyZExpbmVzID0gU3RyaW5nKHRoaXMudGV4dCkuc3BsaXQoLyg/OlxcclxcbnxcXHJ8XFxuKS8pO1xuXHRcdGZvciAodmFyIGk9MCwgbD1oYXJkTGluZXMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0dmFyIHN0ciA9IGhhcmRMaW5lc1tpXTtcblx0XHRcdHZhciB3ID0gbnVsbDtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMubGluZVdpZHRoICE9IG51bGwgJiYgKHcgPSBjdHgubWVhc3VyZVRleHQoc3RyKS53aWR0aCkgPiB0aGlzLmxpbmVXaWR0aCkge1xuXHRcdFx0XHQvLyB0ZXh0IHdyYXBwaW5nOlxuXHRcdFx0XHR2YXIgd29yZHMgPSBzdHIuc3BsaXQoLyhcXHMpLyk7XG5cdFx0XHRcdHN0ciA9IHdvcmRzWzBdO1xuXHRcdFx0XHR3ID0gY3R4Lm1lYXN1cmVUZXh0KHN0cikud2lkdGg7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKHZhciBqPTEsIGpsPXdvcmRzLmxlbmd0aDsgajxqbDsgais9Mikge1xuXHRcdFx0XHRcdC8vIExpbmUgbmVlZHMgdG8gd3JhcDpcblx0XHRcdFx0XHR2YXIgd29yZFcgPSBjdHgubWVhc3VyZVRleHQod29yZHNbal0gKyB3b3Jkc1tqKzFdKS53aWR0aDtcblx0XHRcdFx0XHRpZiAodyArIHdvcmRXID4gdGhpcy5saW5lV2lkdGgpIHtcblx0XHRcdFx0XHRcdGlmIChwYWludCkgeyB0aGlzLl9kcmF3VGV4dExpbmUoY3R4LCBzdHIsIGNvdW50KmxpbmVIZWlnaHQpOyB9XG5cdFx0XHRcdFx0XHRpZiAobGluZXMpIHsgbGluZXMucHVzaChzdHIpOyB9XG5cdFx0XHRcdFx0XHRpZiAodyA+IG1heFcpIHsgbWF4VyA9IHc7IH1cblx0XHRcdFx0XHRcdHN0ciA9IHdvcmRzW2orMV07XG5cdFx0XHRcdFx0XHR3ID0gY3R4Lm1lYXN1cmVUZXh0KHN0cikud2lkdGg7XG5cdFx0XHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdHIgKz0gd29yZHNbal0gKyB3b3Jkc1tqKzFdO1xuXHRcdFx0XHRcdFx0dyArPSB3b3JkVztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKHBhaW50KSB7IHRoaXMuX2RyYXdUZXh0TGluZShjdHgsIHN0ciwgY291bnQqbGluZUhlaWdodCk7IH1cblx0XHRcdGlmIChsaW5lcykgeyBsaW5lcy5wdXNoKHN0cik7IH1cblx0XHRcdGlmIChvICYmIHcgPT0gbnVsbCkgeyB3ID0gY3R4Lm1lYXN1cmVUZXh0KHN0cikud2lkdGg7IH1cblx0XHRcdGlmICh3ID4gbWF4VykgeyBtYXhXID0gdzsgfVxuXHRcdFx0Y291bnQrKztcblx0XHR9XG5cdFx0XG5cdFx0aWYgKG8pIHtcblx0XHRcdG8ud2lkdGggPSBtYXhXO1xuXHRcdFx0by5oZWlnaHQgPSBjb3VudCpsaW5lSGVpZ2h0O1xuXHRcdH1cblx0XHRpZiAoIXBhaW50KSB7IGN0eC5yZXN0b3JlKCk7IH1cblx0XHRyZXR1cm4gbztcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfZHJhd1RleHRMaW5lXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2RyYXdUZXh0TGluZSA9IGZ1bmN0aW9uKGN0eCwgdGV4dCwgeSkge1xuXHRcdC8vIENocm9tZSAxNyB3aWxsIGZhaWwgdG8gZHJhdyB0aGUgdGV4dCBpZiB0aGUgbGFzdCBwYXJhbSBpcyBpbmNsdWRlZCBidXQgbnVsbCwgc28gd2UgZmVlZCBpdCBhIGxhcmdlIHZhbHVlIGluc3RlYWQ6XG5cdFx0aWYgKHRoaXMub3V0bGluZSkgeyBjdHguc3Ryb2tlVGV4dCh0ZXh0LCAwLCB5LCB0aGlzLm1heFdpZHRofHwweEZGRkYpOyB9XG5cdFx0ZWxzZSB7IGN0eC5maWxsVGV4dCh0ZXh0LCAwLCB5LCB0aGlzLm1heFdpZHRofHwweEZGRkYpOyB9XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldE1lYXN1cmVkV2lkdGhcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHRcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dldE1lYXN1cmVkV2lkdGggPSBmdW5jdGlvbih0ZXh0KSB7XG5cdFx0dmFyIGN0eCA9IFRleHQuX3dvcmtpbmdDb250ZXh0O1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0dmFyIHcgPSB0aGlzLl9wcmVwQ29udGV4dChjdHgpLm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0cmV0dXJuIHc7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5UZXh0ID0gY3JlYXRlanMucHJvbW90ZShUZXh0LCBcIkRpc3BsYXlPYmplY3RcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQml0bWFwVGV4dC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBEaXNwbGF5cyB0ZXh0IHVzaW5nIGJpdG1hcCBnbHlwaHMgZGVmaW5lZCBpbiBhIHNwcml0ZSBzaGVldC4gTXVsdGktbGluZSB0ZXh0IGlzIHN1cHBvcnRlZFxuXHQgKiB1c2luZyBuZXcgbGluZSBjaGFyYWN0ZXJzLCBidXQgYXV0b21hdGljIHdyYXBwaW5nIGlzIG5vdCBzdXBwb3J0ZWQuIFNlZSB0aGUgXG5cdCAqIHt7I2Nyb3NzTGluayBcIkJpdG1hcFRleHQvc3ByaXRlU2hlZXQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogcHJvcGVydHkgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gZGVmaW5pbmcgZ2x5cGhzLlxuXHQgKiBcblx0ICogPHN0cm9uZz5JbXBvcnRhbnQ6PC9zdHJvbmc+IEJpdG1hcFRleHQgZXh0ZW5kcyBDb250YWluZXIsIGJ1dCBpcyBub3QgZGVzaWduZWQgdG8gYmUgdXNlZCBhcyBvbmUuXG5cdCAqIEFzIHN1Y2gsIG1ldGhvZHMgbGlrZSBhZGRDaGlsZCBhbmQgcmVtb3ZlQ2hpbGQgYXJlIGRpc2FibGVkLlxuXHQgKiBAY2xhc3MgQml0bWFwVGV4dFxuXHQgKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbdGV4dD1cIlwiXSBUaGUgdGV4dCB0byBkaXNwbGF5LlxuXHQgKiBAcGFyYW0ge1Nwcml0ZVNoZWV0fSBbc3ByaXRlU2hlZXQ9bnVsbF0gVGhlIHNwcml0ZXNoZWV0IHRoYXQgZGVmaW5lcyB0aGUgY2hhcmFjdGVyIGdseXBocy5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gQml0bWFwVGV4dCh0ZXh0LCBzcHJpdGVTaGVldCkge1xuXHRcdHRoaXMuQ29udGFpbmVyX2NvbnN0cnVjdG9yKCk7XG5cdFx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0ZXh0IHRvIGRpc3BsYXkuXG5cdFx0ICogQHByb3BlcnR5IHRleHRcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiBAZGVmYXVsdCBcIlwiXG5cdFx0ICoqL1xuXHRcdHRoaXMudGV4dCA9IHRleHR8fFwiXCI7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQSBTcHJpdGVTaGVldCBpbnN0YW5jZSB0aGF0IGRlZmluZXMgdGhlIGdseXBocyBmb3IgdGhpcyBiaXRtYXAgdGV4dC4gRWFjaCBnbHlwaC9jaGFyYWN0ZXJcblx0XHQgKiBzaG91bGQgaGF2ZSBhIHNpbmdsZSBmcmFtZSBhbmltYXRpb24gZGVmaW5lZCBpbiB0aGUgc3ByaXRlIHNoZWV0IG5hbWVkIHRoZSBzYW1lIGFzXG5cdFx0ICogY29ycmVzcG9uZGluZyBjaGFyYWN0ZXIuIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nIGFuaW1hdGlvbiBkZWZpbml0aW9uOlxuXHRcdCAqXG5cdFx0ICogXHRcdFwiQVwiOiB7ZnJhbWVzOiBbMF19XG5cdFx0ICpcblx0XHQgKiB3b3VsZCBpbmRpY2F0ZSB0aGF0IHRoZSBmcmFtZSBhdCBpbmRleCAwIG9mIHRoZSBzcHJpdGVzaGVldCBzaG91bGQgYmUgZHJhd24gZm9yIHRoZSBcIkFcIiBjaGFyYWN0ZXIuIFRoZSBzaG9ydCBmb3JtXG5cdFx0ICogaXMgYWxzbyBhY2NlcHRhYmxlOlxuXHRcdCAqIFxuXHRcdCAqIFx0XHRcIkFcIjogMFxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0IGlmIGEgY2hhcmFjdGVyIGluIHRoZSB0ZXh0IGlzIG5vdCBmb3VuZCBpbiB0aGUgc3ByaXRlIHNoZWV0LCBpdCB3aWxsIGFsc29cblx0XHQgKiB0cnkgdG8gdXNlIHRoZSBhbHRlcm5hdGUgY2FzZSAodXBwZXIgb3IgbG93ZXIpLlxuXHRcdCAqXG5cdFx0ICogU2VlIFNwcml0ZVNoZWV0IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGRlZmluaW5nIHNwcml0ZSBzaGVldCBkYXRhLlxuXHRcdCAqIEBwcm9wZXJ0eSBzcHJpdGVTaGVldFxuXHRcdCAqIEB0eXBlIFNwcml0ZVNoZWV0XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqKi9cblx0XHR0aGlzLnNwcml0ZVNoZWV0ID0gc3ByaXRlU2hlZXQ7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBoZWlnaHQgb2YgZWFjaCBsaW5lIG9mIHRleHQuIElmIDAsIHRoZW4gaXQgd2lsbCB1c2UgYSBsaW5lIGhlaWdodCBjYWxjdWxhdGVkXG5cdFx0ICogYnkgY2hlY2tpbmcgZm9yIHRoZSBoZWlnaHQgb2YgdGhlIFwiMVwiLCBcIlRcIiwgb3IgXCJMXCIgY2hhcmFjdGVyIChpbiB0aGF0IG9yZGVyKS4gSWZcblx0XHQgKiB0aG9zZSBjaGFyYWN0ZXJzIGFyZSBub3QgZGVmaW5lZCwgaXQgd2lsbCB1c2UgdGhlIGhlaWdodCBvZiB0aGUgZmlyc3QgZnJhbWUgb2YgdGhlXG5cdFx0ICogc3ByaXRlIHNoZWV0LlxuXHRcdCAqIEBwcm9wZXJ0eSBsaW5lSGVpZ2h0XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLmxpbmVIZWlnaHQgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIHNwYWNpbmcgKGluIHBpeGVscykgd2lsbCBiZSBhZGRlZCBhZnRlciBlYWNoIGNoYXJhY3RlciBpbiB0aGUgb3V0cHV0LlxuXHRcdCAqIEBwcm9wZXJ0eSBsZXR0ZXJTcGFjaW5nXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLmxldHRlclNwYWNpbmcgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBJZiBhIHNwYWNlIGNoYXJhY3RlciBpcyBub3QgZGVmaW5lZCBpbiB0aGUgc3ByaXRlIHNoZWV0LCB0aGVuIGVtcHR5IHBpeGVscyBlcXVhbCB0b1xuXHRcdCAqIHNwYWNlV2lkdGggd2lsbCBiZSBpbnNlcnRlZCBpbnN0ZWFkLiBJZiAwLCB0aGVuIGl0IHdpbGwgdXNlIGEgdmFsdWUgY2FsY3VsYXRlZFxuXHRcdCAqIGJ5IGNoZWNraW5nIGZvciB0aGUgd2lkdGggb2YgdGhlIFwiMVwiLCBcImxcIiwgXCJFXCIsIG9yIFwiQVwiIGNoYXJhY3RlciAoaW4gdGhhdCBvcmRlcikuIElmXG5cdFx0ICogdGhvc2UgY2hhcmFjdGVycyBhcmUgbm90IGRlZmluZWQsIGl0IHdpbGwgdXNlIHRoZSB3aWR0aCBvZiB0aGUgZmlyc3QgZnJhbWUgb2YgdGhlXG5cdFx0ICogc3ByaXRlIHNoZWV0LlxuXHRcdCAqIEBwcm9wZXJ0eSBzcGFjZVdpZHRoXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLnNwYWNlV2lkdGggPSAwO1xuXHRcdFxuXHRcdFxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdCBcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfb2xkUHJvcHNcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX29sZFByb3BzID0ge3RleHQ6MCxzcHJpdGVTaGVldDowLGxpbmVIZWlnaHQ6MCxsZXR0ZXJTcGFjaW5nOjAsc3BhY2VXaWR0aDowfTtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChCaXRtYXBUZXh0LCBjcmVhdGVqcy5Db250YWluZXIpO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuLy8gc3RhdGljIHByb3BlcnRpZXM6XG5cdC8qKlxuXHQgKiBCaXRtYXBUZXh0IHVzZXMgU3ByaXRlIGluc3RhbmNlcyB0byBkcmF3IHRleHQuIFRvIHJlZHVjZSB0aGUgY3JlYXRpb24gYW5kIGRlc3RydWN0aW9uIG9mIGluc3RhbmNlcyAoYW5kIHRodXMgZ2FyYmFnZSBjb2xsZWN0aW9uKSwgaXQgbWFpbnRhaW5zXG5cdCAqIGFuIGludGVybmFsIG9iamVjdCBwb29sIG9mIHNwcml0ZSBpbnN0YW5jZXMgdG8gcmV1c2UuIEluY3JlYXNpbmcgdGhpcyB2YWx1ZSBjYW4gY2F1c2UgbW9yZSBzcHJpdGVzIHRvIGJlXG5cdCAqIHJldGFpbmVkLCBzbGlnaHRseSBpbmNyZWFzaW5nIG1lbW9yeSB1c2UsIGJ1dCByZWR1Y2luZyBpbnN0YW50aWF0aW9uLlxuXHQgKiBAcHJvcGVydHkgbWF4UG9vbFNpemVcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqIEBzdGF0aWNcblx0ICogQGRlZmF1bHQgMTAwXG5cdCAqKi9cblx0Qml0bWFwVGV4dC5tYXhQb29sU2l6ZSA9IDEwMDtcblx0XG5cdC8qKlxuXHQgKiBTcHJpdGUgb2JqZWN0IHBvb2wuXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQHN0YXRpY1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Qml0bWFwVGV4dC5fc3ByaXRlUG9vbCA9IFtdO1xuXG5cdFxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBEb2NjZWQgaW4gc3VwZXJjbGFzcy5cblx0ICoqL1xuXHRwLmRyYXcgPSBmdW5jdGlvbihjdHgsIGlnbm9yZUNhY2hlKSB7XG5cdFx0aWYgKHRoaXMuRGlzcGxheU9iamVjdF9kcmF3KGN0eCwgaWdub3JlQ2FjaGUpKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuX3VwZGF0ZVRleHQoKTtcblx0XHR0aGlzLkNvbnRhaW5lcl9kcmF3KGN0eCwgaWdub3JlQ2FjaGUpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIERvY2NlZCBpbiBzdXBlcmNsYXNzLlxuXHQgKiovXG5cdHAuZ2V0Qm91bmRzID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fdXBkYXRlVGV4dCgpO1xuXHRcdHJldHVybiB0aGlzLkNvbnRhaW5lcl9nZXRCb3VuZHMoKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxuXHQgKiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHdoZXRoZXIgaXQgd291bGQgYmUgdmlzaWJsZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHN0YWdlLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzXG5cdCAqKi9cblx0cC5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGFzQ29udGVudCA9IHRoaXMuY2FjaGVDYW52YXMgfHwgKHRoaXMuc3ByaXRlU2hlZXQgJiYgdGhpcy5zcHJpdGVTaGVldC5jb21wbGV0ZSAmJiB0aGlzLnRleHQpO1xuXHRcdHJldHVybiAhISh0aGlzLnZpc2libGUgJiYgdGhpcy5hbHBoYSA+IDAgJiYgdGhpcy5zY2FsZVggIT09IDAgJiYgdGhpcy5zY2FsZVkgIT09IDAgJiYgaGFzQ29udGVudCk7XG5cdH07XG5cdFxuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lUHJvcHMobmV3IEJpdG1hcFRleHQodGhpcy50ZXh0LCB0aGlzLnNwcml0ZVNoZWV0KSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogPHN0cm9uZz5EaXNhYmxlZCBpbiBCaXRtYXBUZXh0Ljwvc3Ryb25nPlxuXHQgKiBAbWV0aG9kIGFkZENoaWxkXG5cdCAqKi9cblx0LyoqXG5cdCAqIDxzdHJvbmc+RGlzYWJsZWQgaW4gQml0bWFwVGV4dC48L3N0cm9uZz5cblx0ICogQG1ldGhvZCBhZGRDaGlsZEF0XG5cdCAqKi9cblx0LyoqXG5cdCAqIDxzdHJvbmc+RGlzYWJsZWQgaW4gQml0bWFwVGV4dC48L3N0cm9uZz5cblx0ICogQG1ldGhvZCByZW1vdmVDaGlsZFxuXHQgKiovXG5cdC8qKlxuXHQgKiA8c3Ryb25nPkRpc2FibGVkIGluIEJpdG1hcFRleHQuPC9zdHJvbmc+XG5cdCAqIEBtZXRob2QgcmVtb3ZlQ2hpbGRBdFxuXHQgKiovXG5cdC8qKlxuXHQgKiA8c3Ryb25nPkRpc2FibGVkIGluIEJpdG1hcFRleHQuPC9zdHJvbmc+XG5cdCAqIEBtZXRob2QgcmVtb3ZlQWxsQ2hpbGRyZW5cblx0ICoqL1xuXHRwLmFkZENoaWxkID0gcC5hZGRDaGlsZEF0ID0gcC5yZW1vdmVDaGlsZCA9IHAucmVtb3ZlQ2hpbGRBdCA9IHAucmVtb3ZlQWxsQ2hpbGRyZW4gPSBmdW5jdGlvbigpIHt9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcbiBcdC8qKlxuXHQgKiBAbWV0aG9kIF9jbG9uZVByb3BzXG5cdCAqIEBwYXJhbSB7Qml0bWFwVGV4dH0gb1xuXHQgKiBAcmV0dXJuIHtCaXRtYXBUZXh0fSBvXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9jbG9uZVByb3BzID0gZnVuY3Rpb24obykge1xuXHRcdHRoaXMuQ29udGFpbmVyX19jbG9uZVByb3BzKG8pO1xuXHRcdG8ubGluZUhlaWdodCA9IHRoaXMubGluZUhlaWdodDtcblx0XHRvLmxldHRlclNwYWNpbmcgPSB0aGlzLmxldHRlclNwYWNpbmc7XG5cdFx0by5zcGFjZVdpZHRoID0gdGhpcy5zcGFjZVdpZHRoO1xuXHRcdHJldHVybiBvO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldEZyYW1lSW5kZXhcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNoYXJhY3RlclxuXHQgKiBAcGFyYW0ge1Nwcml0ZVNoZWV0fSBzcHJpdGVTaGVldFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9nZXRGcmFtZUluZGV4ID0gZnVuY3Rpb24oY2hhcmFjdGVyLCBzcHJpdGVTaGVldCkge1xuXHRcdHZhciBjLCBvID0gc3ByaXRlU2hlZXQuZ2V0QW5pbWF0aW9uKGNoYXJhY3Rlcik7XG5cdFx0aWYgKCFvKSB7XG5cdFx0XHQoY2hhcmFjdGVyICE9IChjID0gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCkpKSB8fCAoY2hhcmFjdGVyICE9IChjID0gY2hhcmFjdGVyLnRvTG93ZXJDYXNlKCkpKSB8fCAoYz1udWxsKTtcblx0XHRcdGlmIChjKSB7IG8gPSBzcHJpdGVTaGVldC5nZXRBbmltYXRpb24oYyk7IH1cblx0XHR9XG5cdFx0cmV0dXJuIG8gJiYgby5mcmFtZXNbMF07XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0RnJhbWVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNoYXJhY3RlclxuXHQgKiBAcGFyYW0ge1Nwcml0ZVNoZWV0fSBzcHJpdGVTaGVldFxuXHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9nZXRGcmFtZSA9IGZ1bmN0aW9uKGNoYXJhY3Rlciwgc3ByaXRlU2hlZXQpIHtcblx0XHR2YXIgaW5kZXggPSB0aGlzLl9nZXRGcmFtZUluZGV4KGNoYXJhY3Rlciwgc3ByaXRlU2hlZXQpO1xuXHRcdHJldHVybiBpbmRleCA9PSBudWxsID8gaW5kZXggOiBzcHJpdGVTaGVldC5nZXRGcmFtZShpbmRleCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0TGluZUhlaWdodFxuXHQgKiBAcGFyYW0ge1Nwcml0ZVNoZWV0fSBzc1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9nZXRMaW5lSGVpZ2h0ID0gZnVuY3Rpb24oc3MpIHtcblx0XHR2YXIgZnJhbWUgPSB0aGlzLl9nZXRGcmFtZShcIjFcIixzcykgfHwgdGhpcy5fZ2V0RnJhbWUoXCJUXCIsc3MpIHx8IHRoaXMuX2dldEZyYW1lKFwiTFwiLHNzKSB8fCBzcy5nZXRGcmFtZSgwKTtcblx0XHRyZXR1cm4gZnJhbWUgPyBmcmFtZS5yZWN0LmhlaWdodCA6IDE7XG5cdH07XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRTcGFjZVdpZHRoXG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IHNzXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dldFNwYWNlV2lkdGggPSBmdW5jdGlvbihzcykge1xuXHRcdHZhciBmcmFtZSA9IHRoaXMuX2dldEZyYW1lKFwiMVwiLHNzKSB8fCB0aGlzLl9nZXRGcmFtZShcImxcIixzcykgfHwgdGhpcy5fZ2V0RnJhbWUoXCJlXCIsc3MpIHx8IHRoaXMuX2dldEZyYW1lKFwiYVwiLHNzKSB8fCBzcy5nZXRGcmFtZSgwKTtcblx0XHRyZXR1cm4gZnJhbWUgPyBmcmFtZS5yZWN0LndpZHRoIDogMTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9kcmF3VGV4dFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fdXBkYXRlVGV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB4PTAsIHk9MCwgbz10aGlzLl9vbGRQcm9wcywgY2hhbmdlPWZhbHNlLCBzcGFjZVc9dGhpcy5zcGFjZVdpZHRoLCBsaW5lSD10aGlzLmxpbmVIZWlnaHQsIHNzPXRoaXMuc3ByaXRlU2hlZXQ7XG5cdFx0dmFyIHBvb2w9Qml0bWFwVGV4dC5fc3ByaXRlUG9vbCwga2lkcz10aGlzLmNoaWxkcmVuLCBjaGlsZEluZGV4PTAsIG51bUtpZHM9a2lkcy5sZW5ndGgsIHNwcml0ZTtcblx0XHRcblx0XHRmb3IgKHZhciBuIGluIG8pIHtcblx0XHRcdGlmIChvW25dICE9IHRoaXNbbl0pIHtcblx0XHRcdFx0b1tuXSA9IHRoaXNbbl07XG5cdFx0XHRcdGNoYW5nZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghY2hhbmdlKSB7IHJldHVybjsgfVxuXHRcdFxuXHRcdHZhciBoYXNTcGFjZSA9ICEhdGhpcy5fZ2V0RnJhbWUoXCIgXCIsIHNzKTtcblx0XHRpZiAoIWhhc1NwYWNlICYmICFzcGFjZVcpIHsgc3BhY2VXID0gdGhpcy5fZ2V0U3BhY2VXaWR0aChzcyk7IH1cblx0XHRpZiAoIWxpbmVIKSB7IGxpbmVIID0gdGhpcy5fZ2V0TGluZUhlaWdodChzcyk7IH1cblx0XHRcblx0XHRmb3IodmFyIGk9MCwgbD10aGlzLnRleHQubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0dmFyIGNoYXJhY3RlciA9IHRoaXMudGV4dC5jaGFyQXQoaSk7XG5cdFx0XHRpZiAoY2hhcmFjdGVyID09IFwiIFwiICYmICFoYXNTcGFjZSkge1xuXHRcdFx0XHR4ICs9IHNwYWNlVztcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9IGVsc2UgaWYgKGNoYXJhY3Rlcj09XCJcXG5cIiB8fCBjaGFyYWN0ZXI9PVwiXFxyXCIpIHtcblx0XHRcdFx0aWYgKGNoYXJhY3Rlcj09XCJcXHJcIiAmJiB0aGlzLnRleHQuY2hhckF0KGkrMSkgPT0gXCJcXG5cIikgeyBpKys7IH0gLy8gY3JsZlxuXHRcdFx0XHR4ID0gMDtcblx0XHRcdFx0eSArPSBsaW5lSDtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBpbmRleCA9IHRoaXMuX2dldEZyYW1lSW5kZXgoY2hhcmFjdGVyLCBzcyk7XG5cdFx0XHRpZiAoaW5kZXggPT0gbnVsbCkgeyBjb250aW51ZTsgfVxuXHRcdFx0XG5cdFx0XHRpZiAoY2hpbGRJbmRleCA8IG51bUtpZHMpIHtcblx0XHRcdFx0c3ByaXRlID0ga2lkc1tjaGlsZEluZGV4XTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtpZHMucHVzaChzcHJpdGUgPSBwb29sLmxlbmd0aCA/IHBvb2wucG9wKCkgOiBuZXcgY3JlYXRlanMuU3ByaXRlKCkpO1xuXHRcdFx0XHRzcHJpdGUucGFyZW50ID0gdGhpcztcblx0XHRcdFx0bnVtS2lkcysrO1xuXHRcdFx0fVxuXHRcdFx0c3ByaXRlLnNwcml0ZVNoZWV0ID0gc3M7XG5cdFx0XHRzcHJpdGUuZ290b0FuZFN0b3AoaW5kZXgpO1xuXHRcdFx0c3ByaXRlLnggPSB4O1xuXHRcdFx0c3ByaXRlLnkgPSB5O1xuXHRcdFx0Y2hpbGRJbmRleCsrO1xuXHRcdFx0XG5cdFx0XHR4ICs9IHNwcml0ZS5nZXRCb3VuZHMoKS53aWR0aCArIHRoaXMubGV0dGVyU3BhY2luZztcblx0XHR9XG5cdFx0d2hpbGUgKG51bUtpZHMgPiBjaGlsZEluZGV4KSB7XG5cdFx0XHQgLy8gZmFzdGVyIHRoYW4gcmVtb3ZlQ2hpbGQuXG5cdFx0XHRwb29sLnB1c2goc3ByaXRlID0ga2lkcy5wb3AoKSk7XG5cdFx0XHRzcHJpdGUucGFyZW50ID0gbnVsbDtcblx0XHRcdG51bUtpZHMtLTtcblx0XHR9XG5cdFx0aWYgKHBvb2wubGVuZ3RoID4gQml0bWFwVGV4dC5tYXhQb29sU2l6ZSkgeyBwb29sLmxlbmd0aCA9IEJpdG1hcFRleHQubWF4UG9vbFNpemU7IH1cblx0fTtcblxuXG5cdGNyZWF0ZWpzLkJpdG1hcFRleHQgPSBjcmVhdGVqcy5wcm9tb3RlKEJpdG1hcFRleHQsIFwiQ29udGFpbmVyXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIE1vdmllQ2xpcC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFRoZSBNb3ZpZUNsaXAgY2xhc3MgYXNzb2NpYXRlcyBhIFR3ZWVuSlMgVGltZWxpbmUgd2l0aCBhbiBFYXNlbEpTIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lclwifX17ey9jcm9zc0xpbmt9fS4gSXQgYWxsb3dzXG5cdCAqIHlvdSB0byBjcmVhdGUgb2JqZWN0cyB3aGljaCBlbmNhcHN1bGF0ZSB0aW1lbGluZSBhbmltYXRpb25zLCBzdGF0ZSBjaGFuZ2VzLCBhbmQgc3luY2hlZCBhY3Rpb25zLiBEdWUgdG8gdGhlXG5cdCAqIGNvbXBsZXhpdGllcyBpbmhlcmVudCBpbiBjb3JyZWN0bHkgc2V0dGluZyB1cCBhIE1vdmllQ2xpcCwgaXQgaXMgbGFyZ2VseSBpbnRlbmRlZCBmb3IgdG9vbCBvdXRwdXQgYW5kIGlzIG5vdCBpbmNsdWRlZFxuXHQgKiBpbiB0aGUgbWFpbiBFYXNlbEpTIGxpYnJhcnkuXG5cdCAqXG5cdCAqIEN1cnJlbnRseSBNb3ZpZUNsaXAgb25seSB3b3JrcyBwcm9wZXJseSBpZiBpdCBpcyB0aWNrIGJhc2VkIChhcyBvcHBvc2VkIHRvIHRpbWUgYmFzZWQpIHRob3VnaCBzb21lIGNvbmNlc3Npb25zIGhhdmVcblx0ICogYmVlbiBtYWRlIHRvIHN1cHBvcnQgdGltZS1iYXNlZCB0aW1lbGluZXMgaW4gdGhlIGZ1dHVyZS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBUaGlzIGV4YW1wbGUgYW5pbWF0ZXMgdHdvIHNoYXBlcyBiYWNrIGFuZCBmb3J0aC4gVGhlIGdyZXkgc2hhcGUgc3RhcnRzIG9uIHRoZSBsZWZ0LCBidXQgd2UganVtcCB0byBhIG1pZC1wb2ludCBpblxuXHQgKiB0aGUgYW5pbWF0aW9uIHVzaW5nIHt7I2Nyb3NzTGluayBcIk1vdmllQ2xpcC9nb3RvQW5kUGxheVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogICAgICB2YXIgc3RhZ2UgPSBuZXcgY3JlYXRlanMuU3RhZ2UoXCJjYW52YXNcIik7XG5cdCAqICAgICAgY3JlYXRlanMuVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIHN0YWdlKTtcblx0ICpcblx0ICogICAgICB2YXIgbWMgPSBuZXcgY3JlYXRlanMuTW92aWVDbGlwKG51bGwsIDAsIHRydWUsIHtzdGFydDoyMH0pO1xuXHQgKiAgICAgIHN0YWdlLmFkZENoaWxkKG1jKTtcblx0ICpcblx0ICogICAgICB2YXIgY2hpbGQxID0gbmV3IGNyZWF0ZWpzLlNoYXBlKFxuXHQgKiAgICAgICAgICBuZXcgY3JlYXRlanMuR3JhcGhpY3MoKS5iZWdpbkZpbGwoXCIjOTk5OTk5XCIpXG5cdCAqICAgICAgICAgICAgICAuZHJhd0NpcmNsZSgzMCwzMCwzMCkpO1xuXHQgKiAgICAgIHZhciBjaGlsZDIgPSBuZXcgY3JlYXRlanMuU2hhcGUoXG5cdCAqICAgICAgICAgIG5ldyBjcmVhdGVqcy5HcmFwaGljcygpLmJlZ2luRmlsbChcIiM1YTljZmJcIilcblx0ICogICAgICAgICAgICAgIC5kcmF3Q2lyY2xlKDMwLDMwLDMwKSk7XG5cdCAqXG5cdCAqICAgICAgbWMudGltZWxpbmUuYWRkVHdlZW4oXG5cdCAqICAgICAgICAgIGNyZWF0ZWpzLlR3ZWVuLmdldChjaGlsZDEpXG5cdCAqICAgICAgICAgICAgICAudG8oe3g6MH0pLnRvKHt4OjYwfSwgNTApLnRvKHt4OjB9LCA1MCkpO1xuXHQgKiAgICAgIG1jLnRpbWVsaW5lLmFkZFR3ZWVuKFxuXHQgKiAgICAgICAgICBjcmVhdGVqcy5Ud2Vlbi5nZXQoY2hpbGQyKVxuXHQgKiAgICAgICAgICAgICAgLnRvKHt4OjYwfSkudG8oe3g6MH0sIDUwKS50byh7eDo2MH0sIDUwKSk7XG5cdCAqXG5cdCAqICAgICAgbWMuZ290b0FuZFBsYXkoXCJzdGFydFwiKTtcblx0ICpcblx0ICogSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIDxjb2RlPnR3ZWVuLnRvKCk8L2NvZGU+IHRvIGFuaW1hdGUgYW5kIHNldCBwcm9wZXJ0aWVzICh1c2Ugbm8gZHVyYXRpb24gdG8gaGF2ZSBpdCBzZXRcblx0ICogaW1tZWRpYXRlbHkpLCBhbmQgdGhlIDxjb2RlPnR3ZWVuLndhaXQoKTwvY29kZT4gbWV0aG9kIHRvIGNyZWF0ZSBkZWxheXMgYmV0d2VlbiBhbmltYXRpb25zLiBOb3RlIHRoYXQgdXNpbmcgdGhlXG5cdCAqIDxjb2RlPnR3ZWVuLnNldCgpPC9jb2RlPiBtZXRob2QgdG8gYWZmZWN0IHByb3BlcnRpZXMgd2lsbCBsaWtlbHkgbm90IHByb3ZpZGUgdGhlIGRlc2lyZWQgcmVzdWx0LlxuXHQgKlxuXHQgKiBAY2xhc3MgTW92aWVDbGlwXG5cdCAqIEBtYWluIE1vdmllQ2xpcFxuXHQgKiBAZXh0ZW5kcyBDb250YWluZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbbW9kZT1pbmRlcGVuZGVudF0gSW5pdGlhbCB2YWx1ZSBmb3IgdGhlIG1vZGUgcHJvcGVydHkuIE9uZSBvZiB7eyNjcm9zc0xpbmsgXCJNb3ZpZUNsaXAvSU5ERVBFTkRFTlQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIHt7I2Nyb3NzTGluayBcIk1vdmllQ2xpcC9TSU5HTEVfRlJBTUU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0sIG9yIHt7I2Nyb3NzTGluayBcIk1vdmllQ2xpcC9TWU5DSEVEOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBUaGUgZGVmYXVsdCBpcyB7eyNjcm9zc0xpbmsgXCJNb3ZpZUNsaXAvSU5ERVBFTkRFTlQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRQb3NpdGlvbj0wXSBJbml0aWFsIHZhbHVlIGZvciB0aGUge3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwL3N0YXJ0UG9zaXRpb246cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogcHJvcGVydHkuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2xvb3A9dHJ1ZV0gSW5pdGlhbCB2YWx1ZSBmb3IgdGhlIHt7I2Nyb3NzTGluayBcIk1vdmllQ2xpcC9sb29wOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHByb3BlcnR5LiBUaGUgZGVmYXVsdCBpcyBgdHJ1ZWAuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbbGFiZWxzPW51bGxdIEEgaGFzaCBvZiBsYWJlbHMgdG8gcGFzcyB0byB0aGUge3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwL3RpbWVsaW5lOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIE1vdmllQ2xpcC4gTGFiZWxzIG9ubHkgbmVlZCB0byBiZSBwYXNzZWQgaWYgdGhleSBuZWVkIHRvIGJlIHVzZWQuXG5cdCAqKi9cblx0ZnVuY3Rpb24gTW92aWVDbGlwKG1vZGUsIHN0YXJ0UG9zaXRpb24sIGxvb3AsIGxhYmVscykge1xuXHRcdHRoaXMuQ29udGFpbmVyX2NvbnN0cnVjdG9yKCk7XG5cdFx0IU1vdmllQ2xpcC5pbml0ZWQmJk1vdmllQ2xpcC5pbml0KCk7IC8vIHN0YXRpYyBpbml0XG5cdFx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIENvbnRyb2xzIGhvdyB0aGlzIE1vdmllQ2xpcCBhZHZhbmNlcyBpdHMgdGltZS4gTXVzdCBiZSBvbmUgb2YgMCAoSU5ERVBFTkRFTlQpLCAxIChTSU5HTEVfRlJBTUUpLCBvciAyIChTWU5DSEVEKS5cblx0XHQgKiBTZWUgZWFjaCBjb25zdGFudCBmb3IgYSBkZXNjcmlwdGlvbiBvZiB0aGUgYmVoYXZpb3VyLlxuXHRcdCAqIEBwcm9wZXJ0eSBtb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqKi9cblx0XHR0aGlzLm1vZGUgPSBtb2RlfHxNb3ZpZUNsaXAuSU5ERVBFTkRFTlQ7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNwZWNpZmllcyB3aGF0IHRoZSBmaXJzdCBmcmFtZSB0byBwbGF5IGluIHRoaXMgbW92aWVjbGlwLCBvciB0aGUgb25seSBmcmFtZSB0byBkaXNwbGF5IGlmIG1vZGUgaXMgU0lOR0xFX0ZSQU1FLlxuXHRcdCAqIEBwcm9wZXJ0eSBzdGFydFBvc2l0aW9uXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb24gfHwgMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBNb3ZpZUNsaXAgc2hvdWxkIGxvb3Agd2hlbiBpdCByZWFjaGVzIHRoZSBlbmQgb2YgaXRzIHRpbWVsaW5lLlxuXHRcdCAqIEBwcm9wZXJ0eSBsb29wXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmxvb3AgPSBsb29wO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY3VycmVudCBmcmFtZSBvZiB0aGUgbW92aWVjbGlwLlxuXHRcdCAqIEBwcm9wZXJ0eSBjdXJyZW50RnJhbWVcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5jdXJyZW50RnJhbWUgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgVHdlZW5KUyBUaW1lbGluZSB0aGF0IGlzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIE1vdmllQ2xpcC4gVGhpcyBpcyBjcmVhdGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgTW92aWVDbGlwXG5cdFx0ICogaW5zdGFuY2UgaXMgaW5pdGlhbGl6ZWQuIEFuaW1hdGlvbnMgYXJlIGNyZWF0ZWQgYnkgYWRkaW5nIDxhIGhyZWY9XCJodHRwOi8vdHdlZW5qcy5jb21cIj5Ud2VlbkpTPC9hPiBUd2VlblxuXHRcdCAqIGluc3RhbmNlcyB0byB0aGUgdGltZWxpbmUuXG5cdFx0ICpcblx0XHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdFx0ICpcblx0XHQgKiAgICAgIHZhciB0d2VlbiA9IGNyZWF0ZWpzLlR3ZWVuLmdldCh0YXJnZXQpLnRvKHt4OjB9KS50byh7eDoxMDB9LCAzMCk7XG5cdFx0ICogICAgICB2YXIgbWMgPSBuZXcgY3JlYXRlanMuTW92aWVDbGlwKCk7XG5cdFx0ICogICAgICBtYy50aW1lbGluZS5hZGRUd2Vlbih0d2Vlbik7XG5cdFx0ICpcblx0XHQgKiBFbGVtZW50cyBjYW4gYmUgYWRkZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgdGltZWxpbmUgYnkgdG9nZ2xpbmcgYW4gXCJfb2ZmXCIgcHJvcGVydHlcblx0XHQgKiB1c2luZyB0aGUgPGNvZGU+dHdlZW5JbnN0YW5jZS50bygpPC9jb2RlPiBtZXRob2QuIE5vdGUgdGhhdCB1c2luZyA8Y29kZT5Ud2Vlbi5zZXQ8L2NvZGU+IGlzIG5vdCByZWNvbW1lbmRlZCB0b1xuXHRcdCAqIGNyZWF0ZSBNb3ZpZUNsaXAgYW5pbWF0aW9ucy4gVGhlIGZvbGxvd2luZyBleGFtcGxlIHdpbGwgdG9nZ2xlIHRoZSB0YXJnZXQgb2ZmIG9uIGZyYW1lIDAsIGFuZCB0aGVuIGJhY2sgb24gZm9yXG5cdFx0ICogZnJhbWUgMS4gWW91IGNhbiB1c2UgdGhlIFwidmlzaWJsZVwiIHByb3BlcnR5IHRvIGFjaGlldmUgdGhlIHNhbWUgZWZmZWN0LlxuXHRcdCAqXG5cdFx0ICogICAgICB2YXIgdHdlZW4gPSBjcmVhdGVqcy5Ud2Vlbi5nZXQodGFyZ2V0KS50byh7X29mZjpmYWxzZX0pXG5cdFx0ICogICAgICAgICAgLndhaXQoMSkudG8oe19vZmY6dHJ1ZX0pXG5cdFx0ICogICAgICAgICAgLndhaXQoMSkudG8oe19vZmY6ZmFsc2V9KTtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSB0aW1lbGluZVxuXHRcdCAqIEB0eXBlIFRpbWVsaW5lXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMudGltZWxpbmUgPSBuZXcgY3JlYXRlanMuVGltZWxpbmUobnVsbCwgbGFiZWxzLCB7cGF1c2VkOnRydWUsIHBvc2l0aW9uOnN0YXJ0UG9zaXRpb24sIHVzZVRpY2tzOnRydWV9KTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgdHJ1ZSwgdGhlIE1vdmllQ2xpcCdzIHBvc2l0aW9uIHdpbGwgbm90IGFkdmFuY2Ugd2hlbiB0aWNrZWQuXG5cdFx0ICogQHByb3BlcnR5IHBhdXNlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMucGF1c2VkID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIHRydWUsIGFjdGlvbnMgaW4gdGhpcyBNb3ZpZUNsaXAncyB0d2VlbnMgd2lsbCBiZSBydW4gd2hlbiB0aGUgcGxheWhlYWQgYWR2YW5jZXMuXG5cdFx0ICogQHByb3BlcnR5IGFjdGlvbnNFbmFibGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmFjdGlvbnNFbmFibGVkID0gdHJ1ZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgdHJ1ZSwgdGhlIE1vdmllQ2xpcCB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgcmVzZXQgdG8gaXRzIGZpcnN0IGZyYW1lIHdoZW5ldmVyIHRoZSB0aW1lbGluZSBhZGRzXG5cdFx0ICogaXQgYmFjayBvbnRvIHRoZSBkaXNwbGF5IGxpc3QuIFRoaXMgb25seSBhcHBsaWVzIHRvIE1vdmllQ2xpcCBpbnN0YW5jZXMgd2l0aCBtb2RlPUlOREVQRU5ERU5ULlxuXHRcdCAqIDxicj48YnI+XG5cdFx0ICogRm9yIGV4YW1wbGUsIGlmIHlvdSBoYWQgYSBjaGFyYWN0ZXIgYW5pbWF0aW9uIHdpdGggYSBcImJvZHlcIiBjaGlsZCBNb3ZpZUNsaXAgaW5zdGFuY2Vcblx0XHQgKiB3aXRoIGRpZmZlcmVudCBjb3N0dW1lcyBvbiBlYWNoIGZyYW1lLCB5b3UgY291bGQgc2V0IGJvZHkuYXV0b1Jlc2V0ID0gZmFsc2UsIHNvIHRoYXRcblx0XHQgKiB5b3UgY2FuIG1hbnVhbGx5IGNoYW5nZSB0aGUgZnJhbWUgaXQgaXMgb24sIHdpdGhvdXQgd29ycnlpbmcgdGhhdCBpdCB3aWxsIGJlIHJlc2V0XG5cdFx0ICogYXV0b21hdGljYWxseS5cblx0XHQgKiBAcHJvcGVydHkgYXV0b1Jlc2V0XG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmF1dG9SZXNldCA9IHRydWU7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgb2YgYm91bmRzIGZvciBlYWNoIGZyYW1lIGluIHRoZSBNb3ZpZUNsaXAuIFRoaXMgaXMgbWFpbmx5IGludGVuZGVkIGZvciB0b29sIG91dHB1dC5cblx0XHQgKiBAcHJvcGVydHkgZnJhbWVCb3VuZHNcblx0XHQgKiBAdHlwZSBBcnJheVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmZyYW1lQm91bmRzID0gdGhpcy5mcmFtZUJvdW5kc3x8bnVsbDsgLy8gVE9ETzogRGVwcmVjYXRlZC4gVGhpcyBpcyBmb3IgYmFja3dhcmRzIHN1cHBvcnQgb2YgRmxhc2hDQ1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEJ5IGRlZmF1bHQgTW92aWVDbGlwIGluc3RhbmNlcyBhZHZhbmNlIG9uZSBmcmFtZSBwZXIgdGljay4gU3BlY2lmeWluZyBhIGZyYW1lcmF0ZSBmb3IgdGhlIE1vdmllQ2xpcFxuXHRcdCAqIHdpbGwgY2F1c2UgaXQgdG8gYWR2YW5jZSBiYXNlZCBvbiBlbGFwc2VkIHRpbWUgYmV0d2VlbiB0aWNrcyBhcyBhcHByb3ByaWF0ZSB0byBtYWludGFpbiB0aGUgdGFyZ2V0XG5cdFx0ICogZnJhbWVyYXRlLlxuXHRcdCAqXG5cdFx0ICogRm9yIGV4YW1wbGUsIGlmIGEgTW92aWVDbGlwIHdpdGggYSBmcmFtZXJhdGUgb2YgMTAgaXMgcGxhY2VkIG9uIGEgU3RhZ2UgYmVpbmcgdXBkYXRlZCBhdCA0MGZwcywgdGhlbiB0aGUgTW92aWVDbGlwIHdpbGxcblx0XHQgKiBhZHZhbmNlIHJvdWdobHkgb25lIGZyYW1lIGV2ZXJ5IDQgdGlja3MuIFRoaXMgd2lsbCBub3QgYmUgZXhhY3QsIGJlY2F1c2UgdGhlIHRpbWUgYmV0d2VlbiBlYWNoIHRpY2sgd2lsbFxuXHRcdCAqIHZhcnkgc2xpZ2h0bHkgYmV0d2VlbiBmcmFtZXMuXG5cdFx0ICpcblx0XHQgKiBUaGlzIGZlYXR1cmUgaXMgZGVwZW5kZW50IG9uIHRoZSB0aWNrIGV2ZW50IG9iamVjdCAob3IgYW4gb2JqZWN0IHdpdGggYW4gYXBwcm9wcmlhdGUgXCJkZWx0YVwiIHByb3BlcnR5KSBiZWluZ1xuXHRcdCAqIHBhc3NlZCBpbnRvIHt7I2Nyb3NzTGluayBcIlN0YWdlL3VwZGF0ZVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgZnJhbWVyYXRlXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMuZnJhbWVyYXRlID0gbnVsbDtcblx0XHRcblx0XHRcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfc3luY2hPZmZzZXRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9zeW5jaE9mZnNldCA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfcHJldlBvc1xuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IC0xXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9wcmV2UG9zID0gLTE7IC8vIFRPRE86IGV2YWx1YXRlIHVzaW5nIGEgLl9yZXNldCBCb29sZWFuIHByb3AgaW5zdGVhZCBvZiAtMS5cblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9wcmV2UG9zaXRpb25cblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9wcmV2UG9zaXRpb24gPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgdGltZSByZW1haW5pbmcgZnJvbSB0aGUgcHJldmlvdXMgdGljaywgb25seSBhcHBsaWNhYmxlIHdoZW4gLmZyYW1lcmF0ZSBpcyBzZXQuXG5cdFx0ICogQHByb3BlcnR5IF90XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl90ID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogTGlzdCBvZiBkaXNwbGF5IG9iamVjdHMgdGhhdCBhcmUgYWN0aXZlbHkgYmVpbmcgbWFuYWdlZCBieSB0aGUgTW92aWVDbGlwLlxuXHRcdCAqIEBwcm9wZXJ0eSBfbWFuYWdlZFxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbWFuYWdlZCA9IHt9O1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKE1vdmllQ2xpcCwgY3JlYXRlanMuQ29udGFpbmVyKTtcblxuXG4vLyBjb25zdGFudHM6XG5cdC8qKlxuXHQgKiBUaGUgTW92aWVDbGlwIHdpbGwgYWR2YW5jZSBpbmRlcGVuZGVudGx5IG9mIGl0cyBwYXJlbnQsIGV2ZW4gaWYgaXRzIHBhcmVudCBpcyBwYXVzZWQuXG5cdCAqIFRoaXMgaXMgdGhlIGRlZmF1bHQgbW9kZS5cblx0ICogQHByb3BlcnR5IElOREVQRU5ERU5UXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqIEBkZWZhdWx0IFwiaW5kZXBlbmRlbnRcIlxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHRNb3ZpZUNsaXAuSU5ERVBFTkRFTlQgPSBcImluZGVwZW5kZW50XCI7XG5cblx0LyoqXG5cdCAqIFRoZSBNb3ZpZUNsaXAgd2lsbCBvbmx5IGRpc3BsYXkgYSBzaW5nbGUgZnJhbWUgKGFzIGRldGVybWluZWQgYnkgdGhlIHN0YXJ0UG9zaXRpb24gcHJvcGVydHkpLlxuXHQgKiBAcHJvcGVydHkgU0lOR0xFX0ZSQU1FXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqIEBkZWZhdWx0IFwic2luZ2xlXCJcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0TW92aWVDbGlwLlNJTkdMRV9GUkFNRSA9IFwic2luZ2xlXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBNb3ZpZUNsaXAgd2lsbCBiZSBhZHZhbmNlZCBvbmx5IHdoZW4gaXRzIHBhcmVudCBhZHZhbmNlcyBhbmQgd2lsbCBiZSBzeW5jaGVkIHRvIHRoZSBwb3NpdGlvbiBvZlxuXHQgKiB0aGUgcGFyZW50IE1vdmllQ2xpcC5cblx0ICogQHByb3BlcnR5IFNZTkNIRURcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICogQGRlZmF1bHQgXCJzeW5jaGVkXCJcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0TW92aWVDbGlwLlNZTkNIRUQgPSBcInN5bmNoZWRcIjtcblx0XG5cdFxuLy8gc3RhdGljIHByb3BlcnRpZXM6XG5cdE1vdmllQ2xpcC5pbml0ZWQgPSBmYWxzZTtcblx0XG5cdFxuLy8gc3RhdGljIG1ldGhvZHM6XG5cdE1vdmllQ2xpcC5pbml0ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKE1vdmllQ2xpcC5pbml0ZWQpIHsgcmV0dXJuOyB9XG5cdFx0Ly8gcGx1Z2lucyBpbnRyb2R1Y2Ugc29tZSBvdmVyaGVhZCB0byBUd2Vlbiwgc28gd2Ugb25seSBpbnN0YWxsIHRoaXMgaWYgYW4gTUMgaXMgaW5zdGFudGlhdGVkLlxuXHRcdE1vdmllQ2xpcFBsdWdpbi5pbnN0YWxsKCk7XG5cdFx0TW92aWVDbGlwLmluaXRlZCA9IHRydWU7XG5cdH07XG5cdFxuXHRcbi8vIGdldHRlciAvIHNldHRlcnM6XG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIk1vdmllQ2xpcC9sYWJlbHM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXRMYWJlbHNcblx0ICogQHJldHVybiB7QXJyYXl9XG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0cC5nZXRMYWJlbHMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50aW1lbGluZS5nZXRMYWJlbHMoKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIk1vdmllQ2xpcC9jdXJyZW50TGFiZWw6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXRDdXJyZW50TGFiZWxcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdHAuZ2V0Q3VycmVudExhYmVsID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fdXBkYXRlVGltZWxpbmUoKTtcblx0XHRyZXR1cm4gdGhpcy50aW1lbGluZS5nZXRDdXJyZW50TGFiZWwoKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIk1vdmllQ2xpcC9kdXJhdGlvbjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldER1cmF0aW9uXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuZ2V0RHVyYXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50aW1lbGluZS5kdXJhdGlvbjtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggbGFiZWwgYW5kIHBvc2l0aW9uIChha2EgZnJhbWUpIHByb3BlcnRpZXMsIHNvcnRlZCBieSBwb3NpdGlvbi5cblx0ICogU2hvcnRjdXQgdG8gVHdlZW5KUzogVGltZWxpbmUuZ2V0TGFiZWxzKCk7XG5cdCAqIEBwcm9wZXJ0eSBsYWJlbHNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGxhYmVsIG9uIG9yIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY3VycmVudCBmcmFtZS4gU2VlIFR3ZWVuSlM6IFRpbWVsaW5lLmdldEN1cnJlbnRMYWJlbCgpXG5cdCAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAcHJvcGVydHkgY3VycmVudExhYmVsXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZHVyYXRpb24gb2YgdGhpcyBNb3ZpZUNsaXAgaW4gc2Vjb25kcyBvciB0aWNrcy4gSWRlbnRpY2FsIHRvIHt7I2Nyb3NzTGluayBcIk1vdmllQ2xpcC9kdXJhdGlvbjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBhbmQgcHJvdmlkZWQgZm9yIEZsYXNoIEFQSSBjb21wYXRpYmlsaXR5LlxuXHQgKiBAcHJvcGVydHkgdG90YWxGcmFtZXNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkdXJhdGlvbiBvZiB0aGlzIE1vdmllQ2xpcCBpbiBzZWNvbmRzIG9yIHRpY2tzLlxuXHQgKiBAcHJvcGVydHkgZHVyYXRpb25cblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cdFx0XHRsYWJlbHM6IHsgZ2V0OiBwLmdldExhYmVscyB9LFxuXHRcdFx0Y3VycmVudExhYmVsOiB7IGdldDogcC5nZXRDdXJyZW50TGFiZWwgfSxcblx0XHRcdHRvdGFsRnJhbWVzOiB7IGdldDogcC5nZXREdXJhdGlvbiB9LFxuXHRcdFx0ZHVyYXRpb246IHsgZ2V0OiBwLmdldER1cmF0aW9uIH1cblx0XHR9KTtcblx0fSBjYXRjaCAoZSkge31cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIENvbnN0cnVjdG9yIGFsaWFzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gVGhpcyBtZXRob2Qgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSB2ZXJzaW9ucy5cblx0ICogU3ViY2xhc3NlcyBzaG91bGQgYmUgdXBkYXRlZCB0byB1c2Uge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZHNcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAZGVwcmVjYXRlZCBpbiBmYXZvdXIgb2YgYGNyZWF0ZWpzLnByb21vdGUoKWBcblx0ICoqL1xuXHRwLmluaXRpYWxpemUgPSBNb3ZpZUNsaXA7IC8vIFRPRE86IERlcHJlY2F0ZWQuIFRoaXMgaXMgZm9yIGJhY2t3YXJkcyBzdXBwb3J0IG9mIEZsYXNoQ0NcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhcy5cblx0ICogVGhpcyBkb2VzIG5vdCBhY2NvdW50IGZvciB3aGV0aGVyIGl0IHdvdWxkIGJlIHZpc2libGUgd2l0aGluIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBzdGFnZS5cblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGlzVmlzaWJsZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhc1xuXHQgKiovXG5cdHAuaXNWaXNpYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gY2hpbGRyZW4gYXJlIHBsYWNlZCBpbiBkcmF3LCBzbyB3ZSBjYW4ndCBkZXRlcm1pbmUgaWYgd2UgaGF2ZSBjb250ZW50LlxuXHRcdHJldHVybiAhISh0aGlzLnZpc2libGUgJiYgdGhpcy5hbHBoYSA+IDAgJiYgdGhpcy5zY2FsZVggIT0gMCAmJiB0aGlzLnNjYWxlWSAhPSAwKTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgdGhlIGRpc3BsYXkgb2JqZWN0IGludG8gdGhlIHNwZWNpZmllZCBjb250ZXh0IGlnbm9yaW5nIGl0cyB2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBhbmQgdHJhbnNmb3JtLlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRyYXcgd2FzIGhhbmRsZWQgKHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyBmdW5jdGlvbmFsaXR5KS5cblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGRyYXdcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIGNvbnRleHQgb2JqZWN0IHRvIGRyYXcgaW50by5cblx0ICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVDYWNoZSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZHJhdyBvcGVyYXRpb24gc2hvdWxkIGlnbm9yZSBhbnkgY3VycmVudCBjYWNoZS5cblx0ICogRm9yIGV4YW1wbGUsIHVzZWQgZm9yIGRyYXdpbmcgdGhlIGNhY2hlICh0byBwcmV2ZW50IGl0IGZyb20gc2ltcGx5IGRyYXdpbmcgYW4gZXhpc3RpbmcgY2FjaGUgYmFja1xuXHQgKiBpbnRvIGl0c2VsZikuXG5cdCAqKi9cblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBpZ25vcmVDYWNoZSkge1xuXHRcdC8vIGRyYXcgdG8gY2FjaGUgZmlyc3Q6XG5cdFx0aWYgKHRoaXMuRGlzcGxheU9iamVjdF9kcmF3KGN0eCwgaWdub3JlQ2FjaGUpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0dGhpcy5fdXBkYXRlVGltZWxpbmUoKTtcblx0XHR0aGlzLkNvbnRhaW5lcl9kcmF3KGN0eCwgaWdub3JlQ2FjaGUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFNldHMgcGF1c2VkIHRvIGZhbHNlLlxuXHQgKiBAbWV0aG9kIHBsYXlcblx0ICoqL1xuXHRwLnBsYXkgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnBhdXNlZCA9IGZhbHNlO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFNldHMgcGF1c2VkIHRvIHRydWUuXG5cdCAqIEBtZXRob2Qgc3RvcFxuXHQgKiovXG5cdHAuc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucGF1c2VkID0gdHJ1ZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBBZHZhbmNlcyB0aGlzIG1vdmllIGNsaXAgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbiBvciBsYWJlbCBhbmQgc2V0cyBwYXVzZWQgdG8gZmFsc2UuXG5cdCAqIEBtZXRob2QgZ290b0FuZFBsYXlcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBwb3NpdGlvbk9yTGFiZWwgVGhlIGFuaW1hdGlvbiBuYW1lIG9yIGZyYW1lIG51bWJlciB0byBnbyB0by5cblx0ICoqL1xuXHRwLmdvdG9BbmRQbGF5ID0gZnVuY3Rpb24ocG9zaXRpb25PckxhYmVsKSB7XG5cdFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9nb3RvKHBvc2l0aW9uT3JMYWJlbCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQWR2YW5jZXMgdGhpcyBtb3ZpZSBjbGlwIHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gb3IgbGFiZWwgYW5kIHNldHMgcGF1c2VkIHRvIHRydWUuXG5cdCAqIEBtZXRob2QgZ290b0FuZFN0b3Bcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBwb3NpdGlvbk9yTGFiZWwgVGhlIGFuaW1hdGlvbiBvciBmcmFtZSBuYW1lIHRvIGdvIHRvLlxuXHQgKiovXG5cdHAuZ290b0FuZFN0b3AgPSBmdW5jdGlvbihwb3NpdGlvbk9yTGFiZWwpIHtcblx0XHR0aGlzLnBhdXNlZCA9IHRydWU7XG5cdFx0dGhpcy5fZ290byhwb3NpdGlvbk9yTGFiZWwpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoZSBwbGF5aGVhZC4gVGhpcyBvY2N1cnMgYXV0b21hdGljYWxseSBlYWNoIHRpY2sgYnkgZGVmYXVsdC5cblx0ICogQHBhcmFtIFt0aW1lXSB7TnVtYmVyfSBUaGUgYW1vdW50IG9mIHRpbWUgaW4gbXMgdG8gYWR2YW5jZSBieS4gT25seSBhcHBsaWNhYmxlIGlmIGZyYW1lcmF0ZSBpcyBzZXQuXG5cdCAqIEBtZXRob2QgYWR2YW5jZVxuXHQqL1xuXHRwLmFkdmFuY2UgPSBmdW5jdGlvbih0aW1lKSB7XG5cdFx0Ly8gVE9ETzogc2hvdWxkIHdlIHdvcnJ5IGF0IGFsbCBhYm91dCBjbGlwcyB3aG8gY2hhbmdlIHRoZWlyIG93biBtb2RlcyB2aWEgZnJhbWUgc2NyaXB0cz9cblx0XHR2YXIgaW5kZXBlbmRlbnQgPSBNb3ZpZUNsaXAuSU5ERVBFTkRFTlQ7XG5cdFx0aWYgKHRoaXMubW9kZSAhPSBpbmRlcGVuZGVudCkgeyByZXR1cm47IH1cblx0XHRcblx0XHR2YXIgbz10aGlzLCBmcHMgPSBvLmZyYW1lcmF0ZTtcblx0XHR3aGlsZSAoKG8gPSBvLnBhcmVudCkgJiYgZnBzID09IG51bGwpIHtcblx0XHRcdGlmIChvLm1vZGUgPT0gaW5kZXBlbmRlbnQpIHsgZnBzID0gby5fZnJhbWVyYXRlOyB9XG5cdFx0fVxuXHRcdHRoaXMuX2ZyYW1lcmF0ZSA9IGZwcztcblx0XHRcblx0XHR2YXIgdCA9IChmcHMgIT0gbnVsbCAmJiBmcHMgIT0gLTEgJiYgdGltZSAhPSBudWxsKSA/IHRpbWUvKDEwMDAvZnBzKSArIHRoaXMuX3QgOiAxO1xuXHRcdHZhciBmcmFtZXMgPSB0fDA7XG5cdFx0dGhpcy5fdCA9IHQtZnJhbWVzOyAvLyBsZWZ0b3ZlciB0aW1lXG5cdFx0XG5cdFx0d2hpbGUgKCF0aGlzLnBhdXNlZCAmJiBmcmFtZXMtLSkge1xuXHRcdFx0dGhpcy5fcHJldlBvc2l0aW9uID0gKHRoaXMuX3ByZXZQb3MgPCAwKSA/IDAgOiB0aGlzLl9wcmV2UG9zaXRpb24rMTtcblx0XHRcdHRoaXMuX3VwZGF0ZVRpbWVsaW5lKCk7XG5cdFx0fVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIE1vdmllQ2xpcCBpbnN0YW5jZXMgY2Fubm90IGJlIGNsb25lZC5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHQvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgdGhpcz8gTmVlZCB0byBjbG9uZSB0aGUgVGltZWxpbmUgJiByZXRhcmdldCB0d2VlbnMgLSBwcmV0dHkgY29tcGxleC5cblx0XHR0aHJvdyhcIk1vdmllQ2xpcCBjYW5ub3QgYmUgY2xvbmVkLlwiKVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltNb3ZpZUNsaXAgKG5hbWU9XCIrICB0aGlzLm5hbWUgK1wiKV1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF90aWNrXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldnRPYmogQW4gZXZlbnQgb2JqZWN0IHRoYXQgd2lsbCBiZSBkaXNwYXRjaGVkIHRvIGFsbCB0aWNrIGxpc3RlbmVycy4gVGhpcyBvYmplY3QgaXMgcmV1c2VkIGJldHdlZW4gZGlzcGF0Y2hlcnMgdG8gcmVkdWNlIGNvbnN0cnVjdGlvbiAmIEdDIGNvc3RzLlxuXHQgKiBmdW5jdGlvbi5cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3RpY2sgPSBmdW5jdGlvbihldnRPYmopIHtcblx0XHR0aGlzLmFkdmFuY2UoZXZ0T2JqJiZldnRPYmouZGVsdGEpO1xuXHRcdHRoaXMuQ29udGFpbmVyX190aWNrKGV2dE9iaik7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfZ290b1xuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHBvc2l0aW9uT3JMYWJlbCBUaGUgYW5pbWF0aW9uIG5hbWUgb3IgZnJhbWUgbnVtYmVyIHRvIGdvIHRvLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ290byA9IGZ1bmN0aW9uKHBvc2l0aW9uT3JMYWJlbCkge1xuXHRcdHZhciBwb3MgPSB0aGlzLnRpbWVsaW5lLnJlc29sdmUocG9zaXRpb25PckxhYmVsKTtcblx0XHRpZiAocG9zID09IG51bGwpIHsgcmV0dXJuOyB9XG5cdFx0Ly8gcHJldmVudCBfdXBkYXRlVGltZWxpbmUgZnJvbSBvdmVyd3JpdGluZyB0aGUgbmV3IHBvc2l0aW9uIGJlY2F1c2Ugb2YgYSByZXNldDpcblx0XHRpZiAodGhpcy5fcHJldlBvcyA9PSAtMSkgeyB0aGlzLl9wcmV2UG9zID0gTmFOOyB9XG5cdFx0dGhpcy5fcHJldlBvc2l0aW9uID0gcG9zO1xuXHRcdHRoaXMuX3QgPSAwO1xuXHRcdHRoaXMuX3VwZGF0ZVRpbWVsaW5lKCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfcmVzZXRcblx0ICogQHByaXZhdGVcblx0ICoqL1xuXHRwLl9yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3ByZXZQb3MgPSAtMTtcblx0XHR0aGlzLl90ID0gdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xuXHRcdHRoaXMucGF1c2VkID0gZmFsc2U7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfdXBkYXRlVGltZWxpbmVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3VwZGF0ZVRpbWVsaW5lID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRsID0gdGhpcy50aW1lbGluZTtcblx0XHR2YXIgc3luY2hlZCA9IHRoaXMubW9kZSAhPSBNb3ZpZUNsaXAuSU5ERVBFTkRFTlQ7XG5cdFx0dGwubG9vcCA9ICh0aGlzLmxvb3A9PW51bGwpID8gdHJ1ZSA6IHRoaXMubG9vcDtcblx0XHRcblx0XHR2YXIgcG9zID0gc3luY2hlZCA/IHRoaXMuc3RhcnRQb3NpdGlvbiArICh0aGlzLm1vZGU9PU1vdmllQ2xpcC5TSU5HTEVfRlJBTUU/MDp0aGlzLl9zeW5jaE9mZnNldCkgOiAodGhpcy5fcHJldlBvcyA8IDAgPyAwIDogdGhpcy5fcHJldlBvc2l0aW9uKTtcblx0XHR2YXIgbW9kZSA9IHN5bmNoZWQgfHwgIXRoaXMuYWN0aW9uc0VuYWJsZWQgPyBjcmVhdGVqcy5Ud2Vlbi5OT05FIDogbnVsbDtcblx0XHRcblx0XHQvLyBwcmUtYXNzaWduIGN1cnJlbnRGcmFtZSBzbyBpdCBpcyBhdmFpbGFibGUgdG8gZnJhbWUgc2NyaXB0czpcblx0XHR0aGlzLmN1cnJlbnRGcmFtZSA9IHRsLl9jYWxjUG9zaXRpb24ocG9zKTtcblx0XHRcblx0XHQvLyB1cGRhdGUgdGltZWxpbmUgcG9zaXRpb24sIGlnbm9yaW5nIGFjdGlvbnMgaWYgdGhpcyBpcyBhIGdyYXBoaWMuXG5cdFx0dGwuc2V0UG9zaXRpb24ocG9zLCBtb2RlKTtcblxuXHRcdHRoaXMuX3ByZXZQb3NpdGlvbiA9IHRsLl9wcmV2UG9zaXRpb247XG5cdFx0aWYgKHRoaXMuX3ByZXZQb3MgPT0gdGwuX3ByZXZQb3MpIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5jdXJyZW50RnJhbWUgPSB0aGlzLl9wcmV2UG9zID0gdGwuX3ByZXZQb3M7XG5cblx0XHRmb3IgKHZhciBuIGluIHRoaXMuX21hbmFnZWQpIHsgdGhpcy5fbWFuYWdlZFtuXSA9IDE7IH1cblxuXHRcdHZhciB0d2VlbnMgPSB0bC5fdHdlZW5zO1xuXHRcdGZvciAodmFyIGk9MCwgbD10d2VlbnMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0dmFyIHR3ZWVuID0gdHdlZW5zW2ldO1xuXHRcdFx0dmFyIHRhcmdldCA9IHR3ZWVuLl90YXJnZXQ7XG5cdFx0XHRpZiAodGFyZ2V0ID09IHRoaXMgfHwgdHdlZW4ucGFzc2l2ZSkgeyBjb250aW51ZTsgfSAvLyBUT0RPOiB0aGlzIGFzc3VtZXMgYWN0aW9ucyB0d2VlbiBoYXMgdGhpcyBhcyB0aGUgdGFyZ2V0LiBWYWxpZD9cblx0XHRcdHZhciBvZmZzZXQgPSB0d2Vlbi5fc3RlcFBvc2l0aW9uO1xuXG5cdFx0XHRpZiAodGFyZ2V0IGluc3RhbmNlb2YgY3JlYXRlanMuRGlzcGxheU9iamVjdCkge1xuXHRcdFx0XHQvLyBtb3Rpb24gdHdlZW4uXG5cdFx0XHRcdHRoaXMuX2FkZE1hbmFnZWRDaGlsZCh0YXJnZXQsIG9mZnNldCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBzdGF0ZSB0d2Vlbi5cblx0XHRcdFx0dGhpcy5fc2V0U3RhdGUodGFyZ2V0LnN0YXRlLCBvZmZzZXQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBraWRzID0gdGhpcy5jaGlsZHJlbjtcblx0XHRmb3IgKGk9a2lkcy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG5cdFx0XHR2YXIgaWQgPSBraWRzW2ldLmlkO1xuXHRcdFx0aWYgKHRoaXMuX21hbmFnZWRbaWRdID09IDEpIHtcblx0XHRcdFx0dGhpcy5yZW1vdmVDaGlsZEF0KGkpO1xuXHRcdFx0XHRkZWxldGUodGhpcy5fbWFuYWdlZFtpZF0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfc2V0U3RhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gc3RhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fc2V0U3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgb2Zmc2V0KSB7XG5cdFx0aWYgKCFzdGF0ZSkgeyByZXR1cm47IH1cblx0XHRmb3IgKHZhciBpPXN0YXRlLmxlbmd0aC0xO2k+PTA7aS0tKSB7XG5cdFx0XHR2YXIgbyA9IHN0YXRlW2ldO1xuXHRcdFx0dmFyIHRhcmdldCA9IG8udDtcblx0XHRcdHZhciBwcm9wcyA9IG8ucDtcblx0XHRcdGZvciAodmFyIG4gaW4gcHJvcHMpIHsgdGFyZ2V0W25dID0gcHJvcHNbbl07IH1cblx0XHRcdHRoaXMuX2FkZE1hbmFnZWRDaGlsZCh0YXJnZXQsIG9mZnNldCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGRzIGEgY2hpbGQgdG8gdGhlIHRpbWVsaW5lLCBhbmQgc2V0cyBpdCB1cCBhcyBhIG1hbmFnZWQgY2hpbGQuXG5cdCAqIEBtZXRob2QgX2FkZE1hbmFnZWRDaGlsZFxuXHQgKiBAcGFyYW0ge01vdmllQ2xpcH0gY2hpbGQgVGhlIGNoaWxkIE1vdmllQ2xpcCB0byBtYW5hZ2Vcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiovXG5cdHAuX2FkZE1hbmFnZWRDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkLCBvZmZzZXQpIHtcblx0XHRpZiAoY2hpbGQuX29mZikgeyByZXR1cm47IH1cblx0XHR0aGlzLmFkZENoaWxkQXQoY2hpbGQsMCk7XG5cblx0XHRpZiAoY2hpbGQgaW5zdGFuY2VvZiBNb3ZpZUNsaXApIHtcblx0XHRcdGNoaWxkLl9zeW5jaE9mZnNldCA9IG9mZnNldDtcblx0XHRcdC8vIFRPRE86IHRoaXMgZG9lcyBub3QgcHJlY2lzZWx5IG1hdGNoIEZsYXNoLiBGbGFzaCBsb3NlcyB0cmFjayBvZiB0aGUgY2xpcCBpZiBpdCBpcyByZW5hbWVkIG9yIHJlbW92ZWQgZnJvbSB0aGUgdGltZWxpbmUsIHdoaWNoIGNhdXNlcyBpdCB0byByZXNldC5cblx0XHRcdGlmIChjaGlsZC5tb2RlID09IE1vdmllQ2xpcC5JTkRFUEVOREVOVCAmJiBjaGlsZC5hdXRvUmVzZXQgJiYgIXRoaXMuX21hbmFnZWRbY2hpbGQuaWRdKSB7IGNoaWxkLl9yZXNldCgpOyB9XG5cdFx0fVxuXHRcdHRoaXMuX21hbmFnZWRbY2hpbGQuaWRdID0gMjtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRCb3VuZHNcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlVHJhbnNmb3JtXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dldEJvdW5kcyA9IGZ1bmN0aW9uKG1hdHJpeCwgaWdub3JlVHJhbnNmb3JtKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuRGlzcGxheU9iamVjdF9nZXRCb3VuZHMoKTtcblx0XHRpZiAoIWJvdW5kcykge1xuXHRcdFx0dGhpcy5fdXBkYXRlVGltZWxpbmUoKTtcblx0XHRcdGlmICh0aGlzLmZyYW1lQm91bmRzKSB7IGJvdW5kcyA9IHRoaXMuX3JlY3RhbmdsZS5jb3B5KHRoaXMuZnJhbWVCb3VuZHNbdGhpcy5jdXJyZW50RnJhbWVdKTsgfVxuXHRcdH1cblx0XHRpZiAoYm91bmRzKSB7IHJldHVybiB0aGlzLl90cmFuc2Zvcm1Cb3VuZHMoYm91bmRzLCBtYXRyaXgsIGlnbm9yZVRyYW5zZm9ybSk7IH1cblx0XHRyZXR1cm4gdGhpcy5Db250YWluZXJfX2dldEJvdW5kcyhtYXRyaXgsIGlnbm9yZVRyYW5zZm9ybSk7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5Nb3ZpZUNsaXAgPSBjcmVhdGVqcy5wcm9tb3RlKE1vdmllQ2xpcCwgXCJDb250YWluZXJcIik7XG5cblxuXG4vLyBNb3ZpZUNsaXBQbHVnaW4gZm9yIFR3ZWVuSlM6XG5cdC8qKlxuXHQgKiBUaGlzIHBsdWdpbiB3b3JrcyB3aXRoIDxhIGhyZWY9XCJodHRwOi8vdHdlZW5qcy5jb21cIiB0YXJnZXQ9XCJfYmxhbmtcIj5Ud2VlbkpTPC9hPiB0byBwcmV2ZW50IHRoZSBzdGFydFBvc2l0aW9uXG5cdCAqIHByb3BlcnR5IGZyb20gdHdlZW5pbmcuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBjbGFzcyBNb3ZpZUNsaXBQbHVnaW5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gTW92aWVDbGlwUGx1Z2luKCkge1xuXHRcdHRocm93KFwiTW92aWVDbGlwUGx1Z2luIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWQuXCIpXG5cdH1cblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIHByaW9yaXR5XG5cdCAqIEBwcml2YXRlXG5cdCAqKi9cblx0TW92aWVDbGlwUGx1Z2luLnByaW9yaXR5ID0gMTAwOyAvLyB2ZXJ5IGhpZ2ggcHJpb3JpdHksIHNob3VsZCBydW4gZmlyc3RcblxuXHQvKipcblx0ICogQG1ldGhvZCBpbnN0YWxsXG5cdCAqIEBwcml2YXRlXG5cdCAqKi9cblx0TW92aWVDbGlwUGx1Z2luLmluc3RhbGwgPSBmdW5jdGlvbigpIHtcblx0XHRjcmVhdGVqcy5Ud2Vlbi5pbnN0YWxsUGx1Z2luKE1vdmllQ2xpcFBsdWdpbiwgW1wic3RhcnRQb3NpdGlvblwiXSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBpbml0XG5cdCAqIEBwYXJhbSB7VHdlZW59IHR3ZWVuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxCb29sZWFufSB2YWx1ZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiovXG5cdE1vdmllQ2xpcFBsdWdpbi5pbml0ID0gZnVuY3Rpb24odHdlZW4sIHByb3AsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2Qgc3RlcFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiovXG5cdE1vdmllQ2xpcFBsdWdpbi5zdGVwID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gdW51c2VkLlxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHR3ZWVuXG5cdCAqIEBwYXJhbSB7VHdlZW59IHR3ZWVuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG5cdCAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyIHwgQm9vbGVhbn0gdmFsdWVcblx0ICogQHBhcmFtIHtBcnJheX0gc3RhcnRWYWx1ZXNcblx0ICogQHBhcmFtIHtBcnJheX0gZW5kVmFsdWVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYXRpb1xuXHQgKiBAcGFyYW0ge09iamVjdH0gd2FpdFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZW5kXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqL1xuXHRNb3ZpZUNsaXBQbHVnaW4udHdlZW4gPSBmdW5jdGlvbih0d2VlbiwgcHJvcCwgdmFsdWUsIHN0YXJ0VmFsdWVzLCBlbmRWYWx1ZXMsIHJhdGlvLCB3YWl0LCBlbmQpIHtcblx0XHRpZiAoISh0d2Vlbi50YXJnZXQgaW5zdGFuY2VvZiBNb3ZpZUNsaXApKSB7IHJldHVybiB2YWx1ZTsgfVxuXHRcdHJldHVybiAocmF0aW8gPT0gMSA/IGVuZFZhbHVlc1twcm9wXSA6IHN0YXJ0VmFsdWVzW3Byb3BdKTtcblx0fTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNwcml0ZVNoZWV0VXRpbHMuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFxuXHRcbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogVGhlIFNwcml0ZVNoZWV0VXRpbHMgY2xhc3MgaXMgYSBjb2xsZWN0aW9uIG9mIHN0YXRpYyBtZXRob2RzIGZvciB3b3JraW5nIHdpdGgge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX1zLlxuXHQgKiBBIHNwcml0ZSBzaGVldCBpcyBhIHNlcmllcyBvZiBpbWFnZXMgKHVzdWFsbHkgYW5pbWF0aW9uIGZyYW1lcykgY29tYmluZWQgaW50byBhIHNpbmdsZSBpbWFnZSBvbiBhIHJlZ3VsYXIgZ3JpZC4gRm9yXG5cdCAqIGV4YW1wbGUsIGFuIGFuaW1hdGlvbiBjb25zaXN0aW5nIG9mIDggMTAweDEwMCBpbWFnZXMgY291bGQgYmUgY29tYmluZWQgaW50byBhIDQwMHgyMDAgc3ByaXRlIHNoZWV0ICg0IGZyYW1lcyBhY3Jvc3Ncblx0ICogYnkgMiBoaWdoKS4gVGhlIFNwcml0ZVNoZWV0VXRpbHMgY2xhc3MgdXNlcyBhIHN0YXRpYyBpbnRlcmZhY2UgYW5kIHNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkLlxuXHQgKiBAY2xhc3MgU3ByaXRlU2hlZXRVdGlsc1xuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0ZnVuY3Rpb24gU3ByaXRlU2hlZXRVdGlscygpIHtcblx0XHR0aHJvdyBcIlNwcml0ZVNoZWV0VXRpbHMgY2Fubm90IGJlIGluc3RhbnRpYXRlZFwiO1xuXHR9XG5cblxuLy8gcHJpdmF0ZSBzdGF0aWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfd29ya2luZ0NhbnZhc1xuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIEhUTUxDYW52YXNFbGVtZW50IHwgT2JqZWN0XG5cdCAqIEBwcm90ZWN0ZWRcblx0Ki9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfd29ya2luZ0NvbnRleHRcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcblx0ICogQHByb3RlY3RlZFxuXHQqL1xuXHR2YXIgY2FudmFzID0gKGNyZWF0ZWpzLmNyZWF0ZUNhbnZhcz9jcmVhdGVqcy5jcmVhdGVDYW52YXMoKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpKTtcblx0aWYgKGNhbnZhcy5nZXRDb250ZXh0KSB7XG5cdFx0U3ByaXRlU2hlZXRVdGlscy5fd29ya2luZ0NhbnZhcyA9IGNhbnZhcztcblx0XHRTcHJpdGVTaGVldFV0aWxzLl93b3JraW5nQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0Y2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDE7XG5cdH1cblxuXG4vLyBwdWJsaWMgc3RhdGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiA8Yj5UaGlzIGlzIGFuIGV4cGVyaW1lbnRhbCBtZXRob2QsIGFuZCBtYXkgYmUgYnVnZ3kuIFBsZWFzZSByZXBvcnQgaXNzdWVzLjwvYj48YnIvPjxici8+XG5cdCAqIEV4dGVuZHMgdGhlIGV4aXN0aW5nIHNwcml0ZSBzaGVldCBieSBmbGlwcGluZyB0aGUgb3JpZ2luYWwgZnJhbWVzIGhvcml6b250YWxseSwgdmVydGljYWxseSwgb3IgYm90aCxcblx0ICogYW5kIGFkZGluZyBhcHByb3ByaWF0ZSBhbmltYXRpb24gJiBmcmFtZSBkYXRhLiBUaGUgZmxpcHBlZCBhbmltYXRpb25zIHdpbGwgaGF2ZSBhIHN1ZmZpeCBhZGRlZCB0byB0aGVpciBuYW1lc1xuXHQgKiAoX2gsIF92LCBfaHYgYXMgYXBwcm9wcmlhdGUpLiBNYWtlIHN1cmUgdGhlIHNwcml0ZSBzaGVldCBpbWFnZXMgYXJlIGZ1bGx5IGxvYWRlZCBiZWZvcmUgdXNpbmcgdGhpcyBtZXRob2QuXG5cdCAqIDxici8+PGJyLz5cblx0ICogRm9yIGV4YW1wbGU6PGJyLz5cblx0ICogU3ByaXRlU2hlZXRVdGlscy5hZGRGbGlwcGVkRnJhbWVzKG15U3ByaXRlU2hlZXQsIHRydWUsIHRydWUpO1xuXHQgKiBUaGUgYWJvdmUgd291bGQgYWRkIGZyYW1lcyB0aGF0IGFyZSBmbGlwcGVkIGhvcml6b250YWxseSBBTkQgZnJhbWVzIHRoYXQgYXJlIGZsaXBwZWQgdmVydGljYWxseS5cblx0ICogPGJyLz48YnIvPlxuXHQgKiBOb3RlIHRoYXQgeW91IGNhbiBhbHNvIGZsaXAgYW55IGRpc3BsYXkgb2JqZWN0IGJ5IHNldHRpbmcgaXRzIHNjYWxlWCBvciBzY2FsZVkgdG8gYSBuZWdhdGl2ZSB2YWx1ZS4gT24gc29tZVxuXHQgKiBicm93c2VycyAoZXNwZWNpYWxseSB0aG9zZSB3aXRob3V0IGhhcmR3YXJlIGFjY2VsZXJhdGVkIGNhbnZhcykgdGhpcyBjYW4gcmVzdWx0IGluIHNsaWdodGx5IGRlZ3JhZGVkIHBlcmZvcm1hbmNlLFxuXHQgKiB3aGljaCBpcyB3aHkgYWRkRmxpcHBlZEZyYW1lcyBpcyBhdmFpbGFibGUuXG5cdCAqIEBtZXRob2QgYWRkRmxpcHBlZEZyYW1lc1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IHNwcml0ZVNoZWV0XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaG9yaXpvbnRhbCBJZiB0cnVlLCBob3Jpem9udGFsbHkgZmxpcHBlZCBmcmFtZXMgd2lsbCBiZSBhZGRlZC5cblx0ICogQHBhcmFtIHtCb29sZWFufSB2ZXJ0aWNhbCBJZiB0cnVlLCB2ZXJ0aWNhbGx5IGZsaXBwZWQgZnJhbWVzIHdpbGwgYmUgYWRkZWQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYm90aCBJZiB0cnVlLCBmcmFtZXMgdGhhdCBhcmUgZmxpcHBlZCBib3RoIGhvcml6b250YWxseSBhbmQgdmVydGljYWxseSB3aWxsIGJlIGFkZGVkLlxuXHQgKiBAZGVwcmVjYXRlZCBNb2Rlcm4gYnJvd3NlcnMgcGVyZm9ybSBiZXR0ZXIgd2hlbiBmbGlwcGluZyB2aWEgYSB0cmFuc2Zvcm0gKGV4LiBzY2FsZVg9LTEpIHJlbmRlcmluZyB0aGlzIG9ic29sZXRlLlxuXHQgKiovXG5cdFNwcml0ZVNoZWV0VXRpbHMuYWRkRmxpcHBlZEZyYW1lcyA9IGZ1bmN0aW9uKHNwcml0ZVNoZWV0LCBob3Jpem9udGFsLCB2ZXJ0aWNhbCwgYm90aCkge1xuXHRcdGlmICghaG9yaXpvbnRhbCAmJiAhdmVydGljYWwgJiYgIWJvdGgpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgY291bnQgPSAwO1xuXHRcdGlmIChob3Jpem9udGFsKSB7IFNwcml0ZVNoZWV0VXRpbHMuX2ZsaXAoc3ByaXRlU2hlZXQsKytjb3VudCx0cnVlLGZhbHNlKTsgfVxuXHRcdGlmICh2ZXJ0aWNhbCkgeyBTcHJpdGVTaGVldFV0aWxzLl9mbGlwKHNwcml0ZVNoZWV0LCsrY291bnQsZmFsc2UsdHJ1ZSk7IH1cblx0XHRpZiAoYm90aCkgeyBTcHJpdGVTaGVldFV0aWxzLl9mbGlwKHNwcml0ZVNoZWV0LCsrY291bnQsdHJ1ZSx0cnVlKTsgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc2luZ2xlIGZyYW1lIG9mIHRoZSBzcGVjaWZpZWQgc3ByaXRlIHNoZWV0IGFzIGEgbmV3IFBORyBpbWFnZS4gQW4gZXhhbXBsZSBvZiB3aGVuIHRoaXMgbWF5IGJlIHVzZWZ1bCBpc1xuXHQgKiB0byB1c2UgYSBzcHJpdGVzaGVldCBmcmFtZSBhcyB0aGUgc291cmNlIGZvciBhIGJpdG1hcCBmaWxsLlxuXHQgKlxuXHQgKiA8c3Ryb25nPldBUk5JTkc6PC9zdHJvbmc+IEluIGFsbW9zdCBhbGwgY2FzZXMgaXQgaXMgYmV0dGVyIHRvIGRpc3BsYXkgYSBzaW5nbGUgZnJhbWUgdXNpbmcgYSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2l0aCBhIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9nb3RvQW5kU3RvcFwifX17ey9jcm9zc0xpbmt9fSBjYWxsIHRoYW4gaXQgaXMgdG8gc2xpY2Ugb3V0IGEgZnJhbWUgdXNpbmcgdGhpc1xuXHQgKiBtZXRob2QgYW5kIGRpc3BsYXkgaXQgd2l0aCBhIEJpdG1hcCBpbnN0YW5jZS4gWW91IGNhbiBhbHNvIGNyb3AgYW4gaW1hZ2UgdXNpbmcgdGhlIHt7I2Nyb3NzTGluayBcIkJpdG1hcC9zb3VyY2VSZWN0XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHByb3BlcnR5IG9mIHt7I2Nyb3NzTGluayBcIkJpdG1hcFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogVGhlIGV4dHJhY3RGcmFtZSBtZXRob2QgbWF5IGNhdXNlIGNyb3NzLWRvbWFpbiB3YXJuaW5ncyBzaW5jZSBpdCBhY2Nlc3NlcyBwaXhlbHMgZGlyZWN0bHkgb24gdGhlIGNhbnZhcy5cblx0ICogQG1ldGhvZCBleHRyYWN0RnJhbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge1Nwcml0ZVNoZWV0fSBzcHJpdGVTaGVldCBUaGUgU3ByaXRlU2hlZXQgaW5zdGFuY2UgdG8gZXh0cmFjdCBhIGZyYW1lIGZyb20uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gZnJhbWVPckFuaW1hdGlvbiBUaGUgZnJhbWUgbnVtYmVyIG9yIGFuaW1hdGlvbiBuYW1lIHRvIGV4dHJhY3QuIElmIGFuIGFuaW1hdGlvblxuXHQgKiBuYW1lIGlzIHNwZWNpZmllZCwgb25seSB0aGUgZmlyc3QgZnJhbWUgb2YgdGhlIGFuaW1hdGlvbiB3aWxsIGJlIGV4dHJhY3RlZC5cblx0ICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gYSBzaW5nbGUgZnJhbWUgb2YgdGhlIHNwZWNpZmllZCBzcHJpdGUgc2hlZXQgYXMgYSBuZXcgUE5HIGltYWdlLlxuXHQqL1xuXHRTcHJpdGVTaGVldFV0aWxzLmV4dHJhY3RGcmFtZSA9IGZ1bmN0aW9uKHNwcml0ZVNoZWV0LCBmcmFtZU9yQW5pbWF0aW9uKSB7XG5cdFx0aWYgKGlzTmFOKGZyYW1lT3JBbmltYXRpb24pKSB7XG5cdFx0XHRmcmFtZU9yQW5pbWF0aW9uID0gc3ByaXRlU2hlZXQuZ2V0QW5pbWF0aW9uKGZyYW1lT3JBbmltYXRpb24pLmZyYW1lc1swXTtcblx0XHR9XG5cdFx0dmFyIGRhdGEgPSBzcHJpdGVTaGVldC5nZXRGcmFtZShmcmFtZU9yQW5pbWF0aW9uKTtcblx0XHRpZiAoIWRhdGEpIHsgcmV0dXJuIG51bGw7IH1cblx0XHR2YXIgciA9IGRhdGEucmVjdDtcblx0XHR2YXIgY2FudmFzID0gU3ByaXRlU2hlZXRVdGlscy5fd29ya2luZ0NhbnZhcztcblx0XHRjYW52YXMud2lkdGggPSByLndpZHRoO1xuXHRcdGNhbnZhcy5oZWlnaHQgPSByLmhlaWdodDtcblx0XHRTcHJpdGVTaGVldFV0aWxzLl93b3JraW5nQ29udGV4dC5kcmF3SW1hZ2UoZGF0YS5pbWFnZSwgci54LCByLnksIHIud2lkdGgsIHIuaGVpZ2h0LCAwLCAwLCByLndpZHRoLCByLmhlaWdodCk7XG5cdFx0dmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG5cdFx0aW1nLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG5cdFx0cmV0dXJuIGltZztcblx0fTtcblxuXHQvKipcblx0ICogTWVyZ2VzIHRoZSByZ2IgY2hhbm5lbHMgb2Ygb25lIGltYWdlIHdpdGggdGhlIGFscGhhIGNoYW5uZWwgb2YgYW5vdGhlci4gVGhpcyBjYW4gYmUgdXNlZCB0byBjb21iaW5lIGEgY29tcHJlc3NlZFxuXHQgKiBKUEVHIGltYWdlIGNvbnRhaW5pbmcgY29sb3IgZGF0YSB3aXRoIGEgUE5HMzIgbW9ub2Nocm9tYXRpYyBpbWFnZSBjb250YWluaW5nIGFscGhhIGRhdGEuIFdpdGggY2VydGFpbiB0eXBlcyBvZlxuXHQgKiBpbWFnZXMgKHRob3NlIHdpdGggZGV0YWlsIHRoYXQgbGVuZCBpdHNlbGYgdG8gSlBFRyBjb21wcmVzc2lvbikgdGhpcyBjYW4gcHJvdmlkZSBzaWduaWZpY2FudCBmaWxlIHNpemUgc2F2aW5nc1xuXHQgKiB2ZXJzdXMgYSBzaW5nbGUgUkdCQSBQTkczMi4gVGhpcyBtZXRob2QgaXMgdmVyeSBmYXN0IChnZW5lcmFsbHkgb24gdGhlIG9yZGVyIG9mIDEtMiBtcyB0byBydW4pLlxuXHQgKiBAbWV0aG9kIG1lcmdlQWxwaGFcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IHJiZ0ltYWdlIFRoZSBpbWFnZSAob3IgY2FudmFzKSBjb250YWluaW5nIHRoZSBSR0IgY2hhbm5lbHMgdG8gdXNlLlxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IGFscGhhSW1hZ2UgVGhlIGltYWdlIChvciBjYW52YXMpIGNvbnRhaW5pbmcgdGhlIGFscGhhIGNoYW5uZWwgdG8gdXNlLlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgT3B0aW9uYWwuIElmIHNwZWNpZmllZCwgdGhpcyBjYW52YXMgd2lsbCBiZSB1c2VkIGFuZCByZXR1cm5lZC4gSWYgbm90LCBhIG5ldyBjYW52YXMgd2lsbCBiZSBjcmVhdGVkLlxuXHQgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gQSBjYW52YXMgd2l0aCB0aGUgY29tYmluZWQgaW1hZ2UgZGF0YS4gVGhpcyBjYW4gYmUgdXNlZCBhcyBhIHNvdXJjZSBmb3IgQml0bWFwIG9yIFNwcml0ZVNoZWV0LlxuXHQgKiBAZGVwcmVjYXRlZCBUb29scyBzdWNoIGFzIEltYWdlQWxwaGEgZ2VuZXJhbGx5IHByb3ZpZGUgYmV0dGVyIHJlc3VsdHMuIFRoaXMgd2lsbCBiZSBtb3ZlZCB0byBzYW5kYm94IGluIHRoZSBmdXR1cmUuXG5cdCovXG5cdFNwcml0ZVNoZWV0VXRpbHMubWVyZ2VBbHBoYSA9IGZ1bmN0aW9uKHJnYkltYWdlLCBhbHBoYUltYWdlLCBjYW52YXMpIHtcblx0XHRpZiAoIWNhbnZhcykgeyBjYW52YXMgPSBjcmVhdGVqcy5jcmVhdGVDYW52YXM/Y3JlYXRlanMuY3JlYXRlQ2FudmFzKCk6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTsgfVxuXHRcdGNhbnZhcy53aWR0aCA9IE1hdGgubWF4KGFscGhhSW1hZ2Uud2lkdGgsIHJnYkltYWdlLndpZHRoKTtcblx0XHRjYW52YXMuaGVpZ2h0ID0gTWF0aC5tYXgoYWxwaGFJbWFnZS5oZWlnaHQsIHJnYkltYWdlLmhlaWdodCk7XG5cdFx0dmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRjdHguZHJhd0ltYWdlKHJnYkltYWdlLDAsMCk7XG5cdFx0Y3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24taW5cIjtcblx0XHRjdHguZHJhd0ltYWdlKGFscGhhSW1hZ2UsMCwwKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdHJldHVybiBjYW52YXM7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBzdGF0aWMgbWV0aG9kczpcblx0U3ByaXRlU2hlZXRVdGlscy5fZmxpcCA9IGZ1bmN0aW9uKHNwcml0ZVNoZWV0LCBjb3VudCwgaCwgdikge1xuXHRcdHZhciBpbWdzID0gc3ByaXRlU2hlZXQuX2ltYWdlcztcblx0XHR2YXIgY2FudmFzID0gU3ByaXRlU2hlZXRVdGlscy5fd29ya2luZ0NhbnZhcztcblx0XHR2YXIgY3R4ID0gU3ByaXRlU2hlZXRVdGlscy5fd29ya2luZ0NvbnRleHQ7XG5cdFx0dmFyIGlsID0gaW1ncy5sZW5ndGgvY291bnQ7XG5cdFx0Zm9yICh2YXIgaT0wO2k8aWw7aSsrKSB7XG5cdFx0XHR2YXIgc3JjID0gaW1nc1tpXTtcblx0XHRcdHNyYy5fX3RtcCA9IGk7IC8vIGEgYml0IGhhY2t5LCBidXQgZmFzdGVyIHRoYW4gZG9pbmcgaW5kZXhPZiBiZWxvdy5cblx0XHRcdGN0eC5zZXRUcmFuc2Zvcm0oMSwwLDAsMSwwLDApO1xuXHRcdFx0Y3R4LmNsZWFyUmVjdCgwLDAsY2FudmFzLndpZHRoKzEsY2FudmFzLmhlaWdodCsxKTtcblx0XHRcdGNhbnZhcy53aWR0aCA9IHNyYy53aWR0aDtcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBzcmMuaGVpZ2h0O1xuXHRcdFx0Y3R4LnNldFRyYW5zZm9ybShoPy0xOjEsIDAsIDAsIHY/LTE6MSwgaD9zcmMud2lkdGg6MCwgdj9zcmMuaGVpZ2h0OjApO1xuXHRcdFx0Y3R4LmRyYXdJbWFnZShzcmMsMCwwKTtcblx0XHRcdHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuXHRcdFx0aW1nLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG5cdFx0XHQvLyB3b3JrIGFyb3VuZCBhIHN0cmFuZ2UgYnVnIGluIFNhZmFyaTpcblx0XHRcdGltZy53aWR0aCA9IHNyYy53aWR0aDtcblx0XHRcdGltZy5oZWlnaHQgPSBzcmMuaGVpZ2h0O1xuXHRcdFx0aW1ncy5wdXNoKGltZyk7XG5cdFx0fVxuXG5cdFx0dmFyIGZyYW1lcyA9IHNwcml0ZVNoZWV0Ll9mcmFtZXM7XG5cdFx0dmFyIGZsID0gZnJhbWVzLmxlbmd0aC9jb3VudDtcblx0XHRmb3IgKGk9MDtpPGZsO2krKykge1xuXHRcdFx0c3JjID0gZnJhbWVzW2ldO1xuXHRcdFx0dmFyIHJlY3QgPSBzcmMucmVjdC5jbG9uZSgpO1xuXHRcdFx0aW1nID0gaW1nc1tzcmMuaW1hZ2UuX190bXAraWwqY291bnRdO1xuXG5cdFx0XHR2YXIgZnJhbWUgPSB7aW1hZ2U6aW1nLHJlY3Q6cmVjdCxyZWdYOnNyYy5yZWdYLHJlZ1k6c3JjLnJlZ1l9O1xuXHRcdFx0aWYgKGgpIHtcblx0XHRcdFx0cmVjdC54ID0gaW1nLndpZHRoLXJlY3QueC1yZWN0LndpZHRoOyAvLyB1cGRhdGUgcmVjdFxuXHRcdFx0XHRmcmFtZS5yZWdYID0gcmVjdC53aWR0aC1zcmMucmVnWDsgLy8gdXBkYXRlIHJlZ2lzdHJhdGlvbiBwb2ludFxuXHRcdFx0fVxuXHRcdFx0aWYgKHYpIHtcblx0XHRcdFx0cmVjdC55ID0gaW1nLmhlaWdodC1yZWN0LnktcmVjdC5oZWlnaHQ7ICAvLyB1cGRhdGUgcmVjdFxuXHRcdFx0XHRmcmFtZS5yZWdZID0gcmVjdC5oZWlnaHQtc3JjLnJlZ1k7IC8vIHVwZGF0ZSByZWdpc3RyYXRpb24gcG9pbnRcblx0XHRcdH1cblx0XHRcdGZyYW1lcy5wdXNoKGZyYW1lKTtcblx0XHR9XG5cblx0XHR2YXIgc2Z4ID0gXCJfXCIrKGg/XCJoXCI6XCJcIikrKHY/XCJ2XCI6XCJcIik7XG5cdFx0dmFyIG5hbWVzID0gc3ByaXRlU2hlZXQuX2FuaW1hdGlvbnM7XG5cdFx0dmFyIGRhdGEgPSBzcHJpdGVTaGVldC5fZGF0YTtcblx0XHR2YXIgYWwgPSBuYW1lcy5sZW5ndGgvY291bnQ7XG5cdFx0Zm9yIChpPTA7aTxhbDtpKyspIHtcblx0XHRcdHZhciBuYW1lID0gbmFtZXNbaV07XG5cdFx0XHRzcmMgPSBkYXRhW25hbWVdO1xuXHRcdFx0dmFyIGFuaW0gPSB7bmFtZTpuYW1lK3NmeCxzcGVlZDpzcmMuc3BlZWQsbmV4dDpzcmMubmV4dCxmcmFtZXM6W119O1xuXHRcdFx0aWYgKHNyYy5uZXh0KSB7IGFuaW0ubmV4dCArPSBzZng7IH1cblx0XHRcdGZyYW1lcyA9IHNyYy5mcmFtZXM7XG5cdFx0XHRmb3IgKHZhciBqPTAsbD1mcmFtZXMubGVuZ3RoO2o8bDtqKyspIHtcblx0XHRcdFx0YW5pbS5mcmFtZXMucHVzaChmcmFtZXNbal0rZmwqY291bnQpO1xuXHRcdFx0fVxuXHRcdFx0ZGF0YVthbmltLm5hbWVdID0gYW5pbTtcblx0XHRcdG5hbWVzLnB1c2goYW5pbS5uYW1lKTtcblx0XHR9XG5cdH07XG5cblxuXHRjcmVhdGVqcy5TcHJpdGVTaGVldFV0aWxzID0gU3ByaXRlU2hlZXRVdGlscztcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTcHJpdGVTaGVldEJ1aWxkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBUaGUgU3ByaXRlU2hlZXRCdWlsZGVyIGFsbG93cyB5b3UgdG8gZ2VuZXJhdGUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2VzIGF0IHJ1biB0aW1lXG5cdCAqIGZyb20gYW55IGRpc3BsYXkgb2JqZWN0LiBUaGlzIGNhbiBhbGxvdyB5b3UgdG8gbWFpbnRhaW4geW91ciBhc3NldHMgYXMgdmVjdG9yIGdyYXBoaWNzIChmb3IgbG93IGZpbGUgc2l6ZSksIGFuZFxuXHQgKiByZW5kZXIgdGhlbSBhdCBydW4gdGltZSBhcyBTcHJpdGVTaGVldHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cblx0ICpcblx0ICogU3ByaXRlU2hlZXRzIGNhbiBiZSBidWlsdCBlaXRoZXIgc3luY2hyb25vdXNseSwgb3IgYXN5bmNocm9ub3VzbHksIHNvIHRoYXQgbGFyZ2UgU3ByaXRlU2hlZXRzIGNhbiBiZSBnZW5lcmF0ZWRcblx0ICogd2l0aG91dCBsb2NraW5nIHRoZSBVSS5cblx0ICpcblx0ICogTm90ZSB0aGF0IHRoZSBcImltYWdlc1wiIHVzZWQgaW4gdGhlIGdlbmVyYXRlZCBTcHJpdGVTaGVldCBhcmUgYWN0dWFsbHkgY2FudmFzIGVsZW1lbnRzLCBhbmQgdGhhdCB0aGV5IHdpbGwgYmVcblx0ICogc2l6ZWQgdG8gdGhlIG5lYXJlc3QgcG93ZXIgb2YgMiB1cCB0byB0aGUgdmFsdWUgb2Yge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRCdWlsZGVyL21heFdpZHRoOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG9yIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0QnVpbGRlci9tYXhIZWlnaHQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBjbGFzcyBTcHJpdGVTaGVldEJ1aWxkZXJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtmcmFtZXJhdGU9MF0gVGhlIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0L2ZyYW1lcmF0ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBvZlxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZXMgdGhhdCBhcmUgY3JlYXRlZC5cblx0ICogQGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIFNwcml0ZVNoZWV0QnVpbGRlcihmcmFtZXJhdGUpIHtcblx0XHR0aGlzLkV2ZW50RGlzcGF0Y2hlcl9jb25zdHJ1Y3RvcigpO1xuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgbWF4aW11bSB3aWR0aCBmb3IgdGhlIGltYWdlcyAobm90IGluZGl2aWR1YWwgZnJhbWVzKSBpbiB0aGUgZ2VuZXJhdGVkIFNwcml0ZVNoZWV0LiBJdCBpcyByZWNvbW1lbmRlZCB0b1xuXHRcdCAqIHVzZSBhIHBvd2VyIG9mIDIgZm9yIHRoaXMgdmFsdWUgKGV4LiAxMDI0LCAyMDQ4LCA0MDk2KS4gSWYgdGhlIGZyYW1lcyBjYW5ub3QgYWxsIGZpdCB3aXRoaW4gdGhlIG1heFxuXHRcdCAqIGRpbWVuc2lvbnMsIHRoZW4gYWRkaXRpb25hbCBpbWFnZXMgd2lsbCBiZSBjcmVhdGVkIGFzIG5lZWRlZC5cblx0XHQgKiBAcHJvcGVydHkgbWF4V2lkdGhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAyMDQ4XG5cdFx0Ki9cblx0XHR0aGlzLm1heFdpZHRoID0gMjA0ODtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIG1heGltdW0gaGVpZ2h0IGZvciB0aGUgaW1hZ2VzIChub3QgaW5kaXZpZHVhbCBmcmFtZXMpIGluIHRoZSBnZW5lcmF0ZWQgU3ByaXRlU2hlZXQuIEl0IGlzIHJlY29tbWVuZGVkIHRvXG5cdFx0ICogdXNlIGEgcG93ZXIgb2YgMiBmb3IgdGhpcyB2YWx1ZSAoZXguIDEwMjQsIDIwNDgsIDQwOTYpLiBJZiB0aGUgZnJhbWVzIGNhbm5vdCBhbGwgZml0IHdpdGhpbiB0aGUgbWF4XG5cdFx0ICogZGltZW5zaW9ucywgdGhlbiBhZGRpdGlvbmFsIGltYWdlcyB3aWxsIGJlIGNyZWF0ZWQgYXMgbmVlZGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBtYXhIZWlnaHRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAyMDQ4XG5cdFx0ICoqL1xuXHRcdHRoaXMubWF4SGVpZ2h0ID0gMjA0ODtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIFNwcml0ZVNoZWV0IHRoYXQgd2FzIGdlbmVyYXRlZC4gVGhpcyB3aWxsIGJlIG51bGwgYmVmb3JlIGEgYnVpbGQgaXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cblx0XHQgKiBAcHJvcGVydHkgc3ByaXRlU2hlZXRcblx0XHQgKiBAdHlwZSBTcHJpdGVTaGVldFxuXHRcdCAqKi9cblx0XHR0aGlzLnNwcml0ZVNoZWV0ID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHNjYWxlIHRvIGFwcGx5IHdoZW4gZHJhd2luZyBhbGwgZnJhbWVzIHRvIHRoZSBTcHJpdGVTaGVldC4gVGhpcyBpcyBtdWx0aXBsaWVkIGFnYWluc3QgYW55IHNjYWxlIHNwZWNpZmllZFxuXHRcdCAqIGluIHRoZSBhZGRGcmFtZSBjYWxsLiBUaGlzIGNhbiBiZSB1c2VkLCBmb3IgZXhhbXBsZSwgdG8gZ2VuZXJhdGUgYSBTcHJpdGVTaGVldCBhdCBydW4gdGltZSB0aGF0IGlzIHRhaWxvcmVkXG5cdFx0ICogdG8gdGhlIGEgc3BlY2lmaWMgZGV2aWNlIHJlc29sdXRpb24gKGV4LiB0YWJsZXQgdnMgbW9iaWxlKS5cblx0XHQgKiBAcHJvcGVydHkgc2NhbGVcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICoqL1xuXHRcdHRoaXMuc2NhbGUgPSAxO1xuXHRcblx0XHQvKipcblx0XHQqIFRoZSBwYWRkaW5nIHRvIHVzZSBiZXR3ZWVuIGZyYW1lcy4gVGhpcyBpcyBoZWxwZnVsIHRvIHByZXNlcnZlIGFudGlhbGlhc2luZyBvbiBkcmF3biB2ZWN0b3IgY29udGVudC5cblx0XHQqIEBwcm9wZXJ0eSBwYWRkaW5nXG5cdFx0KiBAdHlwZSBOdW1iZXJcblx0XHQqIEBkZWZhdWx0IDFcblx0XHQqKi9cblx0XHR0aGlzLnBhZGRpbmcgPSAxO1xuXHRcblx0XHQvKipcblx0XHQgKiBBIG51bWJlciBmcm9tIDAuMDEgdG8gMC45OSB0aGF0IGluZGljYXRlcyB3aGF0IHBlcmNlbnRhZ2Ugb2YgdGltZSB0aGUgYnVpbGRlciBjYW4gdXNlLiBUaGlzIGNhbiBiZVxuXHRcdCAqIHRob3VnaHQgb2YgYXMgdGhlIG51bWJlciBvZiBzZWNvbmRzIHBlciBzZWNvbmQgdGhlIGJ1aWxkZXIgd2lsbCB1c2UuIEZvciBleGFtcGxlLCB3aXRoIGEgdGltZVNsaWNlIHZhbHVlIG9mIDAuMyxcblx0XHQgKiB0aGUgYnVpbGRlciB3aWxsIHJ1biAyMCB0aW1lcyBwZXIgc2Vjb25kLCB1c2luZyBhcHByb3hpbWF0ZWx5IDE1bXMgcGVyIGJ1aWxkICgzMCUgb2YgYXZhaWxhYmxlIHRpbWUsIG9yIDAuM3MgcGVyIHNlY29uZCkuXG5cdFx0ICogRGVmYXVsdHMgdG8gMC4zLlxuXHRcdCAqIEBwcm9wZXJ0eSB0aW1lU2xpY2Vcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwLjNcblx0XHQgKiovXG5cdFx0dGhpcy50aW1lU2xpY2UgPSAwLjM7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxIHRoYXQgaW5kaWNhdGVzIHRoZSBwcm9ncmVzcyBvZiBhIGJ1aWxkLCBvciAtMSBpZiBhIGJ1aWxkIGhhcyBub3Rcblx0XHQgKiBiZWVuIGluaXRpYXRlZC5cblx0XHQgKiBAcHJvcGVydHkgcHJvZ3Jlc3Ncblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAtMVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSAtMTtcblxuXHRcdC8qKlxuXHRcdCAqIEEge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXQvZnJhbWVyYXRlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHZhbHVlIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gbmV3IHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0XCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlcyB0aGF0IGFyZVxuXHRcdCAqIGNyZWF0ZWQuIElmIG5vIGZyYW1lcmF0ZSBpcyBzcGVjaWZpZWQgKG9yIGl0IGlzIDApLCB0aGVuIFNwcml0ZVNoZWV0cyB3aWxsIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyXCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogZnJhbWVyYXRlLlxuXHRcdCAqIEBwcm9wZXJ0eSBmcmFtZXJhdGVcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5mcmFtZXJhdGUgPSBmcmFtZXJhdGUgfHwgMDtcblx0XG5cdFxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9mcmFtZXNcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgQXJyYXlcblx0XHQgKiovXG5cdFx0dGhpcy5fZnJhbWVzID0gW107XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfYW5pbWF0aW9uc1xuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBBcnJheVxuXHRcdCAqKi9cblx0XHR0aGlzLl9hbmltYXRpb25zID0ge307XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfZGF0YVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBBcnJheVxuXHRcdCAqKi9cblx0XHR0aGlzLl9kYXRhID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9uZXh0RnJhbWVJbmRleFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fbmV4dEZyYW1lSW5kZXggPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2luZGV4XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9pbmRleCA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfdGltZXJJRFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fdGltZXJJRCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfc2NhbGVcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3NjYWxlID0gMTtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChTcHJpdGVTaGVldEJ1aWxkZXIsIGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlcik7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cbi8vIGNvbnN0YW50czpcblx0U3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9ESU1FTlNJT05TID0gXCJmcmFtZSBkaW1lbnNpb25zIGV4Y2VlZCBtYXggc3ByaXRlc2hlZXQgZGltZW5zaW9uc1wiO1xuXHRTcHJpdGVTaGVldEJ1aWxkZXIuRVJSX1JVTk5JTkcgPSBcImEgYnVpbGQgaXMgYWxyZWFkeSBydW5uaW5nXCI7XG5cbi8vIGV2ZW50czpcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiBhIGJ1aWxkIGNvbXBsZXRlcy5cblx0ICogQGV2ZW50IGNvbXBsZXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gYW4gYXN5bmNocm9ub3VzIGJ1aWxkIGhhcyBwcm9ncmVzcy5cblx0ICogQGV2ZW50IHByb2dyZXNzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHByb2dyZXNzIFRoZSBjdXJyZW50IHByb2dyZXNzIHZhbHVlICgwLTEpLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBBZGRzIGEgZnJhbWUgdG8gdGhlIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0XCJ9fXt7L2Nyb3NzTGlua319LiBOb3RlIHRoYXQgdGhlIGZyYW1lIHdpbGwgbm90IGJlIGRyYXduIHVudGlsIHlvdVxuXHQgKiBjYWxsIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0QnVpbGRlci9idWlsZFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuIFRoZSBvcHRpb25hbCBzZXR1cCBwYXJhbXMgYWxsb3cgeW91IHRvIGhhdmVcblx0ICogYSBmdW5jdGlvbiBydW4gaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkcmF3IG9jY3Vycy4gRm9yIGV4YW1wbGUsIHRoaXMgYWxsb3dzIHlvdSB0byBhZGQgYSBzaW5nbGUgc291cmNlIG11bHRpcGxlXG5cdCAqIHRpbWVzLCBidXQgbWFuaXB1bGF0ZSBpdCBvciBpdHMgY2hpbGRyZW4gdG8gY2hhbmdlIGl0IHRvIGdlbmVyYXRlIGRpZmZlcmVudCBmcmFtZXMuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUgc291cmNlJ3MgdHJhbnNmb3JtYXRpb25zICh4LCB5LCBzY2FsZSwgcm90YXRlLCBhbHBoYSkgd2lsbCBiZSBpZ25vcmVkLCBleGNlcHQgZm9yIHJlZ1gvWS4gVG8gYXBwbHlcblx0ICogdHJhbnNmb3JtcyB0byBhIHNvdXJjZSBvYmplY3QgYW5kIGhhdmUgdGhlbSBjYXB0dXJlZCBpbiB0aGUgU3ByaXRlU2hlZXQsIHNpbXBseSBwbGFjZSBpdCBpbnRvIGEge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGFuZCBwYXNzIGluIHRoZSBDb250YWluZXIgYXMgdGhlIHNvdXJjZS5cblx0ICogQG1ldGhvZCBhZGRGcmFtZVxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3RcIn19e3svY3Jvc3NMaW5rfX0gIHRvIGRyYXcgYXMgdGhlIGZyYW1lLlxuXHQgKiBAcGFyYW0ge1JlY3RhbmdsZX0gW3NvdXJjZVJlY3RdIEEge3sjY3Jvc3NMaW5rIFwiUmVjdGFuZ2xlXCJ9fXt7L2Nyb3NzTGlua319IGRlZmluaW5nIHRoZSBwb3J0aW9uIG9mIHRoZVxuXHQgKiBzb3VyY2UgdG8gZHJhdyB0byB0aGUgZnJhbWUuIElmIG5vdCBzcGVjaWZpZWQsIGl0IHdpbGwgbG9vayBmb3IgYSBgZ2V0Qm91bmRzYCBtZXRob2QsIGJvdW5kcyBwcm9wZXJ0eSwgb3Jcblx0ICogYG5vbWluYWxCb3VuZHNgIHByb3BlcnR5IG9uIHRoZSBzb3VyY2UgdG8gdXNlLiBJZiBvbmUgaXMgbm90IGZvdW5kLCB0aGUgZnJhbWUgd2lsbCBiZSBza2lwcGVkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlPTFdIE9wdGlvbmFsLiBUaGUgc2NhbGUgdG8gZHJhdyB0aGlzIGZyYW1lIGF0LiBEZWZhdWx0IGlzIDEuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZXR1cEZ1bmN0aW9uXSBBIGZ1bmN0aW9uIHRvIGNhbGwgaW1tZWRpYXRlbHkgYmVmb3JlIGRyYXdpbmcgdGhpcyBmcmFtZS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0d28gcGFyYW1ldGVyczogdGhlIHNvdXJjZSwgYW5kIHNldHVwRGF0YS5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtzZXR1cERhdGFdIEFyYml0cmFyeSBzZXR1cCBkYXRhIHRvIHBhc3MgdG8gc2V0dXBGdW5jdGlvbiBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlci5cblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIGZyYW1lIHRoYXQgd2FzIGp1c3QgYWRkZWQsIG9yIG51bGwgaWYgYSBzb3VyY2VSZWN0IGNvdWxkIG5vdCBiZSBkZXRlcm1pbmVkLlxuXHQgKiovXG5cdHAuYWRkRnJhbWUgPSBmdW5jdGlvbihzb3VyY2UsIHNvdXJjZVJlY3QsIHNjYWxlLCBzZXR1cEZ1bmN0aW9uLCBzZXR1cERhdGEpIHtcblx0XHRpZiAodGhpcy5fZGF0YSkgeyB0aHJvdyBTcHJpdGVTaGVldEJ1aWxkZXIuRVJSX1JVTk5JTkc7IH1cblx0XHR2YXIgcmVjdCA9IHNvdXJjZVJlY3R8fHNvdXJjZS5ib3VuZHN8fHNvdXJjZS5ub21pbmFsQm91bmRzO1xuXHRcdGlmICghcmVjdCYmc291cmNlLmdldEJvdW5kcykgeyByZWN0ID0gc291cmNlLmdldEJvdW5kcygpOyB9XG5cdFx0aWYgKCFyZWN0KSB7IHJldHVybiBudWxsOyB9XG5cdFx0c2NhbGUgPSBzY2FsZXx8MTtcblx0XHRyZXR1cm4gdGhpcy5fZnJhbWVzLnB1c2goe3NvdXJjZTpzb3VyY2UsIHNvdXJjZVJlY3Q6cmVjdCwgc2NhbGU6c2NhbGUsIGZ1bmN0OnNldHVwRnVuY3Rpb24sIGRhdGE6c2V0dXBEYXRhLCBpbmRleDp0aGlzLl9mcmFtZXMubGVuZ3RoLCBoZWlnaHQ6cmVjdC5oZWlnaHQqc2NhbGV9KS0xO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGFuaW1hdGlvbiB0aGF0IHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIGNyZWF0ZWQge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgYWRkQW5pbWF0aW9uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIGZvciB0aGUgYW5pbWF0aW9uLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBmcmFtZXMgQW4gYXJyYXkgb2YgZnJhbWUgaW5kZXhlcyB0aGF0IGNvbXByaXNlIHRoZSBhbmltYXRpb24uIEV4LiBbMyw2LDVdIHdvdWxkIGRlc2NyaWJlIGFuIGFuaW1hdGlvblxuXHQgKiB0aGF0IHBsYXllZCBmcmFtZSBpbmRleGVzIDMsIDYsIGFuZCA1IGluIHRoYXQgb3JkZXIuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbbmV4dF0gU3BlY2lmaWVzIHRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gY29udGludWUgdG8gYWZ0ZXIgdGhpcyBhbmltYXRpb24gZW5kcy4gWW91IGNhblxuXHQgKiBhbHNvIHBhc3MgZmFsc2UgdG8gaGF2ZSB0aGUgYW5pbWF0aW9uIHN0b3Agd2hlbiBpdCBlbmRzLiBCeSBkZWZhdWx0IGl0IHdpbGwgbG9vcCB0byB0aGUgc3RhcnQgb2YgdGhlIHNhbWUgYW5pbWF0aW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkXSBTcGVjaWZpZXMgYSBmcmFtZSBhZHZhbmNlIHNwZWVkIGZvciB0aGlzIGFuaW1hdGlvbi4gRm9yIGV4YW1wbGUsIGEgdmFsdWUgb2YgMC41IHdvdWxkXG5cdCAqIGNhdXNlIHRoZSBhbmltYXRpb24gdG8gYWR2YW5jZSBldmVyeSBzZWNvbmQgdGljay4gTm90ZSB0aGF0IGVhcmxpZXIgdmVyc2lvbnMgdXNlZCBgZnJlcXVlbmN5YCBpbnN0ZWFkLCB3aGljaCBoYWRcblx0ICogdGhlIG9wcG9zaXRlIGVmZmVjdC5cblx0ICoqL1xuXHRwLmFkZEFuaW1hdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIGZyYW1lcywgbmV4dCwgc3BlZWQpIHtcblx0XHRpZiAodGhpcy5fZGF0YSkgeyB0aHJvdyBTcHJpdGVTaGVldEJ1aWxkZXIuRVJSX1JVTk5JTkc7IH1cblx0XHR0aGlzLl9hbmltYXRpb25zW25hbWVdID0ge2ZyYW1lczpmcmFtZXMsIG5leHQ6bmV4dCwgc3BlZWQ6c3BlZWR9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGlzIHdpbGwgdGFrZSBhIHt7I2Nyb3NzTGluayBcIk1vdmllQ2xpcFwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZSwgYW5kIGFkZCBpdHMgZnJhbWVzIGFuZCBsYWJlbHMgdG8gdGhpc1xuXHQgKiBidWlsZGVyLiBMYWJlbHMgd2lsbCBiZSBhZGRlZCBhcyBhbiBhbmltYXRpb24gcnVubmluZyBmcm9tIHRoZSBsYWJlbCBpbmRleCB0byB0aGUgbmV4dCBsYWJlbC4gRm9yIGV4YW1wbGUsIGlmXG5cdCAqIHRoZXJlIGlzIGEgbGFiZWwgbmFtZWQgXCJmb29cIiBhdCBmcmFtZSAwIGFuZCBhIGxhYmVsIG5hbWVkIFwiYmFyXCIgYXQgZnJhbWUgMTAsIGluIGEgTW92aWVDbGlwIHdpdGggMTUgZnJhbWVzLCBpdFxuXHQgKiB3aWxsIGFkZCBhbiBhbmltYXRpb24gbmFtZWQgXCJmb29cIiB0aGF0IHJ1bnMgZnJvbSBmcmFtZSBpbmRleCAwIHRvIDksIGFuZCBhbiBhbmltYXRpb24gbmFtZWQgXCJiYXJcIiB0aGF0IHJ1bnMgZnJvbVxuXHQgKiBmcmFtZSBpbmRleCAxMCB0byAxNC5cblx0ICpcblx0ICogTm90ZSB0aGF0IHRoaXMgd2lsbCBpdGVyYXRlIHRocm91Z2ggdGhlIGZ1bGwgTW92aWVDbGlwIHdpdGgge3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwL2FjdGlvbnNFbmFibGVkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHNldCB0byBgZmFsc2VgLCBlbmRpbmcgb24gdGhlIGxhc3QgZnJhbWUuXG5cdCAqIEBtZXRob2QgYWRkTW92aWVDbGlwXG5cdCAqIEBwYXJhbSB7TW92aWVDbGlwfSBzb3VyY2UgVGhlIHNvdXJjZSBNb3ZpZUNsaXAgaW5zdGFuY2UgdG8gYWRkIHRvIHRoZSBTcHJpdGVTaGVldC5cblx0ICogQHBhcmFtIHtSZWN0YW5nbGV9IFtzb3VyY2VSZWN0XSBBIHt7I2Nyb3NzTGluayBcIlJlY3RhbmdsZVwifX17ey9jcm9zc0xpbmt9fSBkZWZpbmluZyB0aGUgcG9ydGlvbiBvZiB0aGUgc291cmNlIHRvXG5cdCAqIGRyYXcgdG8gdGhlIGZyYW1lLiBJZiBub3Qgc3BlY2lmaWVkLCBpdCB3aWxsIGxvb2sgZm9yIGEge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9nZXRCb3VuZHNcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLCBgZnJhbWVCb3VuZHNgIEFycmF5LCBgYm91bmRzYCBwcm9wZXJ0eSwgb3IgYG5vbWluYWxCb3VuZHNgIHByb3BlcnR5IG9uIHRoZSBzb3VyY2UgdG8gdXNlLiBJZiBvbmUgaXMgbm90XG5cdCAqIGZvdW5kLCB0aGUgTW92aWVDbGlwIHdpbGwgYmUgc2tpcHBlZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZT0xXSBUaGUgc2NhbGUgdG8gZHJhdyB0aGUgbW92aWUgY2xpcCBhdC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW3NldHVwRnVuY3Rpb25dIEEgZnVuY3Rpb24gdG8gY2FsbCBpbW1lZGlhdGVseSBiZWZvcmUgZHJhd2luZyBlYWNoIGZyYW1lLiBJdCB3aWxsIGJlIGNhbGxlZFxuXHQgKiB3aXRoIHRocmVlIHBhcmFtZXRlcnM6IHRoZSBzb3VyY2UsIHNldHVwRGF0YSwgYW5kIHRoZSBmcmFtZSBpbmRleC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtzZXR1cERhdGFdIEFyYml0cmFyeSBzZXR1cCBkYXRhIHRvIHBhc3MgdG8gc2V0dXBGdW5jdGlvbiBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2xhYmVsRnVuY3Rpb25dIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIE1vdmllQ2xpcCBsYWJlbCB0aGF0IGlzIGFkZGVkIHdpdGggZm91clxuXHQgKiBwYXJhbWV0ZXJzOiB0aGUgbGFiZWwgbmFtZSwgdGhlIHNvdXJjZSBNb3ZpZUNsaXAgaW5zdGFuY2UsIHRoZSBzdGFydGluZyBmcmFtZSBpbmRleCAoaW4gdGhlIG1vdmllY2xpcCB0aW1lbGluZSlcblx0ICogYW5kIHRoZSBlbmQgaW5kZXguIEl0IG11c3QgcmV0dXJuIGEgbmV3IG5hbWUgZm9yIHRoZSBsYWJlbC9hbmltYXRpb24sIG9yIGBmYWxzZWAgdG8gZXhjbHVkZSB0aGUgbGFiZWwuXG5cdCAqKi9cblx0cC5hZGRNb3ZpZUNsaXAgPSBmdW5jdGlvbihzb3VyY2UsIHNvdXJjZVJlY3QsIHNjYWxlLCBzZXR1cEZ1bmN0aW9uLCBzZXR1cERhdGEsIGxhYmVsRnVuY3Rpb24pIHtcblx0XHRpZiAodGhpcy5fZGF0YSkgeyB0aHJvdyBTcHJpdGVTaGVldEJ1aWxkZXIuRVJSX1JVTk5JTkc7IH1cblx0XHR2YXIgcmVjdHMgPSBzb3VyY2UuZnJhbWVCb3VuZHM7XG5cdFx0dmFyIHJlY3QgPSBzb3VyY2VSZWN0fHxzb3VyY2UuYm91bmRzfHxzb3VyY2Uubm9taW5hbEJvdW5kcztcblx0XHRpZiAoIXJlY3QmJnNvdXJjZS5nZXRCb3VuZHMpIHsgcmVjdCA9IHNvdXJjZS5nZXRCb3VuZHMoKTsgfVxuXHRcdGlmICghcmVjdCAmJiAhcmVjdHMpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgaSwgbCwgYmFzZUZyYW1lSW5kZXggPSB0aGlzLl9mcmFtZXMubGVuZ3RoO1xuXHRcdHZhciBkdXJhdGlvbiA9IHNvdXJjZS50aW1lbGluZS5kdXJhdGlvbjtcblx0XHRmb3IgKGk9MDsgaTxkdXJhdGlvbjsgaSsrKSB7XG5cdFx0XHR2YXIgciA9IChyZWN0cyYmcmVjdHNbaV0pID8gcmVjdHNbaV0gOiByZWN0O1xuXHRcdFx0dGhpcy5hZGRGcmFtZShzb3VyY2UsIHIsIHNjYWxlLCB0aGlzLl9zZXR1cE1vdmllQ2xpcEZyYW1lLCB7aTppLCBmOnNldHVwRnVuY3Rpb24sIGQ6c2V0dXBEYXRhfSk7XG5cdFx0fVxuXHRcdHZhciBsYWJlbHMgPSBzb3VyY2UudGltZWxpbmUuX2xhYmVscztcblx0XHR2YXIgbGJscyA9IFtdO1xuXHRcdGZvciAodmFyIG4gaW4gbGFiZWxzKSB7XG5cdFx0XHRsYmxzLnB1c2goe2luZGV4OmxhYmVsc1tuXSwgbGFiZWw6bn0pO1xuXHRcdH1cblx0XHRpZiAobGJscy5sZW5ndGgpIHtcblx0XHRcdGxibHMuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS5pbmRleC1iLmluZGV4OyB9KTtcblx0XHRcdGZvciAoaT0wLGw9bGJscy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHRcdHZhciBsYWJlbCA9IGxibHNbaV0ubGFiZWw7XG5cdFx0XHRcdHZhciBzdGFydCA9IGJhc2VGcmFtZUluZGV4K2xibHNbaV0uaW5kZXg7XG5cdFx0XHRcdHZhciBlbmQgPSBiYXNlRnJhbWVJbmRleCsoKGkgPT0gbC0xKSA/IGR1cmF0aW9uIDogbGJsc1tpKzFdLmluZGV4KTtcblx0XHRcdFx0dmFyIGZyYW1lcyA9IFtdO1xuXHRcdFx0XHRmb3IgKHZhciBqPXN0YXJ0OyBqPGVuZDsgaisrKSB7IGZyYW1lcy5wdXNoKGopOyB9XG5cdFx0XHRcdGlmIChsYWJlbEZ1bmN0aW9uKSB7XG5cdFx0XHRcdFx0bGFiZWwgPSBsYWJlbEZ1bmN0aW9uKGxhYmVsLCBzb3VyY2UsIHN0YXJ0LCBlbmQpO1xuXHRcdFx0XHRcdGlmICghbGFiZWwpIHsgY29udGludWU7IH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmFkZEFuaW1hdGlvbihsYWJlbCwgZnJhbWVzLCB0cnVlKTsgLy8gZm9yIG5vdywgdGhpcyBsb29wcyBhbGwgYW5pbWF0aW9ucy5cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEJ1aWxkcyBhIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0XCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGZyYW1lcy5cblx0ICogQG1ldGhvZCBidWlsZFxuXHQgKiBAcmV0dXJuIHtTcHJpdGVTaGVldH0gVGhlIGNyZWF0ZWQgU3ByaXRlU2hlZXQgaW5zdGFuY2UsIG9yIG51bGwgaWYgYSBidWlsZCBpcyBhbHJlYWR5IHJ1bm5pbmcgb3IgYW4gZXJyb3Jcblx0ICogb2NjdXJyZWQuXG5cdCAqKi9cblx0cC5idWlsZCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9kYXRhKSB7IHRocm93IFNwcml0ZVNoZWV0QnVpbGRlci5FUlJfUlVOTklORzsgfVxuXHRcdHRoaXMuX3N0YXJ0QnVpbGQoKTtcblx0XHR3aGlsZSAodGhpcy5fZHJhd05leHQoKSkge31cblx0XHR0aGlzLl9lbmRCdWlsZCgpO1xuXHRcdHJldHVybiB0aGlzLnNwcml0ZVNoZWV0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBc3luY2hyb25vdXNseSBidWlsZHMgYSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBmcmFtZXMuIEl0IHdpbGxcblx0ICogcnVuIDIwIHRpbWVzIHBlciBzZWNvbmQsIHVzaW5nIGFuIGFtb3VudCBvZiB0aW1lIGRlZmluZWQgYnkgYHRpbWVTbGljZWAuIFdoZW4gaXQgaXMgY29tcGxldGUgaXQgd2lsbCBjYWxsIHRoZVxuXHQgKiBzcGVjaWZpZWQgY2FsbGJhY2suXG5cdCAqIEBtZXRob2QgYnVpbGRBc3luY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVTbGljZV0gU2V0cyB0aGUgdGltZVNsaWNlIHByb3BlcnR5IG9uIHRoaXMgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5idWlsZEFzeW5jID0gZnVuY3Rpb24odGltZVNsaWNlKSB7XG5cdFx0aWYgKHRoaXMuX2RhdGEpIHsgdGhyb3cgU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9SVU5OSU5HOyB9XG5cdFx0dGhpcy50aW1lU2xpY2UgPSB0aW1lU2xpY2U7XG5cdFx0dGhpcy5fc3RhcnRCdWlsZCgpO1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dGhpcy5fdGltZXJJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IF90aGlzLl9ydW4oKTsgfSwgNTAtTWF0aC5tYXgoMC4wMSwgTWF0aC5taW4oMC45OSwgdGhpcy50aW1lU2xpY2V8fDAuMykpKjUwKTtcblx0fTtcblxuXHQvKipcblx0ICogU3RvcHMgdGhlIGN1cnJlbnQgYXN5bmNocm9ub3VzIGJ1aWxkLlxuXHQgKiBAbWV0aG9kIHN0b3BBc3luY1xuXHQgKiovXG5cdHAuc3RvcEFzeW5jID0gZnVuY3Rpb24oKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVySUQpO1xuXHRcdHRoaXMuX2RhdGEgPSBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTcHJpdGVTaGVldEJ1aWxkZXIgaW5zdGFuY2VzIGNhbm5vdCBiZSBjbG9uZWQuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3coXCJTcHJpdGVTaGVldEJ1aWxkZXIgY2Fubm90IGJlIGNsb25lZC5cIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltTcHJpdGVTaGVldEJ1aWxkZXJdXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfc3RhcnRCdWlsZFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fc3RhcnRCdWlsZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYWQgPSB0aGlzLnBhZGRpbmd8fDA7XG5cdFx0dGhpcy5wcm9ncmVzcyA9IDA7XG5cdFx0dGhpcy5zcHJpdGVTaGVldCA9IG51bGw7XG5cdFx0dGhpcy5faW5kZXggPSAwO1xuXHRcdHRoaXMuX3NjYWxlID0gdGhpcy5zY2FsZTtcblx0XHR2YXIgZGF0YUZyYW1lcyA9IFtdO1xuXHRcdHRoaXMuX2RhdGEgPSB7XG5cdFx0XHRpbWFnZXM6IFtdLFxuXHRcdFx0ZnJhbWVzOiBkYXRhRnJhbWVzLFxuXHRcdFx0ZnJhbWVyYXRlOiB0aGlzLmZyYW1lcmF0ZSxcblx0XHRcdGFuaW1hdGlvbnM6IHRoaXMuX2FuaW1hdGlvbnMgLy8gVE9ETzogc2hvdWxkIHdlIFwiY2xvbmVcIiBfYW5pbWF0aW9ucyBpbiBjYXNlIHNvbWVvbmUgYWRkcyBtb3JlIGFuaW1hdGlvbnMgYWZ0ZXIgYSBidWlsZD9cblx0XHR9O1xuXG5cdFx0dmFyIGZyYW1lcyA9IHRoaXMuX2ZyYW1lcy5zbGljZSgpO1xuXHRcdGZyYW1lcy5zb3J0KGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gKGEuaGVpZ2h0PD1iLmhlaWdodCkgPyAtMSA6IDE7IH0pO1xuXG5cdFx0aWYgKGZyYW1lc1tmcmFtZXMubGVuZ3RoLTFdLmhlaWdodCtwYWQqMiA+IHRoaXMubWF4SGVpZ2h0KSB7IHRocm93IFNwcml0ZVNoZWV0QnVpbGRlci5FUlJfRElNRU5TSU9OUzsgfVxuXHRcdHZhciB5PTAsIHg9MDtcblx0XHR2YXIgaW1nID0gMDtcblx0XHR3aGlsZSAoZnJhbWVzLmxlbmd0aCkge1xuXHRcdFx0dmFyIG8gPSB0aGlzLl9maWxsUm93KGZyYW1lcywgeSwgaW1nLCBkYXRhRnJhbWVzLCBwYWQpO1xuXHRcdFx0aWYgKG8udyA+IHgpIHsgeCA9IG8udzsgfVxuXHRcdFx0eSArPSBvLmg7XG5cdFx0XHRpZiAoIW8uaCB8fCAhZnJhbWVzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgY2FudmFzID0gY3JlYXRlanMuY3JlYXRlQ2FudmFzP2NyZWF0ZWpzLmNyZWF0ZUNhbnZhcygpOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cdFx0XHRcdGNhbnZhcy53aWR0aCA9IHRoaXMuX2dldFNpemUoeCx0aGlzLm1heFdpZHRoKTtcblx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IHRoaXMuX2dldFNpemUoeSx0aGlzLm1heEhlaWdodCk7XG5cdFx0XHRcdHRoaXMuX2RhdGEuaW1hZ2VzW2ltZ10gPSBjYW52YXM7XG5cdFx0XHRcdGlmICghby5oKSB7XG5cdFx0XHRcdFx0eD15PTA7XG5cdFx0XHRcdFx0aW1nKys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfc2V0dXBNb3ZpZUNsaXBGcmFtZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIHdpZHRoICYgaGVpZ2h0IG9mIHRoZSByb3cuXG5cdCAqKi9cblx0cC5fc2V0dXBNb3ZpZUNsaXBGcmFtZSA9IGZ1bmN0aW9uKHNvdXJjZSwgZGF0YSkge1xuXHRcdHZhciBhZSA9IHNvdXJjZS5hY3Rpb25zRW5hYmxlZDtcblx0XHRzb3VyY2UuYWN0aW9uc0VuYWJsZWQgPSBmYWxzZTtcblx0XHRzb3VyY2UuZ290b0FuZFN0b3AoZGF0YS5pKTtcblx0XHRzb3VyY2UuYWN0aW9uc0VuYWJsZWQgPSBhZTtcblx0XHRkYXRhLmYmJmRhdGEuZihzb3VyY2UsIGRhdGEuZCwgZGF0YS5pKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0U2l6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIHdpZHRoICYgaGVpZ2h0IG9mIHRoZSByb3cuXG5cdCAqKi9cblx0cC5fZ2V0U2l6ZSA9IGZ1bmN0aW9uKHNpemUsbWF4KSB7XG5cdFx0dmFyIHBvdyA9IDQ7XG5cdFx0d2hpbGUgKE1hdGgucG93KDIsKytwb3cpIDwgc2l6ZSl7fVxuXHRcdHJldHVybiBNYXRoLm1pbihtYXgsTWF0aC5wb3coMixwb3cpKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfZmlsbFJvd1xuXHQgKiBAcGFyYW0ge0FycmF5fSBmcmFtZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBpbWdcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFGcmFtZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhZFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIHdpZHRoICYgaGVpZ2h0IG9mIHRoZSByb3cuXG5cdCAqKi9cblx0cC5fZmlsbFJvdyA9IGZ1bmN0aW9uKGZyYW1lcywgeSwgaW1nLCBkYXRhRnJhbWVzLCBwYWQpIHtcblx0XHR2YXIgdyA9IHRoaXMubWF4V2lkdGg7XG5cdFx0dmFyIG1heEggPSB0aGlzLm1heEhlaWdodDtcblx0XHR5ICs9IHBhZDtcblx0XHR2YXIgaCA9IG1heEgteTtcblx0XHR2YXIgeCA9IHBhZDtcblx0XHR2YXIgaGVpZ2h0ID0gMDtcblx0XHRmb3IgKHZhciBpPWZyYW1lcy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG5cdFx0XHR2YXIgZnJhbWUgPSBmcmFtZXNbaV07XG5cdFx0XHR2YXIgc2MgPSB0aGlzLl9zY2FsZSpmcmFtZS5zY2FsZTtcblx0XHRcdHZhciByZWN0ID0gZnJhbWUuc291cmNlUmVjdDtcblx0XHRcdHZhciBzb3VyY2UgPSBmcmFtZS5zb3VyY2U7XG5cdFx0XHR2YXIgcnggPSBNYXRoLmZsb29yKHNjKnJlY3QueC1wYWQpO1xuXHRcdFx0dmFyIHJ5ID0gTWF0aC5mbG9vcihzYypyZWN0LnktcGFkKTtcblx0XHRcdHZhciByaCA9IE1hdGguY2VpbChzYypyZWN0LmhlaWdodCtwYWQqMik7XG5cdFx0XHR2YXIgcncgPSBNYXRoLmNlaWwoc2MqcmVjdC53aWR0aCtwYWQqMik7XG5cdFx0XHRpZiAocncgPiB3KSB7IHRocm93IFNwcml0ZVNoZWV0QnVpbGRlci5FUlJfRElNRU5TSU9OUzsgfVxuXHRcdFx0aWYgKHJoID4gaCB8fCB4K3J3ID4gdykgeyBjb250aW51ZTsgfVxuXHRcdFx0ZnJhbWUuaW1nID0gaW1nO1xuXHRcdFx0ZnJhbWUucmVjdCA9IG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoeCx5LHJ3LHJoKTtcblx0XHRcdGhlaWdodCA9IGhlaWdodCB8fCByaDtcblx0XHRcdGZyYW1lcy5zcGxpY2UoaSwxKTtcblx0XHRcdGRhdGFGcmFtZXNbZnJhbWUuaW5kZXhdID0gW3gseSxydyxyaCxpbWcsTWF0aC5yb3VuZCgtcngrc2Mqc291cmNlLnJlZ1gtcGFkKSxNYXRoLnJvdW5kKC1yeStzYypzb3VyY2UucmVnWS1wYWQpXTtcblx0XHRcdHggKz0gcnc7XG5cdFx0fVxuXHRcdHJldHVybiB7dzp4LCBoOmhlaWdodH07XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2VuZEJ1aWxkXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9lbmRCdWlsZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc3ByaXRlU2hlZXQgPSBuZXcgY3JlYXRlanMuU3ByaXRlU2hlZXQodGhpcy5fZGF0YSk7XG5cdFx0dGhpcy5fZGF0YSA9IG51bGw7XG5cdFx0dGhpcy5wcm9ncmVzcyA9IDE7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiY29tcGxldGVcIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3J1blxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fcnVuID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRzID0gTWF0aC5tYXgoMC4wMSwgTWF0aC5taW4oMC45OSwgdGhpcy50aW1lU2xpY2V8fDAuMykpKjUwO1xuXHRcdHZhciB0ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSt0cztcblx0XHR2YXIgY29tcGxldGUgPSBmYWxzZTtcblx0XHR3aGlsZSAodCA+IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkpIHtcblx0XHRcdGlmICghdGhpcy5fZHJhd05leHQoKSkgeyBjb21wbGV0ZSA9IHRydWU7IGJyZWFrOyB9XG5cdFx0fVxuXHRcdGlmIChjb21wbGV0ZSkge1xuXHRcdFx0dGhpcy5fZW5kQnVpbGQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHRcdHRoaXMuX3RpbWVySUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBfdGhpcy5fcnVuKCk7IH0sIDUwLXRzKTtcblx0XHR9XG5cdFx0dmFyIHAgPSB0aGlzLnByb2dyZXNzID0gdGhpcy5faW5kZXgvdGhpcy5fZnJhbWVzLmxlbmd0aDtcblx0XHRpZiAodGhpcy5oYXNFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIikpIHtcblx0XHRcdHZhciBldnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJwcm9ncmVzc1wiKTtcblx0XHRcdGV2dC5wcm9ncmVzcyA9IHA7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2RyYXdOZXh0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiBCb29sZWFuIFJldHVybnMgZmFsc2UgaWYgdGhpcyBpcyB0aGUgbGFzdCBkcmF3LlxuXHQgKiovXG5cdHAuX2RyYXdOZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGZyYW1lID0gdGhpcy5fZnJhbWVzW3RoaXMuX2luZGV4XTtcblx0XHR2YXIgc2MgPSBmcmFtZS5zY2FsZSp0aGlzLl9zY2FsZTtcblx0XHR2YXIgcmVjdCA9IGZyYW1lLnJlY3Q7XG5cdFx0dmFyIHNvdXJjZVJlY3QgPSBmcmFtZS5zb3VyY2VSZWN0O1xuXHRcdHZhciBjYW52YXMgPSB0aGlzLl9kYXRhLmltYWdlc1tmcmFtZS5pbWddO1xuXHRcdHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdGZyYW1lLmZ1bmN0JiZmcmFtZS5mdW5jdChmcmFtZS5zb3VyY2UsIGZyYW1lLmRhdGEpO1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5yZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG5cdFx0Y3R4LmNsaXAoKTtcblx0XHRjdHgudHJhbnNsYXRlKE1hdGguY2VpbChyZWN0Lngtc291cmNlUmVjdC54KnNjKSwgTWF0aC5jZWlsKHJlY3QueS1zb3VyY2VSZWN0Lnkqc2MpKTtcblx0XHRjdHguc2NhbGUoc2Msc2MpO1xuXHRcdGZyYW1lLnNvdXJjZS5kcmF3KGN0eCk7IC8vIGRpc3BsYXkgb2JqZWN0IHdpbGwgZHJhdyBpdHNlbGYuXG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRyZXR1cm4gKCsrdGhpcy5faW5kZXgpIDwgdGhpcy5fZnJhbWVzLmxlbmd0aDtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLlNwcml0ZVNoZWV0QnVpbGRlciA9IGNyZWF0ZWpzLnByb21vdGUoU3ByaXRlU2hlZXRCdWlsZGVyLCBcIkV2ZW50RGlzcGF0Y2hlclwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBET01FbGVtZW50LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogPGI+VGhpcyBjbGFzcyBpcyBzdGlsbCBleHBlcmltZW50YWwsIGFuZCBtb3JlIGFkdmFuY2VkIHVzZSBpcyBsaWtlbHkgdG8gYmUgYnVnZ3kuIFBsZWFzZSByZXBvcnQgYnVncy48L2I+XG5cdCAqXG5cdCAqIEEgRE9NRWxlbWVudCBhbGxvd3MgeW91IHRvIGFzc29jaWF0ZSBhIEhUTUxFbGVtZW50IHdpdGggdGhlIGRpc3BsYXkgbGlzdC4gSXQgd2lsbCBiZSB0cmFuc2Zvcm1lZFxuXHQgKiB3aXRoaW4gdGhlIERPTSBhcyB0aG91Z2ggaXQgaXMgY2hpbGQgb2YgdGhlIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lclwifX17ey9jcm9zc0xpbmt9fSBpdCBpcyBhZGRlZCB0by4gSG93ZXZlciwgaXQgaXNcblx0ICogbm90IHJlbmRlcmVkIHRvIGNhbnZhcywgYW5kIGFzIHN1Y2ggd2lsbCByZXRhaW4gd2hhdGV2ZXIgei1pbmRleCBpdCBoYXMgcmVsYXRpdmUgdG8gdGhlIGNhbnZhcyAoaWUuIGl0IHdpbGwgYmVcblx0ICogZHJhd24gaW4gZnJvbnQgb2Ygb3IgYmVoaW5kIHRoZSBjYW52YXMpLlxuXHQgKlxuXHQgKiBUaGUgcG9zaXRpb24gb2YgYSBET01FbGVtZW50IGlzIHJlbGF0aXZlIHRvIHRoZWlyIHBhcmVudCBub2RlIGluIHRoZSBET00uIEl0IGlzIHJlY29tbWVuZGVkIHRoYXRcblx0ICogdGhlIERPTSBPYmplY3QgYmUgYWRkZWQgdG8gYSBkaXYgdGhhdCBhbHNvIGNvbnRhaW5zIHRoZSBjYW52YXMgc28gdGhhdCB0aGV5IHNoYXJlIHRoZSBzYW1lIHBvc2l0aW9uXG5cdCAqIG9uIHRoZSBwYWdlLlxuXHQgKlxuXHQgKiBET01FbGVtZW50IGlzIHVzZWZ1bCBmb3IgcG9zaXRpb25pbmcgSFRNTCBlbGVtZW50cyBvdmVyIHRvcCBvZiBjYW52YXMgY29udGVudCwgYW5kIGZvciBlbGVtZW50c1xuXHQgKiB0aGF0IHlvdSB3YW50IHRvIGRpc3BsYXkgb3V0c2lkZSB0aGUgYm91bmRzIG9mIHRoZSBjYW52YXMuIEZvciBleGFtcGxlLCBhIHRvb2x0aXAgd2l0aCByaWNoIEhUTUxcblx0ICogY29udGVudC5cblx0ICpcblx0ICogPGg0Pk1vdXNlIEludGVyYWN0aW9uPC9oND5cblx0ICpcblx0ICogRE9NRWxlbWVudCBpbnN0YW5jZXMgYXJlIG5vdCBmdWxsIEVhc2VsSlMgZGlzcGxheSBvYmplY3RzLCBhbmQgZG8gbm90IHBhcnRpY2lwYXRlIGluIEVhc2VsSlMgbW91c2Vcblx0ICogZXZlbnRzIG9yIHN1cHBvcnQgbWV0aG9kcyBsaWtlIGhpdFRlc3QuIFRvIGdldCBtb3VzZSBldmVudHMgZnJvbSBhIERPTUVsZW1lbnQsIHlvdSBtdXN0IGluc3RlYWQgYWRkIGhhbmRsZXJzIHRvXG5cdCAqIHRoZSBodG1sRWxlbWVudCAobm90ZSwgdGhpcyBkb2VzIG5vdCBzdXBwb3J0IEV2ZW50RGlzcGF0Y2hlcilcblx0ICpcblx0ICogICAgICB2YXIgZG9tRWxlbWVudCA9IG5ldyBjcmVhdGVqcy5ET01FbGVtZW50KGh0bWxFbGVtZW50KTtcblx0ICogICAgICBkb21FbGVtZW50Lmh0bWxFbGVtZW50Lm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcblx0ICogICAgICAgICAgY29uc29sZS5sb2coXCJjbGlja2VkXCIpO1xuXHQgKiAgICAgIH1cblx0ICpcblx0ICogQGNsYXNzIERPTUVsZW1lbnRcblx0ICogQGV4dGVuZHMgRGlzcGxheU9iamVjdFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaHRtbEVsZW1lbnQgQSByZWZlcmVuY2Ugb3IgaWQgZm9yIHRoZSBET00gZWxlbWVudCB0byBtYW5hZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBET01FbGVtZW50KGh0bWxFbGVtZW50KSB7XG5cdFx0dGhpcy5EaXNwbGF5T2JqZWN0X2NvbnN0cnVjdG9yKCk7XG5cdFx0XG5cdFx0aWYgKHR5cGVvZihodG1sRWxlbWVudCk9PVwic3RyaW5nXCIpIHsgaHRtbEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChodG1sRWxlbWVudCk7IH1cblx0XHR0aGlzLm1vdXNlRW5hYmxlZCA9IGZhbHNlO1xuXHRcdFxuXHRcdHZhciBzdHlsZSA9IGh0bWxFbGVtZW50LnN0eWxlO1xuXHRcdHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdHN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IHN0eWxlLldlYmtpdFRyYW5zZm9ybU9yaWdpbiA9IHN0eWxlLm1zVHJhbnNmb3JtT3JpZ2luID0gc3R5bGUuTW96VHJhbnNmb3JtT3JpZ2luID0gc3R5bGUuT1RyYW5zZm9ybU9yaWdpbiA9IFwiMCUgMCVcIjtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIERPTSBvYmplY3QgdG8gbWFuYWdlLlxuXHRcdCAqIEBwcm9wZXJ0eSBodG1sRWxlbWVudFxuXHRcdCAqIEB0eXBlIEhUTUxFbGVtZW50XG5cdFx0ICovXG5cdFx0dGhpcy5odG1sRWxlbWVudCA9IGh0bWxFbGVtZW50O1xuXHRcblx0XG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX29sZE10eFxuXHRcdCAqIEB0eXBlIE1hdHJpeDJEXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX29sZFByb3BzID0gbnVsbDtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChET01FbGVtZW50LCBjcmVhdGVqcy5EaXNwbGF5T2JqZWN0KTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXMuXG5cdCAqIFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3Igd2hldGhlciBpdCB3b3VsZCBiZSB2aXNpYmxlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgc3RhZ2UuXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBpc1Zpc2libGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXNcblx0ICovXG5cdHAuaXNWaXNpYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuaHRtbEVsZW1lbnQgIT0gbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgdGhlIGRpc3BsYXkgb2JqZWN0IGludG8gdGhlIHNwZWNpZmllZCBjb250ZXh0IGlnbm9yaW5nIGl0cyB2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBhbmQgdHJhbnNmb3JtLlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRyYXcgd2FzIGhhbmRsZWQgKHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyBmdW5jdGlvbmFsaXR5KS5cblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGRyYXdcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIGNvbnRleHQgb2JqZWN0IHRvIGRyYXcgaW50by5cblx0ICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVDYWNoZSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZHJhdyBvcGVyYXRpb24gc2hvdWxkIGlnbm9yZSBhbnkgY3VycmVudCBjYWNoZS5cblx0ICogRm9yIGV4YW1wbGUsIHVzZWQgZm9yIGRyYXdpbmcgdGhlIGNhY2hlICh0byBwcmV2ZW50IGl0IGZyb20gc2ltcGx5IGRyYXdpbmcgYW4gZXhpc3RpbmcgY2FjaGUgYmFja1xuXHQgKiBpbnRvIGl0c2VsZikuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRwLmRyYXcgPSBmdW5jdGlvbihjdHgsIGlnbm9yZUNhY2hlKSB7XG5cdFx0Ly8gdGhpcyByZWxpZXMgb24gdGhlIF90aWNrIG1ldGhvZCBiZWNhdXNlIGRyYXcgaXNuJ3QgY2FsbGVkIGlmIHRoZSBwYXJlbnQgaXMgbm90IHZpc2libGUuXG5cdFx0Ly8gdGhlIGFjdHVhbCB1cGRhdGUgaGFwcGVucyBpbiBfaGFuZGxlRHJhd0VuZFxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBOb3QgYXBwbGljYWJsZSB0byBET01FbGVtZW50LlxuXHQgKiBAbWV0aG9kIGNhY2hlXG5cdCAqL1xuXHRwLmNhY2hlID0gZnVuY3Rpb24oKSB7fTtcblxuXHQvKipcblx0ICogTm90IGFwcGxpY2FibGUgdG8gRE9NRWxlbWVudC5cblx0ICogQG1ldGhvZCB1bmNhY2hlXG5cdCAqL1xuXHRwLnVuY2FjaGUgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qKlxuXHQgKiBOb3QgYXBwbGljYWJsZSB0byBET01FbGVtZW50LlxuXHQgKiBAbWV0aG9kIHVwZGF0ZUNhY2hlXG5cdCAqL1xuXHRwLnVwZGF0ZUNhY2hlID0gZnVuY3Rpb24oKSB7fTtcblxuXHQvKipcblx0ICogTm90IGFwcGxpY2FibGUgdG8gRE9NRWxlbWVudC5cblx0ICogQG1ldGhvZCBoaXRUZXN0XG5cdCAqL1xuXHRwLmhpdFRlc3QgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qKlxuXHQgKiBOb3QgYXBwbGljYWJsZSB0byBET01FbGVtZW50LlxuXHQgKiBAbWV0aG9kIGxvY2FsVG9HbG9iYWxcblx0ICovXG5cdHAubG9jYWxUb0dsb2JhbCA9IGZ1bmN0aW9uKCkge307XG5cblx0LyoqXG5cdCAqIE5vdCBhcHBsaWNhYmxlIHRvIERPTUVsZW1lbnQuXG5cdCAqIEBtZXRob2QgZ2xvYmFsVG9Mb2NhbFxuXHQgKi9cblx0cC5nbG9iYWxUb0xvY2FsID0gZnVuY3Rpb24oKSB7fTtcblxuXHQvKipcblx0ICogTm90IGFwcGxpY2FibGUgdG8gRE9NRWxlbWVudC5cblx0ICogQG1ldGhvZCBsb2NhbFRvTG9jYWxcblx0ICovXG5cdHAubG9jYWxUb0xvY2FsID0gZnVuY3Rpb24oKSB7fTtcblxuXHQvKipcblx0ICogRE9NRWxlbWVudCBjYW5ub3QgYmUgY2xvbmVkLiBUaHJvd3MgYW4gZXJyb3IuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyhcIkRPTUVsZW1lbnQgY2Fubm90IGJlIGNsb25lZC5cIilcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbRE9NRWxlbWVudCAobmFtZT1cIisgIHRoaXMubmFtZSArXCIpXVwiO1xuXHR9O1xuXG5cdC8qKlxuICAgICAqIEludGVyYWN0aW9uIGV2ZW50cyBzaG91bGQgYmUgYWRkZWQgdG8gYGh0bWxFbGVtZW50YCwgYW5kIG5vdCB0aGUgRE9NRWxlbWVudCBpbnN0YW5jZSwgc2luY2UgRE9NRWxlbWVudCBpbnN0YW5jZXNcblx0ICogYXJlIG5vdCBmdWxsIEVhc2VsSlMgZGlzcGxheSBvYmplY3RzIGFuZCBkbyBub3QgcGFydGljaXBhdGUgaW4gRWFzZWxKUyBtb3VzZSBldmVudHMuXG5cdCAqIEBldmVudCBjbGlja1xuXHQgKi9cblxuICAgICAvKipcbiAgICAgKiBJbnRlcmFjdGlvbiBldmVudHMgc2hvdWxkIGJlIGFkZGVkIHRvIGBodG1sRWxlbWVudGAsIGFuZCBub3QgdGhlIERPTUVsZW1lbnQgaW5zdGFuY2UsIHNpbmNlIERPTUVsZW1lbnQgaW5zdGFuY2VzXG4gXHQgKiBhcmUgbm90IGZ1bGwgRWFzZWxKUyBkaXNwbGF5IG9iamVjdHMgYW5kIGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiBFYXNlbEpTIG1vdXNlIGV2ZW50cy5cblx0ICogQGV2ZW50IGRibENsaWNrXG5cdCAqL1xuXG4gICAgIC8qKlxuICAgICAgKiBJbnRlcmFjdGlvbiBldmVudHMgc2hvdWxkIGJlIGFkZGVkIHRvIGBodG1sRWxlbWVudGAsIGFuZCBub3QgdGhlIERPTUVsZW1lbnQgaW5zdGFuY2UsIHNpbmNlIERPTUVsZW1lbnQgaW5zdGFuY2VzXG4gXHQgICogYXJlIG5vdCBmdWxsIEVhc2VsSlMgZGlzcGxheSBvYmplY3RzIGFuZCBkbyBub3QgcGFydGljaXBhdGUgaW4gRWFzZWxKUyBtb3VzZSBldmVudHMuXG5cdCAgKiBAZXZlbnQgbW91c2Vkb3duXG5cdCAgKi9cblxuICAgICAvKipcbiAgICAgICogVGhlIEhUTUxFbGVtZW50IGNhbiBsaXN0ZW4gZm9yIHRoZSBtb3VzZW92ZXIgZXZlbnQsIG5vdCB0aGUgRE9NRWxlbWVudCBpbnN0YW5jZS5cbiAgICAgICogU2luY2UgRE9NRWxlbWVudCBpbnN0YW5jZXMgYXJlIG5vdCBmdWxsIEVhc2VsSlMgZGlzcGxheSBvYmplY3RzIGFuZCBkbyBub3QgcGFydGljaXBhdGUgaW4gRWFzZWxKUyBtb3VzZSBldmVudHMuXG4gICAgICAqIEBldmVudCBtb3VzZW92ZXJcblx0ICAqL1xuXG4gICAgIC8qKlxuICAgICAgKiBOb3QgYXBwbGljYWJsZSB0byBET01FbGVtZW50LlxuXHQgICogQGV2ZW50IHRpY2tcblx0ICAqL1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX3RpY2tcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2dE9iaiBBbiBldmVudCBvYmplY3QgdGhhdCB3aWxsIGJlIGRpc3BhdGNoZWQgdG8gYWxsIHRpY2sgbGlzdGVuZXJzLiBUaGlzIG9iamVjdCBpcyByZXVzZWQgYmV0d2VlbiBkaXNwYXRjaGVycyB0byByZWR1Y2UgY29uc3RydWN0aW9uICYgR0MgY29zdHMuXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl90aWNrID0gZnVuY3Rpb24oZXZ0T2JqKSB7XG5cdFx0dmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpO1xuXHRcdHN0YWdlJiZzdGFnZS5vbihcImRyYXdlbmRcIiwgdGhpcy5faGFuZGxlRHJhd0VuZCwgdGhpcywgdHJ1ZSk7XG5cdFx0dGhpcy5EaXNwbGF5T2JqZWN0X190aWNrKGV2dE9iaik7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlRHJhd0VuZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldnRcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5faGFuZGxlRHJhd0VuZCA9IGZ1bmN0aW9uKGV2dCkge1xuXHRcdHZhciBvID0gdGhpcy5odG1sRWxlbWVudDtcblx0XHRpZiAoIW8pIHsgcmV0dXJuOyB9XG5cdFx0dmFyIHN0eWxlID0gby5zdHlsZTtcblx0XHRcblx0XHR2YXIgcHJvcHMgPSB0aGlzLmdldENvbmNhdGVuYXRlZERpc3BsYXlQcm9wcyh0aGlzLl9wcm9wcyksIG10eCA9IHByb3BzLm1hdHJpeDtcblx0XHRcblx0XHR2YXIgdmlzaWJpbGl0eSA9IHByb3BzLnZpc2libGUgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCI7XG5cdFx0aWYgKHZpc2liaWxpdHkgIT0gc3R5bGUudmlzaWJpbGl0eSkgeyBzdHlsZS52aXNpYmlsaXR5ID0gdmlzaWJpbGl0eTsgfVxuXHRcdGlmICghcHJvcHMudmlzaWJsZSkgeyByZXR1cm47IH1cblx0XHRcblx0XHR2YXIgb2xkUHJvcHMgPSB0aGlzLl9vbGRQcm9wcywgb2xkTXR4ID0gb2xkUHJvcHMmJm9sZFByb3BzLm1hdHJpeDtcblx0XHR2YXIgbiA9IDEwMDAwOyAvLyBwcmVjaXNpb25cblx0XHRcblx0XHRpZiAoIW9sZE10eCB8fCAhb2xkTXR4LmVxdWFscyhtdHgpKSB7XG5cdFx0XHR2YXIgc3RyID0gXCJtYXRyaXgoXCIgKyAobXR4LmEqbnwwKS9uICtcIixcIisgKG10eC5iKm58MCkvbiArXCIsXCIrIChtdHguYypufDApL24gK1wiLFwiKyAobXR4LmQqbnwwKS9uICtcIixcIisgKG10eC50eCswLjV8MCk7XG5cdFx0XHRzdHlsZS50cmFuc2Zvcm0gPSBzdHlsZS5XZWJraXRUcmFuc2Zvcm0gPSBzdHlsZS5PVHJhbnNmb3JtID0gc3R5bGUubXNUcmFuc2Zvcm0gPSBzdHIgK1wiLFwiKyAobXR4LnR5KzAuNXwwKSArXCIpXCI7XG5cdFx0XHRzdHlsZS5Nb3pUcmFuc2Zvcm0gPSBzdHIgK1wicHgsXCIrIChtdHgudHkrMC41fDApICtcInB4KVwiO1xuXHRcdFx0aWYgKCFvbGRQcm9wcykgeyBvbGRQcm9wcyA9IHRoaXMuX29sZFByb3BzID0gbmV3IGNyZWF0ZWpzLkRpc3BsYXlQcm9wcyh0cnVlLCBOYU4pOyB9XG5cdFx0XHRvbGRQcm9wcy5tYXRyaXguY29weShtdHgpO1xuXHRcdH1cblx0XHRcblx0XHRpZiAob2xkUHJvcHMuYWxwaGEgIT0gcHJvcHMuYWxwaGEpIHtcblx0XHRcdHN0eWxlLm9wYWNpdHkgPSBcIlwiKyhwcm9wcy5hbHBoYSpufDApL247XG5cdFx0XHRvbGRQcm9wcy5hbHBoYSA9IHByb3BzLmFscGhhO1xuXHRcdH1cblx0fTtcblxuXG5cdGNyZWF0ZWpzLkRPTUVsZW1lbnQgPSBjcmVhdGVqcy5wcm9tb3RlKERPTUVsZW1lbnQsIFwiRGlzcGxheU9iamVjdFwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBGaWx0ZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBCYXNlIGNsYXNzIHRoYXQgYWxsIGZpbHRlcnMgc2hvdWxkIGluaGVyaXQgZnJvbS4gRmlsdGVycyBuZWVkIHRvIGJlIGFwcGxpZWQgdG8gb2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBjYWNoZWQgdXNpbmdcblx0ICogdGhlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvY2FjaGVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLiBJZiBhbiBvYmplY3QgY2hhbmdlcywgcGxlYXNlIGNhY2hlIGl0IGFnYWluLCBvciB1c2Vcblx0ICoge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC91cGRhdGVDYWNoZVwifX17ey9jcm9zc0xpbmt9fS4gTm90ZSB0aGF0IHRoZSBmaWx0ZXJzIG11c3QgYmUgYXBwbGllZCBiZWZvcmUgY2FjaGluZy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIG15SW5zdGFuY2UuZmlsdGVycyA9IFtcblx0ICogICAgICAgICAgbmV3IGNyZWF0ZWpzLkNvbG9yRmlsdGVyKDAsIDAsIDAsIDEsIDI1NSwgMCwgMCksXG5cdCAqICAgICAgICAgIG5ldyBjcmVhdGVqcy5CbHVyRmlsdGVyKDUsIDUsIDEwKVxuXHQgKiAgICAgIF07XG5cdCAqICAgICAgbXlJbnN0YW5jZS5jYWNoZSgwLDAsIDEwMCwgMTAwKTtcblx0ICpcblx0ICogTm90ZSB0aGF0IGVhY2ggZmlsdGVyIGNhbiBpbXBsZW1lbnQgYSB7eyNjcm9zc0xpbmsgXCJGaWx0ZXIvZ2V0Qm91bmRzXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCwgd2hpY2ggcmV0dXJucyB0aGVcblx0ICogbWFyZ2lucyB0aGF0IG5lZWQgdG8gYmUgYXBwbGllZCBpbiBvcmRlciB0byBmdWxseSBkaXNwbGF5IHRoZSBmaWx0ZXIuIEZvciBleGFtcGxlLCB0aGUge3sjY3Jvc3NMaW5rIFwiQmx1ckZpbHRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aWxsIGNhdXNlIGFuIG9iamVjdCB0byBmZWF0aGVyIG91dHdhcmRzLCByZXN1bHRpbmcgaW4gYSBtYXJnaW4gYXJvdW5kIHRoZSBzaGFwZS5cblx0ICpcblx0ICogPGg0PkVhc2VsSlMgRmlsdGVyczwvaDQ+XG5cdCAqIEVhc2VsSlMgY29tZXMgd2l0aCBhIG51bWJlciBvZiBwcmUtYnVpbHQgZmlsdGVyczpcblx0ICogPHVsPjxsaT57eyNjcm9zc0xpbmsgXCJBbHBoYU1hcEZpbHRlclwifX17ey9jcm9zc0xpbmt9fSA6IE1hcCBhIGdyZXlzY2FsZSBpbWFnZSB0byB0aGUgYWxwaGEgY2hhbm5lbCBvZiBhIGRpc3BsYXkgb2JqZWN0PC9saT5cblx0ICogICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWxwaGFNYXNrRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319OiBNYXAgYW4gaW1hZ2UncyBhbHBoYSBjaGFubmVsIHRvIHRoZSBhbHBoYSBjaGFubmVsIG9mIGEgZGlzcGxheSBvYmplY3Q8L2xpPlxuXHQgKiAgICAgIDxsaT57eyNjcm9zc0xpbmsgXCJCbHVyRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319OiBBcHBseSB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBibHVyIHRvIGEgZGlzcGxheSBvYmplY3Q8L2xpPlxuXHQgKiAgICAgIDxsaT57eyNjcm9zc0xpbmsgXCJDb2xvckZpbHRlclwifX17ey9jcm9zc0xpbmt9fTogQ29sb3IgdHJhbnNmb3JtIGEgZGlzcGxheSBvYmplY3Q8L2xpPlxuXHQgKiAgICAgIDxsaT57eyNjcm9zc0xpbmsgXCJDb2xvck1hdHJpeEZpbHRlclwifX17ey9jcm9zc0xpbmt9fTogVHJhbnNmb3JtIGFuIGltYWdlIHVzaW5nIGEge3sjY3Jvc3NMaW5rIFwiQ29sb3JNYXRyaXhcIn19e3svY3Jvc3NMaW5rfX08L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiBAY2xhc3MgRmlsdGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIEZpbHRlcigpIHt9XG5cdHZhciBwID0gRmlsdGVyLnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBQcm92aWRlcyBwYWRkaW5nIHZhbHVlcyBmb3IgdGhpcyBmaWx0ZXIuIFRoYXQgaXMsIGhvdyBtdWNoIHRoZSBmaWx0ZXIgd2lsbCBleHRlbmQgdGhlIHZpc3VhbCBib3VuZHMgb2YgYW4gb2JqZWN0IGl0IGlzIGFwcGxpZWQgdG8uXG5cdCAqIEBtZXRob2QgZ2V0Qm91bmRzXG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBbcmVjdF0gSWYgc3BlY2lmaWVkLCB0aGUgcHJvdmlkZWQgUmVjdGFuZ2xlIGluc3RhbmNlIHdpbGwgYmUgZXhwYW5kZWQgYnkgdGhlIHBhZGRpbmcgYW1vdW50cyBhbmQgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gSWYgYSBgcmVjdGAgcGFyYW0gd2FzIHByb3ZpZGVkLCBpdCBpcyByZXR1cm5lZC4gSWYgbm90LCBlaXRoZXIgYSBuZXcgcmVjdGFuZ2xlIHdpdGggdGhlIHBhZGRpbmcgdmFsdWVzLCBvciBudWxsIGlmIG5vIHBhZGRpbmcgaXMgcmVxdWlyZWQgZm9yIHRoaXMgZmlsdGVyLlxuXHQgKiovXG5cdHAuZ2V0Qm91bmRzID0gZnVuY3Rpb24ocmVjdCkge1xuXHRcdHJldHVybiByZWN0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIHRoZSBmaWx0ZXIgdG8gdGhlIHNwZWNpZmllZCBjb250ZXh0LlxuXHQgKiBAbWV0aG9kIGFwcGx5RmlsdGVyXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIDJEIGNvbnRleHQgdG8gdXNlIGFzIHRoZSBzb3VyY2UuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIHRvIHVzZSBmb3IgdGhlIHNvdXJjZSByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiB0byB1c2UgZm9yIHRoZSBzb3VyY2UgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIFRoZSB3aWR0aCB0byB1c2UgZm9yIHRoZSBzb3VyY2UgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IHRvIHVzZSBmb3IgdGhlIHNvdXJjZSByZWN0LlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gW3RhcmdldEN0eF0gVGhlIDJEIGNvbnRleHQgdG8gZHJhdyB0aGUgcmVzdWx0IHRvLiBEZWZhdWx0cyB0byB0aGUgY29udGV4dCBwYXNzZWQgdG8gY3R4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RhcmdldFhdIFRoZSB4IHBvc2l0aW9uIHRvIGRyYXcgdGhlIHJlc3VsdCB0by4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIHBhc3NlZCB0byB4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RhcmdldFldIFRoZSB5IHBvc2l0aW9uIHRvIGRyYXcgdGhlIHJlc3VsdCB0by4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIHBhc3NlZCB0byB5LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgZmlsdGVyIHdhcyBhcHBsaWVkIHN1Y2Nlc3NmdWxseS5cblx0ICoqL1xuXHRwLmFwcGx5RmlsdGVyID0gZnVuY3Rpb24oY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0YXJnZXRDdHgsIHRhcmdldFgsIHRhcmdldFkpIHtcblx0XHQvLyB0aGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBiZWNhdXNlIG1vc3QgZmlsdGVycyBhY2Nlc3MgcGl4ZWwgZGF0YS4gSXQgaXMgb3ZlcnJpZGRlbiB3aGVuIG5vdCBuZWVkZWQuXG5cdFx0dGFyZ2V0Q3R4ID0gdGFyZ2V0Q3R4IHx8IGN0eDtcblx0XHRpZiAodGFyZ2V0WCA9PSBudWxsKSB7IHRhcmdldFggPSB4OyB9XG5cdFx0aWYgKHRhcmdldFkgPT0gbnVsbCkgeyB0YXJnZXRZID0geTsgfVxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9hcHBseUZpbHRlcihpbWFnZURhdGEpKSB7XG5cdFx0XHR0YXJnZXRDdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgdGFyZ2V0WCwgdGFyZ2V0WSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbRmlsdGVyXVwiO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBGaWx0ZXIgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7RmlsdGVyfSBBIGNsb25lIG9mIHRoZSBjdXJyZW50IEZpbHRlciBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBGaWx0ZXIoKTtcblx0fTtcblx0XG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9hcHBseUZpbHRlclxuXHQgKiBAcGFyYW0ge0ltYWdlRGF0YX0gaW1hZ2VEYXRhIFRhcmdldCBJbWFnZURhdGEgaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqKi9cblx0cC5fYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbihpbWFnZURhdGEpIHsgcmV0dXJuIHRydWU7IH07XG5cblxuXHRjcmVhdGVqcy5GaWx0ZXIgPSBGaWx0ZXI7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQmx1ckZpbHRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEFwcGxpZXMgYSBib3ggYmx1ciB0byBEaXNwbGF5T2JqZWN0cy4gTm90ZSB0aGF0IHRoaXMgZmlsdGVyIGlzIGZhaXJseSBDUFUgaW50ZW5zaXZlLCBwYXJ0aWN1bGFybHkgaWYgdGhlIHF1YWxpdHkgaXNcblx0ICogc2V0IGhpZ2hlciB0aGFuIDEuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogVGhpcyBleGFtcGxlIGNyZWF0ZXMgYSByZWQgY2lyY2xlLCBhbmQgdGhlbiBhcHBsaWVzIGEgNSBwaXhlbCBibHVyIHRvIGl0LiBJdCB1c2VzIHRoZSB7eyNjcm9zc0xpbmsgXCJGaWx0ZXIvZ2V0Qm91bmRzXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZCB0byBhY2NvdW50IGZvciB0aGUgc3ByZWFkIHRoYXQgdGhlIGJsdXIgY2F1c2VzLlxuXHQgKlxuXHQgKiAgICAgIHZhciBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpLnNldCh7eDoxMDAseToxMDB9KTtcblx0ICogICAgICBzaGFwZS5ncmFwaGljcy5iZWdpbkZpbGwoXCIjZmYwMDAwXCIpLmRyYXdDaXJjbGUoMCwwLDUwKTtcblx0ICpcblx0ICogICAgICB2YXIgYmx1ckZpbHRlciA9IG5ldyBjcmVhdGVqcy5CbHVyRmlsdGVyKDUsIDUsIDEpO1xuXHQgKiAgICAgIHNoYXBlLmZpbHRlcnMgPSBbYmx1ckZpbHRlcl07XG5cdCAqICAgICAgdmFyIGJvdW5kcyA9IGJsdXJGaWx0ZXIuZ2V0Qm91bmRzKCk7XG5cdCAqXG5cdCAqICAgICAgc2hhcGUuY2FjaGUoLTUwK2JvdW5kcy54LCAtNTArYm91bmRzLnksIDEwMCtib3VuZHMud2lkdGgsIDEwMCtib3VuZHMuaGVpZ2h0KTtcblx0ICpcblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkZpbHRlclwifX17ey9jcm9zc0xpbmt9fSBmb3IgYW4gbW9yZSBpbmZvcm1hdGlvbiBvbiBhcHBseWluZyBmaWx0ZXJzLlxuXHQgKiBAY2xhc3MgQmx1ckZpbHRlclxuXHQgKiBAZXh0ZW5kcyBGaWx0ZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYmx1clg9MF0gVGhlIGhvcml6b250YWwgYmx1ciByYWRpdXMgaW4gcGl4ZWxzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2JsdXJZPTBdIFRoZSB2ZXJ0aWNhbCBibHVyIHJhZGl1cyBpbiBwaXhlbHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcXVhbGl0eT0xXSBUaGUgbnVtYmVyIG9mIGJsdXIgaXRlcmF0aW9ucy5cblx0ICoqL1xuXHRmdW5jdGlvbiBCbHVyRmlsdGVyKCBibHVyWCwgYmx1clksIHF1YWxpdHkpIHtcblx0XHRpZiAoIGlzTmFOKGJsdXJYKSB8fCBibHVyWCA8IDAgKSBibHVyWCA9IDA7XG5cdFx0aWYgKCBpc05hTihibHVyWSkgfHwgYmx1clkgPCAwICkgYmx1clkgPSAwO1xuXHRcdGlmICggaXNOYU4ocXVhbGl0eSkgfHwgcXVhbGl0eSA8IDEgICkgcXVhbGl0eSA9IDE7XG5cblxuXHRcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEhvcml6b250YWwgYmx1ciByYWRpdXMgaW4gcGl4ZWxzXG5cdFx0ICogQHByb3BlcnR5IGJsdXJYXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLmJsdXJYID0gYmx1clggfCAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVmVydGljYWwgYmx1ciByYWRpdXMgaW4gcGl4ZWxzXG5cdFx0ICogQHByb3BlcnR5IGJsdXJZXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLmJsdXJZID0gYmx1clkgfCAwO1xuXG5cdFx0LyoqXG5cdFx0ICogTnVtYmVyIG9mIGJsdXIgaXRlcmF0aW9ucy4gRm9yIGV4YW1wbGUsIGEgdmFsdWUgb2YgMSB3aWxsIHByb2R1Y2UgYSByb3VnaCBibHVyLiBBIHZhbHVlIG9mIDIgd2lsbCBwcm9kdWNlIGFcblx0XHQgKiBzbW9vdGhlciBibHVyLCBidXQgdGFrZSB0d2ljZSBhcyBsb25nIHRvIHJ1bi5cblx0XHQgKiBAcHJvcGVydHkgcXVhbGl0eVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5xdWFsaXR5ID0gcXVhbGl0eSB8IDA7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQmx1ckZpbHRlciwgY3JlYXRlanMuRmlsdGVyKTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXG4vLyBjb25zdGFudHM6XG5cdC8qKlxuXHQgKiBBcnJheSBvZiBtdWx0aXBseSB2YWx1ZXMgZm9yIGJsdXIgY2FsY3VsYXRpb25zLlxuXHQgKiBAcHJvcGVydHkgTVVMX1RBQkxFXG5cdCAqIEB0eXBlIEFycmF5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdEJsdXJGaWx0ZXIuTVVMX1RBQkxFID0gWzEsIDE3MSwgMjA1LCAyOTMsIDU3LCAzNzMsIDc5LCAxMzcsIDI0MSwgMjcsIDM5MSwgMzU3LCA0MSwgMTksIDI4MywgMjY1LCA0OTcsIDQ2OSwgNDQzLCA0MjEsIDI1LCAxOTEsIDM2NSwgMzQ5LCAzMzUsIDE2MSwgMTU1LCAxNDksIDksIDI3OCwgMjY5LCAyNjEsIDUwNSwgMjQ1LCA0NzUsIDIzMSwgNDQ5LCA0MzcsIDIxMywgNDE1LCA0MDUsIDM5NSwgMTkzLCAzNzcsIDM2OSwgMzYxLCAzNTMsIDM0NSwgMTY5LCAzMzEsIDMyNSwgMzE5LCAzMTMsIDMwNywgMzAxLCAzNywgMTQ1LCAyODUsIDI4MSwgNjksIDI3MSwgMjY3LCAyNjMsIDI1OSwgNTA5LCA1MDEsIDQ5MywgMjQzLCA0NzksIDExOCwgNDY1LCA0NTksIDExMywgNDQ2LCA1NSwgNDM1LCA0MjksIDQyMywgMjA5LCA0MTMsIDUxLCA0MDMsIDE5OSwgMzkzLCA5NywgMywgMzc5LCAzNzUsIDM3MSwgMzY3LCAzNjMsIDM1OSwgMzU1LCAzNTEsIDM0NywgNDMsIDg1LCAzMzcsIDMzMywgMTY1LCAzMjcsIDMyMywgNSwgMzE3LCAxNTcsIDMxMSwgNzcsIDMwNSwgMzAzLCA3NSwgMjk3LCAyOTQsIDczLCAyODksIDI4NywgNzEsIDE0MSwgMjc5LCAyNzcsIDI3NSwgNjgsIDEzNSwgNjcsIDEzMywgMzMsIDI2MiwgMjYwLCAxMjksIDUxMSwgNTA3LCA1MDMsIDQ5OSwgNDk1LCA0OTEsIDYxLCAxMjEsIDQ4MSwgNDc3LCAyMzcsIDIzNSwgNDY3LCAyMzIsIDExNSwgNDU3LCAyMjcsIDQ1MSwgNywgNDQ1LCAyMjEsIDQzOSwgMjE4LCA0MzMsIDIxNSwgNDI3LCA0MjUsIDIxMSwgNDE5LCA0MTcsIDIwNywgNDExLCA0MDksIDIwMywgMjAyLCA0MDEsIDM5OSwgMzk2LCAxOTcsIDQ5LCAzODksIDM4NywgMzg1LCAzODMsIDk1LCAxODksIDQ3LCAxODcsIDkzLCAxODUsIDIzLCAxODMsIDkxLCAxODEsIDQ1LCAxNzksIDg5LCAxNzcsIDExLCAxNzUsIDg3LCAxNzMsIDM0NSwgMzQzLCAzNDEsIDMzOSwgMzM3LCAyMSwgMTY3LCA4MywgMzMxLCAzMjksIDMyNywgMTYzLCA4MSwgMzIzLCAzMjEsIDMxOSwgMTU5LCA3OSwgMzE1LCAzMTMsIDM5LCAxNTUsIDMwOSwgMzA3LCAxNTMsIDMwNSwgMzAzLCAxNTEsIDc1LCAyOTksIDE0OSwgMzcsIDI5NSwgMTQ3LCA3MywgMjkxLCAxNDUsIDI4OSwgMjg3LCAxNDMsIDI4NSwgNzEsIDE0MSwgMjgxLCAzNSwgMjc5LCAxMzksIDY5LCAyNzUsIDEzNywgMjczLCAxNywgMjcxLCAxMzUsIDI2OSwgMjY3LCAxMzMsIDI2NSwgMzMsIDI2MywgMTMxLCAyNjEsIDEzMCwgMjU5LCAxMjksIDI1NywgMV07XG5cblx0LyoqXG5cdCAqIEFycmF5IG9mIHNoaWZ0IHZhbHVlcyBmb3IgYmx1ciBjYWxjdWxhdGlvbnMuXG5cdCAqIEBwcm9wZXJ0eSBTSEdfVEFCTEVcblx0ICogQHR5cGUgQXJyYXlcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0Qmx1ckZpbHRlci5TSEdfVEFCTEUgPSBbMCwgOSwgMTAsIDExLCA5LCAxMiwgMTAsIDExLCAxMiwgOSwgMTMsIDEzLCAxMCwgOSwgMTMsIDEzLCAxNCwgMTQsIDE0LCAxNCwgMTAsIDEzLCAxNCwgMTQsIDE0LCAxMywgMTMsIDEzLCA5LCAxNCwgMTQsIDE0LCAxNSwgMTQsIDE1LCAxNCwgMTUsIDE1LCAxNCwgMTUsIDE1LCAxNSwgMTQsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTQsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDEyLCAxNCwgMTUsIDE1LCAxMywgMTUsIDE1LCAxNSwgMTUsIDE2LCAxNiwgMTYsIDE1LCAxNiwgMTQsIDE2LCAxNiwgMTQsIDE2LCAxMywgMTYsIDE2LCAxNiwgMTUsIDE2LCAxMywgMTYsIDE1LCAxNiwgMTQsIDksIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDEzLCAxNCwgMTYsIDE2LCAxNSwgMTYsIDE2LCAxMCwgMTYsIDE1LCAxNiwgMTQsIDE2LCAxNiwgMTQsIDE2LCAxNiwgMTQsIDE2LCAxNiwgMTQsIDE1LCAxNiwgMTYsIDE2LCAxNCwgMTUsIDE0LCAxNSwgMTMsIDE2LCAxNiwgMTUsIDE3LCAxNywgMTcsIDE3LCAxNywgMTcsIDE0LCAxNSwgMTcsIDE3LCAxNiwgMTYsIDE3LCAxNiwgMTUsIDE3LCAxNiwgMTcsIDExLCAxNywgMTYsIDE3LCAxNiwgMTcsIDE2LCAxNywgMTcsIDE2LCAxNywgMTcsIDE2LCAxNywgMTcsIDE2LCAxNiwgMTcsIDE3LCAxNywgMTYsIDE0LCAxNywgMTcsIDE3LCAxNywgMTUsIDE2LCAxNCwgMTYsIDE1LCAxNiwgMTMsIDE2LCAxNSwgMTYsIDE0LCAxNiwgMTUsIDE2LCAxMiwgMTYsIDE1LCAxNiwgMTcsIDE3LCAxNywgMTcsIDE3LCAxMywgMTYsIDE1LCAxNywgMTcsIDE3LCAxNiwgMTUsIDE3LCAxNywgMTcsIDE2LCAxNSwgMTcsIDE3LCAxNCwgMTYsIDE3LCAxNywgMTYsIDE3LCAxNywgMTYsIDE1LCAxNywgMTYsIDE0LCAxNywgMTYsIDE1LCAxNywgMTYsIDE3LCAxNywgMTYsIDE3LCAxNSwgMTYsIDE3LCAxNCwgMTcsIDE2LCAxNSwgMTcsIDE2LCAxNywgMTMsIDE3LCAxNiwgMTcsIDE3LCAxNiwgMTcsIDE0LCAxNywgMTYsIDE3LCAxNiwgMTcsIDE2LCAxNywgOV07XG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLmdldEJvdW5kcyA9IGZ1bmN0aW9uIChyZWN0KSB7XG5cdFx0dmFyIHggPSB0aGlzLmJsdXJYfDAsIHkgPSB0aGlzLmJsdXJZfCAwO1xuXHRcdGlmICh4IDw9IDAgJiYgeSA8PSAwKSB7IHJldHVybiByZWN0OyB9XG5cdFx0dmFyIHEgPSBNYXRoLnBvdyh0aGlzLnF1YWxpdHksIDAuMik7XG5cdFx0cmV0dXJuIChyZWN0IHx8IG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoKSkucGFkKHgqcSsxLHkqcSsxLHgqcSsxLHkqcSsxKTtcblx0fTtcblxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBCbHVyRmlsdGVyKHRoaXMuYmx1clgsIHRoaXMuYmx1clksIHRoaXMucXVhbGl0eSk7XG5cdH07XG5cblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltCbHVyRmlsdGVyXVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLl9hcHBseUZpbHRlciA9IGZ1bmN0aW9uIChpbWFnZURhdGEpIHtcblxuXHRcdHZhciByYWRpdXNYID0gdGhpcy5ibHVyWCA+PiAxO1xuXHRcdGlmIChpc05hTihyYWRpdXNYKSB8fCByYWRpdXNYIDwgMCkgcmV0dXJuIGZhbHNlO1xuXHRcdHZhciByYWRpdXNZID0gdGhpcy5ibHVyWSA+PiAxO1xuXHRcdGlmIChpc05hTihyYWRpdXNZKSB8fCByYWRpdXNZIDwgMCkgcmV0dXJuIGZhbHNlO1xuXHRcdGlmIChyYWRpdXNYID09IDAgJiYgcmFkaXVzWSA9PSAwKSByZXR1cm4gZmFsc2U7XG5cblx0XHR2YXIgaXRlcmF0aW9ucyA9IHRoaXMucXVhbGl0eTtcblx0XHRpZiAoaXNOYU4oaXRlcmF0aW9ucykgfHwgaXRlcmF0aW9ucyA8IDEpIGl0ZXJhdGlvbnMgPSAxO1xuXHRcdGl0ZXJhdGlvbnMgfD0gMDtcblx0XHRpZiAoaXRlcmF0aW9ucyA+IDMpIGl0ZXJhdGlvbnMgPSAzO1xuXHRcdGlmIChpdGVyYXRpb25zIDwgMSkgaXRlcmF0aW9ucyA9IDE7XG5cblx0XHR2YXIgcHggPSBpbWFnZURhdGEuZGF0YTtcblx0XHR2YXIgeD0wLCB5PTAsIGk9MCwgcD0wLCB5cD0wLCB5aT0wLCB5dz0wLCByPTAsIGc9MCwgYj0wLCBhPTAsIHByPTAsIHBnPTAsIHBiPTAsIHBhPTA7XG5cblx0XHR2YXIgZGl2eCA9IChyYWRpdXNYICsgcmFkaXVzWCArIDEpIHwgMDtcblx0XHR2YXIgZGl2eSA9IChyYWRpdXNZICsgcmFkaXVzWSArIDEpIHwgMDtcblx0XHR2YXIgdyA9IGltYWdlRGF0YS53aWR0aCB8IDA7XG5cdFx0dmFyIGggPSBpbWFnZURhdGEuaGVpZ2h0IHwgMDtcblxuXHRcdHZhciB3MSA9ICh3IC0gMSkgfCAwO1xuXHRcdHZhciBoMSA9IChoIC0gMSkgfCAwO1xuXHRcdHZhciByeHAxID0gKHJhZGl1c1ggKyAxKSB8IDA7XG5cdFx0dmFyIHJ5cDEgPSAocmFkaXVzWSArIDEpIHwgMDtcblxuXHRcdHZhciBzc3ggPSB7cjowLGI6MCxnOjAsYTowfTtcblx0XHR2YXIgc3ggPSBzc3g7XG5cdFx0Zm9yICggaSA9IDE7IGkgPCBkaXZ4OyBpKysgKVxuXHRcdHtcblx0XHRcdHN4ID0gc3gubiA9IHtyOjAsYjowLGc6MCxhOjB9O1xuXHRcdH1cblx0XHRzeC5uID0gc3N4O1xuXG5cdFx0dmFyIHNzeSA9IHtyOjAsYjowLGc6MCxhOjB9O1xuXHRcdHZhciBzeSA9IHNzeTtcblx0XHRmb3IgKCBpID0gMTsgaSA8IGRpdnk7IGkrKyApXG5cdFx0e1xuXHRcdFx0c3kgPSBzeS5uID0ge3I6MCxiOjAsZzowLGE6MH07XG5cdFx0fVxuXHRcdHN5Lm4gPSBzc3k7XG5cblx0XHR2YXIgc2kgPSBudWxsO1xuXG5cblx0XHR2YXIgbXR4ID0gQmx1ckZpbHRlci5NVUxfVEFCTEVbcmFkaXVzWF0gfCAwO1xuXHRcdHZhciBzdHggPSBCbHVyRmlsdGVyLlNIR19UQUJMRVtyYWRpdXNYXSB8IDA7XG5cdFx0dmFyIG10eSA9IEJsdXJGaWx0ZXIuTVVMX1RBQkxFW3JhZGl1c1ldIHwgMDtcblx0XHR2YXIgc3R5ID0gQmx1ckZpbHRlci5TSEdfVEFCTEVbcmFkaXVzWV0gfCAwO1xuXG5cdFx0d2hpbGUgKGl0ZXJhdGlvbnMtLSA+IDApIHtcblxuXHRcdFx0eXcgPSB5aSA9IDA7XG5cdFx0XHR2YXIgbXMgPSBtdHg7XG5cdFx0XHR2YXIgc3MgPSBzdHg7XG5cdFx0XHRmb3IgKHkgPSBoOyAtLXkgPiAtMTspIHtcblx0XHRcdFx0ciA9IHJ4cDEgKiAocHIgPSBweFsoeWkpIHwgMF0pO1xuXHRcdFx0XHRnID0gcnhwMSAqIChwZyA9IHB4Wyh5aSArIDEpIHwgMF0pO1xuXHRcdFx0XHRiID0gcnhwMSAqIChwYiA9IHB4Wyh5aSArIDIpIHwgMF0pO1xuXHRcdFx0XHRhID0gcnhwMSAqIChwYSA9IHB4Wyh5aSArIDMpIHwgMF0pO1xuXG5cdFx0XHRcdHN4ID0gc3N4O1xuXG5cdFx0XHRcdGZvciggaSA9IHJ4cDE7IC0taSA+IC0xOyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzeC5yID0gcHI7XG5cdFx0XHRcdFx0c3guZyA9IHBnO1xuXHRcdFx0XHRcdHN4LmIgPSBwYjtcblx0XHRcdFx0XHRzeC5hID0gcGE7XG5cdFx0XHRcdFx0c3ggPSBzeC5uO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yKCBpID0gMTsgaSA8IHJ4cDE7IGkrKyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRwID0gKHlpICsgKCh3MSA8IGkgPyB3MSA6IGkpIDw8IDIpKSB8IDA7XG5cdFx0XHRcdFx0ciArPSAoIHN4LnIgPSBweFtwXSk7XG5cdFx0XHRcdFx0ZyArPSAoIHN4LmcgPSBweFtwKzFdKTtcblx0XHRcdFx0XHRiICs9ICggc3guYiA9IHB4W3ArMl0pO1xuXHRcdFx0XHRcdGEgKz0gKCBzeC5hID0gcHhbcCszXSk7XG5cblx0XHRcdFx0XHRzeCA9IHN4Lm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzaSA9IHNzeDtcblx0XHRcdFx0Zm9yICggeCA9IDA7IHggPCB3OyB4KysgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cHhbeWkrK10gPSAociAqIG1zKSA+Pj4gc3M7XG5cdFx0XHRcdFx0cHhbeWkrK10gPSAoZyAqIG1zKSA+Pj4gc3M7XG5cdFx0XHRcdFx0cHhbeWkrK10gPSAoYiAqIG1zKSA+Pj4gc3M7XG5cdFx0XHRcdFx0cHhbeWkrK10gPSAoYSAqIG1zKSA+Pj4gc3M7XG5cblx0XHRcdFx0XHRwID0gKCh5dyArICgocCA9IHggKyByYWRpdXNYICsgMSkgPCB3MSA/IHAgOiB3MSkpIDw8IDIpO1xuXG5cdFx0XHRcdFx0ciAtPSBzaS5yIC0gKCBzaS5yID0gcHhbcF0pO1xuXHRcdFx0XHRcdGcgLT0gc2kuZyAtICggc2kuZyA9IHB4W3ArMV0pO1xuXHRcdFx0XHRcdGIgLT0gc2kuYiAtICggc2kuYiA9IHB4W3ArMl0pO1xuXHRcdFx0XHRcdGEgLT0gc2kuYSAtICggc2kuYSA9IHB4W3ArM10pO1xuXG5cdFx0XHRcdFx0c2kgPSBzaS5uO1xuXG5cdFx0XHRcdH1cblx0XHRcdFx0eXcgKz0gdztcblx0XHRcdH1cblxuXHRcdFx0bXMgPSBtdHk7XG5cdFx0XHRzcyA9IHN0eTtcblx0XHRcdGZvciAoeCA9IDA7IHggPCB3OyB4KyspIHtcblx0XHRcdFx0eWkgPSAoeCA8PCAyKSB8IDA7XG5cblx0XHRcdFx0ciA9IChyeXAxICogKHByID0gcHhbeWldKSkgfCAwO1xuXHRcdFx0XHRnID0gKHJ5cDEgKiAocGcgPSBweFsoeWkgKyAxKSB8IDBdKSkgfCAwO1xuXHRcdFx0XHRiID0gKHJ5cDEgKiAocGIgPSBweFsoeWkgKyAyKSB8IDBdKSkgfCAwO1xuXHRcdFx0XHRhID0gKHJ5cDEgKiAocGEgPSBweFsoeWkgKyAzKSB8IDBdKSkgfCAwO1xuXG5cdFx0XHRcdHN5ID0gc3N5O1xuXHRcdFx0XHRmb3IoIGkgPSAwOyBpIDwgcnlwMTsgaSsrIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHN5LnIgPSBwcjtcblx0XHRcdFx0XHRzeS5nID0gcGc7XG5cdFx0XHRcdFx0c3kuYiA9IHBiO1xuXHRcdFx0XHRcdHN5LmEgPSBwYTtcblx0XHRcdFx0XHRzeSA9IHN5Lm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR5cCA9IHc7XG5cblx0XHRcdFx0Zm9yKCBpID0gMTsgaSA8PSByYWRpdXNZOyBpKysgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0eWkgPSAoIHlwICsgeCApIDw8IDI7XG5cblx0XHRcdFx0XHRyICs9ICggc3kuciA9IHB4W3lpXSk7XG5cdFx0XHRcdFx0ZyArPSAoIHN5LmcgPSBweFt5aSsxXSk7XG5cdFx0XHRcdFx0YiArPSAoIHN5LmIgPSBweFt5aSsyXSk7XG5cdFx0XHRcdFx0YSArPSAoIHN5LmEgPSBweFt5aSszXSk7XG5cblx0XHRcdFx0XHRzeSA9IHN5Lm47XG5cblx0XHRcdFx0XHRpZiggaSA8IGgxIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR5cCArPSB3O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHlpID0geDtcblx0XHRcdFx0c2kgPSBzc3k7XG5cdFx0XHRcdGlmICggaXRlcmF0aW9ucyA+IDAgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Zm9yICggeSA9IDA7IHkgPCBoOyB5KysgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHAgPSB5aSA8PCAyO1xuXHRcdFx0XHRcdFx0cHhbcCszXSA9IHBhID0oYSAqIG1zKSA+Pj4gc3M7XG5cdFx0XHRcdFx0XHRpZiAoIHBhID4gMCApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHB4W3BdICAgPSAoKHIgKiBtcykgPj4+IHNzICk7XG5cdFx0XHRcdFx0XHRcdHB4W3ArMV0gPSAoKGcgKiBtcykgPj4+IHNzICk7XG5cdFx0XHRcdFx0XHRcdHB4W3ArMl0gPSAoKGIgKiBtcykgPj4+IHNzICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRweFtwXSA9IHB4W3ArMV0gPSBweFtwKzJdID0gMFxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRwID0gKCB4ICsgKCggKCBwID0geSArIHJ5cDEpIDwgaDEgPyBwIDogaDEgKSAqIHcgKSkgPDwgMjtcblxuXHRcdFx0XHRcdFx0ciAtPSBzaS5yIC0gKCBzaS5yID0gcHhbcF0pO1xuXHRcdFx0XHRcdFx0ZyAtPSBzaS5nIC0gKCBzaS5nID0gcHhbcCsxXSk7XG5cdFx0XHRcdFx0XHRiIC09IHNpLmIgLSAoIHNpLmIgPSBweFtwKzJdKTtcblx0XHRcdFx0XHRcdGEgLT0gc2kuYSAtICggc2kuYSA9IHB4W3ArM10pO1xuXG5cdFx0XHRcdFx0XHRzaSA9IHNpLm47XG5cblx0XHRcdFx0XHRcdHlpICs9IHc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZvciAoIHkgPSAwOyB5IDwgaDsgeSsrIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRwID0geWkgPDwgMjtcblx0XHRcdFx0XHRcdHB4W3ArM10gPSBwYSA9KGEgKiBtcykgPj4+IHNzO1xuXHRcdFx0XHRcdFx0aWYgKCBwYSA+IDAgKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRwYSA9IDI1NSAvIHBhO1xuXHRcdFx0XHRcdFx0XHRweFtwXSAgID0gKChyICogbXMpID4+PiBzcyApICogcGE7XG5cdFx0XHRcdFx0XHRcdHB4W3ArMV0gPSAoKGcgKiBtcykgPj4+IHNzICkgKiBwYTtcblx0XHRcdFx0XHRcdFx0cHhbcCsyXSA9ICgoYiAqIG1zKSA+Pj4gc3MgKSAqIHBhO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cHhbcF0gPSBweFtwKzFdID0gcHhbcCsyXSA9IDBcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cCA9ICggeCArICgoICggcCA9IHkgKyByeXAxKSA8IGgxID8gcCA6IGgxICkgKiB3ICkpIDw8IDI7XG5cblx0XHRcdFx0XHRcdHIgLT0gc2kuciAtICggc2kuciA9IHB4W3BdKTtcblx0XHRcdFx0XHRcdGcgLT0gc2kuZyAtICggc2kuZyA9IHB4W3ArMV0pO1xuXHRcdFx0XHRcdFx0YiAtPSBzaS5iIC0gKCBzaS5iID0gcHhbcCsyXSk7XG5cdFx0XHRcdFx0XHRhIC09IHNpLmEgLSAoIHNpLmEgPSBweFtwKzNdKTtcblxuXHRcdFx0XHRcdFx0c2kgPSBzaS5uO1xuXG5cdFx0XHRcdFx0XHR5aSArPSB3O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkJsdXJGaWx0ZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEJsdXJGaWx0ZXIsIFwiRmlsdGVyXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEFscGhhTWFwRmlsdGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cdFxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBBcHBsaWVzIGEgZ3JleXNjYWxlIGFscGhhIG1hcCBpbWFnZSAob3IgY2FudmFzKSB0byB0aGUgdGFyZ2V0LCBzdWNoIHRoYXQgdGhlIGFscGhhIGNoYW5uZWwgb2YgdGhlIHJlc3VsdCB3aWxsXG5cdCAqIGJlIGNvcGllZCBmcm9tIHRoZSByZWQgY2hhbm5lbCBvZiB0aGUgbWFwLCBhbmQgdGhlIFJHQiBjaGFubmVscyB3aWxsIGJlIGNvcGllZCBmcm9tIHRoZSB0YXJnZXQuXG5cdCAqXG5cdCAqIEdlbmVyYWxseSwgaXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3UgdXNlIHt7I2Nyb3NzTGluayBcIkFscGhhTWFza0ZpbHRlclwifX17ey9jcm9zc0xpbmt9fSwgYmVjYXVzZSBpdCBoYXMgbXVjaFxuXHQgKiBiZXR0ZXIgcGVyZm9ybWFuY2UuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogVGhpcyBleGFtcGxlIGRyYXdzIGEgcmVkLT5ibHVlIGJveCwgY2FjaGVzIGl0LCBhbmQgdGhlbiB1c2VzIHRoZSBjYWNoZSBjYW52YXMgYXMgYW4gYWxwaGEgbWFwIG9uIGEgMTAweDEwMCBpbWFnZS5cblx0ICpcblx0ICogICAgICAgdmFyIGJveCA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuXHQgKiAgICAgICBib3guZ3JhcGhpY3MuYmVnaW5MaW5lYXJHcmFkaWVudEZpbGwoW1wiI2ZmMDAwMFwiLCBcIiMwMDAwZmZcIl0sIFswLCAxXSwgMCwgMCwgMCwgMTAwKVxuXHQgKiAgICAgICBib3guZ3JhcGhpY3MuZHJhd1JlY3QoMCwgMCwgMTAwLCAxMDApO1xuXHQgKiAgICAgICBib3guY2FjaGUoMCwgMCwgMTAwLCAxMDApO1xuXHQgKlxuXHQgKiAgICAgICB2YXIgYm1wID0gbmV3IGNyZWF0ZWpzLkJpdG1hcChcInBhdGgvdG8vaW1hZ2UuanBnXCIpO1xuXHQgKiAgICAgICBibXAuZmlsdGVycyA9IFtcblx0ICogICAgICAgICAgIG5ldyBjcmVhdGVqcy5BbHBoYU1hcEZpbHRlcihib3guY2FjaGVDYW52YXMpXG5cdCAqICAgICAgIF07XG5cdCAqICAgICAgIGJtcC5jYWNoZSgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqICAgICAgIHN0YWdlLmFkZENoaWxkKGJtcCk7XG5cdCAqXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gYXBwbHlpbmcgZmlsdGVycy5cblx0ICogQGNsYXNzIEFscGhhTWFwRmlsdGVyXG5cdCAqIEBleHRlbmRzIEZpbHRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBhbHBoYU1hcCBUaGUgZ3JleXNjYWxlIGltYWdlIChvciBjYW52YXMpIHRvIHVzZSBhcyB0aGUgYWxwaGEgdmFsdWUgZm9yIHRoZVxuXHQgKiByZXN1bHQuIFRoaXMgc2hvdWxkIGJlIGV4YWN0bHkgdGhlIHNhbWUgZGltZW5zaW9ucyBhcyB0aGUgdGFyZ2V0LlxuXHQgKiovXG5cdGZ1bmN0aW9uIEFscGhhTWFwRmlsdGVyKGFscGhhTWFwKSB7XG5cdFxuXHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIGdyZXlzY2FsZSBpbWFnZSAob3IgY2FudmFzKSB0byB1c2UgYXMgdGhlIGFscGhhIHZhbHVlIGZvciB0aGUgcmVzdWx0LiBUaGlzIHNob3VsZCBiZSBleGFjdGx5IHRoZSBzYW1lXG5cdFx0ICogZGltZW5zaW9ucyBhcyB0aGUgdGFyZ2V0LlxuXHRcdCAqIEBwcm9wZXJ0eSBhbHBoYU1hcFxuXHRcdCAqIEB0eXBlIEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnRcblx0XHQgKiovXG5cdFx0dGhpcy5hbHBoYU1hcCA9IGFscGhhTWFwO1xuXHRcdFxuXHRcdFxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9hbHBoYU1hcFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2FscGhhTWFwID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX21hcERhdGFcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgVWludDhDbGFtcGVkQXJyYXlcblx0XHQgKiovXG5cdFx0dGhpcy5fbWFwRGF0YSA9IG51bGw7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQWxwaGFNYXBGaWx0ZXIsIGNyZWF0ZWpzLkZpbHRlcik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG8gPSBuZXcgQWxwaGFNYXBGaWx0ZXIodGhpcy5hbHBoYU1hcCk7XG5cdFx0by5fYWxwaGFNYXAgPSB0aGlzLl9hbHBoYU1hcDtcblx0XHRvLl9tYXBEYXRhID0gdGhpcy5fbWFwRGF0YTtcblx0XHRyZXR1cm4gbztcblx0fTtcblxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltBbHBoYU1hcEZpbHRlcl1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuX2FwcGx5RmlsdGVyID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xuXHRcdGlmICghdGhpcy5hbHBoYU1hcCkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdGlmICghdGhpcy5fcHJlcEFscGhhTWFwKCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XG5cdFx0Ly8gVE9ETzogdXBkYXRlIHRvIHN1cHBvcnQgc2NlbmFyaW9zIHdoZXJlIHRoZSB0YXJnZXQgaGFzIGRpZmZlcmVudCBkaW1lbnNpb25zLlxuXHRcdHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcERhdGE7XG5cdFx0Zm9yKHZhciBpPTAsIGw9ZGF0YS5sZW5ndGg7IGk8bDsgaSArPSA0KSB7IGRhdGFbaSArIDNdID0gbWFwW2ldIHx8IDA7IH1cblx0XHRcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfcHJlcEFscGhhTWFwXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9wcmVwQWxwaGFNYXAgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLmFscGhhTWFwKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0aGlzLmFscGhhTWFwID09IHRoaXMuX2FscGhhTWFwICYmIHRoaXMuX21hcERhdGEpIHsgcmV0dXJuIHRydWU7IH1cblxuXHRcdHRoaXMuX21hcERhdGEgPSBudWxsO1xuXHRcdHZhciBtYXAgPSB0aGlzLl9hbHBoYU1hcCA9IHRoaXMuYWxwaGFNYXA7XG5cdFx0dmFyIGNhbnZhcyA9IG1hcDtcblx0XHR2YXIgY3R4O1xuXHRcdGlmIChtYXAgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuXHRcdFx0Y3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FudmFzID0gY3JlYXRlanMuY3JlYXRlQ2FudmFzID8gY3JlYXRlanMuY3JlYXRlQ2FudmFzKCkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXHRcdFx0Y2FudmFzLndpZHRoID0gbWFwLndpZHRoO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IG1hcC5oZWlnaHQ7XG5cdFx0XHRjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdFx0Y3R4LmRyYXdJbWFnZShtYXAsIDAsIDApO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgaW1nRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgbWFwLndpZHRoLCBtYXAuaGVpZ2h0KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHQvL2lmICghdGhpcy5zdXBwcmVzc0Nyb3NzRG9tYWluRXJyb3JzKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmFibGUgdG8gYWNjZXNzIGxvY2FsIGltYWdlIGRhdGE6IFwiICsgZSk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdFxuXHRcdHRoaXMuX21hcERhdGEgPSBpbWdEYXRhLmRhdGE7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5BbHBoYU1hcEZpbHRlciA9IGNyZWF0ZWpzLnByb21vdGUoQWxwaGFNYXBGaWx0ZXIsIFwiRmlsdGVyXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEFscGhhTWFza0ZpbHRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBBcHBsaWVzIHRoZSBhbHBoYSBmcm9tIHRoZSBtYXNrIGltYWdlIChvciBjYW52YXMpIHRvIHRoZSB0YXJnZXQsIHN1Y2ggdGhhdCB0aGUgYWxwaGEgY2hhbm5lbCBvZiB0aGUgcmVzdWx0IHdpbGxcblx0ICogYmUgZGVyaXZlZCBmcm9tIHRoZSBtYXNrLCBhbmQgdGhlIFJHQiBjaGFubmVscyB3aWxsIGJlIGNvcGllZCBmcm9tIHRoZSB0YXJnZXQuIFRoaXMgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCB0b1xuXHQgKiBhcHBseSBhbiBhbHBoYSBtYXNrIHRvIGEgZGlzcGxheSBvYmplY3QuIFRoaXMgY2FuIGFsc28gYmUgdXNlZCB0byBjb21iaW5lIGEgSlBHIGNvbXByZXNzZWQgUkdCIGltYWdlIHdpdGggYSBQTkczMlxuXHQgKiBhbHBoYSBtYXNrLCB3aGljaCBjYW4gcmVzdWx0IGluIGEgbXVjaCBzbWFsbGVyIGZpbGUgc2l6ZSB0aGFuIGEgc2luZ2xlIFBORzMyIGNvbnRhaW5pbmcgQVJHQi5cblx0ICpcblx0ICogPGI+SU1QT1JUQU5UIE5PVEU6IFRoaXMgZmlsdGVyIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IHRoZSB0YXJnZXRDdHgsIG9yIHRhcmdldFgvWSBwYXJhbWV0ZXJzIGNvcnJlY3RseS48L2I+XG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogVGhpcyBleGFtcGxlIGRyYXdzIGEgZ3JhZGllbnQgYm94LCB0aGVuIGNhY2hlcyBpdCBhbmQgdXNlcyB0aGUgXCJjYWNoZUNhbnZhc1wiIGFzIHRoZSBhbHBoYSBtYXNrIG9uIGEgMTAweDEwMCBpbWFnZS5cblx0ICpcblx0ICogICAgICB2YXIgYm94ID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG5cdCAqICAgICAgYm94LmdyYXBoaWNzLmJlZ2luTGluZWFyR3JhZGllbnRGaWxsKFtcIiMwMDAwMDBcIiwgXCJyZ2JhKDAsIDAsIDAsIDApXCJdLCBbMCwgMV0sIDAsIDAsIDEwMCwgMTAwKVxuXHQgKiAgICAgIGJveC5ncmFwaGljcy5kcmF3UmVjdCgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqICAgICAgYm94LmNhY2hlKDAsIDAsIDEwMCwgMTAwKTtcblx0ICpcblx0ICogICAgICB2YXIgYm1wID0gbmV3IGNyZWF0ZWpzLkJpdG1hcChcInBhdGgvdG8vaW1hZ2UuanBnXCIpO1xuXHQgKiAgICAgIGJtcC5maWx0ZXJzID0gW1xuXHQgKiAgICAgICAgICBuZXcgY3JlYXRlanMuQWxwaGFNYXNrRmlsdGVyKGJveC5jYWNoZUNhbnZhcylcblx0ICogICAgICBdO1xuXHQgKiAgICAgIGJtcC5jYWNoZSgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gYXBwbHlpbmcgZmlsdGVycy5cblx0ICogQGNsYXNzIEFscGhhTWFza0ZpbHRlclxuXHQgKiBAZXh0ZW5kcyBGaWx0ZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gbWFza1xuXHQgKiovXG5cdGZ1bmN0aW9uIEFscGhhTWFza0ZpbHRlcihtYXNrKSB7XG5cdFxuXHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIGltYWdlIChvciBjYW52YXMpIHRvIHVzZSBhcyB0aGUgbWFzay5cblx0XHQgKiBAcHJvcGVydHkgbWFza1xuXHRcdCAqIEB0eXBlIEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnRcblx0XHQgKiovXG5cdFx0dGhpcy5tYXNrID0gbWFzaztcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChBbHBoYU1hc2tGaWx0ZXIsIGNyZWF0ZWpzLkZpbHRlcik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cdFxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEFwcGxpZXMgdGhlIGZpbHRlciB0byB0aGUgc3BlY2lmaWVkIGNvbnRleHQuXG5cdCAqXG5cdCAqIDxzdHJvbmc+SU1QT1JUQU5UIE5PVEU6IFRoaXMgZmlsdGVyIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IHRoZSB0YXJnZXRDdHgsIG9yIHRhcmdldFgvWSBwYXJhbWV0ZXJzXG5cdCAqIGNvcnJlY3RseS48L3N0cm9uZz5cblx0ICogQG1ldGhvZCBhcHBseUZpbHRlclxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSAyRCBjb250ZXh0IHRvIHVzZSBhcyB0aGUgc291cmNlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBwb3NpdGlvbiB0byB1c2UgZm9yIHRoZSBzb3VyY2UgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24gdG8gdXNlIGZvciB0aGUgc291cmNlIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggdG8gdXNlIGZvciB0aGUgc291cmNlIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCB0byB1c2UgZm9yIHRoZSBzb3VyY2UgcmVjdC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFt0YXJnZXRDdHhdIE5PVCBTVVBQT1JURUQgSU4gVEhJUyBGSUxURVIuIFRoZSAyRCBjb250ZXh0IHRvIGRyYXcgdGhlIHJlc3VsdCB0by4gRGVmYXVsdHMgdG8gdGhlIGNvbnRleHQgcGFzc2VkIHRvIGN0eC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0YXJnZXRYXSBOT1QgU1VQUE9SVEVEIElOIFRISVMgRklMVEVSLiBUaGUgeCBwb3NpdGlvbiB0byBkcmF3IHRoZSByZXN1bHQgdG8uIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBwYXNzZWQgdG8geC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0YXJnZXRZXSBOT1QgU1VQUE9SVEVEIElOIFRISVMgRklMVEVSLiBUaGUgeSBwb3NpdGlvbiB0byBkcmF3IHRoZSByZXN1bHQgdG8uIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBwYXNzZWQgdG8geS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIGZpbHRlciB3YXMgYXBwbGllZCBzdWNjZXNzZnVsbHkuXG5cdCAqKi9cblx0cC5hcHBseUZpbHRlciA9IGZ1bmN0aW9uIChjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHRhcmdldEN0eCwgdGFyZ2V0WCwgdGFyZ2V0WSkge1xuXHRcdGlmICghdGhpcy5tYXNrKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0dGFyZ2V0Q3R4ID0gdGFyZ2V0Q3R4IHx8IGN0eDtcblx0XHRpZiAodGFyZ2V0WCA9PSBudWxsKSB7IHRhcmdldFggPSB4OyB9XG5cdFx0aWYgKHRhcmdldFkgPT0gbnVsbCkgeyB0YXJnZXRZID0geTsgfVxuXG5cdFx0dGFyZ2V0Q3R4LnNhdmUoKTtcblx0XHRpZiAoY3R4ICE9IHRhcmdldEN0eCkge1xuXHRcdFx0Ly8gVE9ETzogc3VwcG9ydCB0YXJnZXRDdHggYW5kIHRhcmdldFgvWVxuXHRcdFx0Ly8gY2xlYXJSZWN0LCB0aGVuIGRyYXcgdGhlIGN0eCBpbj9cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR0YXJnZXRDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1pblwiO1xuXHRcdHRhcmdldEN0eC5kcmF3SW1hZ2UodGhpcy5tYXNrLCB0YXJnZXRYLCB0YXJnZXRZKTtcblx0XHR0YXJnZXRDdHgucmVzdG9yZSgpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG5ldyBBbHBoYU1hc2tGaWx0ZXIodGhpcy5tYXNrKTtcblx0fTtcblxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltBbHBoYU1hc2tGaWx0ZXJdXCI7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5BbHBoYU1hc2tGaWx0ZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEFscGhhTWFza0ZpbHRlciwgXCJGaWx0ZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQ29sb3JGaWx0ZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBBcHBsaWVzIGEgY29sb3IgdHJhbnNmb3JtIHRvIERpc3BsYXlPYmplY3RzLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIFRoaXMgZXhhbXBsZSBkcmF3cyBhIHJlZCBjaXJjbGUsIGFuZCB0aGVuIHRyYW5zZm9ybXMgaXQgdG8gQmx1ZS4gVGhpcyBpcyBhY2NvbXBsaXNoZWQgYnkgbXVsdGlwbHlpbmcgYWxsIHRoZSBjaGFubmVsc1xuXHQgKiB0byAwIChleGNlcHQgYWxwaGEsIHdoaWNoIGlzIHNldCB0byAxKSwgYW5kIHRoZW4gYWRkaW5nIDI1NSB0byB0aGUgYmx1ZSBjaGFubmVsLlxuXHQgKlxuXHQgKiAgICAgIHZhciBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpLnNldCh7eDoxMDAseToxMDB9KTtcblx0ICogICAgICBzaGFwZS5ncmFwaGljcy5iZWdpbkZpbGwoXCIjZmYwMDAwXCIpLmRyYXdDaXJjbGUoMCwwLDUwKTtcblx0ICpcblx0ICogICAgICBzaGFwZS5maWx0ZXJzID0gW1xuXHQgKiAgICAgICAgICBuZXcgY3JlYXRlanMuQ29sb3JGaWx0ZXIoMCwwLDAsMSwgMCwwLDI1NSwwKVxuXHQgKiAgICAgIF07XG5cdCAqICAgICAgc2hhcGUuY2FjaGUoLTUwLCAtNTAsIDEwMCwgMTAwKTtcblx0ICpcblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkZpbHRlclwifX17ey9jcm9zc0xpbmt9fSBmb3IgYW4gbW9yZSBpbmZvcm1hdGlvbiBvbiBhcHBseWluZyBmaWx0ZXJzLlxuXHQgKiBAY2xhc3MgQ29sb3JGaWx0ZXJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtyZWRNdWx0aXBsaWVyPTFdIFRoZSBhbW91bnQgdG8gbXVsdGlwbHkgYWdhaW5zdCB0aGUgcmVkIGNoYW5uZWwuIFRoaXMgaXMgYSByYW5nZSBiZXR3ZWVuIDAgYW5kIDEuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZ3JlZW5NdWx0aXBsaWVyPTFdIFRoZSBhbW91bnQgdG8gbXVsdGlwbHkgYWdhaW5zdCB0aGUgZ3JlZW4gY2hhbm5lbC4gVGhpcyBpcyBhIHJhbmdlIGJldHdlZW4gMCBhbmQgMS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtibHVlTXVsdGlwbGllcj0xXSBUaGUgYW1vdW50IHRvIG11bHRpcGx5IGFnYWluc3QgdGhlIGJsdWUgY2hhbm5lbC4gVGhpcyBpcyBhIHJhbmdlIGJldHdlZW4gMCBhbmQgMS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthbHBoYU11bHRpcGxpZXI9MV0gVGhlIGFtb3VudCB0byBtdWx0aXBseSBhZ2FpbnN0IHRoZSBhbHBoYSBjaGFubmVsLiBUaGlzIGlzIGEgcmFuZ2UgYmV0d2VlbiAwIGFuZCAxLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3JlZE9mZnNldD0wXSBUaGUgYW1vdW50IHRvIGFkZCB0byB0aGUgcmVkIGNoYW5uZWwgYWZ0ZXIgaXQgaGFzIGJlZW4gbXVsdGlwbGllZC4gVGhpcyBpcyBhIHJhbmdlXG5cdCAqIGJldHdlZW4gLTI1NSBhbmQgMjU1LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2dyZWVuT2Zmc2V0PTBdIFRoZSBhbW91bnQgdG8gYWRkIHRvIHRoZSBncmVlbiBjaGFubmVsIGFmdGVyIGl0IGhhcyBiZWVuIG11bHRpcGxpZWQuIFRoaXMgaXMgYSByYW5nZVxuXHQgICogYmV0d2VlbiAtMjU1IGFuZCAyNTUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYmx1ZU9mZnNldD0wXSBUaGUgYW1vdW50IHRvIGFkZCB0byB0aGUgYmx1ZSBjaGFubmVsIGFmdGVyIGl0IGhhcyBiZWVuIG11bHRpcGxpZWQuIFRoaXMgaXMgYSByYW5nZVxuXHQgICogYmV0d2VlbiAtMjU1IGFuZCAyNTUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYWxwaGFPZmZzZXQ9MF0gVGhlIGFtb3VudCB0byBhZGQgdG8gdGhlIGFscGhhIGNoYW5uZWwgYWZ0ZXIgaXQgaGFzIGJlZW4gbXVsdGlwbGllZC4gVGhpcyBpcyBhIHJhbmdlXG5cdCAgKiBiZXR3ZWVuIC0yNTUgYW5kIDI1NS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBleHRlbmRzIEZpbHRlclxuXHQgKiovXG5cdGZ1bmN0aW9uIENvbG9yRmlsdGVyKHJlZE11bHRpcGxpZXIsIGdyZWVuTXVsdGlwbGllciwgYmx1ZU11bHRpcGxpZXIsIGFscGhhTXVsdGlwbGllciwgcmVkT2Zmc2V0LCBncmVlbk9mZnNldCwgYmx1ZU9mZnNldCwgYWxwaGFPZmZzZXQpIHtcblx0XHRcblx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFJlZCBjaGFubmVsIG11bHRpcGxpZXIuXG5cdFx0ICogQHByb3BlcnR5IHJlZE11bHRpcGxpZXJcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5yZWRNdWx0aXBsaWVyID0gcmVkTXVsdGlwbGllciAhPSBudWxsID8gcmVkTXVsdGlwbGllciA6IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEdyZWVuIGNoYW5uZWwgbXVsdGlwbGllci5cblx0XHQgKiBAcHJvcGVydHkgZ3JlZW5NdWx0aXBsaWVyXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuZ3JlZW5NdWx0aXBsaWVyID0gZ3JlZW5NdWx0aXBsaWVyICE9IG51bGwgPyBncmVlbk11bHRpcGxpZXIgOiAxO1xuXHRcblx0XHQvKipcblx0XHQgKiBCbHVlIGNoYW5uZWwgbXVsdGlwbGllci5cblx0XHQgKiBAcHJvcGVydHkgYmx1ZU11bHRpcGxpZXJcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5ibHVlTXVsdGlwbGllciA9IGJsdWVNdWx0aXBsaWVyICE9IG51bGwgPyBibHVlTXVsdGlwbGllciA6IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFscGhhIGNoYW5uZWwgbXVsdGlwbGllci5cblx0XHQgKiBAcHJvcGVydHkgYWxwaGFNdWx0aXBsaWVyXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuYWxwaGFNdWx0aXBsaWVyID0gYWxwaGFNdWx0aXBsaWVyICE9IG51bGwgPyBhbHBoYU11bHRpcGxpZXIgOiAxO1xuXHRcblx0XHQvKipcblx0XHQgKiBSZWQgY2hhbm5lbCBvZmZzZXQgKGFkZGVkIHRvIHZhbHVlKS5cblx0XHQgKiBAcHJvcGVydHkgcmVkT2Zmc2V0XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMucmVkT2Zmc2V0ID0gcmVkT2Zmc2V0IHx8IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEdyZWVuIGNoYW5uZWwgb2Zmc2V0IChhZGRlZCB0byB2YWx1ZSkuXG5cdFx0ICogQHByb3BlcnR5IGdyZWVuT2Zmc2V0XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuZ3JlZW5PZmZzZXQgPSBncmVlbk9mZnNldCB8fCAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBCbHVlIGNoYW5uZWwgb2Zmc2V0IChhZGRlZCB0byB2YWx1ZSkuXG5cdFx0ICogQHByb3BlcnR5IGJsdWVPZmZzZXRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5ibHVlT2Zmc2V0ID0gYmx1ZU9mZnNldCB8fCAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBBbHBoYSBjaGFubmVsIG9mZnNldCAoYWRkZWQgdG8gdmFsdWUpLlxuXHRcdCAqIEBwcm9wZXJ0eSBhbHBoYU9mZnNldFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLmFscGhhT2Zmc2V0ID0gYWxwaGFPZmZzZXQgfHwgMDtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChDb2xvckZpbHRlciwgY3JlYXRlanMuRmlsdGVyKTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltDb2xvckZpbHRlcl1cIjtcblx0fTtcblxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvckZpbHRlcih0aGlzLnJlZE11bHRpcGxpZXIsIHRoaXMuZ3JlZW5NdWx0aXBsaWVyLCB0aGlzLmJsdWVNdWx0aXBsaWVyLCB0aGlzLmFscGhhTXVsdGlwbGllciwgdGhpcy5yZWRPZmZzZXQsIHRoaXMuZ3JlZW5PZmZzZXQsIHRoaXMuYmx1ZU9mZnNldCwgdGhpcy5hbHBoYU9mZnNldCk7XG5cdH07XG5cdFxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuX2FwcGx5RmlsdGVyID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG5cdFx0dmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcblx0XHR2YXIgbCA9IGRhdGEubGVuZ3RoO1xuXHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKz00KSB7XG5cdFx0XHRkYXRhW2ldID0gZGF0YVtpXSp0aGlzLnJlZE11bHRpcGxpZXIrdGhpcy5yZWRPZmZzZXQ7XG5cdFx0XHRkYXRhW2krMV0gPSBkYXRhW2krMV0qdGhpcy5ncmVlbk11bHRpcGxpZXIrdGhpcy5ncmVlbk9mZnNldDtcblx0XHRcdGRhdGFbaSsyXSA9IGRhdGFbaSsyXSp0aGlzLmJsdWVNdWx0aXBsaWVyK3RoaXMuYmx1ZU9mZnNldDtcblx0XHRcdGRhdGFbaSszXSA9IGRhdGFbaSszXSp0aGlzLmFscGhhTXVsdGlwbGllcit0aGlzLmFscGhhT2Zmc2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLkNvbG9yRmlsdGVyID0gY3JlYXRlanMucHJvbW90ZShDb2xvckZpbHRlciwgXCJGaWx0ZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQ29sb3JNYXRyaXguanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBQcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIGZvciBhc3NlbWJsaW5nIGEgbWF0cml4IGZvciB1c2Ugd2l0aCB0aGUge3sjY3Jvc3NMaW5rIFwiQ29sb3JNYXRyaXhGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIE1vc3QgbWV0aG9kcyByZXR1cm4gdGhlIGluc3RhbmNlIHRvIGZhY2lsaXRhdGUgY2hhaW5lZCBjYWxscy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIG15Q29sb3JNYXRyaXguYWRqdXN0SHVlKDIwKS5hZGp1c3RCcmlnaHRuZXNzKDUwKTtcblx0ICpcblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkZpbHRlclwifX17ey9jcm9zc0xpbmt9fSBmb3IgYW4gZXhhbXBsZSBvZiBob3cgdG8gYXBwbHkgZmlsdGVycywgb3Ige3sjY3Jvc3NMaW5rIFwiQ29sb3JNYXRyaXhGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGFuIGV4YW1wbGUgb2YgaG93IHRvIHVzZSBDb2xvck1hdHJpeCB0byBjaGFuZ2UgYSBEaXNwbGF5T2JqZWN0J3MgY29sb3IuXG5cdCAqIEBjbGFzcyBDb2xvck1hdHJpeFxuXHQgKiBAcGFyYW0ge051bWJlcn0gYnJpZ2h0bmVzc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gY29udHJhc3Rcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNhdHVyYXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGh1ZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBDb2xvck1hdHJpeChicmlnaHRuZXNzLCBjb250cmFzdCwgc2F0dXJhdGlvbiwgaHVlKSB7XG5cdFx0dGhpcy5zZXRDb2xvcihicmlnaHRuZXNzLCBjb250cmFzdCwgc2F0dXJhdGlvbiwgaHVlKTtcblx0fVxuXHR2YXIgcCA9IENvbG9yTWF0cml4LnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblxuLy8gY29uc3RhbnRzOlxuXHQvKipcblx0ICogQXJyYXkgb2YgZGVsdGEgdmFsdWVzIGZvciBjb250cmFzdCBjYWxjdWxhdGlvbnMuXG5cdCAqIEBwcm9wZXJ0eSBERUxUQV9JTkRFWFxuXHQgKiBAdHlwZSBBcnJheVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRDb2xvck1hdHJpeC5ERUxUQV9JTkRFWCA9IFtcblx0XHQwLCAgICAwLjAxLCAwLjAyLCAwLjA0LCAwLjA1LCAwLjA2LCAwLjA3LCAwLjA4LCAwLjEsICAwLjExLFxuXHRcdDAuMTIsIDAuMTQsIDAuMTUsIDAuMTYsIDAuMTcsIDAuMTgsIDAuMjAsIDAuMjEsIDAuMjIsIDAuMjQsXG5cdFx0MC4yNSwgMC4yNywgMC4yOCwgMC4zMCwgMC4zMiwgMC4zNCwgMC4zNiwgMC4zOCwgMC40MCwgMC40Mixcblx0XHQwLjQ0LCAwLjQ2LCAwLjQ4LCAwLjUsICAwLjUzLCAwLjU2LCAwLjU5LCAwLjYyLCAwLjY1LCAwLjY4LFxuXHRcdDAuNzEsIDAuNzQsIDAuNzcsIDAuODAsIDAuODMsIDAuODYsIDAuODksIDAuOTIsIDAuOTUsIDAuOTgsXG5cdFx0MS4wLCAgMS4wNiwgMS4xMiwgMS4xOCwgMS4yNCwgMS4zMCwgMS4zNiwgMS40MiwgMS40OCwgMS41NCxcblx0XHQxLjYwLCAxLjY2LCAxLjcyLCAxLjc4LCAxLjg0LCAxLjkwLCAxLjk2LCAyLjAsICAyLjEyLCAyLjI1LFxuXHRcdDIuMzcsIDIuNTAsIDIuNjIsIDIuNzUsIDIuODcsIDMuMCwgIDMuMiwgIDMuNCwgIDMuNiwgIDMuOCxcblx0XHQ0LjAsICA0LjMsICA0LjcsICA0LjksICA1LjAsICA1LjUsICA2LjAsICA2LjUsICA2LjgsICA3LjAsXG5cdFx0Ny4zLCAgNy41LCAgNy44LCAgOC4wLCAgOC40LCAgOC43LCAgOS4wLCAgOS40LCAgOS42LCAgOS44LFxuXHRcdDEwLjBcblx0XTtcblxuXHQvKipcblx0ICogSWRlbnRpdHkgbWF0cml4IHZhbHVlcy5cblx0ICogQHByb3BlcnR5IElERU5USVRZX01BVFJJWFxuXHQgKiBAdHlwZSBBcnJheVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRDb2xvck1hdHJpeC5JREVOVElUWV9NQVRSSVggPSBbXG5cdFx0MSwwLDAsMCwwLFxuXHRcdDAsMSwwLDAsMCxcblx0XHQwLDAsMSwwLDAsXG5cdFx0MCwwLDAsMSwwLFxuXHRcdDAsMCwwLDAsMVxuXHRdO1xuXG5cdC8qKlxuXHQgKiBUaGUgY29uc3RhbnQgbGVuZ3RoIG9mIGEgY29sb3IgbWF0cml4LlxuXHQgKiBAcHJvcGVydHkgTEVOR1RIXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRDb2xvck1hdHJpeC5MRU5HVEggPSBDb2xvck1hdHJpeC5JREVOVElUWV9NQVRSSVgubGVuZ3RoO1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmVzZXRzIHRoZSBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWVzLlxuXHQgKiBAbWV0aG9kIHNldENvbG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBicmlnaHRuZXNzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb250cmFzdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2F0dXJhdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gaHVlXG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRwLnNldENvbG9yID0gZnVuY3Rpb24oYnJpZ2h0bmVzcyxjb250cmFzdCxzYXR1cmF0aW9uLGh1ZSkge1xuXHRcdHJldHVybiB0aGlzLnJlc2V0KCkuYWRqdXN0Q29sb3IoYnJpZ2h0bmVzcyxjb250cmFzdCxzYXR1cmF0aW9uLGh1ZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlc2V0cyB0aGUgbWF0cml4IHRvIGlkZW50aXR5IHZhbHVlcy5cblx0ICogQG1ldGhvZCByZXNldFxuXHQgKiBAcmV0dXJuIHtDb2xvck1hdHJpeH0gVGhlIENvbG9yTWF0cml4IGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0cC5yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmNvcHkoQ29sb3JNYXRyaXguSURFTlRJVFlfTUFUUklYKTtcblx0fTtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgbWV0aG9kIHRvIGFkanVzdCBicmlnaHRuZXNzLCBjb250cmFzdCwgc2F0dXJhdGlvbiBhbmQgaHVlLlxuXHQgKiBFcXVpdmFsZW50IHRvIGNhbGxpbmcgYWRqdXN0SHVlKGh1ZSksIGFkanVzdENvbnRyYXN0KGNvbnRyYXN0KSxcblx0ICogYWRqdXN0QnJpZ2h0bmVzcyhicmlnaHRuZXNzKSwgYWRqdXN0U2F0dXJhdGlvbihzYXR1cmF0aW9uKSwgaW4gdGhhdCBvcmRlci5cblx0ICogQG1ldGhvZCBhZGp1c3RDb2xvclxuXHQgKiBAcGFyYW0ge051bWJlcn0gYnJpZ2h0bmVzc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gY29udHJhc3Rcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNhdHVyYXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGh1ZVxuXHQgKiBAcmV0dXJuIHtDb2xvck1hdHJpeH0gVGhlIENvbG9yTWF0cml4IGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYWRqdXN0Q29sb3IgPSBmdW5jdGlvbihicmlnaHRuZXNzLGNvbnRyYXN0LHNhdHVyYXRpb24saHVlKSB7XG5cdFx0dGhpcy5hZGp1c3RIdWUoaHVlKTtcblx0XHR0aGlzLmFkanVzdENvbnRyYXN0KGNvbnRyYXN0KTtcblx0XHR0aGlzLmFkanVzdEJyaWdodG5lc3MoYnJpZ2h0bmVzcyk7XG5cdFx0cmV0dXJuIHRoaXMuYWRqdXN0U2F0dXJhdGlvbihzYXR1cmF0aW9uKTtcblx0fTtcblxuXHQvKipcblx0ICogQWRqdXN0cyB0aGUgYnJpZ2h0bmVzcyBvZiBwaXhlbCBjb2xvciBieSBhZGRpbmcgdGhlIHNwZWNpZmllZCB2YWx1ZSB0byB0aGUgcmVkLCBncmVlbiBhbmQgYmx1ZSBjaGFubmVscy5cblx0ICogUG9zaXRpdmUgdmFsdWVzIHdpbGwgbWFrZSB0aGUgaW1hZ2UgYnJpZ2h0ZXIsIG5lZ2F0aXZlIHZhbHVlcyB3aWxsIG1ha2UgaXQgZGFya2VyLlxuXHQgKiBAbWV0aG9kIGFkanVzdEJyaWdodG5lc3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIEEgdmFsdWUgYmV0d2VlbiAtMjU1ICYgMjU1IHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgUkdCIGNoYW5uZWxzLlxuXHQgKiBAcmV0dXJuIHtDb2xvck1hdHJpeH0gVGhlIENvbG9yTWF0cml4IGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYWRqdXN0QnJpZ2h0bmVzcyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09IDAgfHwgaXNOYU4odmFsdWUpKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dmFsdWUgPSB0aGlzLl9jbGVhblZhbHVlKHZhbHVlLDI1NSk7XG5cdFx0dGhpcy5fbXVsdGlwbHlNYXRyaXgoW1xuXHRcdFx0MSwwLDAsMCx2YWx1ZSxcblx0XHRcdDAsMSwwLDAsdmFsdWUsXG5cdFx0XHQwLDAsMSwwLHZhbHVlLFxuXHRcdFx0MCwwLDAsMSwwLFxuXHRcdFx0MCwwLDAsMCwxXG5cdFx0XSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkanVzdHMgdGhlIGNvbnRyYXN0IG9mIHBpeGVsIGNvbG9yLlxuXHQgKiBQb3NpdGl2ZSB2YWx1ZXMgd2lsbCBpbmNyZWFzZSBjb250cmFzdCwgbmVnYXRpdmUgdmFsdWVzIHdpbGwgZGVjcmVhc2UgY29udHJhc3QuXG5cdCAqIEBtZXRob2QgYWRqdXN0Q29udHJhc3Rcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIEEgdmFsdWUgYmV0d2VlbiAtMTAwICYgMTAwLlxuXHQgKiBAcmV0dXJuIHtDb2xvck1hdHJpeH0gVGhlIENvbG9yTWF0cml4IGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYWRqdXN0Q29udHJhc3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PSAwIHx8IGlzTmFOKHZhbHVlKSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHZhbHVlID0gdGhpcy5fY2xlYW5WYWx1ZSh2YWx1ZSwxMDApO1xuXHRcdHZhciB4O1xuXHRcdGlmICh2YWx1ZTwwKSB7XG5cdFx0XHR4ID0gMTI3K3ZhbHVlLzEwMCoxMjc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHggPSB2YWx1ZSUxO1xuXHRcdFx0aWYgKHggPT0gMCkge1xuXHRcdFx0XHR4ID0gQ29sb3JNYXRyaXguREVMVEFfSU5ERVhbdmFsdWVdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0eCA9IENvbG9yTWF0cml4LkRFTFRBX0lOREVYWyh2YWx1ZTw8MCldKigxLXgpK0NvbG9yTWF0cml4LkRFTFRBX0lOREVYWyh2YWx1ZTw8MCkrMV0qeDsgLy8gdXNlIGxpbmVhciBpbnRlcnBvbGF0aW9uIGZvciBtb3JlIGdyYW51bGFyaXR5LlxuXHRcdFx0fVxuXHRcdFx0eCA9IHgqMTI3KzEyNztcblx0XHR9XG5cdFx0dGhpcy5fbXVsdGlwbHlNYXRyaXgoW1xuXHRcdFx0eC8xMjcsMCwwLDAsMC41KigxMjcteCksXG5cdFx0XHQwLHgvMTI3LDAsMCwwLjUqKDEyNy14KSxcblx0XHRcdDAsMCx4LzEyNywwLDAuNSooMTI3LXgpLFxuXHRcdFx0MCwwLDAsMSwwLFxuXHRcdFx0MCwwLDAsMCwxXG5cdFx0XSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkanVzdHMgdGhlIGNvbG9yIHNhdHVyYXRpb24gb2YgdGhlIHBpeGVsLlxuXHQgKiBQb3NpdGl2ZSB2YWx1ZXMgd2lsbCBpbmNyZWFzZSBzYXR1cmF0aW9uLCBuZWdhdGl2ZSB2YWx1ZXMgd2lsbCBkZWNyZWFzZSBzYXR1cmF0aW9uICh0cmVuZCB0b3dhcmRzIGdyZXlzY2FsZSkuXG5cdCAqIEBtZXRob2QgYWRqdXN0U2F0dXJhdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgQSB2YWx1ZSBiZXR3ZWVuIC0xMDAgJiAxMDAuXG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hZGp1c3RTYXR1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT0gMCB8fCBpc05hTih2YWx1ZSkpIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR2YWx1ZSA9IHRoaXMuX2NsZWFuVmFsdWUodmFsdWUsMTAwKTtcblx0XHR2YXIgeCA9IDErKCh2YWx1ZSA+IDApID8gMyp2YWx1ZS8xMDAgOiB2YWx1ZS8xMDApO1xuXHRcdHZhciBsdW1SID0gMC4zMDg2O1xuXHRcdHZhciBsdW1HID0gMC42MDk0O1xuXHRcdHZhciBsdW1CID0gMC4wODIwO1xuXHRcdHRoaXMuX211bHRpcGx5TWF0cml4KFtcblx0XHRcdGx1bVIqKDEteCkreCxsdW1HKigxLXgpLGx1bUIqKDEteCksMCwwLFxuXHRcdFx0bHVtUiooMS14KSxsdW1HKigxLXgpK3gsbHVtQiooMS14KSwwLDAsXG5cdFx0XHRsdW1SKigxLXgpLGx1bUcqKDEteCksbHVtQiooMS14KSt4LDAsMCxcblx0XHRcdDAsMCwwLDEsMCxcblx0XHRcdDAsMCwwLDAsMVxuXHRcdF0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEFkanVzdHMgdGhlIGh1ZSBvZiB0aGUgcGl4ZWwgY29sb3IuXG5cdCAqIEBtZXRob2QgYWRqdXN0SHVlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBBIHZhbHVlIGJldHdlZW4gLTE4MCAmIDE4MC5cblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmFkanVzdEh1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09IDAgfHwgaXNOYU4odmFsdWUpKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dmFsdWUgPSB0aGlzLl9jbGVhblZhbHVlKHZhbHVlLDE4MCkvMTgwKk1hdGguUEk7XG5cdFx0dmFyIGNvc1ZhbCA9IE1hdGguY29zKHZhbHVlKTtcblx0XHR2YXIgc2luVmFsID0gTWF0aC5zaW4odmFsdWUpO1xuXHRcdHZhciBsdW1SID0gMC4yMTM7XG5cdFx0dmFyIGx1bUcgPSAwLjcxNTtcblx0XHR2YXIgbHVtQiA9IDAuMDcyO1xuXHRcdHRoaXMuX211bHRpcGx5TWF0cml4KFtcblx0XHRcdGx1bVIrY29zVmFsKigxLWx1bVIpK3NpblZhbCooLWx1bVIpLGx1bUcrY29zVmFsKigtbHVtRykrc2luVmFsKigtbHVtRyksbHVtQitjb3NWYWwqKC1sdW1CKStzaW5WYWwqKDEtbHVtQiksMCwwLFxuXHRcdFx0bHVtUitjb3NWYWwqKC1sdW1SKStzaW5WYWwqKDAuMTQzKSxsdW1HK2Nvc1ZhbCooMS1sdW1HKStzaW5WYWwqKDAuMTQwKSxsdW1CK2Nvc1ZhbCooLWx1bUIpK3NpblZhbCooLTAuMjgzKSwwLDAsXG5cdFx0XHRsdW1SK2Nvc1ZhbCooLWx1bVIpK3NpblZhbCooLSgxLWx1bVIpKSxsdW1HK2Nvc1ZhbCooLWx1bUcpK3NpblZhbCoobHVtRyksbHVtQitjb3NWYWwqKDEtbHVtQikrc2luVmFsKihsdW1CKSwwLDAsXG5cdFx0XHQwLDAsMCwxLDAsXG5cdFx0XHQwLDAsMCwwLDFcblx0XHRdKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQ29uY2F0ZW5hdGVzIChtdWx0aXBsaWVzKSB0aGUgc3BlY2lmaWVkIG1hdHJpeCB3aXRoIHRoaXMgb25lLlxuXHQgKiBAbWV0aG9kIGNvbmNhdFxuXHQgKiBAcGFyYW0ge0FycmF5fSBtYXRyaXggQW4gYXJyYXkgb3IgQ29sb3JNYXRyaXggaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5jb25jYXQgPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRtYXRyaXggPSB0aGlzLl9maXhNYXRyaXgobWF0cml4KTtcblx0XHRpZiAobWF0cml4Lmxlbmd0aCAhPSBDb2xvck1hdHJpeC5MRU5HVEgpIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR0aGlzLl9tdWx0aXBseU1hdHJpeChtYXRyaXgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBDb2xvck1hdHJpeC5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtDb2xvck1hdHJpeH0gQSBjbG9uZSBvZiB0aGlzIENvbG9yTWF0cml4LlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKG5ldyBDb2xvck1hdHJpeCgpKS5jb3B5KHRoaXMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm4gYSBsZW5ndGggMjUgKDV4NSkgYXJyYXkgaW5zdGFuY2UgY29udGFpbmluZyB0aGlzIG1hdHJpeCdzIHZhbHVlcy5cblx0ICogQG1ldGhvZCB0b0FycmF5XG5cdCAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBob2xkaW5nIHRoaXMgbWF0cml4J3MgdmFsdWVzLlxuXHQgKiovXG5cdHAudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcnIgPSBbXTtcblx0XHRmb3IgKHZhciBpPSAwLCBsPUNvbG9yTWF0cml4LkxFTkdUSDsgaTxsOyBpKyspIHtcblx0XHRcdGFycltpXSA9IHRoaXNbaV07XG5cdFx0fVxuXHRcdHJldHVybiBhcnI7XG5cdH07XG5cblx0LyoqXG5cdCAqIENvcHkgdGhlIHNwZWNpZmllZCBtYXRyaXgncyB2YWx1ZXMgdG8gdGhpcyBtYXRyaXguXG5cdCAqIEBtZXRob2QgY29weVxuXHQgKiBAcGFyYW0ge0FycmF5fSBtYXRyaXggQW4gYXJyYXkgb3IgQ29sb3JNYXRyaXggaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5jb3B5ID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0dmFyIGwgPSBDb2xvck1hdHJpeC5MRU5HVEg7XG5cdFx0Zm9yICh2YXIgaT0wO2k8bDtpKyspIHtcblx0XHRcdHRoaXNbaV0gPSBtYXRyaXhbaV07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltDb2xvck1hdHJpeF1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9tdWx0aXBseU1hdHJpeFxuXHQgKiBAcGFyYW0ge0FycmF5fSBtYXRyaXhcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX211bHRpcGx5TWF0cml4ID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0dmFyIGksIGosIGssIGNvbCA9IFtdO1xuXG5cdFx0Zm9yIChpPTA7aTw1O2krKykge1xuXHRcdFx0Zm9yIChqPTA7ajw1O2orKykge1xuXHRcdFx0XHRjb2xbal0gPSB0aGlzW2oraSo1XTtcblx0XHRcdH1cblx0XHRcdGZvciAoaj0wO2o8NTtqKyspIHtcblx0XHRcdFx0dmFyIHZhbD0wO1xuXHRcdFx0XHRmb3IgKGs9MDtrPDU7aysrKSB7XG5cdFx0XHRcdFx0dmFsICs9IG1hdHJpeFtqK2sqNV0qY29sW2tdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXNbaitpKjVdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogTWFrZSBzdXJlIHZhbHVlcyBhcmUgd2l0aGluIHRoZSBzcGVjaWZpZWQgcmFuZ2UsIGh1ZSBoYXMgYSBsaW1pdCBvZiAxODAsIGJyaWdodG5lc3MgaXMgMjU1LCBvdGhlcnMgYXJlIDEwMC5cblx0ICogQG1ldGhvZCBfY2xlYW5WYWx1ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVGhlIHJhdyBudW1iZXJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGxpbWl0IFRoZSBtYXhpbXVtIHRoYXQgdGhlIG51bWJlciBjYW4gYmUuIFRoZSBtaW5pbXVtIGlzIHRoZSBsaW1pdCAqIC0xLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fY2xlYW5WYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlLCBsaW1pdCkge1xuXHRcdHJldHVybiBNYXRoLm1pbihsaW1pdCxNYXRoLm1heCgtbGltaXQsdmFsdWUpKTtcblx0fTtcblxuXHQvKipcblx0ICogTWFrZXMgc3VyZSBtYXRyaXhlcyBhcmUgNXg1ICgyNSBsb25nKS5cblx0ICogQG1ldGhvZCBfZml4TWF0cml4XG5cdCAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZml4TWF0cml4ID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0aWYgKG1hdHJpeCBpbnN0YW5jZW9mIENvbG9yTWF0cml4KSB7IG1hdHJpeCA9IG1hdHJpeC50b0FycmF5KCk7IH1cblx0XHRpZiAobWF0cml4Lmxlbmd0aCA8IENvbG9yTWF0cml4LkxFTkdUSCkge1xuXHRcdFx0bWF0cml4ID0gbWF0cml4LnNsaWNlKDAsbWF0cml4Lmxlbmd0aCkuY29uY2F0KENvbG9yTWF0cml4LklERU5USVRZX01BVFJJWC5zbGljZShtYXRyaXgubGVuZ3RoLENvbG9yTWF0cml4LkxFTkdUSCkpO1xuXHRcdH0gZWxzZSBpZiAobWF0cml4Lmxlbmd0aCA+IENvbG9yTWF0cml4LkxFTkdUSCkge1xuXHRcdFx0bWF0cml4ID0gbWF0cml4LnNsaWNlKDAsQ29sb3JNYXRyaXguTEVOR1RIKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1hdHJpeDtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLkNvbG9yTWF0cml4ID0gQ29sb3JNYXRyaXg7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQ29sb3JNYXRyaXhGaWx0ZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBBbGxvd3MgeW91IHRvIGNhcnJ5IG91dCBjb21wbGV4IGNvbG9yIG9wZXJhdGlvbnMgc3VjaCBhcyBtb2RpZnlpbmcgc2F0dXJhdGlvbiwgYnJpZ2h0bmVzcywgb3IgaW52ZXJ0aW5nLiBTZWUgdGhlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkNvbG9yTWF0cml4XCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGNoYW5naW5nIGNvbG9ycy4gRm9yIGFuIGVhc2llciBjb2xvciB0cmFuc2Zvcm0sXG5cdCAqIGNvbnNpZGVyIHRoZSB7eyNjcm9zc0xpbmsgXCJDb2xvckZpbHRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBUaGlzIGV4YW1wbGUgY3JlYXRlcyBhIHJlZCBjaXJjbGUsIGludmVydHMgaXRzIGh1ZSwgYW5kIHRoZW4gc2F0dXJhdGVzIGl0IHRvIGJyaWdodGVuIGl0IHVwLlxuXHQgKlxuXHQgKiAgICAgIHZhciBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpLnNldCh7eDoxMDAseToxMDB9KTtcblx0ICogICAgICBzaGFwZS5ncmFwaGljcy5iZWdpbkZpbGwoXCIjZmYwMDAwXCIpLmRyYXdDaXJjbGUoMCwwLDUwKTtcblx0ICpcblx0ICogICAgICB2YXIgbWF0cml4ID0gbmV3IGNyZWF0ZWpzLkNvbG9yTWF0cml4KCkuYWRqdXN0SHVlKDE4MCkuYWRqdXN0U2F0dXJhdGlvbigxMDApO1xuXHQgKiAgICAgIHNoYXBlLmZpbHRlcnMgPSBbXG5cdCAqICAgICAgICAgIG5ldyBjcmVhdGVqcy5Db2xvck1hdHJpeEZpbHRlcihtYXRyaXgpXG5cdCAqICAgICAgXTtcblx0ICpcblx0ICogICAgICBzaGFwZS5jYWNoZSgtNTAsIC01MCwgMTAwLCAxMDApO1xuXHQgKlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhbiBtb3JlIGluZm9ybWF0aW9uIG9uIGFwcGx5aW5nIGZpbHRlcnMuXG5cdCAqIEBjbGFzcyBDb2xvck1hdHJpeEZpbHRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQGV4dGVuZHMgRmlsdGVyXG5cdCAqIEBwYXJhbSB7QXJyYXkgfCBDb2xvck1hdHJpeH0gbWF0cml4IEEgNHg1IG1hdHJpeCBkZXNjcmliaW5nIHRoZSBjb2xvciBvcGVyYXRpb24gdG8gcGVyZm9ybS4gU2VlIGFsc28gdGhlIHt7I2Nyb3NzTGluayBcIkNvbG9yTWF0cml4XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGNsYXNzLlxuXHQgKiovXG5cdGZ1bmN0aW9uIENvbG9yTWF0cml4RmlsdGVyKG1hdHJpeCkge1xuXHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQSA0eDUgbWF0cml4IGRlc2NyaWJpbmcgdGhlIGNvbG9yIG9wZXJhdGlvbiB0byBwZXJmb3JtLiBTZWUgYWxzbyB0aGUge3sjY3Jvc3NMaW5rIFwiQ29sb3JNYXRyaXhcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBAcHJvcGVydHkgbWF0cml4XG5cdFx0ICogQHR5cGUgQXJyYXkgfCBDb2xvck1hdHJpeFxuXHRcdCAqKi9cblx0XHR0aGlzLm1hdHJpeCA9IG1hdHJpeDtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChDb2xvck1hdHJpeEZpbHRlciwgY3JlYXRlanMuRmlsdGVyKTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblx0XG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0NvbG9yTWF0cml4RmlsdGVyXVwiO1xuXHR9O1xuXG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yTWF0cml4RmlsdGVyKHRoaXMubWF0cml4KTtcblx0fTtcblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLl9hcHBseUZpbHRlciA9IGZ1bmN0aW9uKGltYWdlRGF0YSkgeyBcblx0XHR2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuXHRcdHZhciBsID0gZGF0YS5sZW5ndGg7XG5cdFx0dmFyIHIsZyxiLGE7XG5cdFx0dmFyIG10eCA9IHRoaXMubWF0cml4O1xuXHRcdHZhciBtMCA9ICBtdHhbMF0sICBtMSA9ICBtdHhbMV0sICBtMiA9ICBtdHhbMl0sICBtMyA9ICBtdHhbM10sICBtNCA9ICBtdHhbNF07XG5cdFx0dmFyIG01ID0gIG10eFs1XSwgIG02ID0gIG10eFs2XSwgIG03ID0gIG10eFs3XSwgIG04ID0gIG10eFs4XSwgIG05ID0gIG10eFs5XTtcblx0XHR2YXIgbTEwID0gbXR4WzEwXSwgbTExID0gbXR4WzExXSwgbTEyID0gbXR4WzEyXSwgbTEzID0gbXR4WzEzXSwgbTE0ID0gbXR4WzE0XTtcblx0XHR2YXIgbTE1ID0gbXR4WzE1XSwgbTE2ID0gbXR4WzE2XSwgbTE3ID0gbXR4WzE3XSwgbTE4ID0gbXR4WzE4XSwgbTE5ID0gbXR4WzE5XTtcblxuXHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKz00KSB7XG5cdFx0XHRyID0gZGF0YVtpXTtcblx0XHRcdGcgPSBkYXRhW2krMV07XG5cdFx0XHRiID0gZGF0YVtpKzJdO1xuXHRcdFx0YSA9IGRhdGFbaSszXTtcblx0XHRcdGRhdGFbaV0gPSByKm0wK2cqbTErYiptMithKm0zK200OyAvLyByZWRcblx0XHRcdGRhdGFbaSsxXSA9IHIqbTUrZyptNitiKm03K2EqbTgrbTk7IC8vIGdyZWVuXG5cdFx0XHRkYXRhW2krMl0gPSByKm0xMCtnKm0xMStiKm0xMithKm0xMyttMTQ7IC8vIGJsdWVcblx0XHRcdGRhdGFbaSszXSA9IHIqbTE1K2cqbTE2K2IqbTE3K2EqbTE4K20xOTsgLy8gYWxwaGFcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5Db2xvck1hdHJpeEZpbHRlciA9IGNyZWF0ZWpzLnByb21vdGUoQ29sb3JNYXRyaXhGaWx0ZXIsIFwiRmlsdGVyXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFRvdWNoLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcbiAqIEdsb2JhbCB1dGlsaXR5IGZvciB3b3JraW5nIHdpdGggbXVsdGktdG91Y2ggZW5hYmxlZCBkZXZpY2VzIGluIEVhc2VsSlMuIEN1cnJlbnRseSBzdXBwb3J0cyBXM0MgVG91Y2ggQVBJIChpT1MgYW5kXG4gKiBtb2Rlcm4gQW5kcm9pZCBicm93c2VyKSBhbmQgdGhlIFBvaW50ZXIgQVBJIChJRSksIGluY2x1ZGluZyBtcy1wcmVmaXhlZCBldmVudHMgaW4gSUUxMCwgYW5kIHVucHJlZml4ZWQgaW4gSUUxMS5cbiAqXG4gKiBFbnN1cmUgdGhhdCB5b3Uge3sjY3Jvc3NMaW5rIFwiVG91Y2gvZGlzYWJsZVwifX17ey9jcm9zc0xpbmt9fSB0b3VjaCB3aGVuIGNsZWFuaW5nIHVwIHlvdXIgYXBwbGljYXRpb24uIFlvdSBkbyBub3QgaGF2ZVxuICogdG8gY2hlY2sgaWYgdG91Y2ggaXMgc3VwcG9ydGVkIHRvIGVuYWJsZSBpdCwgYXMgaXQgd2lsbCBmYWlsIGdyYWNlZnVsbHkgaWYgaXQgaXMgbm90IHN1cHBvcnRlZC5cbiAqXG4gKiA8aDQ+RXhhbXBsZTwvaDQ+XG4gKlxuICogICAgICB2YXIgc3RhZ2UgPSBuZXcgY3JlYXRlanMuU3RhZ2UoXCJjYW52YXNJZFwiKTtcbiAqICAgICAgY3JlYXRlanMuVG91Y2guZW5hYmxlKHN0YWdlKTtcbiAqXG4gKiA8c3Ryb25nPk5vdGU6PC9zdHJvbmc+IEl0IGlzIGltcG9ydGFudCB0byBkaXNhYmxlIFRvdWNoIG9uIGEgc3RhZ2UgdGhhdCB5b3UgYXJlIG5vIGxvbmdlciB1c2luZzpcbiAqXG4gKiAgICAgIGNyZWF0ZWpzLlRvdWNoLmRpc2FibGUoc3RhZ2UpO1xuICpcbiAqIEBjbGFzcyBUb3VjaFxuICogQHN0YXRpY1xuICoqL1xuXHRmdW5jdGlvbiBUb3VjaCgpIHtcblx0XHR0aHJvdyBcIlRvdWNoIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWRcIjtcblx0fVxuXG5cbi8vIHB1YmxpYyBzdGF0aWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIGlmIHRvdWNoIGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBicm93c2VyLlxuXHQgKiBAbWV0aG9kIGlzU3VwcG9ydGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEluZGljYXRlcyB3aGV0aGVyIHRvdWNoIGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBicm93c2VyLlxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VG91Y2guaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm5cdCEhKCgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIC8vIGlPUyAmIEFuZHJvaWRcblx0XHRcdHx8ICh3aW5kb3cubmF2aWdhdG9yWydtc1BvaW50ZXJFbmFibGVkJ10gJiYgd2luZG93Lm5hdmlnYXRvclsnbXNNYXhUb3VjaFBvaW50cyddID4gMCkgLy8gSUUxMFxuXHRcdFx0fHwgKHdpbmRvdy5uYXZpZ2F0b3JbJ3BvaW50ZXJFbmFibGVkJ10gJiYgd2luZG93Lm5hdmlnYXRvclsnbWF4VG91Y2hQb2ludHMnXSA+IDApKTsgLy8gSUUxMStcblx0fTtcblxuXHQvKipcblx0ICogRW5hYmxlcyB0b3VjaCBpbnRlcmFjdGlvbiBmb3IgdGhlIHNwZWNpZmllZCBFYXNlbEpTIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319LiBDdXJyZW50bHkgc3VwcG9ydHMgaU9TXG5cdCAqIChhbmQgY29tcGF0aWJsZSBicm93c2Vycywgc3VjaCBhcyBtb2Rlcm4gQW5kcm9pZCBicm93c2VycyksIGFuZCBJRTEwLzExLiBTdXBwb3J0cyBib3RoIHNpbmdsZSB0b3VjaCBhbmRcblx0ICogbXVsdGktdG91Y2ggbW9kZXMuIEV4dGVuZHMgdGhlIEVhc2VsSlMge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBtb2RlbCwgYnV0IHdpdGhvdXQgc3VwcG9ydCBmb3Jcblx0ICogZG91YmxlIGNsaWNrIG9yIG92ZXIvb3V0IGV2ZW50cy4gU2VlIHRoZSBNb3VzZUV2ZW50IHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnQvcG9pbnRlcklkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAbWV0aG9kIGVuYWJsZVxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZSBUaGUge3sjY3Jvc3NMaW5rIFwiU3RhZ2VcIn19e3svY3Jvc3NMaW5rfX0gdG8gZW5hYmxlIHRvdWNoIG9uLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaW5nbGVUb3VjaD1mYWxzZV0gSWYgYHRydWVgLCBvbmx5IGEgc2luZ2xlIHRvdWNoIHdpbGwgYmUgYWN0aXZlIGF0IGEgdGltZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbYWxsb3dEZWZhdWx0PWZhbHNlXSBJZiBgdHJ1ZWAsIHRoZW4gZGVmYXVsdCBnZXN0dXJlIGFjdGlvbnMgKGV4LiBzY3JvbGxpbmcsIHpvb21pbmcpIHdpbGwgYmVcblx0ICogYWxsb3dlZCB3aGVuIHRoZSB1c2VyIGlzIGludGVyYWN0aW5nIHdpdGggdGhlIHRhcmdldCBjYW52YXMuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRvdWNoIHdhcyBzdWNjZXNzZnVsbHkgZW5hYmxlZCBvbiB0aGUgdGFyZ2V0IHN0YWdlLlxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VG91Y2guZW5hYmxlID0gZnVuY3Rpb24oc3RhZ2UsIHNpbmdsZVRvdWNoLCBhbGxvd0RlZmF1bHQpIHtcblx0XHRpZiAoIXN0YWdlIHx8ICFzdGFnZS5jYW52YXMgfHwgIVRvdWNoLmlzU3VwcG9ydGVkKCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKHN0YWdlLl9fdG91Y2gpIHsgcmV0dXJuIHRydWU7IH1cblxuXHRcdC8vIGluamVjdCByZXF1aXJlZCBwcm9wZXJ0aWVzIG9uIHN0YWdlOlxuXHRcdHN0YWdlLl9fdG91Y2ggPSB7cG9pbnRlcnM6e30sIG11bHRpdG91Y2g6IXNpbmdsZVRvdWNoLCBwcmV2ZW50RGVmYXVsdDohYWxsb3dEZWZhdWx0LCBjb3VudDowfTtcblxuXHRcdC8vIG5vdGUgdGhhdCBpbiB0aGUgZnV0dXJlIHdlIG1heSBuZWVkIHRvIGRpc2FibGUgdGhlIHN0YW5kYXJkIG1vdXNlIGV2ZW50IG1vZGVsIGJlZm9yZSBhZGRpbmdcblx0XHQvLyB0aGVzZSB0byBwcmV2ZW50IGR1cGxpY2F0ZSBjYWxscy4gSXQgZG9lc24ndCBzZWVtIHRvIGJlIGFuIGlzc3VlIHdpdGggaU9TIGRldmljZXMgdGhvdWdoLlxuXHRcdGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHsgVG91Y2guX0lPU19lbmFibGUoc3RhZ2UpOyB9XG5cdFx0ZWxzZSBpZiAod2luZG93Lm5hdmlnYXRvclsnbXNQb2ludGVyRW5hYmxlZCddIHx8IHdpbmRvdy5uYXZpZ2F0b3JbXCJwb2ludGVyRW5hYmxlZFwiXSkgeyBUb3VjaC5fSUVfZW5hYmxlKHN0YWdlKTsgfVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIHNldCB1cCB3aGVuIGNhbGxpbmcgYFRvdWNoLmVuYWJsZSgpYCBvbiBhIHN0YWdlLlxuXHQgKiBAbWV0aG9kIGRpc2FibGVcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2UgVGhlIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319IHRvIGRpc2FibGUgdG91Y2ggb24uXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUb3VjaC5kaXNhYmxlID0gZnVuY3Rpb24oc3RhZ2UpIHtcblx0XHRpZiAoIXN0YWdlKSB7IHJldHVybjsgfVxuXHRcdGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHsgVG91Y2guX0lPU19kaXNhYmxlKHN0YWdlKTsgfVxuXHRcdGVsc2UgaWYgKHdpbmRvdy5uYXZpZ2F0b3JbJ21zUG9pbnRlckVuYWJsZWQnXSB8fCB3aW5kb3cubmF2aWdhdG9yW1wicG9pbnRlckVuYWJsZWRcIl0pIHsgVG91Y2guX0lFX2Rpc2FibGUoc3RhZ2UpOyB9XG5cdFx0XG5cdFx0ZGVsZXRlIHN0YWdlLl9fdG91Y2g7XG5cdH07XG5cblxuLy8gUHJpdmF0ZSBzdGF0aWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX0lPU19lbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZVxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VG91Y2guX0lPU19lbmFibGUgPSBmdW5jdGlvbihzdGFnZSkge1xuXHRcdHZhciBjYW52YXMgPSBzdGFnZS5jYW52YXM7XG5cdFx0dmFyIGYgPSBzdGFnZS5fX3RvdWNoLmYgPSBmdW5jdGlvbihlKSB7IFRvdWNoLl9JT1NfaGFuZGxlRXZlbnQoc3RhZ2UsZSk7IH07XG5cdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIGYsIGZhbHNlKTtcblx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBmLCBmYWxzZSk7XG5cdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBmLCBmYWxzZSk7XG5cdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCBmLCBmYWxzZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX0lPU19kaXNhYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2Vcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRvdWNoLl9JT1NfZGlzYWJsZSA9IGZ1bmN0aW9uKHN0YWdlKSB7XG5cdFx0dmFyIGNhbnZhcyA9IHN0YWdlLmNhbnZhcztcblx0XHRpZiAoIWNhbnZhcykgeyByZXR1cm47IH1cblx0XHR2YXIgZiA9IHN0YWdlLl9fdG91Y2guZjtcblx0XHRjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgZiwgZmFsc2UpO1xuXHRcdGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGYsIGZhbHNlKTtcblx0XHRjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGYsIGZhbHNlKTtcblx0XHRjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIGYsIGZhbHNlKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfSU9TX2hhbmRsZUV2ZW50XG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBldmVudCB0byBoYW5kbGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VG91Y2guX0lPU19oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKHN0YWdlLCBlKSB7XG5cdFx0aWYgKCFzdGFnZSkgeyByZXR1cm47IH1cblx0XHRpZiAoc3RhZ2UuX190b3VjaC5wcmV2ZW50RGVmYXVsdCkgeyBlLnByZXZlbnREZWZhdWx0JiZlLnByZXZlbnREZWZhdWx0KCk7IH1cblx0XHR2YXIgdG91Y2hlcyA9IGUuY2hhbmdlZFRvdWNoZXM7XG5cdFx0dmFyIHR5cGUgPSBlLnR5cGU7XG5cdFx0Zm9yICh2YXIgaT0gMCxsPXRvdWNoZXMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0dmFyIHRvdWNoID0gdG91Y2hlc1tpXTtcblx0XHRcdHZhciBpZCA9IHRvdWNoLmlkZW50aWZpZXI7XG5cdFx0XHRpZiAodG91Y2gudGFyZ2V0ICE9IHN0YWdlLmNhbnZhcykgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRpZiAodHlwZSA9PSBcInRvdWNoc3RhcnRcIikge1xuXHRcdFx0XHR0aGlzLl9oYW5kbGVTdGFydChzdGFnZSwgaWQsIGUsIHRvdWNoLnBhZ2VYLCB0b3VjaC5wYWdlWSk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT0gXCJ0b3VjaG1vdmVcIikge1xuXHRcdFx0XHR0aGlzLl9oYW5kbGVNb3ZlKHN0YWdlLCBpZCwgZSwgdG91Y2gucGFnZVgsIHRvdWNoLnBhZ2VZKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PSBcInRvdWNoZW5kXCIgfHwgdHlwZSA9PSBcInRvdWNoY2FuY2VsXCIpIHtcblx0XHRcdFx0dGhpcy5faGFuZGxlRW5kKHN0YWdlLCBpZCwgZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9JRV9lbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZVxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VG91Y2guX0lFX2VuYWJsZSA9IGZ1bmN0aW9uKHN0YWdlKSB7XG5cdFx0dmFyIGNhbnZhcyA9IHN0YWdlLmNhbnZhcztcblx0XHR2YXIgZiA9IHN0YWdlLl9fdG91Y2guZiA9IGZ1bmN0aW9uKGUpIHsgVG91Y2guX0lFX2hhbmRsZUV2ZW50KHN0YWdlLGUpOyB9O1xuXG5cdFx0aWYgKHdpbmRvdy5uYXZpZ2F0b3JbXCJwb2ludGVyRW5hYmxlZFwiXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIk1TUG9pbnRlckRvd25cIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJNb3ZlXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyVXBcIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJDYW5jZWxcIiwgZiwgZmFsc2UpO1xuXHRcdFx0aWYgKHN0YWdlLl9fdG91Y2gucHJldmVudERlZmF1bHQpIHsgY2FudmFzLnN0eWxlLm1zVG91Y2hBY3Rpb24gPSBcIm5vbmVcIjsgfVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIsIGYsIGZhbHNlKTtcblx0XHRcdGlmIChzdGFnZS5fX3RvdWNoLnByZXZlbnREZWZhdWx0KSB7IGNhbnZhcy5zdHlsZS50b3VjaEFjdGlvbiA9IFwibm9uZVwiOyB9XG5cblx0XHR9XG5cdFx0c3RhZ2UuX190b3VjaC5hY3RpdmVJRHMgPSB7fTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfSUVfZGlzYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUb3VjaC5fSUVfZGlzYWJsZSA9IGZ1bmN0aW9uKHN0YWdlKSB7XG5cdFx0dmFyIGYgPSBzdGFnZS5fX3RvdWNoLmY7XG5cblx0XHRpZiAod2luZG93Lm5hdmlnYXRvcltcInBvaW50ZXJFbmFibGVkXCJdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyTW92ZVwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIk1TUG9pbnRlclVwXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyQ2FuY2VsXCIsIGYsIGZhbHNlKTtcblx0XHRcdGlmIChzdGFnZS5jYW52YXMpIHtcblx0XHRcdFx0c3RhZ2UuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJEb3duXCIsIGYsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJjYW5jZWxcIiwgZiwgZmFsc2UpO1xuXHRcdFx0aWYgKHN0YWdlLmNhbnZhcykge1xuXHRcdFx0XHRzdGFnZS5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGYsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX0lFX2hhbmRsZUV2ZW50XG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBldmVudCB0byBoYW5kbGUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRvdWNoLl9JRV9oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKHN0YWdlLCBlKSB7XG5cdFx0aWYgKCFzdGFnZSkgeyByZXR1cm47IH1cblx0XHRpZiAoc3RhZ2UuX190b3VjaC5wcmV2ZW50RGVmYXVsdCkgeyBlLnByZXZlbnREZWZhdWx0ICYmIGUucHJldmVudERlZmF1bHQoKTsgfVxuXHRcdHZhciB0eXBlID0gZS50eXBlO1xuXHRcdHZhciBpZCA9IGUucG9pbnRlcklkO1xuXHRcdHZhciBpZHMgPSBzdGFnZS5fX3RvdWNoLmFjdGl2ZUlEcztcblxuXHRcdGlmICh0eXBlID09IFwiTVNQb2ludGVyRG93blwiIHx8IHR5cGUgPT0gXCJwb2ludGVyZG93blwiKSB7XG5cdFx0XHRpZiAoZS5zcmNFbGVtZW50ICE9IHN0YWdlLmNhbnZhcykgeyByZXR1cm47IH1cblx0XHRcdGlkc1tpZF0gPSB0cnVlO1xuXHRcdFx0dGhpcy5faGFuZGxlU3RhcnQoc3RhZ2UsIGlkLCBlLCBlLnBhZ2VYLCBlLnBhZ2VZKTtcblx0XHR9IGVsc2UgaWYgKGlkc1tpZF0pIHsgLy8gaXQncyBhbiBpZCB3ZSdyZSB3YXRjaGluZ1xuXHRcdFx0aWYgKHR5cGUgPT0gXCJNU1BvaW50ZXJNb3ZlXCIgfHwgdHlwZSA9PSBcInBvaW50ZXJtb3ZlXCIpIHtcblx0XHRcdFx0dGhpcy5faGFuZGxlTW92ZShzdGFnZSwgaWQsIGUsIGUucGFnZVgsIGUucGFnZVkpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09IFwiTVNQb2ludGVyVXBcIiB8fCB0eXBlID09IFwiTVNQb2ludGVyQ2FuY2VsXCJcblx0XHRcdFx0XHR8fCB0eXBlID09IFwicG9pbnRlcnVwXCIgfHwgdHlwZSA9PSBcInBvaW50ZXJjYW5jZWxcIikge1xuXHRcdFx0XHRkZWxldGUoaWRzW2lkXSk7XG5cdFx0XHRcdHRoaXMuX2hhbmRsZUVuZChzdGFnZSwgaWQsIGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlU3RhcnRcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2Vcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBpZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VG91Y2guX2hhbmRsZVN0YXJ0ID0gZnVuY3Rpb24oc3RhZ2UsIGlkLCBlLCB4LCB5KSB7XG5cdFx0dmFyIHByb3BzID0gc3RhZ2UuX190b3VjaDtcblx0XHRpZiAoIXByb3BzLm11bHRpdG91Y2ggJiYgcHJvcHMuY291bnQpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIGlkcyA9IHByb3BzLnBvaW50ZXJzO1xuXHRcdGlmIChpZHNbaWRdKSB7IHJldHVybjsgfVxuXHRcdGlkc1tpZF0gPSB0cnVlO1xuXHRcdHByb3BzLmNvdW50Kys7XG5cdFx0c3RhZ2UuX2hhbmRsZVBvaW50ZXJEb3duKGlkLCBlLCB4LCB5KTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlTW92ZVxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGlkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUb3VjaC5faGFuZGxlTW92ZSA9IGZ1bmN0aW9uKHN0YWdlLCBpZCwgZSwgeCwgeSkge1xuXHRcdGlmICghc3RhZ2UuX190b3VjaC5wb2ludGVyc1tpZF0pIHsgcmV0dXJuOyB9XG5cdFx0c3RhZ2UuX2hhbmRsZVBvaW50ZXJNb3ZlKGlkLCBlLCB4LCB5KTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlRW5kXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gaWRcblx0ICogQHBhcmFtIHtPYmplY3R9IGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRvdWNoLl9oYW5kbGVFbmQgPSBmdW5jdGlvbihzdGFnZSwgaWQsIGUpIHtcblx0XHQvLyBUT0RPOiBjYW5jZWwgc2hvdWxkIGJlIGhhbmRsZWQgZGlmZmVyZW50bHkgZm9yIHByb3BlciBVSSAoZXguIGFuIHVwIHdvdWxkIHRyaWdnZXIgYSBjbGljaywgYSBjYW5jZWwgd291bGQgbW9yZSBjbG9zZWx5IHJlc2VtYmxlIGFuIG91dCkuXG5cdFx0dmFyIHByb3BzID0gc3RhZ2UuX190b3VjaDtcblx0XHR2YXIgaWRzID0gcHJvcHMucG9pbnRlcnM7XG5cdFx0aWYgKCFpZHNbaWRdKSB7IHJldHVybjsgfVxuXHRcdHByb3BzLmNvdW50LS07XG5cdFx0c3RhZ2UuX2hhbmRsZVBvaW50ZXJVcChpZCwgZSwgdHJ1ZSk7XG5cdFx0ZGVsZXRlKGlkc1tpZF0pO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuVG91Y2ggPSBUb3VjaDtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyB2ZXJzaW9uLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBTdGF0aWMgY2xhc3MgaG9sZGluZyBsaWJyYXJ5IHNwZWNpZmljIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHZlcnNpb24gYW5kIGJ1aWxkRGF0ZSBvZlxuXHQgKiB0aGUgbGlicmFyeS5cblx0ICogQGNsYXNzIEVhc2VsSlNcblx0ICoqL1xuXHR2YXIgcyA9IGNyZWF0ZWpzLkVhc2VsSlMgPSBjcmVhdGVqcy5FYXNlbEpTIHx8IHt9O1xuXG5cdC8qKlxuXHQgKiBUaGUgdmVyc2lvbiBzdHJpbmcgZm9yIHRoaXMgcmVsZWFzZS5cblx0ICogQHByb3BlcnR5IHZlcnNpb25cblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRzLnZlcnNpb24gPSAvKj12ZXJzaW9uKi9cIjAuOC4yXCI7IC8vIGluamVjdGVkIGJ5IGJ1aWxkIHByb2Nlc3NcblxuXHQvKipcblx0ICogVGhlIGJ1aWxkIGRhdGUgZm9yIHRoaXMgcmVsZWFzZSBpbiBVVEMgZm9ybWF0LlxuXHQgKiBAcHJvcGVydHkgYnVpbGREYXRlXG5cdCAqIEB0eXBlIFN0cmluZ1xuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0cy5idWlsZERhdGUgPSAvKj1kYXRlKi9cIlRodSwgMjYgTm92IDIwMTUgMjA6NDQ6MzQgR01UXCI7IC8vIGluamVjdGVkIGJ5IGJ1aWxkIHByb2Nlc3NcblxufSkoKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIHZlcnNpb24uanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBTdGF0aWMgY2xhc3MgaG9sZGluZyBsaWJyYXJ5IHNwZWNpZmljIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHZlcnNpb24gYW5kIGJ1aWxkRGF0ZSBvZiB0aGUgbGlicmFyeS5cblx0ICogQGNsYXNzIFByZWxvYWRKU1xuXHQgKiovXG5cdHZhciBzID0gY3JlYXRlanMuUHJlbG9hZEpTID0gY3JlYXRlanMuUHJlbG9hZEpTIHx8IHt9O1xuXG5cdC8qKlxuXHQgKiBUaGUgdmVyc2lvbiBzdHJpbmcgZm9yIHRoaXMgcmVsZWFzZS5cblx0ICogQHByb3BlcnR5IHZlcnNpb25cblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdHMudmVyc2lvbiA9IC8qPXZlcnNpb24qL1wiMC42LjJcIjsgLy8gaW5qZWN0ZWQgYnkgYnVpbGQgcHJvY2Vzc1xuXG5cdC8qKlxuXHQgKiBUaGUgYnVpbGQgZGF0ZSBmb3IgdGhpcyByZWxlYXNlIGluIFVUQyBmb3JtYXQuXG5cdCAqIEBwcm9wZXJ0eSBidWlsZERhdGVcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdHMuYnVpbGREYXRlID0gLyo9ZGF0ZSovXCJUaHUsIDI2IE5vdiAyMDE1IDIwOjQ0OjMxIEdNVFwiOyAvLyBpbmplY3RlZCBieSBidWlsZCBwcm9jZXNzXG5cbn0pKCk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBwcm94eS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuLyoqXG4gKiBWYXJpb3VzIHV0aWxpdGllcyB0aGF0IHRoZSBDcmVhdGVKUyBTdWl0ZSB1c2VzLiBVdGlsaXRpZXMgYXJlIGNyZWF0ZWQgYXMgc2VwYXJhdGUgZmlsZXMsIGFuZCB3aWxsIGJlIGF2YWlsYWJsZSBvbiB0aGVcbiAqIGNyZWF0ZWpzIG5hbWVzcGFjZSBkaXJlY3RseS5cbiAqXG4gKiA8aDQ+RXhhbXBsZTwvaDQ+XG4gKlxuICogICAgICBteU9iamVjdC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGNyZWF0ZWpzLnByb3h5KG15TWV0aG9kLCBzY29wZSkpO1xuICpcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqIEBtYWluIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIEEgZnVuY3Rpb24gcHJveHkgZm9yIG1ldGhvZHMuIEJ5IGRlZmF1bHQsIEphdmFTY3JpcHQgbWV0aG9kcyBkbyBub3QgbWFpbnRhaW4gc2NvcGUsIHNvIHBhc3NpbmcgYSBtZXRob2QgYXMgYVxuXHQgKiBjYWxsYmFjayB3aWxsIHJlc3VsdCBpbiB0aGUgbWV0aG9kIGdldHRpbmcgY2FsbGVkIGluIHRoZSBzY29wZSBvZiB0aGUgY2FsbGVyLiBVc2luZyBhIHByb3h5IGVuc3VyZXMgdGhhdCB0aGVcblx0ICogbWV0aG9kIGdldHMgY2FsbGVkIGluIHRoZSBjb3JyZWN0IHNjb3BlLlxuXHQgKlxuXHQgKiBBZGRpdGlvbmFsIGFyZ3VtZW50cyBjYW4gYmUgcGFzc2VkIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBmdW5jdGlvbiB3aGVuIGl0IGlzIGNhbGxlZC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIG15T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJldmVudFwiLCBjcmVhdGVqcy5wcm94eShteUhhbmRsZXIsIHRoaXMsIGFyZzEsIGFyZzIpKTtcblx0ICpcblx0ICogICAgICBmdW5jdGlvbiBteUhhbmRsZXIoYXJnMSwgYXJnMikge1xuXHQgKiAgICAgICAgICAgLy8gVGhpcyBnZXRzIGNhbGxlZCB3aGVuIG15T2JqZWN0Lm15Q2FsbGJhY2sgaXMgZXhlY3V0ZWQuXG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBAbWV0aG9kIHByb3h5XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBUaGUgZnVuY3Rpb24gdG8gY2FsbFxuXHQgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgVGhlIHNjb3BlIHRvIGNhbGwgdGhlIG1ldGhvZCBuYW1lIG9uXG5cdCAqIEBwYXJhbSB7bWl4ZWR9IFthcmddICogQXJndW1lbnRzIHRoYXQgYXJlIGFwcGVuZGVkIHRvIHRoZSBjYWxsYmFjayBmb3IgYWRkaXRpb25hbCBwYXJhbXMuXG5cdCAqIEBwdWJsaWNcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0Y3JlYXRlanMucHJveHkgPSBmdW5jdGlvbiAobWV0aG9kLCBzY29wZSkge1xuXHRcdHZhciBhQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBtZXRob2QuYXBwbHkoc2NvcGUsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkuY29uY2F0KGFBcmdzKSk7XG5cdFx0fTtcblx0fVxuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRXJyb3JFdmVudC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogQSBnZW5lcmFsIGVycm9yIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LCB0aGF0IGRlc2NyaWJlcyBhbiBlcnJvciB0aGF0IG9jY3VycmVkLCBhcyB3ZWxsIGFzIGFueSBkZXRhaWxzLlxuXHQgKiBAY2xhc3MgRXJyb3JFdmVudFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3RpdGxlXSBUaGUgZXJyb3IgdGl0bGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXSBUaGUgZXJyb3IgZGVzY3JpcHRpb25cblx0ICogQHBhcmFtIHtPYmplY3R9IFtkYXRhXSBBZGRpdGlvbmFsIGVycm9yIGRhdGFcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBFcnJvckV2ZW50KHRpdGxlLCBtZXNzYWdlLCBkYXRhKSB7XG5cdFx0dGhpcy5FdmVudF9jb25zdHJ1Y3RvcihcImVycm9yXCIpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHNob3J0IGVycm9yIHRpdGxlLCB3aGljaCBpbmRpY2F0ZXMgdGhlIHR5cGUgb2YgZXJyb3IgdGhhdCBvY2N1cnJlZC5cblx0XHQgKiBAcHJvcGVydHkgdGl0bGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHR0aGlzLnRpdGxlID0gdGl0bGU7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdmVyYm9zZSBlcnJvciBtZXNzYWdlLCBjb250YWluaW5nIGRldGFpbHMgYWJvdXQgdGhlIGVycm9yLlxuXHRcdCAqIEBwcm9wZXJ0eSBtZXNzYWdlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblxuXHRcdC8qKlxuXHRcdCAqIEFkZGl0aW9uYWwgZGF0YSBhdHRhY2hlZCB0byBhbiBlcnJvci5cblx0XHQgKiBAcHJvcGVydHkgZGF0YVxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5kYXRhID0gZGF0YTtcblx0fVxuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEVycm9yRXZlbnQsIGNyZWF0ZWpzLkV2ZW50KTtcblxuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KHRoaXMudGl0bGUsIHRoaXMubWVzc2FnZSwgdGhpcy5kYXRhKTtcblx0fTtcblxuXHRjcmVhdGVqcy5FcnJvckV2ZW50ID0gY3JlYXRlanMucHJvbW90ZShFcnJvckV2ZW50LCBcIkV2ZW50XCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gUHJvZ3Jlc3NFdmVudC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uIChzY29wZSkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBDcmVhdGVKUyB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGRpc3BhdGNoZWQgd2hlbiBwcm9ncmVzcyBjaGFuZ2VzLlxuXHQgKiBAY2xhc3MgUHJvZ3Jlc3NFdmVudFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbG9hZGVkIFRoZSBhbW91bnQgdGhhdCBoYXMgYmVlbiBsb2FkZWQuIFRoaXMgY2FuIGJlIGFueSBudW1iZXIgcmVsYXRpdmUgdG8gdGhlIHRvdGFsLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RvdGFsPTFdIFRoZSB0b3RhbCBhbW91bnQgdGhhdCB3aWxsIGxvYWQuIFRoaXMgd2lsbCBkZWZhdWx0IHRvIDEsIHNvIGlmIHRoZSBgbG9hZGVkYCB2YWx1ZSBpc1xuXHQgKiBhIHBlcmNlbnRhZ2UgKGJldHdlZW4gMCBhbmQgMSksIGl0IGNhbiBiZSBvbWl0dGVkLlxuXHQgKiBAdG9kbyBDb25zaWRlciBoYXZpbmcgdGhpcyBldmVudCBiZSBhIFwiZmlsZXByb2dyZXNzXCIgZXZlbnQgYXMgd2VsbFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFByb2dyZXNzRXZlbnQobG9hZGVkLCB0b3RhbCkge1xuXHRcdHRoaXMuRXZlbnRfY29uc3RydWN0b3IoXCJwcm9ncmVzc1wiKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBhbW91bnQgdGhhdCBoYXMgYmVlbiBsb2FkZWQgKG91dCBvZiBhIHRvdGFsIGFtb3VudClcblx0XHQgKiBAcHJvcGVydHkgbG9hZGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLmxvYWRlZCA9IGxvYWRlZDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0b3RhbCBcInNpemVcIiBvZiB0aGUgbG9hZC5cblx0XHQgKiBAcHJvcGVydHkgdG90YWxcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLnRvdGFsID0gKHRvdGFsID09IG51bGwpID8gMSA6IHRvdGFsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHBlcmNlbnRhZ2UgKG91dCBvZiAxKSB0aGF0IHRoZSBsb2FkIGhhcyBiZWVuIGNvbXBsZXRlZC4gVGhpcyBpcyBjYWxjdWxhdGVkIHVzaW5nIGBsb2FkZWQvdG90YWxgLlxuXHRcdCAqIEBwcm9wZXJ0eSBwcm9ncmVzc1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSAodG90YWwgPT0gMCkgPyAwIDogdGhpcy5sb2FkZWQgLyB0aGlzLnRvdGFsO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFByb2dyZXNzRXZlbnQsIGNyZWF0ZWpzLkV2ZW50KTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBQcm9ncmVzc0V2ZW50IGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge1Byb2dyZXNzRXZlbnR9IGEgY2xvbmUgb2YgdGhlIEV2ZW50IGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IGNyZWF0ZWpzLlByb2dyZXNzRXZlbnQodGhpcy5sb2FkZWQsIHRoaXMudG90YWwpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLlByb2dyZXNzRXZlbnQgPSBjcmVhdGVqcy5wcm9tb3RlKFByb2dyZXNzRXZlbnQsIFwiRXZlbnRcIik7XG5cbn0od2luZG93KSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBqc29uMy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuLyohIEpTT04gdjMuMy4yIHwgaHR0cDovL2Jlc3RpZWpzLmdpdGh1Yi5pby9qc29uMyB8IENvcHlyaWdodCAyMDEyLTIwMTQsIEtpdCBDYW1icmlkZ2UgfCBodHRwOi8va2l0Lm1pdC1saWNlbnNlLm9yZyAqL1xuOyhmdW5jdGlvbiAoKSB7XG4gIC8vIERldGVjdCB0aGUgYGRlZmluZWAgZnVuY3Rpb24gZXhwb3NlZCBieSBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuIFRoZVxuICAvLyBzdHJpY3QgYGRlZmluZWAgY2hlY2sgaXMgbmVjZXNzYXJ5IGZvciBjb21wYXRpYmlsaXR5IHdpdGggYHIuanNgLlxuICB2YXIgaXNMb2FkZXIgPSB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZDtcblxuICAvLyBBIHNldCBvZiB0eXBlcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIG9iamVjdHMgZnJvbSBwcmltaXRpdmVzLlxuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgIFwib2JqZWN0XCI6IHRydWVcbiAgfTtcblxuICAvLyBEZXRlY3QgdGhlIGBleHBvcnRzYCBvYmplY3QgZXhwb3NlZCBieSBDb21tb25KUyBpbXBsZW1lbnRhdGlvbnMuXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLy8gVXNlIHRoZSBgZ2xvYmFsYCBvYmplY3QgZXhwb3NlZCBieSBOb2RlIChpbmNsdWRpbmcgQnJvd3NlcmlmeSB2aWFcbiAgLy8gYGluc2VydC1tb2R1bGUtZ2xvYmFsc2ApLCBOYXJ3aGFsLCBhbmQgUmluZ28gYXMgdGhlIGRlZmF1bHQgY29udGV4dCxcbiAgLy8gYW5kIHRoZSBgd2luZG93YCBvYmplY3QgaW4gYnJvd3NlcnMuIFJoaW5vIGV4cG9ydHMgYSBgZ2xvYmFsYCBmdW5jdGlvblxuICAvLyBpbnN0ZWFkLlxuICB2YXIgcm9vdCA9IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyB8fCB0aGlzLFxuICAgICAgZnJlZUdsb2JhbCA9IGZyZWVFeHBvcnRzICYmIG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIHR5cGVvZiBnbG9iYWwgPT0gXCJvYmplY3RcIiAmJiBnbG9iYWw7XG5cbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWxbXCJnbG9iYWxcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcIndpbmRvd1wiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wic2VsZlwiXSA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgfVxuXG4gIC8vIFB1YmxpYzogSW5pdGlhbGl6ZXMgSlNPTiAzIHVzaW5nIHRoZSBnaXZlbiBgY29udGV4dGAgb2JqZWN0LCBhdHRhY2hpbmcgdGhlXG4gIC8vIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGZ1bmN0aW9ucyB0byB0aGUgc3BlY2lmaWVkIGBleHBvcnRzYCBvYmplY3QuXG4gIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0LCBleHBvcnRzKSB7XG4gICAgY29udGV4dCB8fCAoY29udGV4dCA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG4gICAgZXhwb3J0cyB8fCAoZXhwb3J0cyA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG5cbiAgICAvLyBOYXRpdmUgY29uc3RydWN0b3IgYWxpYXNlcy5cbiAgICB2YXIgTnVtYmVyID0gY29udGV4dFtcIk51bWJlclwiXSB8fCByb290W1wiTnVtYmVyXCJdLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0W1wiU3RyaW5nXCJdIHx8IHJvb3RbXCJTdHJpbmdcIl0sXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHRbXCJPYmplY3RcIl0gfHwgcm9vdFtcIk9iamVjdFwiXSxcbiAgICAgICAgRGF0ZSA9IGNvbnRleHRbXCJEYXRlXCJdIHx8IHJvb3RbXCJEYXRlXCJdLFxuICAgICAgICBTeW50YXhFcnJvciA9IGNvbnRleHRbXCJTeW50YXhFcnJvclwiXSB8fCByb290W1wiU3ludGF4RXJyb3JcIl0sXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHRbXCJUeXBlRXJyb3JcIl0gfHwgcm9vdFtcIlR5cGVFcnJvclwiXSxcbiAgICAgICAgTWF0aCA9IGNvbnRleHRbXCJNYXRoXCJdIHx8IHJvb3RbXCJNYXRoXCJdLFxuICAgICAgICBuYXRpdmVKU09OID0gY29udGV4dFtcIkpTT05cIl0gfHwgcm9vdFtcIkpTT05cIl07XG5cbiAgICAvLyBEZWxlZ2F0ZSB0byB0aGUgbmF0aXZlIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGltcGxlbWVudGF0aW9ucy5cbiAgICBpZiAodHlwZW9mIG5hdGl2ZUpTT04gPT0gXCJvYmplY3RcIiAmJiBuYXRpdmVKU09OKSB7XG4gICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IG5hdGl2ZUpTT04uc3RyaW5naWZ5O1xuICAgICAgZXhwb3J0cy5wYXJzZSA9IG5hdGl2ZUpTT04ucGFyc2U7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgYWxpYXNlcy5cbiAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBnZXRDbGFzcyA9IG9iamVjdFByb3RvLnRvU3RyaW5nLFxuICAgICAgICBpc1Byb3BlcnR5LCBmb3JFYWNoLCB1bmRlZjtcblxuICAgIC8vIFRlc3QgdGhlIGBEYXRlI2dldFVUQypgIG1ldGhvZHMuIEJhc2VkIG9uIHdvcmsgYnkgQFlhZmZsZS5cbiAgICB2YXIgaXNFeHRlbmRlZCA9IG5ldyBEYXRlKC0zNTA5ODI3MzM0NTczMjkyKTtcbiAgICB0cnkge1xuICAgICAgLy8gVGhlIGBnZXRVVENGdWxsWWVhcmAsIGBNb250aGAsIGFuZCBgRGF0ZWAgbWV0aG9kcyByZXR1cm4gbm9uc2Vuc2ljYWxcbiAgICAgIC8vIHJlc3VsdHMgZm9yIGNlcnRhaW4gZGF0ZXMgaW4gT3BlcmEgPj0gMTAuNTMuXG4gICAgICBpc0V4dGVuZGVkID0gaXNFeHRlbmRlZC5nZXRVVENGdWxsWWVhcigpID09IC0xMDkyNTIgJiYgaXNFeHRlbmRlZC5nZXRVVENNb250aCgpID09PSAwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDRGF0ZSgpID09PSAxICYmXG4gICAgICAgIC8vIFNhZmFyaSA8IDIuMC4yIHN0b3JlcyB0aGUgaW50ZXJuYWwgbWlsbGlzZWNvbmQgdGltZSB2YWx1ZSBjb3JyZWN0bHksXG4gICAgICAgIC8vIGJ1dCBjbGlwcyB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBkYXRlIG1ldGhvZHMgdG8gdGhlIHJhbmdlIG9mXG4gICAgICAgIC8vIHNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgKFstMiAqKiAzMSwgMiAqKiAzMSAtIDFdKS5cbiAgICAgICAgaXNFeHRlbmRlZC5nZXRVVENIb3VycygpID09IDEwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWludXRlcygpID09IDM3ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDU2Vjb25kcygpID09IDYgJiYgaXNFeHRlbmRlZC5nZXRVVENNaWxsaXNlY29uZHMoKSA9PSA3MDg7XG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXG4gICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgd2hldGhlciB0aGUgbmF0aXZlIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBwYXJzZWBcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgYXJlIHNwZWMtY29tcGxpYW50LiBCYXNlZCBvbiB3b3JrIGJ5IEtlbiBTbnlkZXIuXG4gICAgZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICAgIGlmIChoYXNbbmFtZV0gIT09IHVuZGVmKSB7XG4gICAgICAgIC8vIFJldHVybiBjYWNoZWQgZmVhdHVyZSB0ZXN0IHJlc3VsdC5cbiAgICAgICAgcmV0dXJuIGhhc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1N1cHBvcnRlZDtcbiAgICAgIGlmIChuYW1lID09IFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpIHtcbiAgICAgICAgLy8gSUUgPD0gNyBkb2Vzbid0IHN1cHBvcnQgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIHVzaW5nIHNxdWFyZVxuICAgICAgICAvLyBicmFja2V0IG5vdGF0aW9uLiBJRSA4IG9ubHkgc3VwcG9ydHMgdGhpcyBmb3IgcHJpbWl0aXZlcy5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBcImFcIlswXSAhPSBcImFcIjtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImpzb25cIikge1xuICAgICAgICAvLyBJbmRpY2F0ZXMgd2hldGhlciBib3RoIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBKU09OLnBhcnNlYCBhcmVcbiAgICAgICAgLy8gc3VwcG9ydGVkLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IGhhcyhcImpzb24tc3RyaW5naWZ5XCIpICYmIGhhcyhcImpzb24tcGFyc2VcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUsIHNlcmlhbGl6ZWQgPSAne1wiYVwiOlsxLHRydWUsZmFsc2UsbnVsbCxcIlxcXFx1MDAwMFxcXFxiXFxcXG5cXFxcZlxcXFxyXFxcXHRcIl19JztcbiAgICAgICAgLy8gVGVzdCBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tc3RyaW5naWZ5XCIpIHtcbiAgICAgICAgICB2YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnksIHN0cmluZ2lmeVN1cHBvcnRlZCA9IHR5cGVvZiBzdHJpbmdpZnkgPT0gXCJmdW5jdGlvblwiICYmIGlzRXh0ZW5kZWQ7XG4gICAgICAgICAgaWYgKHN0cmluZ2lmeVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgLy8gQSB0ZXN0IGZ1bmN0aW9uIG9iamVjdCB3aXRoIGEgY3VzdG9tIGB0b0pTT05gIG1ldGhvZC5cbiAgICAgICAgICAgICh2YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9KS50b0pTT04gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCAzLjFiMSBhbmQgYjIgc2VyaWFsaXplIHN0cmluZywgbnVtYmVyLCBhbmQgYm9vbGVhblxuICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZXMgYXMgb2JqZWN0IGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgwKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIsIGFuZCBKU09OIDIgc2VyaWFsaXplIHdyYXBwZWQgcHJpbWl0aXZlcyBhcyBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IE51bWJlcigpKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IFN0cmluZygpKSA9PSAnXCJcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgaXMgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3JcbiAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBkZWZpbmUgYSBjYW5vbmljYWwgSlNPTiByZXByZXNlbnRhdGlvbiAodGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGB0b0pTT05gIHByb3BlcnRpZXMgYXMgd2VsbCwgKnVubGVzcyogdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gd2l0aGluIGFuIG9iamVjdCBvciBhcnJheSkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KGdldENsYXNzKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBJRSA4IHNlcmlhbGl6ZXMgYHVuZGVmaW5lZGAgYXMgYFwidW5kZWZpbmVkXCJgLiBTYWZhcmkgPD0gNS4xLjcgYW5kXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjMgcGFzcyB0aGlzIHRlc3QuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHVuZGVmKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjcgYW5kIEZGIDMuMWIzIHRocm93IGBFcnJvcmBzIGFuZCBgVHlwZUVycm9yYHMsXG4gICAgICAgICAgICAgICAgLy8gcmVzcGVjdGl2ZWx5LCBpZiB0aGUgdmFsdWUgaXMgb21pdHRlZCBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgbnVtYmVyLFxuICAgICAgICAgICAgICAgIC8vIHN0cmluZywgYXJyYXksIG9iamVjdCwgQm9vbGVhbiwgb3IgYG51bGxgIGxpdGVyYWwuIFRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcyBhcyB3ZWxsLCB1bmxlc3MgdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gaW5zaWRlIG9iamVjdCBvciBhcnJheSBsaXRlcmFscy4gWVVJIDMuMC4wYjEgaWdub3JlcyBjdXN0b20gYHRvSlNPTmBcbiAgICAgICAgICAgICAgICAvLyBtZXRob2RzIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt2YWx1ZV0pID09IFwiWzFdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgc2VyaWFsaXplcyBgW3VuZGVmaW5lZF1gIGFzIGBcIltdXCJgIGluc3RlYWQgb2ZcbiAgICAgICAgICAgICAgICAvLyBgXCJbbnVsbF1cImAuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZl0pID09IFwiW251bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBZVUkgMy4wLjBiMSBmYWlscyB0byBzZXJpYWxpemUgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsKSA9PSBcIm51bGxcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIGhhbHRzIHNlcmlhbGl6YXRpb24gaWYgYW4gYXJyYXkgY29udGFpbnMgYSBmdW5jdGlvbjpcbiAgICAgICAgICAgICAgICAvLyBgWzEsIHRydWUsIGdldENsYXNzLCAxXWAgc2VyaWFsaXplcyBhcyBcIlsxLHRydWUsXSxcIi4gRkYgMy4xYjNcbiAgICAgICAgICAgICAgICAvLyBlbGlkZXMgbm9uLUpTT04gdmFsdWVzIGZyb20gb2JqZWN0cyBhbmQgYXJyYXlzLCB1bmxlc3MgdGhleVxuICAgICAgICAgICAgICAgIC8vIGRlZmluZSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmLCBnZXRDbGFzcywgbnVsbF0pID09IFwiW251bGwsbnVsbCxudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHNlcmlhbGl6YXRpb24gdGVzdC4gRkYgMy4xYjEgdXNlcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZXNcbiAgICAgICAgICAgICAgICAvLyB3aGVyZSBjaGFyYWN0ZXIgZXNjYXBlIGNvZGVzIGFyZSBleHBlY3RlZCAoZS5nLiwgYFxcYmAgPT4gYFxcdTAwMDhgKS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoeyBcImFcIjogW3ZhbHVlLCB0cnVlLCBmYWxzZSwgbnVsbCwgXCJcXHgwMFxcYlxcblxcZlxcclxcdFwiXSB9KSA9PSBzZXJpYWxpemVkICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEgYW5kIGIyIGlnbm9yZSB0aGUgYGZpbHRlcmAgYW5kIGB3aWR0aGAgYXJndW1lbnRzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsLCB2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFsxLCAyXSwgbnVsbCwgMSkgPT0gXCJbXFxuIDEsXFxuIDJcXG5dXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBKU09OIDIsIFByb3RvdHlwZSA8PSAxLjcsIGFuZCBvbGRlciBXZWJLaXQgYnVpbGRzIGluY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgLy8gc2VyaWFsaXplIGV4dGVuZGVkIHllYXJzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtOC42NGUxNSkpID09ICdcIi0yNzE4MjEtMDQtMjBUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFRoZSBtaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKDguNjRlMTUpKSA9PSAnXCIrMjc1NzYwLTA5LTEzVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDw9IDExLjAgaW5jb3JyZWN0bHkgc2VyaWFsaXplcyB5ZWFycyBwcmlvciB0byAwIGFzIG5lZ2F0aXZlXG4gICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCB5ZWFycyBpbnN0ZWFkIG9mIHNpeC1kaWdpdCB5ZWFycy4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTYyMTk4NzU1MmU1KSkgPT0gJ1wiLTAwMDAwMS0wMS0wMVQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS41IGFuZCBPcGVyYSA+PSAxMC41MyBpbmNvcnJlY3RseSBzZXJpYWxpemUgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgbGVzcyB0aGFuIDEwMDAuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC0xKSkgPT0gJ1wiMTk2OS0xMi0zMVQyMzo1OTo1OS45OTlaXCInO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHN0cmluZ2lmeVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXN0IGBKU09OLnBhcnNlYC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXBhcnNlXCIpIHtcbiAgICAgICAgICB2YXIgcGFyc2UgPSBleHBvcnRzLnBhcnNlO1xuICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2UgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYSBiYXJlIGxpdGVyYWwgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAgIC8vIENvbmZvcm1pbmcgaW1wbGVtZW50YXRpb25zIHNob3VsZCBhbHNvIGNvZXJjZSB0aGUgaW5pdGlhbCBhcmd1bWVudCB0b1xuICAgICAgICAgICAgICAvLyBhIHN0cmluZyBwcmlvciB0byBwYXJzaW5nLlxuICAgICAgICAgICAgICBpZiAocGFyc2UoXCIwXCIpID09PSAwICYmICFwYXJzZShmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgcGFyc2luZyB0ZXN0LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlU3VwcG9ydGVkID0gdmFsdWVbXCJhXCJdLmxlbmd0aCA9PSA1ICYmIHZhbHVlW1wiYVwiXVswXSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuMiBhbmQgRkYgMy4xYjEgYWxsb3cgdW5lc2NhcGVkIHRhYnMgaW4gc3RyaW5ncy5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSAhcGFyc2UoJ1wiXFx0XCInKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCBhbmQgNC4wLjEgYWxsb3cgbGVhZGluZyBgK2Agc2lnbnMgYW5kIGxlYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAvLyBkZWNpbWFsIHBvaW50cy4gRkYgNC4wLCA0LjAuMSwgYW5kIElFIDktMTAgYWxzbyBhbGxvd1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNlcnRhaW4gb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjAxXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAsIDQuMC4xLCBhbmQgUmhpbm8gMS43UjMtUjQgYWxsb3cgdHJhaWxpbmcgZGVjaW1hbFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50cy4gVGhlc2UgZW52aXJvbm1lbnRzLCBhbG9uZyB3aXRoIEZGIDMuMWIxIGFuZCAyLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYWxsb3cgdHJhaWxpbmcgY29tbWFzIGluIEpTT04gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIxLlwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gcGFyc2VTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNbbmFtZV0gPSAhIWlzU3VwcG9ydGVkO1xuICAgIH1cblxuICAgIGlmICghaGFzKFwianNvblwiKSkge1xuICAgICAgLy8gQ29tbW9uIGBbW0NsYXNzXV1gIG5hbWUgYWxpYXNlcy5cbiAgICAgIHZhciBmdW5jdGlvbkNsYXNzID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLFxuICAgICAgICAgIGRhdGVDbGFzcyA9IFwiW29iamVjdCBEYXRlXVwiLFxuICAgICAgICAgIG51bWJlckNsYXNzID0gXCJbb2JqZWN0IE51bWJlcl1cIixcbiAgICAgICAgICBzdHJpbmdDbGFzcyA9IFwiW29iamVjdCBTdHJpbmddXCIsXG4gICAgICAgICAgYXJyYXlDbGFzcyA9IFwiW29iamVjdCBBcnJheV1cIixcbiAgICAgICAgICBib29sZWFuQ2xhc3MgPSBcIltvYmplY3QgQm9vbGVhbl1cIjtcblxuICAgICAgLy8gRGV0ZWN0IGluY29tcGxldGUgc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4LlxuICAgICAgdmFyIGNoYXJJbmRleEJ1Z2d5ID0gaGFzKFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpO1xuXG4gICAgICAvLyBEZWZpbmUgYWRkaXRpb25hbCB1dGlsaXR5IG1ldGhvZHMgaWYgdGhlIGBEYXRlYCBtZXRob2RzIGFyZSBidWdneS5cbiAgICAgIGlmICghaXNFeHRlbmRlZCkge1xuICAgICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgICAgICAvLyBBIG1hcHBpbmcgYmV0d2VlbiB0aGUgbW9udGhzIG9mIHRoZSB5ZWFyIGFuZCB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlblxuICAgICAgICAvLyBKYW51YXJ5IDFzdCBhbmQgdGhlIGZpcnN0IG9mIHRoZSByZXNwZWN0aXZlIG1vbnRoLlxuICAgICAgICB2YXIgTW9udGhzID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcbiAgICAgICAgLy8gSW50ZXJuYWw6IENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW4gdGhlIFVuaXggZXBvY2ggYW5kIHRoZVxuICAgICAgICAvLyBmaXJzdCBkYXkgb2YgdGhlIGdpdmVuIG1vbnRoLlxuICAgICAgICB2YXIgZ2V0RGF5ID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoKSB7XG4gICAgICAgICAgcmV0dXJuIE1vbnRoc1ttb250aF0gKyAzNjUgKiAoeWVhciAtIDE5NzApICsgZmxvb3IoKHllYXIgLSAxOTY5ICsgKG1vbnRoID0gKyhtb250aCA+IDEpKSkgLyA0KSAtIGZsb29yKCh5ZWFyIC0gMTkwMSArIG1vbnRoKSAvIDEwMCkgKyBmbG9vcigoeWVhciAtIDE2MDEgKyBtb250aCkgLyA0MDApO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyBpZiBhIHByb3BlcnR5IGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIHRoZSBnaXZlblxuICAgICAgLy8gb2JqZWN0LiBEZWxlZ2F0ZXMgdG8gdGhlIG5hdGl2ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBtZXRob2QuXG4gICAgICBpZiAoIShpc1Byb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHkpKSB7XG4gICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBjb25zdHJ1Y3RvcjtcbiAgICAgICAgICBpZiAoKG1lbWJlcnMuX19wcm90b19fID0gbnVsbCwgbWVtYmVycy5fX3Byb3RvX18gPSB7XG4gICAgICAgICAgICAvLyBUaGUgKnByb3RvKiBwcm9wZXJ0eSBjYW5ub3QgYmUgc2V0IG11bHRpcGxlIHRpbWVzIGluIHJlY2VudFxuICAgICAgICAgICAgLy8gdmVyc2lvbnMgb2YgRmlyZWZveCBhbmQgU2VhTW9ua2V5LlxuICAgICAgICAgICAgXCJ0b1N0cmluZ1wiOiAxXG4gICAgICAgICAgfSwgbWVtYmVycykudG9TdHJpbmcgIT0gZ2V0Q2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuMyBkb2Vzbid0IGltcGxlbWVudCBgT2JqZWN0I2hhc093blByb3BlcnR5YCwgYnV0XG4gICAgICAgICAgICAvLyBzdXBwb3J0cyB0aGUgbXV0YWJsZSAqcHJvdG8qIHByb3BlcnR5LlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAvLyBDYXB0dXJlIGFuZCBicmVhayB0aGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIChzZWUgc2VjdGlvbiA4LjYuMlxuICAgICAgICAgICAgICAvLyBvZiB0aGUgRVMgNS4xIHNwZWMpLiBUaGUgcGFyZW50aGVzaXplZCBleHByZXNzaW9uIHByZXZlbnRzIGFuXG4gICAgICAgICAgICAgIC8vIHVuc2FmZSB0cmFuc2Zvcm1hdGlvbiBieSB0aGUgQ2xvc3VyZSBDb21waWxlci5cbiAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gdGhpcy5fX3Byb3RvX18sIHJlc3VsdCA9IHByb3BlcnR5IGluICh0aGlzLl9fcHJvdG9fXyA9IG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gb3JpZ2luYWw7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDYXB0dXJlIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3AtbGV2ZWwgYE9iamVjdGAgY29uc3RydWN0b3IuXG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IG1lbWJlcnMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgdG8gc2ltdWxhdGUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW5cbiAgICAgICAgICAgIC8vIG90aGVyIGVudmlyb25tZW50cy5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9ICh0aGlzLmNvbnN0cnVjdG9yIHx8IGNvbnN0cnVjdG9yKS5wcm90b3R5cGU7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmICEocHJvcGVydHkgaW4gcGFyZW50ICYmIHRoaXNbcHJvcGVydHldID09PSBwYXJlbnRbcHJvcGVydHldKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lbWJlcnMgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBpc1Byb3BlcnR5LmNhbGwodGhpcywgcHJvcGVydHkpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogTm9ybWFsaXplcyB0aGUgYGZvci4uLmluYCBpdGVyYXRpb24gYWxnb3JpdGhtIGFjcm9zc1xuICAgICAgLy8gZW52aXJvbm1lbnRzLiBFYWNoIGVudW1lcmF0ZWQga2V5IGlzIHlpZWxkZWQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLlxuICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzaXplID0gMCwgUHJvcGVydGllcywgbWVtYmVycywgcHJvcGVydHk7XG5cbiAgICAgICAgLy8gVGVzdHMgZm9yIGJ1Z3MgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQncyBgZm9yLi4uaW5gIGFsZ29yaXRobS4gVGhlXG4gICAgICAgIC8vIGB2YWx1ZU9mYCBwcm9wZXJ0eSBpbmhlcml0cyB0aGUgbm9uLWVudW1lcmFibGUgZmxhZyBmcm9tXG4gICAgICAgIC8vIGBPYmplY3QucHJvdG90eXBlYCBpbiBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgTmV0c2NhcGUsIGFuZCBNb3ppbGxhLlxuICAgICAgICAoUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlT2YgPSAwO1xuICAgICAgICB9KS5wcm90b3R5cGUudmFsdWVPZiA9IDA7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUHJvcGVydGllc2AgY2xhc3MuXG4gICAgICAgIG1lbWJlcnMgPSBuZXcgUHJvcGVydGllcygpO1xuICAgICAgICBmb3IgKHByb3BlcnR5IGluIG1lbWJlcnMpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgYWxsIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIGlmIChpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFByb3BlcnRpZXMgPSBtZW1iZXJzID0gbnVsbDtcblxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGl0ZXJhdGlvbiBhbGdvcml0aG0uXG4gICAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAgIC8vIEEgbGlzdCBvZiBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBtZW1iZXJzID0gW1widmFsdWVPZlwiLCBcInRvU3RyaW5nXCIsIFwidG9Mb2NhbGVTdHJpbmdcIiwgXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLCBcImlzUHJvdG90eXBlT2ZcIiwgXCJoYXNPd25Qcm9wZXJ0eVwiLCBcImNvbnN0cnVjdG9yXCJdO1xuICAgICAgICAgIC8vIElFIDw9IDgsIE1vemlsbGEgMS4wLCBhbmQgTmV0c2NhcGUgNi4yIGlnbm9yZSBzaGFkb3dlZCBub24tZW51bWVyYWJsZVxuICAgICAgICAgIC8vIHByb3BlcnRpZXMuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgbGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGhhc1Byb3BlcnR5ID0gIWlzRnVuY3Rpb24gJiYgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciAhPSBcImZ1bmN0aW9uXCIgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eV0gJiYgb2JqZWN0Lmhhc093blByb3BlcnR5IHx8IGlzUHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBHZWNrbyA8PSAxLjAgZW51bWVyYXRlcyB0aGUgYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHVuZGVyXG4gICAgICAgICAgICAgIC8vIGNlcnRhaW4gY29uZGl0aW9uczsgSUUgZG9lcyBub3QuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gbWVtYmVycy5sZW5ndGg7IHByb3BlcnR5ID0gbWVtYmVyc1stLWxlbmd0aF07IGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgY2FsbGJhY2socHJvcGVydHkpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHNpemUgPT0gMikge1xuICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuNCBlbnVtZXJhdGVzIHNoYWRvd2VkIHByb3BlcnRpZXMgdHdpY2UuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzZXQgb2YgaXRlcmF0ZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBTdG9yZSBlYWNoIHByb3BlcnR5IG5hbWUgdG8gcHJldmVudCBkb3VibGUgZW51bWVyYXRpb24uIFRoZVxuICAgICAgICAgICAgICAvLyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgaXMgbm90IGVudW1lcmF0ZWQgZHVlIHRvIGNyb3NzLVxuICAgICAgICAgICAgICAvLyBlbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgIWlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkgJiYgKG1lbWJlcnNbcHJvcGVydHldID0gMSkgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyBidWdzIGRldGVjdGVkOyB1c2UgdGhlIHN0YW5kYXJkIGBmb3IuLi5pbmAgYWxnb3JpdGhtLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGlzQ29uc3RydWN0b3I7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiAhKGlzQ29uc3RydWN0b3IgPSBwcm9wZXJ0eSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgZHVlIHRvXG4gICAgICAgICAgICAvLyBjcm9zcy1lbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICBpZiAoaXNDb25zdHJ1Y3RvciB8fCBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCAocHJvcGVydHkgPSBcImNvbnN0cnVjdG9yXCIpKSkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFB1YmxpYzogU2VyaWFsaXplcyBhIEphdmFTY3JpcHQgYHZhbHVlYCBhcyBhIEpTT04gc3RyaW5nLiBUaGUgb3B0aW9uYWxcbiAgICAgIC8vIGBmaWx0ZXJgIGFyZ3VtZW50IG1heSBzcGVjaWZ5IGVpdGhlciBhIGZ1bmN0aW9uIHRoYXQgYWx0ZXJzIGhvdyBvYmplY3QgYW5kXG4gICAgICAvLyBhcnJheSBtZW1iZXJzIGFyZSBzZXJpYWxpemVkLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBudW1iZXJzIHRoYXRcbiAgICAgIC8vIGluZGljYXRlcyB3aGljaCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgb3B0aW9uYWwgYHdpZHRoYFxuICAgICAgLy8gYXJndW1lbnQgbWF5IGJlIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGluZGVudGF0aW9uXG4gICAgICAvLyBsZXZlbCBvZiB0aGUgb3V0cHV0LlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSkge1xuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgRXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXFxcXFwiJyxcbiAgICAgICAgICA4OiBcIlxcXFxiXCIsXG4gICAgICAgICAgMTI6IFwiXFxcXGZcIixcbiAgICAgICAgICAxMDogXCJcXFxcblwiLFxuICAgICAgICAgIDEzOiBcIlxcXFxyXCIsXG4gICAgICAgICAgOTogXCJcXFxcdFwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IENvbnZlcnRzIGB2YWx1ZWAgaW50byBhIHplcm8tcGFkZGVkIHN0cmluZyBzdWNoIHRoYXQgaXRzXG4gICAgICAgIC8vIGxlbmd0aCBpcyBhdCBsZWFzdCBlcXVhbCB0byBgd2lkdGhgLiBUaGUgYHdpZHRoYCBtdXN0IGJlIDw9IDYuXG4gICAgICAgIHZhciBsZWFkaW5nWmVyb2VzID0gXCIwMDAwMDBcIjtcbiAgICAgICAgdmFyIHRvUGFkZGVkU3RyaW5nID0gZnVuY3Rpb24gKHdpZHRoLCB2YWx1ZSkge1xuICAgICAgICAgIC8vIFRoZSBgfHwgMGAgZXhwcmVzc2lvbiBpcyBuZWNlc3NhcnkgdG8gd29yayBhcm91bmQgYSBidWcgaW5cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgd2hlcmUgYDAgPT0gLTBgLCBidXQgYFN0cmluZygtMCkgIT09IFwiMFwiYC5cbiAgICAgICAgICByZXR1cm4gKGxlYWRpbmdaZXJvZXMgKyAodmFsdWUgfHwgMCkpLnNsaWNlKC13aWR0aCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IERvdWJsZS1xdW90ZXMgYSBzdHJpbmcgYHZhbHVlYCwgcmVwbGFjaW5nIGFsbCBBU0NJSSBjb250cm9sXG4gICAgICAgIC8vIGNoYXJhY3RlcnMgKGNoYXJhY3RlcnMgd2l0aCBjb2RlIHVuaXQgdmFsdWVzIGJldHdlZW4gMCBhbmQgMzEpIHdpdGhcbiAgICAgICAgLy8gdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFF1b3RlKHZhbHVlKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgdmFyIHVuaWNvZGVQcmVmaXggPSBcIlxcXFx1MDBcIjtcbiAgICAgICAgdmFyIHF1b3RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9ICdcIicsIGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLCB1c2VDaGFySW5kZXggPSAhY2hhckluZGV4QnVnZ3kgfHwgbGVuZ3RoID4gMTA7XG4gICAgICAgICAgdmFyIHN5bWJvbHMgPSB1c2VDaGFySW5kZXggJiYgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuc3BsaXQoXCJcIikgOiB2YWx1ZSk7XG4gICAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBjb250cm9sIGNoYXJhY3RlciwgYXBwZW5kIGl0cyBVbmljb2RlIG9yXG4gICAgICAgICAgICAvLyBzaG9ydGhhbmQgZXNjYXBlIHNlcXVlbmNlOyBvdGhlcndpc2UsIGFwcGVuZCB0aGUgY2hhcmFjdGVyIGFzLWlzLlxuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDg6IGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMjogY2FzZSAxMzogY2FzZSAzNDogY2FzZSA5MjpcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gRXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1bmljb2RlUHJlZml4ICsgdG9QYWRkZWRTdHJpbmcoMiwgY2hhckNvZGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdXNlQ2hhckluZGV4ID8gc3ltYm9sc1tpbmRleF0gOiB2YWx1ZS5jaGFyQXQoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ1wiJztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgc2VyaWFsaXplcyBhbiBvYmplY3QuIEltcGxlbWVudHMgdGhlXG4gICAgICAgIC8vIGBTdHIoa2V5LCBob2xkZXIpYCwgYEpPKHZhbHVlKWAsIGFuZCBgSkEodmFsdWUpYCBvcGVyYXRpb25zLlxuICAgICAgICB2YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKHByb3BlcnR5LCBvYmplY3QsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUsIGNsYXNzTmFtZSwgeWVhciwgbW9udGgsIGRhdGUsIHRpbWUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIHJlc3VsdHMsIGVsZW1lbnQsIGluZGV4LCBsZW5ndGgsIHByZWZpeCwgcmVzdWx0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBOZWNlc3NhcnkgZm9yIGhvc3Qgb2JqZWN0IHN1cHBvcnQuXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGRhdGVDbGFzcyAmJiAhaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCkge1xuICAgICAgICAgICAgICAgIC8vIERhdGVzIGFyZSBzZXJpYWxpemVkIGFjY29yZGluZyB0byB0aGUgYERhdGUjdG9KU09OYCBtZXRob2RcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuOS41LjQ0LiBTZWUgc2VjdGlvbiAxNS45LjEuMTVcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIElTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmcgZm9ybWF0LlxuICAgICAgICAgICAgICAgIGlmIChnZXREYXkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGNvbXB1dGUgdGhlIHllYXIsIG1vbnRoLCBkYXRlLCBob3VycywgbWludXRlcyxcbiAgICAgICAgICAgICAgICAgIC8vIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgaWYgdGhlIGBnZXRVVEMqYCBtZXRob2RzIGFyZVxuICAgICAgICAgICAgICAgICAgLy8gYnVnZ3kuIEFkYXB0ZWQgZnJvbSBAWWFmZmxlJ3MgYGRhdGUtc2hpbWAgcHJvamVjdC5cbiAgICAgICAgICAgICAgICAgIGRhdGUgPSBmbG9vcih2YWx1ZSAvIDg2NGU1KTtcbiAgICAgICAgICAgICAgICAgIGZvciAoeWVhciA9IGZsb29yKGRhdGUgLyAzNjUuMjQyNSkgKyAxOTcwIC0gMTsgZ2V0RGF5KHllYXIgKyAxLCAwKSA8PSBkYXRlOyB5ZWFyKyspO1xuICAgICAgICAgICAgICAgICAgZm9yIChtb250aCA9IGZsb29yKChkYXRlIC0gZ2V0RGF5KHllYXIsIDApKSAvIDMwLjQyKTsgZ2V0RGF5KHllYXIsIG1vbnRoICsgMSkgPD0gZGF0ZTsgbW9udGgrKyk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gMSArIGRhdGUgLSBnZXREYXkoeWVhciwgbW9udGgpO1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGB0aW1lYCB2YWx1ZSBzcGVjaWZpZXMgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkgKHNlZSBFU1xuICAgICAgICAgICAgICAgICAgLy8gNS4xIHNlY3Rpb24gMTUuOS4xLjIpLiBUaGUgZm9ybXVsYSBgKEEgJSBCICsgQikgJSBCYCBpcyB1c2VkXG4gICAgICAgICAgICAgICAgICAvLyB0byBjb21wdXRlIGBBIG1vZHVsbyBCYCwgYXMgdGhlIGAlYCBvcGVyYXRvciBkb2VzIG5vdFxuICAgICAgICAgICAgICAgICAgLy8gY29ycmVzcG9uZCB0byB0aGUgYG1vZHVsb2Agb3BlcmF0aW9uIGZvciBuZWdhdGl2ZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgICAgdGltZSA9ICh2YWx1ZSAlIDg2NGU1ICsgODY0ZTUpICUgODY0ZTU7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgYXJlIG9idGFpbmVkIGJ5XG4gICAgICAgICAgICAgICAgICAvLyBkZWNvbXBvc2luZyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheS4gU2VlIHNlY3Rpb24gMTUuOS4xLjEwLlxuICAgICAgICAgICAgICAgICAgaG91cnMgPSBmbG9vcih0aW1lIC8gMzZlNSkgJSAyNDtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBmbG9vcih0aW1lIC8gNmU0KSAlIDYwO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IGZsb29yKHRpbWUgLyAxZTMpICUgNjA7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aW1lICUgMWUzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB5ZWFyID0gdmFsdWUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICAgIG1vbnRoID0gdmFsdWUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSB2YWx1ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgICAgICAgICAgICBob3VycyA9IHZhbHVlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gdmFsdWUuZ2V0VVRDTWludXRlcygpO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IHZhbHVlLmdldFVUQ1NlY29uZHMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gKHllYXIgPD0gMCB8fCB5ZWFyID49IDFlNCA/ICh5ZWFyIDwgMCA/IFwiLVwiIDogXCIrXCIpICsgdG9QYWRkZWRTdHJpbmcoNiwgeWVhciA8IDAgPyAteWVhciA6IHllYXIpIDogdG9QYWRkZWRTdHJpbmcoNCwgeWVhcikpICtcbiAgICAgICAgICAgICAgICAgIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbW9udGggKyAxKSArIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgZGF0ZSkgK1xuICAgICAgICAgICAgICAgICAgLy8gTW9udGhzLCBkYXRlcywgaG91cnMsIG1pbnV0ZXMsIGFuZCBzZWNvbmRzIHNob3VsZCBoYXZlIHR3b1xuICAgICAgICAgICAgICAgICAgLy8gZGlnaXRzOyBtaWxsaXNlY29uZHMgc2hvdWxkIGhhdmUgdGhyZWUuXG4gICAgICAgICAgICAgICAgICBcIlRcIiArIHRvUGFkZGVkU3RyaW5nKDIsIGhvdXJzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbWludXRlcykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIHNlY29uZHMpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNS4wLCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgICAgXCIuXCIgKyB0b1BhZGRlZFN0cmluZygzLCBtaWxsaXNlY29uZHMpICsgXCJaXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT0gXCJmdW5jdGlvblwiICYmICgoY2xhc3NOYW1lICE9IG51bWJlckNsYXNzICYmIGNsYXNzTmFtZSAhPSBzdHJpbmdDbGFzcyAmJiBjbGFzc05hbWUgIT0gYXJyYXlDbGFzcykgfHwgaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkpIHtcbiAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIGFkZHMgbm9uLXN0YW5kYXJkIGB0b0pTT05gIG1ldGhvZHMgdG8gdGhlXG4gICAgICAgICAgICAgIC8vIGBOdW1iZXJgLCBgU3RyaW5nYCwgYERhdGVgLCBhbmQgYEFycmF5YCBwcm90b3R5cGVzLiBKU09OIDNcbiAgICAgICAgICAgICAgLy8gaWdub3JlcyBhbGwgYHRvSlNPTmAgbWV0aG9kcyBvbiB0aGVzZSBvYmplY3RzIHVubGVzcyB0aGV5IGFyZVxuICAgICAgICAgICAgICAvLyBkZWZpbmVkIGRpcmVjdGx5IG9uIGFuIGluc3RhbmNlLlxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gSWYgYSByZXBsYWNlbWVudCBmdW5jdGlvbiB3YXMgcHJvdmlkZWQsIGNhbGwgaXQgdG8gb2J0YWluIHRoZSB2YWx1ZVxuICAgICAgICAgICAgLy8gZm9yIHNlcmlhbGl6YXRpb24uXG4gICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBib29sZWFuQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEJvb2xlYW5zIGFyZSByZXByZXNlbnRlZCBsaXRlcmFsbHkuXG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIGBJbmZpbml0eWAgYW5kIGBOYU5gIGFyZSBzZXJpYWxpemVkIGFzXG4gICAgICAgICAgICAvLyBgXCJudWxsXCJgLlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDAgPyBcIlwiICsgdmFsdWUgOiBcIm51bGxcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgLy8gU3RyaW5ncyBhcmUgZG91YmxlLXF1b3RlZCBhbmQgZXNjYXBlZC5cbiAgICAgICAgICAgIHJldHVybiBxdW90ZShcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGlzIGlzIGEgbGluZWFyIHNlYXJjaDsgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIC8vIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZiB1bmlxdWUgbmVzdGVkIG9iamVjdHMuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHN0YWNrLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgIGlmIChzdGFja1tsZW5ndGhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIEN5Y2xpYyBzdHJ1Y3R1cmVzIGNhbm5vdCBiZSBzZXJpYWxpemVkIGJ5IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCBhbmQgaW5kZW50IG9uZSBhZGRpdGlvbmFsIGxldmVsLlxuICAgICAgICAgICAgcHJlZml4ID0gaW5kZW50YXRpb247XG4gICAgICAgICAgICBpbmRlbnRhdGlvbiArPSB3aGl0ZXNwYWNlO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBhcnJheSBlbGVtZW50cy5cbiAgICAgICAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gc2VyaWFsaXplKGluZGV4LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW1lbnQgPT09IHVuZGVmID8gXCJudWxsXCIgOiBlbGVtZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJbXFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIl1cIiA6IChcIltcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIl1cIikpIDogXCJbXVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdCBtZW1iZXJzLiBNZW1iZXJzIGFyZSBzZWxlY3RlZCBmcm9tXG4gICAgICAgICAgICAgIC8vIGVpdGhlciBhIHVzZXItc3BlY2lmaWVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMsIG9yIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgLy8gaXRzZWxmLlxuICAgICAgICAgICAgICBmb3JFYWNoKHByb3BlcnRpZXMgfHwgdmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2VyaWFsaXplKHByb3BlcnR5LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBY2NvcmRpbmcgdG8gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMzogXCJJZiBgZ2FwYCB7d2hpdGVzcGFjZX1cbiAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgYG1lbWJlcmAge3F1b3RlKHByb3BlcnR5KSArIFwiOlwifVxuICAgICAgICAgICAgICAgICAgLy8gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgYG1lbWJlcmAgYW5kIHRoZSBgc3BhY2VgIGNoYXJhY3Rlci5cIlxuICAgICAgICAgICAgICAgICAgLy8gVGhlIFwiYHNwYWNlYCBjaGFyYWN0ZXJcIiByZWZlcnMgdG8gdGhlIGxpdGVyYWwgc3BhY2VcbiAgICAgICAgICAgICAgICAgIC8vIGNoYXJhY3Rlciwgbm90IHRoZSBgc3BhY2VgIHt3aWR0aH0gYXJndW1lbnQgcHJvdmlkZWQgdG9cbiAgICAgICAgICAgICAgICAgIC8vIGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocXVvdGUocHJvcGVydHkpICsgXCI6XCIgKyAod2hpdGVzcGFjZSA/IFwiIFwiIDogXCJcIikgKyBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJ7XFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIn1cIiA6IChcIntcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIn1cIikpIDogXCJ7fVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvYmplY3QgZnJvbSB0aGUgdHJhdmVyc2VkIG9iamVjdCBzdGFjay5cbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5zdHJpbmdpZnlgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAoc291cmNlLCBmaWx0ZXIsIHdpZHRoKSB7XG4gICAgICAgICAgdmFyIHdoaXRlc3BhY2UsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCBjbGFzc05hbWU7XG4gICAgICAgICAgaWYgKG9iamVjdFR5cGVzW3R5cGVvZiBmaWx0ZXJdICYmIGZpbHRlcikge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKGZpbHRlcikpID09IGZ1bmN0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmaWx0ZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHByb3BlcnR5IG5hbWVzIGFycmF5IGludG8gYSBtYWtlc2hpZnQgc2V0LlxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZmlsdGVyLmxlbmd0aCwgdmFsdWU7IGluZGV4IDwgbGVuZ3RoOyB2YWx1ZSA9IGZpbHRlcltpbmRleCsrXSwgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKSksIGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpICYmIChwcm9wZXJ0aWVzW3ZhbHVlXSA9IDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwod2lkdGgpKSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBgd2lkdGhgIHRvIGFuIGludGVnZXIgYW5kIGNyZWF0ZSBhIHN0cmluZyBjb250YWluaW5nXG4gICAgICAgICAgICAgIC8vIGB3aWR0aGAgbnVtYmVyIG9mIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgIGlmICgod2lkdGggLT0gd2lkdGggJSAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHdoaXRlc3BhY2UgPSBcIlwiLCB3aWR0aCA+IDEwICYmICh3aWR0aCA9IDEwKTsgd2hpdGVzcGFjZS5sZW5ndGggPCB3aWR0aDsgd2hpdGVzcGFjZSArPSBcIiBcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAgIHdoaXRlc3BhY2UgPSB3aWR0aC5sZW5ndGggPD0gMTAgPyB3aWR0aCA6IHdpZHRoLnNsaWNlKDAsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIGRpc2NhcmRzIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGVtcHR5IHN0cmluZyBrZXlzXG4gICAgICAgICAgLy8gKGBcIlwiYCkgb25seSBpZiB0aGV5IGFyZSB1c2VkIGRpcmVjdGx5IHdpdGhpbiBhbiBvYmplY3QgbWVtYmVyIGxpc3RcbiAgICAgICAgICAvLyAoZS5nLiwgYCEoXCJcIiBpbiB7IFwiXCI6IDF9KWApLlxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoXCJcIiwgKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gc291cmNlLCB2YWx1ZSksIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBcIlwiLCBbXSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFB1YmxpYzogUGFyc2VzIGEgSlNPTiBzb3VyY2Ugc3RyaW5nLlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXBhcnNlXCIpKSB7XG4gICAgICAgIHZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgdW5lc2NhcGVkXG4gICAgICAgIC8vIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgVW5lc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcIixcbiAgICAgICAgICAzNDogJ1wiJyxcbiAgICAgICAgICA0NzogXCIvXCIsXG4gICAgICAgICAgOTg6IFwiXFxiXCIsXG4gICAgICAgICAgMTE2OiBcIlxcdFwiLFxuICAgICAgICAgIDExMDogXCJcXG5cIixcbiAgICAgICAgICAxMDI6IFwiXFxmXCIsXG4gICAgICAgICAgMTE0OiBcIlxcclwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFN0b3JlcyB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICB2YXIgSW5kZXgsIFNvdXJjZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVzZXRzIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93cyBhIGBTeW50YXhFcnJvcmAuXG4gICAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmV0dXJucyB0aGUgbmV4dCB0b2tlbiwgb3IgYFwiJFwiYCBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkXG4gICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzdHJpbmcuIEEgdG9rZW4gbWF5IGJlIGEgc3RyaW5nLCBudW1iZXIsIGBudWxsYFxuICAgICAgICAvLyBsaXRlcmFsLCBvciBCb29sZWFuIGxpdGVyYWwuXG4gICAgICAgIHZhciBsZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IFNvdXJjZSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aCwgdmFsdWUsIGJlZ2luLCBwb3NpdGlvbiwgaXNTaWduZWQsIGNoYXJDb2RlO1xuICAgICAgICAgIHdoaWxlIChJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMzogY2FzZSAzMjpcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UgdG9rZW5zLCBpbmNsdWRpbmcgdGFicywgY2FycmlhZ2UgcmV0dXJucywgbGluZVxuICAgICAgICAgICAgICAgIC8vIGZlZWRzLCBhbmQgc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDEyMzogY2FzZSAxMjU6IGNhc2UgOTE6IGNhc2UgOTM6IGNhc2UgNTg6IGNhc2UgNDQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYSBwdW5jdHVhdG9yIHRva2VuIChge2AsIGB9YCwgYFtgLCBgXWAsIGA6YCwgb3IgYCxgKSBhdFxuICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgIHZhbHVlID0gY2hhckluZGV4QnVnZ3kgPyBzb3VyY2UuY2hhckF0KEluZGV4KSA6IHNvdXJjZVtJbmRleF07XG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAgLy8gYFwiYCBkZWxpbWl0cyBhIEpTT04gc3RyaW5nOyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmRcbiAgICAgICAgICAgICAgICAvLyBiZWdpbiBwYXJzaW5nIHRoZSBzdHJpbmcuIFN0cmluZyB0b2tlbnMgYXJlIHByZWZpeGVkIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgLy8gc2VudGluZWwgYEBgIGNoYXJhY3RlciB0byBkaXN0aW5ndWlzaCB0aGVtIGZyb20gcHVuY3R1YXRvcnMgYW5kXG4gICAgICAgICAgICAgICAgLy8gZW5kLW9mLXN0cmluZyB0b2tlbnMuXG4gICAgICAgICAgICAgICAgZm9yICh2YWx1ZSA9IFwiQFwiLCBJbmRleCsrOyBJbmRleCA8IGxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5lc2NhcGVkIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVycyAodGhvc2Ugd2l0aCBhIGNvZGUgdW5pdFxuICAgICAgICAgICAgICAgICAgICAvLyBsZXNzIHRoYW4gdGhlIHNwYWNlIGNoYXJhY3RlcikgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09IDkyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgcmV2ZXJzZSBzb2xpZHVzIChgXFxgKSBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGFuIGVzY2FwZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udHJvbCBjaGFyYWN0ZXIgKGluY2x1ZGluZyBgXCJgLCBgXFxgLCBhbmQgYC9gKSBvciBVbmljb2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTI6IGNhc2UgMzQ6IGNhc2UgNDc6IGNhc2UgOTg6IGNhc2UgMTE2OiBjYXNlIDExMDogY2FzZSAxMDI6IGNhc2UgMTE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gVW5lc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBcXHVgIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYSBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgdmFsaWRhdGUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IGNvZGUgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWdpbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXggKyA0OyBJbmRleCA8IHBvc2l0aW9uOyBJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHZhbGlkIHNlcXVlbmNlIGNvbXByaXNlcyBmb3VyIGhleGRpZ2l0cyAoY2FzZS1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZW5zaXRpdmUpIHRoYXQgZm9ybSBhIHNpbmdsZSBoZXhhZGVjaW1hbCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTAyIHx8IGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDcwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGZyb21DaGFyQ29kZShcIjB4XCIgKyBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBbiB1bmVzY2FwZWQgZG91YmxlLXF1b3RlIGNoYXJhY3RlciBtYXJrcyB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSBhIHN0cmluZyBpcyB2YWxpZC5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJDb2RlID49IDMyICYmIGNoYXJDb2RlICE9IDkyICYmIGNoYXJDb2RlICE9IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHN0cmluZyBhcy1pcy5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZCByZXR1cm4gdGhlIHJldml2ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW50ZXJtaW5hdGVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIG51bWJlcnMgYW5kIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBwYXN0IHRoZSBuZWdhdGl2ZSBzaWduLCBpZiBvbmUgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYW4gaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgemVyb2VzIGFyZSBpbnRlcnByZXRlZCBhcyBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0OCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXggKyAxKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIG9jdGFsIGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGludGVnZXIgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgZm9yICg7IEluZGV4IDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IEluZGV4KyspO1xuICAgICAgICAgICAgICAgICAgLy8gRmxvYXRzIGNhbm5vdCBjb250YWluIGEgbGVhZGluZyBkZWNpbWFsIHBvaW50OyBob3dldmVyLCB0aGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlIGlzIGFscmVhZHkgYWNjb3VudGVkIGZvciBieSB0aGUgcGFyc2VyLlxuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSA0Nikge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBkZWNpbWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIHRyYWlsaW5nIGRlY2ltYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgZXhwb25lbnRzLiBUaGUgYGVgIGRlbm90aW5nIHRoZSBleHBvbmVudCBpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDEwMSB8fCBjaGFyQ29kZSA9PSA2OSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHBhc3QgdGhlIHNpZ24gZm9sbG93aW5nIHRoZSBleHBvbmVudCwgaWYgb25lIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQzIHx8IGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZXhwb25lbnRpYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIGVtcHR5IGV4cG9uZW50LlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIENvZXJjZSB0aGUgcGFyc2VkIHZhbHVlIHRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gK3NvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBIG5lZ2F0aXZlIHNpZ24gbWF5IG9ubHkgcHJlY2VkZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgIGlmIChpc1NpZ25lZCkge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYHRydWVgLCBgZmFsc2VgLCBhbmQgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA1KSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW5yZWNvZ25pemVkIHRva2VuLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJldHVybiB0aGUgc2VudGluZWwgYCRgIGNoYXJhY3RlciBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkIHRoZSBlbmRcbiAgICAgICAgICAvLyBvZiB0aGUgc291cmNlIHN0cmluZy5cbiAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFBhcnNlcyBhIEpTT04gYHZhbHVlYCB0b2tlbi5cbiAgICAgICAgdmFyIGdldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHRzLCBoYXNNZW1iZXJzO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIiRcIikge1xuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICgoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgPT0gXCJAXCIpIHtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZW50aW5lbCBgQGAgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZSBvYmplY3QgYW5kIGFycmF5IGxpdGVyYWxzLlxuICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiW1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gYXJyYXksIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IGFycmF5LlxuICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3Npbmcgc3F1YXJlIGJyYWNrZXQgbWFya3MgdGhlIGVuZCBvZiB0aGUgYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYXJyYXkgbGl0ZXJhbCBjb250YWlucyBlbGVtZW50cywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0aW5nIHRoZSBwcmV2aW91cyBlbGVtZW50IGZyb20gdGhlXG4gICAgICAgICAgICAgICAgLy8gbmV4dC5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIGFycmF5IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVsaXNpb25zIGFuZCBsZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChnZXQodmFsdWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBvYmplY3QsIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IG9iamVjdC5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIGN1cmx5IGJyYWNlIG1hcmtzIHRoZSBlbmQgb2YgdGhlIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgbGl0ZXJhbCBjb250YWlucyBtZW1iZXJzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRvci5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBvYmplY3QgbWVtYmVyLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZCwgb2JqZWN0IHByb3BlcnR5IG5hbWVzIG11c3QgYmVcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVkIHN0cmluZ3MsIGFuZCBhIGA6YCBtdXN0IHNlcGFyYXRlIGVhY2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgICAvLyBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIgfHwgdHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIgfHwgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pICE9IFwiQFwiIHx8IGxleCgpICE9IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzW3ZhbHVlLnNsaWNlKDEpXSA9IGdldChsZXgoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRva2VuIGVuY291bnRlcmVkLlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBVcGRhdGVzIGEgdHJhdmVyc2VkIG9iamVjdCBtZW1iZXIuXG4gICAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IHdhbGsoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgIGlmIChlbGVtZW50ID09PSB1bmRlZikge1xuICAgICAgICAgICAgZGVsZXRlIHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZVtwcm9wZXJ0eV0gPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgdHJhdmVyc2VzIGEgcGFyc2VkIEpTT04gb2JqZWN0LCBpbnZva2luZyB0aGVcbiAgICAgICAgLy8gYGNhbGxiYWNrYCBmdW5jdGlvbiBmb3IgZWFjaCB2YWx1ZS4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFdhbGsoaG9sZGVyLCBuYW1lKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgdmFyIHdhbGsgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldLCBsZW5ndGg7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBgZm9yRWFjaGAgY2FuJ3QgYmUgdXNlZCB0byB0cmF2ZXJzZSBhbiBhcnJheSBpbiBPcGVyYSA8PSA4LjU0XG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0cyBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGBmYWxzZWBcbiAgICAgICAgICAgIC8vIGZvciBhcnJheSBpbmRpY2VzIChlLmcuLCBgIVsxLCAyLCAzXS5oYXNPd25Qcm9wZXJ0eShcIjBcIilgKS5cbiAgICAgICAgICAgIGlmIChnZXRDbGFzcy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIGZvciAobGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIGxlbmd0aCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzb3VyY2UsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5wYXJzZWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcbiAgICAgICAgICBJbmRleCA9IDA7XG4gICAgICAgICAgU291cmNlID0gXCJcIiArIHNvdXJjZTtcbiAgICAgICAgICByZXN1bHQgPSBnZXQobGV4KCkpO1xuICAgICAgICAgIC8vIElmIGEgSlNPTiBzdHJpbmcgY29udGFpbnMgbXVsdGlwbGUgdG9rZW5zLCBpdCBpcyBpbnZhbGlkLlxuICAgICAgICAgIGlmIChsZXgoKSAhPSBcIiRcIikge1xuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGdldENsYXNzLmNhbGwoY2FsbGJhY2spID09IGZ1bmN0aW9uQ2xhc3MgPyB3YWxrKCh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHJlc3VsdCwgdmFsdWUpLCBcIlwiLCBjYWxsYmFjaykgOiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0c1tcInJ1bkluQ29udGV4dFwiXSA9IHJ1bkluQ29udGV4dDtcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfVxuXG4gIGlmIChmcmVlRXhwb3J0cyAmJiAhaXNMb2FkZXIpIHtcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIGVudmlyb25tZW50cy5cbiAgICBydW5JbkNvbnRleHQocm9vdCwgZnJlZUV4cG9ydHMpO1xuICB9IGVsc2Uge1xuICAgIC8vIEV4cG9ydCBmb3Igd2ViIGJyb3dzZXJzIGFuZCBKYXZhU2NyaXB0IGVuZ2luZXMuXG4gICAgdmFyIG5hdGl2ZUpTT04gPSByb290LkpTT04sXG4gICAgICAgIHByZXZpb3VzSlNPTiA9IHJvb3RbXCJKU09OM1wiXSxcbiAgICAgICAgaXNSZXN0b3JlZCA9IGZhbHNlO1xuXG4gICAgdmFyIEpTT04zID0gcnVuSW5Db250ZXh0KHJvb3QsIChyb290W1wiSlNPTjNcIl0gPSB7XG4gICAgICAvLyBQdWJsaWM6IFJlc3RvcmVzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgZ2xvYmFsIGBKU09OYCBvYmplY3QgYW5kXG4gICAgICAvLyByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgSlNPTjNgIG9iamVjdC5cbiAgICAgIFwibm9Db25mbGljdFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNSZXN0b3JlZCkge1xuICAgICAgICAgIGlzUmVzdG9yZWQgPSB0cnVlO1xuICAgICAgICAgIHJvb3QuSlNPTiA9IG5hdGl2ZUpTT047XG4gICAgICAgICAgcm9vdFtcIkpTT04zXCJdID0gcHJldmlvdXNKU09OO1xuICAgICAgICAgIG5hdGl2ZUpTT04gPSBwcmV2aW91c0pTT04gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OMztcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICByb290LkpTT04gPSB7XG4gICAgICBcInBhcnNlXCI6IEpTT04zLnBhcnNlLFxuICAgICAgXCJzdHJpbmdpZnlcIjogSlNPTjMuc3RyaW5naWZ5XG4gICAgfTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBmb3IgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLlxuICBpZiAoaXNMb2FkZXIpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEpTT04zO1xuICAgIH0pO1xuICB9XG59KS5jYWxsKHRoaXMpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRG9tVXRpbHMuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cblx0LyoqXG5cdCAqIEEgZmV3IHV0aWxpdGllcyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgZG9tLlxuXHQgKiBAY2xhc3MgRG9tVXRpbHNcblx0ICovXG5cdHZhciBzID0ge307XG5cblx0cy5hcHBlbmRUb0hlYWQgPSBmdW5jdGlvbiAoZWwpIHtcblx0XHRzLmdldEhlYWQoKS5hcHBlbmRDaGlsZChlbClcblx0fVxuXG5cdHMuZ2V0SGVhZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG5cdH1cblxuXHRzLmdldEJvZHkgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdO1xuXHR9XG5cblx0Y3JlYXRlanMuRG9tVXRpbHMgPSBzO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRGF0YVV0aWxzLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXG5cdC8qKlxuXHQgKiBBIGZldyBkYXRhIHV0aWxpdGllcyBmb3IgZm9ybWF0dGluZyBkaWZmZXJlbnQgZGF0YSB0eXBlcy5cblx0ICogQGNsYXNzIERhdGFVdGlsc1xuXHQgKi9cblx0dmFyIHMgPSB7fTtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogUGFyc2UgWE1MIHVzaW5nIHRoZSBET00uIFRoaXMgaXMgcmVxdWlyZWQgd2hlbiBwcmVsb2FkaW5nIFhNTCBvciBTVkcuXG5cdCAqIEBtZXRob2QgcGFyc2VYTUxcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIHJhdyB0ZXh0IG9yIFhNTCB0aGF0IGlzIGxvYWRlZCBieSBYSFIuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBtaW1lIHR5cGUgb2YgdGhlIFhNTC4gVXNlIFwidGV4dC94bWxcIiBmb3IgWE1MLCBhbmQgIFwiaW1hZ2Uvc3ZnK3htbFwiIGZvciBTVkcgcGFyc2luZy5cblx0ICogQHJldHVybiB7WE1MfSBBbiBYTUwgZG9jdW1lbnRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5wYXJzZVhNTCA9IGZ1bmN0aW9uICh0ZXh0LCB0eXBlKSB7XG5cdFx0dmFyIHhtbCA9IG51bGw7XG5cdFx0Ly8gQ29jb29uSlMgZG9lcyBub3Qgc3VwcG9ydCBYTUwgcGFyc2luZyB3aXRoIGVpdGhlciBtZXRob2QuXG5cblx0XHQvLyBNb3N0IGJyb3dzZXJzIHdpbGwgdXNlIERPTVBhcnNlclxuXHRcdC8vIElFIGZhaWxzIG9uIGNlcnRhaW4gU1ZHIGZpbGVzLCBzbyB3ZSBoYXZlIGEgZmFsbGJhY2sgYmVsb3cuXG5cdFx0dHJ5IHtcblx0XHRcdGlmICh3aW5kb3cuRE9NUGFyc2VyKSB7XG5cdFx0XHRcdHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG5cdFx0XHRcdHhtbCA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcodGV4dCwgdHlwZSk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIGZvciBJRSBzdXBwb3J0LlxuXHRcdGlmICgheG1sKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR4bWwgPSBuZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxET01cIik7XG5cdFx0XHRcdHhtbC5hc3luYyA9IGZhbHNlO1xuXHRcdFx0XHR4bWwubG9hZFhNTCh0ZXh0KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0eG1sID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4geG1sO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXJzZSBhIHN0cmluZyBpbnRvIGFuIE9iamVjdC5cblx0ICogQG1ldGhvZCBwYXJzZUpTT05cblx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSBsb2FkZWQgSlNPTiBzdHJpbmdcblx0ICogQHJldHVybnMge09iamVjdH0gQSBKYXZhU2NyaXB0IG9iamVjdC5cblx0ICovXG5cdHMucGFyc2VKU09OID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09IG51bGwpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Ly8gVE9ETzsgSGFuZGxlIHRoaXMgd2l0aCBhIGN1c3RvbSBlcnJvcj9cblx0XHRcdHRocm93IGU7XG5cdFx0fVxuXHR9O1xuXG5cdGNyZWF0ZWpzLkRhdGFVdGlscyA9IHM7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBMb2FkSXRlbS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIEFsbCBsb2FkZXJzIGFjY2VwdCBhbiBpdGVtIGNvbnRhaW5pbmcgdGhlIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGlzIGNsYXNzLiBJZiBhIHJhdyBvYmplY3QgaXMgcGFzc2VkIGluc3RlYWQsXG5cdCAqIGl0IHdpbGwgbm90IGJlIGFmZmVjdGVkLCBidXQgaXQgbXVzdCBjb250YWluIGF0IGxlYXN0IGEge3sjY3Jvc3NMaW5rIFwic3JjOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5LiBBXG5cdCAqIHN0cmluZyBwYXRoIG9yIEhUTUwgdGFnIGlzIGFsc28gYWNjZXB0YWJsZSwgYnV0IGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYSBMb2FkSXRlbSB1c2luZyB0aGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiY3JlYXRlXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCBieSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBAY2xhc3MgTG9hZEl0ZW1cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0ZnVuY3Rpb24gTG9hZEl0ZW0oKSB7XG5cdFx0LyoqXG5cdFx0ICogVGhlIHNvdXJjZSBvZiB0aGUgZmlsZSB0aGF0IGlzIGJlaW5nIGxvYWRlZC4gVGhpcyBwcm9wZXJ0eSBpcyA8Yj5yZXF1aXJlZDwvYj4uIFRoZSBzb3VyY2UgY2FuIGVpdGhlciBiZSBhXG5cdFx0ICogc3RyaW5nIChyZWNvbW1lbmRlZCksIG9yIGFuIEhUTUwgdGFnLlxuXHRcdCAqIFRoaXMgY2FuIGFsc28gYmUgYW4gb2JqZWN0LCBidXQgaW4gdGhhdCBjYXNlIGl0IGhhcyB0byBpbmNsdWRlIGEgdHlwZSBhbmQgYmUgaGFuZGxlZCBieSBhIHBsdWdpbi5cblx0XHQgKiBAcHJvcGVydHkgc3JjXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5zcmMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHR5cGUgZmlsZSB0aGF0IGlzIGJlaW5nIGxvYWRlZC4gVGhlIHR5cGUgb2YgdGhlIGZpbGUgaXMgdXN1YWxseSBpbmZlcnJlZCBieSB0aGUgZXh0ZW5zaW9uLCBidXQgY2FuIGFsc29cblx0XHQgKiBiZSBzZXQgbWFudWFsbHkuIFRoaXMgaXMgaGVscGZ1bCBpbiBjYXNlcyB3aGVyZSBhIGZpbGUgZG9lcyBub3QgaGF2ZSBhbiBleHRlbnNpb24uXG5cdFx0ICogQHByb3BlcnR5IHR5cGVcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnR5cGUgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgaWRlbnRpZmllciB3aGljaCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhlIGxvYWRlZCBvYmplY3QuIElmIG5vbmUgaXMgcHJvdmlkZWQsIHRoaXMgd2lsbCBiZVxuXHRcdCAqIGF1dG9tYXRpY2FsbHkgc2V0IHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJzcmM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IGlkXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5pZCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBEZXRlcm1pbmVzIGlmIGEgbWFuaWZlc3Qgd2lsbCBtYWludGFpbiB0aGUgb3JkZXIgb2YgdGhpcyBpdGVtLCBpbiByZWxhdGlvbiB0byBvdGhlciBpdGVtcyBpbiB0aGUgbWFuaWZlc3Rcblx0XHQgKiB0aGF0IGhhdmUgYWxzbyBzZXQgdGhlIGBtYWludGFpbk9yZGVyYCBwcm9wZXJ0eSB0byBgdHJ1ZWAuIFRoaXMgb25seSBhcHBsaWVzIHdoZW4gdGhlIG1heCBjb25uZWN0aW9ucyBoYXNcblx0XHQgKiBiZWVuIHNldCBhYm92ZSAxICh1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc2V0TWF4Q29ubmVjdGlvbnNcIn19e3svY3Jvc3NMaW5rfX0pLiBFdmVyeXRoaW5nIHdpdGggdGhpc1xuXHRcdCAqIHByb3BlcnR5IHNldCB0byBgZmFsc2VgIHdpbGwgZmluaXNoIGFzIGl0IGlzIGxvYWRlZC4gT3JkZXJlZCBpdGVtcyBhcmUgY29tYmluZWQgd2l0aCBzY3JpcHQgdGFncyBsb2FkaW5nIGluXG5cdFx0ICogb3JkZXIgd2hlbiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbWFpbnRhaW5TY3JpcHRPcmRlcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpcyBzZXQgdG8gYHRydWVgLlxuXHRcdCAqIEBwcm9wZXJ0eSBtYWludGFpbk9yZGVyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLm1haW50YWluT3JkZXIgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEEgY2FsbGJhY2sgdXNlZCBieSBKU09OUCByZXF1ZXN0cyB0aGF0IGRlZmluZXMgd2hhdCBnbG9iYWwgbWV0aG9kIHRvIGNhbGwgd2hlbiB0aGUgSlNPTlAgY29udGVudCBpcyBsb2FkZWQuXG5cdFx0ICogQHByb3BlcnR5IGNhbGxiYWNrXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5jYWxsYmFjayA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBbiBhcmJpdHJhcnkgZGF0YSBvYmplY3QsIHdoaWNoIGlzIGluY2x1ZGVkIHdpdGggdGhlIGxvYWRlZCBvYmplY3QuXG5cdFx0ICogQHByb3BlcnR5IGRhdGFcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmRhdGEgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHJlcXVlc3QgbWV0aG9kIHVzZWQgZm9yIEhUVFAgY2FsbHMuIEJvdGgge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvR0VUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvUE9TVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSByZXF1ZXN0IHR5cGVzIGFyZSBzdXBwb3J0ZWQsIGFuZCBhcmUgZGVmaW5lZCBhc1xuXHRcdCAqIGNvbnN0YW50cyBvbiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgbWV0aG9kXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBnZXRcblx0XHQgKi9cblx0XHR0aGlzLm1ldGhvZCA9IGNyZWF0ZWpzLkxvYWRJdGVtLkdFVDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBoYXNoIG9mIG5hbWUvdmFsdWUgcGFpcnMgdG8gc2VuZCB0byB0aGUgc2VydmVyLlxuXHRcdCAqIEBwcm9wZXJ0eSB2YWx1ZXNcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnZhbHVlcyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3QgaGFzaCBvZiBoZWFkZXJzIHRvIGF0dGFjaCB0byBhbiBYSFIgcmVxdWVzdC4gUHJlbG9hZEpTIHdpbGwgYXV0b21hdGljYWxseSBhdHRhY2ggc29tZSBkZWZhdWx0XG5cdFx0ICogaGVhZGVycyB3aGVuIHJlcXVpcmVkLCBpbmNsdWRpbmcgXCJPcmlnaW5cIiwgXCJDb250ZW50LVR5cGVcIiwgYW5kIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiLiBZb3UgbWF5IG92ZXJyaWRlIHRoZVxuXHRcdCAqIGRlZmF1bHQgaGVhZGVycyBieSBpbmNsdWRpbmcgdGhlbSBpbiB5b3VyIGhlYWRlcnMgb2JqZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBoZWFkZXJzXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5oZWFkZXJzID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBjcmVkZW50aWFscyBmb3IgWEhSIHJlcXVlc3RzLlxuXHRcdCAqIEBwcm9wZXJ0eSB3aXRoQ3JlZGVudGlhbHNcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIG1pbWUgdHlwZSBvZiBYSFItYmFzZWQgcmVxdWVzdHMuIFRoaXMgaXMgYXV0b21hdGljYWxseSBzZXQgdG8gXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIgZm9yIHRleHRcblx0XHQgKiBiYXNlZCBmaWxlcyAoanNvbiwgeG1sLCB0ZXh0LCBjc3MsIGpzKS5cblx0XHQgKiBAcHJvcGVydHkgbWltZVR5cGVcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLm1pbWVUeXBlID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFNldHMgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBmb3IgQ09SUy1lbmFibGVkIGltYWdlcyBsb2FkaW5nIGNyb3NzLWRvbWFpbi5cblx0XHQgKiBAcHJvcGVydHkgY3Jvc3NPcmlnaW5cblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBBbm9ueW1vdXNcblx0XHQgKi9cblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgYSByZXF1ZXN0IHRpbWVzIG91dC4gVGhpcyBvbmx5IGFwcGxpZXMgdG8gdGFnLWJhc2VkIGFuZCBhbmQgWEhSXG5cdFx0ICogKGxldmVsIG9uZSkgbG9hZGluZywgYXMgWEhSIChsZXZlbCAyKSBwcm92aWRlcyBpdHMgb3duIHRpbWVvdXQgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IGxvYWRUaW1lb3V0XG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCA4MDAwICg4IHNlY29uZHMpXG5cdFx0ICovXG5cdFx0dGhpcy5sb2FkVGltZW91dCA9IHMuTE9BRF9USU1FT1VUX0RFRkFVTFQ7XG5cdH07XG5cblx0dmFyIHAgPSBMb2FkSXRlbS5wcm90b3R5cGUgPSB7fTtcblx0dmFyIHMgPSBMb2FkSXRlbTtcblxuXHQvKipcblx0ICogRGVmYXVsdCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgYSByZXF1ZXN0IHRpbWVzIG91dC4gVGhpcyBvbmx5IGFwcGxpZXMgdG8gdGFnLWJhc2VkIGFuZCBhbmQgWEhSXG5cdCAqIChsZXZlbCBvbmUpIGxvYWRpbmcsIGFzIFhIUiAobGV2ZWwgMikgcHJvdmlkZXMgaXRzIG93biB0aW1lb3V0IGV2ZW50LlxuXHQgKiBAcHJvcGVydHkgTE9BRF9USU1FT1VUX0RFRkFVTFRcblx0ICogQHR5cGUge251bWJlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5MT0FEX1RJTUVPVVRfREVGQVVMVCA9IDgwMDA7XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIExvYWRJdGVtLlxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+U3RyaW5nLWJhc2VkIGl0ZW1zIGFyZSBjb252ZXJ0ZWQgdG8gYSBMb2FkSXRlbSB3aXRoIGEgcG9wdWxhdGVkIHt7I2Nyb3NzTGluayBcInNyYzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS48L2xpPlxuXHQgKiAgICAgPGxpPkxvYWRJdGVtIGluc3RhbmNlcyBhcmUgcmV0dXJuZWQgYXMtaXM8L2xpPlxuXHQgKiAgICAgPGxpPk9iamVjdHMgYXJlIHJldHVybmVkIHdpdGggYW55IG5lZWRlZCBwcm9wZXJ0aWVzIGFkZGVkPC9saT5cblx0ICogPC91bD5cblx0ICogQG1ldGhvZCBjcmVhdGVcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxTdHJpbmd8T2JqZWN0fSB2YWx1ZSBUaGUgbG9hZCBpdGVtIHZhbHVlXG5cdCAqIEByZXR1cm5zIHtMb2FkSXRlbXxPYmplY3R9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY3JlYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG5ldyBMb2FkSXRlbSgpO1xuXHRcdFx0aXRlbS5zcmMgPSB2YWx1ZTtcblx0XHRcdHJldHVybiBpdGVtO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBzKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCAmJiB2YWx1ZS5zcmMpIHtcblx0XHRcdGlmICh2YWx1ZS5sb2FkVGltZW91dCA9PSBudWxsKSB7XG5cdFx0XHRcdHZhbHVlLmxvYWRUaW1lb3V0ID0gcy5MT0FEX1RJTUVPVVRfREVGQVVMVDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVHlwZSBub3QgcmVjb2duaXplZC5cIik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBQcm92aWRlcyBhIGNoYWluYWJsZSBzaG9ydGN1dCBtZXRob2QgZm9yIHNldHRpbmcgYSBudW1iZXIgb2YgcHJvcGVydGllcyBvbiB0aGUgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgbG9hZEl0ZW0gPSBuZXcgY3JlYXRlanMuTG9hZEl0ZW0oKS5zZXQoe3NyYzpcImltYWdlLnBuZ1wiLCBtYWludGFpbk9yZGVyOnRydWV9KTtcblx0ICpcblx0ICogQG1ldGhvZCBzZXRcblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEEgZ2VuZXJpYyBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRvIGNvcHkgdG8gdGhlIExvYWRJdGVtIGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtMb2FkSXRlbX0gUmV0dXJucyB0aGUgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQqL1xuXHRwLnNldCA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykgeyB0aGlzW25dID0gcHJvcHNbbl07IH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHRjcmVhdGVqcy5Mb2FkSXRlbSA9IHM7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBSZXF1ZXN0VXRpbHMuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cblx0LyoqXG5cdCAqIFV0aWxpdGllcyB0aGF0IGFzc2lzdCB3aXRoIHBhcnNpbmcgbG9hZCBpdGVtcywgYW5kIGRldGVybWluaW5nIGZpbGUgdHlwZXMsIGV0Yy5cblx0ICogQGNsYXNzIFJlcXVlc3RVdGlsc1xuXHQgKi9cblx0dmFyIHMgPSB7fTtcblxuXHQvKipcblx0ICogVGhlIFJlZ3VsYXIgRXhwcmVzc2lvbiB1c2VkIHRvIHRlc3QgZmlsZSBVUkxTIGZvciBhbiBhYnNvbHV0ZSBwYXRoLlxuXHQgKiBAcHJvcGVydHkgQUJTT0xVVEVfUEFUSFxuXHQgKiBAdHlwZSB7UmVnRXhwfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLkFCU09MVVRFX1BBVFQgPSAvXig/Olxcdys6KT9cXC97Mn0vaTtcblxuXHQvKipcblx0ICogVGhlIFJlZ3VsYXIgRXhwcmVzc2lvbiB1c2VkIHRvIHRlc3QgZmlsZSBVUkxTIGZvciBhIHJlbGF0aXZlIHBhdGguXG5cdCAqIEBwcm9wZXJ0eSBSRUxBVElWRV9QQVRIXG5cdCAqIEB0eXBlIHtSZWdFeHB9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuUkVMQVRJVkVfUEFUVCA9ICgvXlsuL10qP1xcLy9pKTtcblxuXHQvKipcblx0ICogVGhlIFJlZ3VsYXIgRXhwcmVzc2lvbiB1c2VkIHRvIHRlc3QgZmlsZSBVUkxTIGZvciBhbiBleHRlbnNpb24uIE5vdGUgdGhhdCBVUklzIG11c3QgYWxyZWFkeSBoYXZlIHRoZSBxdWVyeSBzdHJpbmdcblx0ICogcmVtb3ZlZC5cblx0ICogQHByb3BlcnR5IEVYVEVOU0lPTl9QQVRUXG5cdCAqIEB0eXBlIHtSZWdFeHB9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuRVhURU5TSU9OX1BBVFQgPSAvXFwvP1teL10rXFwuKFxcd3sxLDV9KSQvaTtcblxuXHQvKipcblx0ICogUGFyc2UgYSBmaWxlIHBhdGggdG8gZGV0ZXJtaW5lIHRoZSBpbmZvcm1hdGlvbiB3ZSBuZWVkIHRvIHdvcmsgd2l0aCBpdC4gQ3VycmVudGx5LCBQcmVsb2FkSlMgbmVlZHMgdG8ga25vdzpcblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPklmIHRoZSBwYXRoIGlzIGFic29sdXRlLiBBYnNvbHV0ZSBwYXRocyBzdGFydCB3aXRoIGEgcHJvdG9jb2wgKHN1Y2ggYXMgYGh0dHA6Ly9gLCBgZmlsZTovL2AsIG9yXG5cdCAqICAgICBgLy9uZXR3b3JrUGF0aGApPC9saT5cblx0ICogICAgIDxsaT5JZiB0aGUgcGF0aCBpcyByZWxhdGl2ZS4gUmVsYXRpdmUgcGF0aHMgc3RhcnQgd2l0aCBgLi4vYCBvciBgL3BhdGhgIChvciBzaW1pbGFyKTwvbGk+XG5cdCAqICAgICA8bGk+VGhlIGZpbGUgZXh0ZW5zaW9uLiBUaGlzIGlzIGRldGVybWluZWQgYnkgdGhlIGZpbGVuYW1lIHdpdGggYW4gZXh0ZW5zaW9uLiBRdWVyeSBzdHJpbmdzIGFyZSBkcm9wcGVkLCBhbmRcblx0ICogICAgIHRoZSBmaWxlIHBhdGggaXMgZXhwZWN0ZWQgdG8gZm9sbG93IHRoZSBmb3JtYXQgYG5hbWUuZXh0YC48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBAbWV0aG9kIHBhcnNlVVJJXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IEFuIE9iamVjdCB3aXRoIGFuIGBhYnNvbHV0ZWAgYW5kIGByZWxhdGl2ZWAgQm9vbGVhbiB2YWx1ZXMsIGFzIHdlbGwgYXMgYW4gb3B0aW9uYWwgJ2V4dGVuc2lvbmBcblx0ICogcHJvcGVydHksIHdoaWNoIGlzIHRoZSBsb3dlcmNhc2UgZXh0ZW5zaW9uLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLnBhcnNlVVJJID0gZnVuY3Rpb24gKHBhdGgpIHtcblx0XHR2YXIgaW5mbyA9IHthYnNvbHV0ZTogZmFsc2UsIHJlbGF0aXZlOiBmYWxzZX07XG5cdFx0aWYgKHBhdGggPT0gbnVsbCkgeyByZXR1cm4gaW5mbzsgfVxuXG5cdFx0Ly8gRHJvcCB0aGUgcXVlcnkgc3RyaW5nXG5cdFx0dmFyIHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoXCI/XCIpO1xuXHRcdGlmIChxdWVyeUluZGV4ID4gLTEpIHtcblx0XHRcdHBhdGggPSBwYXRoLnN1YnN0cigwLCBxdWVyeUluZGV4KTtcblx0XHR9XG5cblx0XHQvLyBBYnNvbHV0ZVxuXHRcdHZhciBtYXRjaDtcblx0XHRpZiAocy5BQlNPTFVURV9QQVRULnRlc3QocGF0aCkpIHtcblx0XHRcdGluZm8uYWJzb2x1dGUgPSB0cnVlO1xuXG5cdFx0XHQvLyBSZWxhdGl2ZVxuXHRcdH0gZWxzZSBpZiAocy5SRUxBVElWRV9QQVRULnRlc3QocGF0aCkpIHtcblx0XHRcdGluZm8ucmVsYXRpdmUgPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIEV4dGVuc2lvblxuXHRcdGlmIChtYXRjaCA9IHBhdGgubWF0Y2gocy5FWFRFTlNJT05fUEFUVCkpIHtcblx0XHRcdGluZm8uZXh0ZW5zaW9uID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGluZm87XG5cdH07XG5cblx0LyoqXG5cdCAqIEZvcm1hdHMgYW4gb2JqZWN0IGludG8gYSBxdWVyeSBzdHJpbmcgZm9yIGVpdGhlciBhIFBPU1Qgb3IgR0VUIHJlcXVlc3QuXG5cdCAqIEBtZXRob2QgZm9ybWF0UXVlcnlTdHJpbmdcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgdG8gY29udmVydCB0byBhIHF1ZXJ5IHN0cmluZy5cblx0ICogQHBhcmFtIHtBcnJheX0gW3F1ZXJ5XSBFeGlzdGluZyBuYW1lL3ZhbHVlIHBhaXJzIHRvIGFwcGVuZCBvbiB0byB0aGlzIHF1ZXJ5LlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmZvcm1hdFF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24gKGRhdGEsIHF1ZXJ5KSB7XG5cdFx0aWYgKGRhdGEgPT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGRhdGEuJyk7XG5cdFx0fVxuXHRcdHZhciBwYXJhbXMgPSBbXTtcblx0XHRmb3IgKHZhciBuIGluIGRhdGEpIHtcblx0XHRcdHBhcmFtcy5wdXNoKG4gKyAnPScgKyBlc2NhcGUoZGF0YVtuXSkpO1xuXHRcdH1cblx0XHRpZiAocXVlcnkpIHtcblx0XHRcdHBhcmFtcyA9IHBhcmFtcy5jb25jYXQocXVlcnkpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGFyYW1zLmpvaW4oJyYnKTtcblx0fTtcblxuXHQvKipcblx0ICogQSB1dGlsaXR5IG1ldGhvZCB0aGF0IGJ1aWxkcyBhIGZpbGUgcGF0aCB1c2luZyBhIHNvdXJjZSBhbmQgYSBkYXRhIG9iamVjdCwgYW5kIGZvcm1hdHMgaXQgaW50byBhIG5ldyBwYXRoLlxuXHQgKiBAbWV0aG9kIGJ1aWxkUGF0aFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VyY2UgcGF0aCB0byBhZGQgdmFsdWVzIHRvLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIE9iamVjdCB1c2VkIHRvIGFwcGVuZCB2YWx1ZXMgdG8gdGhpcyByZXF1ZXN0IGFzIGEgcXVlcnkgc3RyaW5nLiBFeGlzdGluZyBwYXJhbWV0ZXJzIG9uIHRoZVxuXHQgKiBwYXRoIHdpbGwgYmUgcHJlc2VydmVkLlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBBIGZvcm1hdHRlZCBzdHJpbmcgdGhhdCBjb250YWlucyB0aGUgcGF0aCBhbmQgdGhlIHN1cHBsaWVkIHBhcmFtZXRlcnMuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuYnVpbGRQYXRoID0gZnVuY3Rpb24gKHNyYywgZGF0YSkge1xuXHRcdGlmIChkYXRhID09IG51bGwpIHtcblx0XHRcdHJldHVybiBzcmM7XG5cdFx0fVxuXG5cdFx0dmFyIHF1ZXJ5ID0gW107XG5cdFx0dmFyIGlkeCA9IHNyYy5pbmRleE9mKCc/Jyk7XG5cblx0XHRpZiAoaWR4ICE9IC0xKSB7XG5cdFx0XHR2YXIgcSA9IHNyYy5zbGljZShpZHggKyAxKTtcblx0XHRcdHF1ZXJ5ID0gcXVlcnkuY29uY2F0KHEuc3BsaXQoJyYnKSk7XG5cdFx0fVxuXG5cdFx0aWYgKGlkeCAhPSAtMSkge1xuXHRcdFx0cmV0dXJuIHNyYy5zbGljZSgwLCBpZHgpICsgJz8nICsgdGhpcy5mb3JtYXRRdWVyeVN0cmluZyhkYXRhLCBxdWVyeSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBzcmMgKyAnPycgKyB0aGlzLmZvcm1hdFF1ZXJ5U3RyaW5nKGRhdGEsIHF1ZXJ5KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgaXNDcm9zc0RvbWFpblxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBBIGxvYWQgaXRlbSB3aXRoIGEgYHNyY2AgcHJvcGVydHkuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBsb2FkIGl0ZW0gaXMgbG9hZGluZyBmcm9tIGEgZGlmZmVyZW50IGRvbWFpbiB0aGFuIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzQ3Jvc3NEb21haW4gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHZhciB0YXJnZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcblx0XHR0YXJnZXQuaHJlZiA9IGl0ZW0uc3JjO1xuXG5cdFx0dmFyIGhvc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcblx0XHRob3N0LmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG5cdFx0dmFyIGNyb3NzZG9tYWluID0gKHRhcmdldC5ob3N0bmFtZSAhPSBcIlwiKSAmJlxuXHRcdFx0XHRcdFx0ICAodGFyZ2V0LnBvcnQgIT0gaG9zdC5wb3J0IHx8XG5cdFx0XHRcdFx0XHQgICB0YXJnZXQucHJvdG9jb2wgIT0gaG9zdC5wcm90b2NvbCB8fFxuXHRcdFx0XHRcdFx0ICAgdGFyZ2V0Lmhvc3RuYW1lICE9IGhvc3QuaG9zdG5hbWUpO1xuXHRcdHJldHVybiBjcm9zc2RvbWFpbjtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBpc0xvY2FsXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIEEgbG9hZCBpdGVtIHdpdGggYSBgc3JjYCBwcm9wZXJ0eVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgbG9hZCBpdGVtIGlzIGxvYWRpbmcgZnJvbSB0aGUgXCJmaWxlOlwiIHByb3RvY29sLiBBc3N1bWUgdGhhdCB0aGUgaG9zdCBtdXN0IGJlIGxvY2FsIGFzXG5cdCAqIHdlbGwuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaXNMb2NhbCA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0dmFyIHRhcmdldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXHRcdHRhcmdldC5ocmVmID0gaXRlbS5zcmM7XG5cdFx0cmV0dXJuIHRhcmdldC5ob3N0bmFtZSA9PSBcIlwiICYmIHRhcmdldC5wcm90b2NvbCA9PSBcImZpbGU6XCI7XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSBpZiBhIHNwZWNpZmljIHR5cGUgc2hvdWxkIGJlIGxvYWRlZCBhcyBhIGJpbmFyeSBmaWxlLiBDdXJyZW50bHksIG9ubHkgaW1hZ2VzIGFuZCBpdGVtcyBtYXJrZWRcblx0ICogc3BlY2lmaWNhbGx5IGFzIFwiYmluYXJ5XCIgYXJlIGxvYWRlZCBhcyBiaW5hcnkuIE5vdGUgdGhhdCBhdWRpbyBpcyA8Yj5ub3Q8L2I+IGEgYmluYXJ5IHR5cGUsIGFzIHdlIGNhbiBub3QgcGxheVxuXHQgKiBiYWNrIHVzaW5nIGFuIGF1ZGlvIHRhZyBpZiBpdCBpcyBsb2FkZWQgYXMgYmluYXJ5LiBQbHVnaW5zIGNhbiBjaGFuZ2UgdGhlIGl0ZW0gdHlwZSB0byBiaW5hcnkgdG8gZW5zdXJlIHRoZXkgZ2V0XG5cdCAqIGEgYmluYXJ5IHJlc3VsdCB0byB3b3JrIHdpdGguIEJpbmFyeSBmaWxlcyBhcmUgbG9hZGVkIHVzaW5nIFhIUjIuIFR5cGVzIGFyZSBkZWZpbmVkIGFzIHN0YXRpYyBjb25zdGFudHMgb25cblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgaXNCaW5hcnlcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGl0ZW0gdHlwZS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIHNwZWNpZmllZCB0eXBlIGlzIGJpbmFyeS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5pc0JpbmFyeSA9IGZ1bmN0aW9uICh0eXBlKSB7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLklNQUdFOlxuXHRcdFx0Y2FzZSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5CSU5BUlk6XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgaXRlbSBpcyBhIHZhbGlkIEhUTUxJbWFnZUVsZW1lbnRcblx0ICogQG1ldGhvZCBpc0ltYWdlVGFnXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzSW1hZ2VUYWcgPSBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0gaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBpdGVtIGlzIGEgdmFsaWQgSFRNTEF1ZGlvRWxlbWVudFxuXHQgKiBAbWV0aG9kIGlzQXVkaW9UYWdcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cblx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaXNBdWRpb1RhZyA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRpZiAod2luZG93LkhUTUxBdWRpb0VsZW1lbnQpIHtcblx0XHRcdHJldHVybiBpdGVtIGluc3RhbmNlb2YgSFRNTEF1ZGlvRWxlbWVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgaXRlbSBpcyBhIHZhbGlkIEhUTUxWaWRlb0VsZW1lbnRcblx0ICogQG1ldGhvZCBpc1ZpZGVvVGFnXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzVmlkZW9UYWcgPSBmdW5jdGlvbihpdGVtKSB7XG5cdFx0aWYgKHdpbmRvdy5IVE1MVmlkZW9FbGVtZW50KSB7XG5cdFx0XHRyZXR1cm4gaXRlbSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSBpZiBhIHNwZWNpZmljIHR5cGUgaXMgYSB0ZXh0LWJhc2VkIGFzc2V0LCBhbmQgc2hvdWxkIGJlIGxvYWRlZCBhcyBVVEYtOC5cblx0ICogQG1ldGhvZCBpc1RleHRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGl0ZW0gdHlwZS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIHNwZWNpZmllZCB0eXBlIGlzIHRleHQuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaXNUZXh0ID0gZnVuY3Rpb24gKHR5cGUpIHtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVEVYVDpcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSlNPTjpcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuTUFOSUZFU1Q6XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlhNTDpcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuQ1NTOlxuXHRcdFx0Y2FzZSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TVkc6XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpBVkFTQ1JJUFQ6XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNQUklURVNIRUVUOlxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSB0aGUgdHlwZSBvZiB0aGUgb2JqZWN0IHVzaW5nIGNvbW1vbiBleHRlbnNpb25zLiBOb3RlIHRoYXQgdGhlIHR5cGUgY2FuIGJlIHBhc3NlZCBpbiB3aXRoIHRoZSBsb2FkIGl0ZW1cblx0ICogaWYgaXQgaXMgYW4gdW51c3VhbCBleHRlbnNpb24uXG5cdCAqIEBtZXRob2QgZ2V0VHlwZUJ5RXh0ZW5zaW9uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBleHRlbnNpb24gVGhlIGZpbGUgZXh0ZW5zaW9uIHRvIHVzZSB0byBkZXRlcm1pbmUgdGhlIGxvYWQgdHlwZS5cblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgZGV0ZXJtaW5lZCBsb2FkIHR5cGUgKGZvciBleGFtcGxlLCA8Y29kZT5BYnN0cmFjdExvYWRlci5JTUFHRTwvY29kZT4pLiBXaWxsIHJldHVybiBgbnVsbGAgaWZcblx0ICogdGhlIHR5cGUgY2FuIG5vdCBiZSBkZXRlcm1pbmVkIGJ5IHRoZSBleHRlbnNpb24uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuZ2V0VHlwZUJ5RXh0ZW5zaW9uID0gZnVuY3Rpb24gKGV4dGVuc2lvbikge1xuXHRcdGlmIChleHRlbnNpb24gPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlRFWFQ7XG5cdFx0fVxuXG5cdFx0c3dpdGNoIChleHRlbnNpb24udG9Mb3dlckNhc2UoKSkge1xuXHRcdFx0Y2FzZSBcImpwZWdcIjpcblx0XHRcdGNhc2UgXCJqcGdcIjpcblx0XHRcdGNhc2UgXCJnaWZcIjpcblx0XHRcdGNhc2UgXCJwbmdcIjpcblx0XHRcdGNhc2UgXCJ3ZWJwXCI6XG5cdFx0XHRjYXNlIFwiYm1wXCI6XG5cdFx0XHRcdHJldHVybiBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5JTUFHRTtcblx0XHRcdGNhc2UgXCJvZ2dcIjpcblx0XHRcdGNhc2UgXCJtcDNcIjpcblx0XHRcdGNhc2UgXCJ3ZWJtXCI6XG5cdFx0XHRcdHJldHVybiBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TT1VORDtcblx0XHRcdGNhc2UgXCJtcDRcIjpcblx0XHRcdGNhc2UgXCJ3ZWJtXCI6XG5cdFx0XHRjYXNlIFwidHNcIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlZJREVPO1xuXHRcdFx0Y2FzZSBcImpzb25cIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpTT047XG5cdFx0XHRjYXNlIFwieG1sXCI6XG5cdFx0XHRcdHJldHVybiBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5YTUw7XG5cdFx0XHRjYXNlIFwiY3NzXCI6XG5cdFx0XHRcdHJldHVybiBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5DU1M7XG5cdFx0XHRjYXNlIFwianNcIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpBVkFTQ1JJUFQ7XG5cdFx0XHRjYXNlICdzdmcnOlxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU1ZHO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlRFWFQ7XG5cdFx0fVxuXHR9O1xuXG5cdGNyZWF0ZWpzLlJlcXVlc3RVdGlscyA9IHM7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBBYnN0cmFjdExvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBUaGUgYmFzZSBsb2FkZXIsIHdoaWNoIGRlZmluZXMgYWxsIHRoZSBnZW5lcmljIG1ldGhvZHMsIHByb3BlcnRpZXMsIGFuZCBldmVudHMuIEFsbCBsb2FkZXJzIGV4dGVuZCB0aGlzIGNsYXNzLFxuXHQgKiBpbmNsdWRpbmcgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQGNsYXNzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18b2JqZWN0fHN0cmluZ30gbG9hZEl0ZW0gVGhlIGl0ZW0gdG8gYmUgbG9hZGVkLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtwcmVmZXJYSFJdIERldGVybWluZXMgaWYgdGhlIExvYWRJdGVtIHNob3VsZCA8ZW0+dHJ5PC9lbT4gYW5kIGxvYWQgdXNpbmcgWEhSLCBvciB0YWtlIGFcblx0ICogdGFnLWJhc2VkIGFwcHJvYWNoLCB3aGljaCBjYW4gYmUgYmV0dGVyIGluIGNyb3NzLWRvbWFpbiBzaXR1YXRpb25zLiBOb3QgYWxsIGxvYWRlcnMgY2FuIGxvYWQgdXNpbmcgb25lIG9yIHRoZVxuXHQgKiBvdGhlciwgc28gdGhpcyBpcyBhIHN1Z2dlc3RlZCBkaXJlY3RpdmUuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV0gVGhlIHR5cGUgb2YgbG9hZGVyLiBMb2FkZXIgdHlwZXMgYXJlIGRlZmluZWQgYXMgY29uc3RhbnRzIG9uIHRoZSBBYnN0cmFjdExvYWRlciBjbGFzcyxcblx0ICogc3VjaCBhcyB7eyNjcm9zc0xpbmsgXCJJTUFHRTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiQ1NTOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LCBldGMuXG5cdCAqIEBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlclxuXHQgKi9cblx0ZnVuY3Rpb24gQWJzdHJhY3RMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUiwgdHlwZSkge1xuXHRcdHRoaXMuRXZlbnREaXNwYXRjaGVyX2NvbnN0cnVjdG9yKCk7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIElmIHRoZSBsb2FkZXIgaGFzIGNvbXBsZXRlZCBsb2FkaW5nLiBUaGlzIHByb3ZpZGVzIGEgcXVpY2sgY2hlY2ssIGJ1dCBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgZGlmZmVyZW50IGFwcHJvYWNoZXNcblx0XHQgKiB1c2VkIGZvciBsb2FkaW5nIGRvIG5vdCBwaWxlIHVwIHJlc3VsdGluZyBpbiBtb3JlIHRoYW4gb25lIGBjb21wbGV0ZWAge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IGxvYWRlZFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5sb2FkZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZSBpZiB0aGUgbG9hZGVyIHdhcyBjYW5jZWxlZC4gQ2FuY2VsZWQgbG9hZHMgd2lsbCBub3QgZmlyZSBjb21wbGV0ZSBldmVudHMuIE5vdGUgdGhhdCB0aGlzIHByb3BlcnR5XG5cdFx0ICogaXMgcmVhZG9ubHksIHNvIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSBxdWV1ZXMgc2hvdWxkIGJlIGNsb3NlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvY2xvc2VcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBpbnN0ZWFkLlxuXHRcdCAqIEBwcm9wZXJ0eSBjYW5jZWxlZFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5jYW5jZWxlZCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgbG9hZCBwcm9ncmVzcyAocGVyY2VudGFnZSkgZm9yIHRoaXMgaXRlbS4gVGhpcyB3aWxsIGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMS5cblx0XHQgKlxuXHRcdCAqIDxoND5FeGFtcGxlPC9oND5cblx0XHQgKlxuXHRcdCAqICAgICB2YXIgcXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG5cdFx0ICogICAgIHF1ZXVlLmxvYWRGaWxlKFwibGFyZ2VJbWFnZS5wbmdcIik7XG5cdFx0ICogICAgIHF1ZXVlLm9uKFwicHJvZ3Jlc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAgICBjb25zb2xlLmxvZyhcIlByb2dyZXNzOlwiLCBxdWV1ZS5wcm9ncmVzcywgZXZlbnQucHJvZ3Jlc3MpO1xuXHRcdCAqICAgICB9KTtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBwcm9ncmVzc1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgaXRlbSB0aGlzIGxvYWRlciB3aWxsIGxvYWQuIFNlZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlclwifX17ey9jcm9zc0xpbmt9fSBmb3IgYSBmdWxsIGxpc3Qgb2Zcblx0XHQgKiBzdXBwb3J0ZWQgdHlwZXMuXG5cdFx0ICogQHByb3BlcnR5IHR5cGVcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cblx0XHQvKipcblx0XHQgKiBBIGZvcm1hdHRlciBmdW5jdGlvbiB0aGF0IGNvbnZlcnRzIHRoZSBsb2FkZWQgcmF3IHJlc3VsdCBpbnRvIHRoZSBmaW5hbCByZXN1bHQuIEZvciBleGFtcGxlLCB0aGUgSlNPTkxvYWRlclxuXHRcdCAqIGNvbnZlcnRzIGEgc3RyaW5nIG9mIHRleHQgaW50byBhIEphdmFTY3JpcHQgb2JqZWN0LiBOb3QgYWxsIGxvYWRlcnMgaGF2ZSBhIHJlc3VsdEZvcm1hdHRlciwgYW5kIHRoaXMgcHJvcGVydHlcblx0XHQgKiBjYW4gYmUgb3ZlcnJpZGRlbiB0byBwcm92aWRlIGN1c3RvbSBmb3JtYXR0aW5nLlxuXHRcdCAqXG5cdFx0ICogT3B0aW9uYWxseSwgYSByZXN1bHRGb3JtYXR0ZXIgY2FuIHJldHVybiBhIGNhbGxiYWNrIGZ1bmN0aW9uIGluIGNhc2VzIHdoZXJlIHRoZSBmb3JtYXR0aW5nIG5lZWRzIHRvIGJlXG5cdFx0ICogYXN5bmNocm9ub3VzLCBzdWNoIGFzIGNyZWF0aW5nIGEgbmV3IGltYWdlLiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgcGFzc2VkIDIgcGFyYW1ldGVycywgd2hpY2ggYXJlIGNhbGxiYWNrc1xuXHRcdCAqIHRvIGhhbmRsZSBzdWNjZXNzIGFuZCBlcnJvciBjb25kaXRpb25zIGluIHRoZSByZXN1bHRGb3JtYXR0ZXIuIE5vdGUgdGhhdCB0aGUgcmVzdWx0Rm9ybWF0dGVyIG1ldGhvZCBpc1xuXHRcdCAqIGNhbGxlZCBpbiB0aGUgY3VycmVudCBzY29wZSwgYXMgd2VsbCBhcyB0aGUgc3VjY2VzcyBhbmQgZXJyb3IgY2FsbGJhY2tzLlxuXHRcdCAqXG5cdFx0ICogPGg0PkV4YW1wbGUgYXN5bmNocm9ub3VzIHJlc3VsdEZvcm1hdHRlcjwvaDQ+XG5cdFx0ICpcblx0XHQgKiBcdGZ1bmN0aW9uIF9mb3JtYXRSZXN1bHQobG9hZGVyKSB7XG5cdFx0ICogXHRcdHJldHVybiBmdW5jdGlvbihzdWNjZXNzLCBlcnJvcikge1xuXHRcdCAqIFx0XHRcdGlmIChlcnJvckNvbmRpdGlvbikgeyBlcnJvcihlcnJvckRldGFpbEV2ZW50KTsgfVxuXHRcdCAqIFx0XHRcdHN1Y2Nlc3MocmVzdWx0KTtcblx0XHQgKiBcdFx0fVxuXHRcdCAqIFx0fVxuXHRcdCAqIEBwcm9wZXJ0eSByZXN1bHRGb3JtYXR0ZXJcblx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gbnVsbDtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogVGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319IHRoaXMgbG9hZGVyIHJlcHJlc2VudHMuIE5vdGUgdGhhdCB0aGlzIGlzIG51bGwgaW4gYSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0sXG5cdFx0ICogYnV0IHdpbGwgYmUgYXZhaWxhYmxlIG9uIGxvYWRlcnMgc3VjaCBhcyB7eyNjcm9zc0xpbmsgXCJYTUxMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkltYWdlTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBfaXRlbVxuXHRcdCAqIEB0eXBlIHtMb2FkSXRlbXxPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRpZiAobG9hZEl0ZW0pIHtcblx0XHRcdHRoaXMuX2l0ZW0gPSBjcmVhdGVqcy5Mb2FkSXRlbS5jcmVhdGUobG9hZEl0ZW0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9pdGVtID0gbnVsbDtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRoZSBsb2FkZXIgd2lsbCB0cnkgYW5kIGxvYWQgY29udGVudCB1c2luZyBYSFIgKHRydWUpIG9yIEhUTUwgdGFncyAoZmFsc2UpLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcHJlZmVyWEhSXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9wcmVmZXJYSFIgPSBwcmVmZXJYSFI7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbG9hZGVkIHJlc3VsdCBhZnRlciBpdCBpcyBmb3JtYXR0ZWQgYnkgYW4gb3B0aW9uYWwge3sjY3Jvc3NMaW5rIFwicmVzdWx0Rm9ybWF0dGVyXCJ9fXt7L2Nyb3NzTGlua319LiBGb3Jcblx0XHQgKiBpdGVtcyB0aGF0IGFyZSBub3QgZm9ybWF0dGVkLCB0aGlzIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIHt7I2Nyb3NzTGluayBcIl9yYXdSZXN1bHQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogVGhlIHJlc3VsdCBpcyBhY2Nlc3NlZCB1c2luZyB0aGUge3sjY3Jvc3NMaW5rIFwiZ2V0UmVzdWx0XCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cblx0XHQgKiBAcHJvcGVydHkgX3Jlc3VsdFxuXHRcdCAqIEB0eXBlIHtPYmplY3R8U3RyaW5nfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcmVzdWx0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsb2FkZWQgcmVzdWx0IGJlZm9yZSBpdCBpcyBmb3JtYXR0ZWQuIFRoZSByYXdSZXN1bHQgaXMgYWNjZXNzZWQgdXNpbmcgdGhlIHt7I2Nyb3NzTGluayBcImdldFJlc3VsdFwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIG1ldGhvZCwgYW5kIHBhc3NpbmcgYHRydWVgLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmF3UmVzdWx0XG5cdFx0ICogQHR5cGUge09iamVjdHxTdHJpbmd9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9yYXdSZXN1bHQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBsaXN0IG9mIGl0ZW1zIHRoYXQgbG9hZGVycyBsb2FkIGJlaGluZCB0aGUgc2NlbmVzLiBUaGlzIGRvZXMgbm90IGluY2x1ZGUgdGhlIG1haW4gaXRlbSB0aGUgbG9hZGVyIGlzXG5cdFx0ICogcmVzcG9uc2libGUgZm9yIGxvYWRpbmcuIEV4YW1wbGVzIG9mIGxvYWRlcnMgdGhhdCBoYXZlIHN1Yi1pdGVtcyBpbmNsdWRlIHRoZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldExvYWRlclwifX17ey9jcm9zc0xpbmt9fSBhbmRcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRJdGVtc1xuXHRcdCAqIEB0eXBlIHtudWxsfVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkZWRJdGVtcyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYXR0cmlidXRlIHRoZSBpdGVtcyBsb2FkZWQgdXNpbmcgdGFncyB1c2UgZm9yIHRoZSBzb3VyY2UuXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gSFRNTCB0YWcgKG9yIHNpbWlsYXIpIHRoYXQgYSBsb2FkZXIgbWF5IHVzZSB0byBsb2FkIEhUTUwgY29udGVudCwgc3VjaCBhcyBpbWFnZXMsIHNjcmlwdHMsIGV0Yy5cblx0XHQgKiBAcHJvcGVydHkgX3RhZ1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl90YWcgPSBudWxsO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEFic3RyYWN0TG9hZGVyLCBjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIpO1xuXHR2YXIgcyA9IEFic3RyYWN0TG9hZGVyO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cblx0LyoqXG5cdCAqIERlZmluZXMgYSBQT1NUIHJlcXVlc3QsIHVzZSBmb3IgYSBtZXRob2QgdmFsdWUgd2hlbiBsb2FkaW5nIGRhdGEuXG5cdCAqIEBwcm9wZXJ0eSBQT1NUXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHBvc3Rcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5QT1NUID0gXCJQT1NUXCI7XG5cblx0LyoqXG5cdCAqIERlZmluZXMgYSBHRVQgcmVxdWVzdCwgdXNlIGZvciBhIG1ldGhvZCB2YWx1ZSB3aGVuIGxvYWRpbmcgZGF0YS5cblx0ICogQHByb3BlcnR5IEdFVFxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBnZXRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5HRVQgPSBcIkdFVFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBnZW5lcmljIGJpbmFyeSB0eXBlcy4gTm90ZSB0aGF0IGltYWdlcyBhcmUgbG9hZGVkIGFzIGJpbmFyeSBmaWxlcyB3aGVuIHVzaW5nIFhIUi5cblx0ICogQHByb3BlcnR5IEJJTkFSWVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBiaW5hcnlcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuQklOQVJZID0gXCJiaW5hcnlcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgY3NzIGZpbGVzLiBDU1MgZmlsZXMgYXJlIGxvYWRlZCB1c2luZyBhICZsdDtsaW5rJmd0OyB3aGVuIGxvYWRlZCB3aXRoIFhIUiwgb3IgYVxuXHQgKiAmbHQ7c3R5bGUmZ3Q7IHRhZyB3aGVuIGxvYWRlZCB3aXRoIHRhZ3MuXG5cdCAqIEBwcm9wZXJ0eSBDU1Ncblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgY3NzXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLkNTUyA9IFwiY3NzXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIGltYWdlIGZpbGVzLCB1c3VhbGx5IHBuZywgZ2lmLCBvciBqcGcvanBlZy4gSW1hZ2VzIGFyZSBsb2FkZWQgaW50byBhbiAmbHQ7aW1hZ2UmZ3Q7IHRhZy5cblx0ICogQHByb3BlcnR5IElNQUdFXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGltYWdlXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLklNQUdFID0gXCJpbWFnZVwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBqYXZhc2NyaXB0IGZpbGVzLCB1c3VhbGx5IHdpdGggdGhlIFwianNcIiBmaWxlIGV4dGVuc2lvbi4gSmF2YVNjcmlwdCBmaWxlcyBhcmUgbG9hZGVkIGludG8gYVxuXHQgKiAmbHQ7c2NyaXB0Jmd0OyB0YWcuXG5cdCAqXG5cdCAqIFNpbmNlIHZlcnNpb24gMC40LjErLCBkdWUgdG8gaG93IHRhZy1sb2FkZWQgc2NyaXB0cyB3b3JrLCBhbGwgSmF2YVNjcmlwdCBmaWxlcyBhcmUgYXV0b21hdGljYWxseSBpbmplY3RlZCBpbnRvXG5cdCAqIHRoZSBib2R5IG9mIHRoZSBkb2N1bWVudCB0byBtYWludGFpbiBwYXJpdHkgYmV0d2VlbiBYSFIgYW5kIHRhZy1sb2FkZWQgc2NyaXB0cy4gSW4gdmVyc2lvbiAwLjQuMCBhbmQgZWFybGllcixcblx0ICogb25seSB0YWctbG9hZGVkIHNjcmlwdHMgYXJlIGluamVjdGVkLlxuXHQgKiBAcHJvcGVydHkgSkFWQVNDUklQVFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBqYXZhc2NyaXB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLkpBVkFTQ1JJUFQgPSBcImphdmFzY3JpcHRcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IganNvbiBmaWxlcywgdXN1YWxseSB3aXRoIHRoZSBcImpzb25cIiBmaWxlIGV4dGVuc2lvbi4gSlNPTiBkYXRhIGlzIGxvYWRlZCBhbmQgcGFyc2VkIGludG8gYVxuXHQgKiBKYXZhU2NyaXB0IG9iamVjdC4gTm90ZSB0aGF0IGlmIGEgYGNhbGxiYWNrYCBpcyBwcmVzZW50IG9uIHRoZSBsb2FkIGl0ZW0sIHRoZSBmaWxlIHdpbGwgYmUgbG9hZGVkIHdpdGggSlNPTlAsXG5cdCAqIG5vIG1hdHRlciB3aGF0IHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvcHJlZmVyWEhSOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGlzIHNldCB0bywgYW5kIHRoZSBKU09OXG5cdCAqIG11c3QgY29udGFpbiBhIG1hdGNoaW5nIHdyYXBwZXIgZnVuY3Rpb24uXG5cdCAqIEBwcm9wZXJ0eSBKU09OXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGpzb25cblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuSlNPTiA9IFwianNvblwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBqc29ucCBmaWxlcywgdXN1YWxseSB3aXRoIHRoZSBcImpzb25cIiBmaWxlIGV4dGVuc2lvbi4gSlNPTiBkYXRhIGlzIGxvYWRlZCBhbmQgcGFyc2VkIGludG8gYVxuXHQgKiBKYXZhU2NyaXB0IG9iamVjdC4gWW91IGFyZSByZXF1aXJlZCB0byBwYXNzIGEgY2FsbGJhY2sgcGFyYW1ldGVyIHRoYXQgbWF0Y2hlcyB0aGUgZnVuY3Rpb24gd3JhcHBlciBpbiB0aGUgSlNPTi5cblx0ICogTm90ZSB0aGF0IEpTT05QIHdpbGwgYWx3YXlzIGJlIHVzZWQgaWYgdGhlcmUgaXMgYSBjYWxsYmFjayBwcmVzZW50LCBubyBtYXR0ZXIgd2hhdCB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3ByZWZlclhIUjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBwcm9wZXJ0eSBpcyBzZXQgdG8uXG5cdCAqIEBwcm9wZXJ0eSBKU09OUFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBqc29ucFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5KU09OUCA9IFwianNvbnBcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IganNvbi1iYXNlZCBtYW5pZmVzdCBmaWxlcywgdXN1YWxseSB3aXRoIHRoZSBcImpzb25cIiBmaWxlIGV4dGVuc2lvbi4gVGhlIEpTT04gZGF0YSBpcyBsb2FkZWRcblx0ICogYW5kIHBhcnNlZCBpbnRvIGEgSmF2YVNjcmlwdCBvYmplY3QuIFByZWxvYWRKUyB3aWxsIHRoZW4gbG9vayBmb3IgYSBcIm1hbmlmZXN0XCIgcHJvcGVydHkgaW4gdGhlIEpTT04sIHdoaWNoIGlzIGFuXG5cdCAqIEFycmF5IG9mIGZpbGVzIHRvIGxvYWQsIGZvbGxvd2luZyB0aGUgc2FtZSBmb3JtYXQgYXMgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLiBJZiBhIFwiY2FsbGJhY2tcIiBpcyBzcGVjaWZpZWQgb24gdGhlIG1hbmlmZXN0IG9iamVjdCwgdGhlbiBpdCB3aWxsIGJlIGxvYWRlZCB1c2luZyBKU09OUCBpbnN0ZWFkLFxuXHQgKiByZWdhcmRsZXNzIG9mIHdoYXQgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9wcmVmZXJYSFI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaXMgc2V0IHRvLlxuXHQgKiBAcHJvcGVydHkgTUFOSUZFU1Rcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgbWFuaWZlc3Rcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuTUFOSUZFU1QgPSBcIm1hbmlmZXN0XCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIHNvdW5kIGZpbGVzLCB1c3VhbGx5IG1wMywgb2dnLCBvciB3YXYuIFdoZW4gbG9hZGluZyB2aWEgdGFncywgYXVkaW8gaXMgbG9hZGVkIGludG8gYW5cblx0ICogJmx0O2F1ZGlvJmd0OyB0YWcuXG5cdCAqIEBwcm9wZXJ0eSBTT1VORFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBzb3VuZFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5TT1VORCA9IFwic291bmRcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgdmlkZW8gZmlsZXMsIHVzdWFsbHkgbXA0LCB0cywgb3Igb2dnLiBXaGVuIGxvYWRpbmcgdmlhIHRhZ3MsIHZpZGVvIGlzIGxvYWRlZCBpbnRvIGFuXG5cdCAqICZsdDt2aWRlbyZndDsgdGFnLlxuXHQgKiBAcHJvcGVydHkgVklERU9cblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgdmlkZW9cblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuVklERU8gPSBcInZpZGVvXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIFNwcml0ZVNoZWV0IGZpbGVzLiBTcHJpdGVTaGVldCBmaWxlcyBhcmUgSlNPTiBmaWxlcyB0aGF0IGNvbnRhaW4gc3RyaW5nIGltYWdlIHBhdGhzLlxuXHQgKiBAcHJvcGVydHkgU1BSSVRFU0hFRVRcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgc3ByaXRlc2hlZXRcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuU1BSSVRFU0hFRVQgPSBcInNwcml0ZXNoZWV0XCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIFNWRyBmaWxlcy5cblx0ICogQHByb3BlcnR5IFNWR1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBzdmdcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuU1ZHID0gXCJzdmdcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgdGV4dCBmaWxlcywgd2hpY2ggaXMgYWxzbyB0aGUgZGVmYXVsdCBmaWxlIHR5cGUgaWYgdGhlIHR5cGUgY2FuIG5vdCBiZSBkZXRlcm1pbmVkLiBUZXh0IGlzXG5cdCAqIGxvYWRlZCBhcyByYXcgdGV4dC5cblx0ICogQHByb3BlcnR5IFRFWFRcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgdGV4dFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5URVhUID0gXCJ0ZXh0XCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIHhtbCBmaWxlcy4gWE1MIGlzIGxvYWRlZCBpbnRvIGFuIFhNTCBkb2N1bWVudC5cblx0ICogQHByb3BlcnR5IFhNTFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCB4bWxcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuWE1MID0gXCJ4bWxcIjtcblxuLy8gRXZlbnRzXG5cdC8qKlxuXHQgKiBUaGUge3sjY3Jvc3NMaW5rIFwiUHJvZ3Jlc3NFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGZpcmVkIHdoZW4gdGhlIG92ZXJhbGwgcHJvZ3Jlc3MgY2hhbmdlcy4gUHJpb3IgdG9cblx0ICogdmVyc2lvbiAwLjYuMCwgdGhpcyB3YXMganVzdCBhIHJlZ3VsYXIge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBldmVudCBwcm9ncmVzc1xuXHQgKiBAc2luY2UgMC4zLjBcblx0ICovXG5cblx0LyoqXG5cdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGZpcmVkIHdoZW4gYSBsb2FkIHN0YXJ0cy5cblx0ICogQGV2ZW50IGxvYWRzdGFydFxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBzaW5jZSAwLjMuMVxuXHQgKi9cblxuXHQvKipcblx0ICogVGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgd2hlbiB0aGUgZW50aXJlIHF1ZXVlIGhhcyBiZWVuIGxvYWRlZC5cblx0ICogQGV2ZW50IGNvbXBsZXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGUge3sjY3Jvc3NMaW5rIFwiRXJyb3JFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGZpcmVkIHdoZW4gdGhlIGxvYWRlciBlbmNvdW50ZXJzIGFuIGVycm9yLiBJZiB0aGUgZXJyb3Igd2FzXG5cdCAqIGVuY291bnRlcmVkIGJ5IGEgZmlsZSwgdGhlIGV2ZW50IHdpbGwgY29udGFpbiB0aGUgaXRlbSB0aGF0IGNhdXNlZCB0aGUgZXJyb3IuIFByaW9yIHRvIHZlcnNpb24gMC42LjAsIHRoaXMgd2FzXG5cdCAqIGp1c3QgYSByZWd1bGFyIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAZXZlbnQgZXJyb3Jcblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGUge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCB3aGVuIHRoZSBsb2FkZXIgZW5jb3VudGVycyBhbiBpbnRlcm5hbCBmaWxlIGxvYWQgZXJyb3IuXG5cdCAqIFRoaXMgZW5hYmxlcyBsb2FkZXJzIHRvIG1haW50YWluIGludGVybmFsIHF1ZXVlcywgYW5kIHN1cmZhY2UgZmlsZSBsb2FkIGVycm9ycy5cblx0ICogQGV2ZW50IGZpbGVlcnJvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW4gdHlwZSAoXCJmaWxlZXJyb3JcIilcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxvYmplY3R9IFRoZSBpdGVtIHRoYXQgZW5jb3VudGVyZWQgdGhlIGVycm9yXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHQvKipcblx0ICogVGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgd2hlbiBhIGxvYWRlciBpbnRlcm5hbGx5IGxvYWRzIGEgZmlsZS4gVGhpcyBlbmFibGVzXG5cdCAqIGxvYWRlcnMgc3VjaCBhcyB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fSB0byBtYWludGFpbiBpbnRlcm5hbCB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX1zXG5cdCAqIGFuZCBub3RpZnkgd2hlbiB0aGV5IGhhdmUgbG9hZGVkIGEgZmlsZS4gVGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBkaXNwYXRjaGVzIGFcblx0ICogc2xpZ2h0bHkgZGlmZmVyZW50IHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudC5cblx0ICogQGV2ZW50IGZpbGVsb2FkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZSAoXCJmaWxlbG9hZFwiKVxuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBUaGUgZmlsZSBpdGVtIHdoaWNoIHdhcyBzcGVjaWZpZWQgaW4gdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBvciB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319IGNhbGwuIElmIG9ubHkgYSBzdHJpbmcgcGF0aCBvciB0YWcgd2FzIHNwZWNpZmllZCwgdGhlXG5cdCAqIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhhdCB2YWx1ZSBhcyBhIGBzcmNgIHByb3BlcnR5LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0IFRoZSBIVE1MIHRhZyBvciBwYXJzZWQgcmVzdWx0IG9mIHRoZSBsb2FkZWQgaXRlbS5cblx0ICogQHBhcmFtIHtPYmplY3R9IHJhd1Jlc3VsdCBUaGUgdW5wcm9jZXNzZWQgcmVzdWx0LCB1c3VhbGx5IHRoZSByYXcgdGV4dCBvciBiaW5hcnkgZGF0YSBiZWZvcmUgaXQgaXMgY29udmVydGVkXG5cdCAqIHRvIGEgdXNhYmxlIG9iamVjdC5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGUge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCBhZnRlciB0aGUgaW50ZXJuYWwgcmVxdWVzdCBpcyBjcmVhdGVkLCBidXQgYmVmb3JlIGEgbG9hZC5cblx0ICogVGhpcyBhbGxvd3MgdXBkYXRlcyB0byB0aGUgbG9hZGVyIGZvciBzcGVjaWZpYyBsb2FkaW5nIG5lZWRzLCBzdWNoIGFzIGJpbmFyeSBvciBYSFIgaW1hZ2UgbG9hZGluZy5cblx0ICogQGV2ZW50IGluaXRpYWxpemVcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlIChcImluaXRpYWxpemVcIilcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyIFRoZSBsb2FkZXIgdGhhdCBoYXMgYmVlbiBpbml0aWFsaXplZC5cblx0ICovXG5cblxuXHQvKipcblx0ICogR2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBtYW5pZmVzdCBpdGVtIHRoYXQgaXMgbG9hZGVkIGJ5IHRoaXMgbG9hZGVyLiBJbiBzb21lIGNhc2VzIHRoaXMgd2lsbCBiZSB0aGUgdmFsdWUgdGhhdCB3YXNcblx0ICogcGFzc2VkIGludG8ge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319IHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fSBvclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319LiBIb3dldmVyIGlmIG9ubHkgYSBTdHJpbmcgcGF0aCB3YXMgcGFzc2VkIGluLCB0aGVuIGl0IHdpbGxcblx0ICogYmUgYSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBnZXRJdGVtXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIG1hbmlmZXN0IGl0ZW0gdGhhdCB0aGlzIGxvYWRlciBpcyByZXNwb25zaWJsZSBmb3IgbG9hZGluZy5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLmdldEl0ZW0gPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2l0ZW07XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCBhIHJlZmVyZW5jZSB0byB0aGUgY29udGVudCB0aGF0IHdhcyBsb2FkZWQgYnkgdGhlIGxvYWRlciAob25seSBhdmFpbGFibGUgYWZ0ZXIgdGhlIHt7I2Nyb3NzTGluayBcImNvbXBsZXRlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IGlzIGRpc3BhdGNoZWQuXG5cdCAqIEBtZXRob2QgZ2V0UmVzdWx0XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Jhdz1mYWxzZV0gRGV0ZXJtaW5lcyBpZiB0aGUgcmV0dXJuZWQgcmVzdWx0IHdpbGwgYmUgdGhlIGZvcm1hdHRlZCBjb250ZW50LCBvciB0aGUgcmF3IGxvYWRlZFxuXHQgKiBkYXRhIChpZiBpdCBleGlzdHMpLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5nZXRSZXN1bHQgPSBmdW5jdGlvbiAocmF3KSB7XG5cdFx0cmV0dXJuIHJhdyA/IHRoaXMuX3Jhd1Jlc3VsdCA6IHRoaXMuX3Jlc3VsdDtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBgdGFnYCB0aGlzIG9iamVjdCBjcmVhdGVzIG9yIHVzZXMgZm9yIGxvYWRpbmcuXG5cdCAqIEBtZXRob2QgZ2V0VGFnXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIHRhZyBpbnN0YW5jZVxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuZ2V0VGFnID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl90YWc7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgYHRhZ2AgdGhpcyBpdGVtIHVzZXMgZm9yIGxvYWRpbmcuXG5cdCAqIEBtZXRob2Qgc2V0VGFnXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YWcgVGhlIHRhZyBpbnN0YW5jZVxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuc2V0VGFnID0gZnVuY3Rpb24odGFnKSB7XG5cdCAgdGhpcy5fdGFnID0gdGFnO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBCZWdpbiBsb2FkaW5nIHRoZSBpdGVtLiBUaGlzIG1ldGhvZCBpcyByZXF1aXJlZCB3aGVuIHVzaW5nIGEgbG9hZGVyIGJ5IGl0c2VsZi5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBxdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUoKTtcblx0ICogICAgICBxdWV1ZS5vbihcImNvbXBsZXRlXCIsIGhhbmRsZUNvbXBsZXRlKTtcblx0ICogICAgICBxdWV1ZS5sb2FkTWFuaWZlc3QoZmlsZUFycmF5LCBmYWxzZSk7IC8vIE5vdGUgdGhlIDJuZCBhcmd1bWVudCB0aGF0IHRlbGxzIHRoZSBxdWV1ZSBub3QgdG8gc3RhcnQgbG9hZGluZyB5ZXRcblx0ICogICAgICBxdWV1ZS5sb2FkKCk7XG5cdCAqXG5cdCAqIEBtZXRob2QgbG9hZFxuXHQgKi9cblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NyZWF0ZVJlcXVlc3QoKTtcblxuXHRcdHRoaXMuX3JlcXVlc3Qub24oXCJjb21wbGV0ZVwiLCB0aGlzLCB0aGlzKTtcblx0XHR0aGlzLl9yZXF1ZXN0Lm9uKFwicHJvZ3Jlc3NcIiwgdGhpcywgdGhpcyk7XG5cdFx0dGhpcy5fcmVxdWVzdC5vbihcImxvYWRTdGFydFwiLCB0aGlzLCB0aGlzKTtcblx0XHR0aGlzLl9yZXF1ZXN0Lm9uKFwiYWJvcnRcIiwgdGhpcywgdGhpcyk7XG5cdFx0dGhpcy5fcmVxdWVzdC5vbihcInRpbWVvdXRcIiwgdGhpcywgdGhpcyk7XG5cdFx0dGhpcy5fcmVxdWVzdC5vbihcImVycm9yXCIsIHRoaXMsIHRoaXMpO1xuXG5cdFx0dmFyIGV2dCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImluaXRpYWxpemVcIik7XG5cdFx0ZXZ0LmxvYWRlciA9IHRoaXMuX3JlcXVlc3Q7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cblx0XHR0aGlzLl9yZXF1ZXN0LmxvYWQoKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2xvc2UgdGhlIHRoZSBpdGVtLiBUaGlzIHdpbGwgc3RvcCBhbnkgb3BlbiByZXF1ZXN0cyAoYWx0aG91Z2ggZG93bmxvYWRzIHVzaW5nIEhUTUwgdGFncyBtYXkgc3RpbGwgY29udGludWUgaW5cblx0ICogdGhlIGJhY2tncm91bmQpLCBidXQgZXZlbnRzIHdpbGwgbm90IGxvbmdlciBiZSBkaXNwYXRjaGVkLlxuXHQgKiBAbWV0aG9kIGNhbmNlbFxuXHQgKi9cblx0cC5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5jYW5jZWxlZCA9IHRydWU7XG5cdFx0dGhpcy5kZXN0cm95KCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENsZWFuIHVwIHRoZSBsb2FkZXIuXG5cdCAqIEBtZXRob2QgZGVzdHJveVxuXHQgKi9cblx0cC5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QpIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoKTtcblx0XHRcdHRoaXMuX3JlcXVlc3QuZGVzdHJveSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuXG5cdFx0dGhpcy5faXRlbSA9IG51bGw7XG5cdFx0dGhpcy5fcmF3UmVzdWx0ID0gbnVsbDtcblx0XHR0aGlzLl9yZXN1bHQgPSBudWxsO1xuXG5cdFx0dGhpcy5fbG9hZEl0ZW1zID0gbnVsbDtcblxuXHRcdHRoaXMucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoKTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IGFueSBpdGVtcyBsb2FkZWQgaW50ZXJuYWxseSBieSB0aGUgbG9hZGVyLiBUaGUgZW5hYmxlcyBsb2FkZXJzIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogdG8gZXhwb3NlIGl0ZW1zIGl0IGxvYWRzIGludGVybmFsbHkuXG5cdCAqIEBtZXRob2QgZ2V0TG9hZGVkSXRlbXNcblx0ICogQHJldHVybiB7QXJyYXl9IEEgbGlzdCBvZiB0aGUgaXRlbXMgbG9hZGVkIGJ5IHRoZSBsb2FkZXIuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5nZXRMb2FkZWRJdGVtcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbG9hZGVkSXRlbXM7XG5cdH07XG5cblxuXHQvLyBQcml2YXRlIG1ldGhvZHNcblx0LyoqXG5cdCAqIENyZWF0ZSBhbiBpbnRlcm5hbCByZXF1ZXN0IHVzZWQgZm9yIGxvYWRpbmcuIEJ5IGRlZmF1bHQsIGFuIHt7I2Nyb3NzTGluayBcIlhIUlJlcXVlc3RcIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0ICoge3sjY3Jvc3NMaW5rIFwiVGFnUmVxdWVzdFwifX17ey9jcm9zc0xpbmt9fSBpcyBjcmVhdGVkLCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlIG9mIHt7I2Nyb3NzTGluayBcInByZWZlclhIUjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogT3RoZXIgbG9hZGVycyBtYXkgb3ZlcnJpZGUgdGhpcyB0byB1c2UgZGlmZmVyZW50IHJlcXVlc3QgdHlwZXMsIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIHdoaWNoIHVzZXMge3sjY3Jvc3NMaW5rIFwiSlNPTkxvYWRlclwifX17ey9jcm9zc0xpbmt9fSBvciB7eyNjcm9zc0xpbmsgXCJKU09OUExvYWRlclwifX17ey9jcm9zc0xpbmt9fSB1bmRlciB0aGUgaG9vZC5cblx0ICogQG1ldGhvZCBfY3JlYXRlUmVxdWVzdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9wcmVmZXJYSFIpIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuVGFnUmVxdWVzdCh0aGlzLl9pdGVtLCB0aGlzLl90YWcgfHwgdGhpcy5fY3JlYXRlVGFnKCksIHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuWEhSUmVxdWVzdCh0aGlzLl9pdGVtKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSB0aGUgSFRNTCB0YWcgdXNlZCBmb3IgbG9hZGluZy4gVGhpcyBtZXRob2QgZG9lcyBub3RoaW5nIGJ5IGRlZmF1bHQsIGFuZCBuZWVkcyB0byBiZSBpbXBsZW1lbnRlZFxuXHQgKiBieSBsb2FkZXJzIHRoYXQgcmVxdWlyZSB0YWcgbG9hZGluZy5cblx0ICogQG1ldGhvZCBfY3JlYXRlVGFnXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHRhZyBzb3VyY2Vcblx0ICogQHJldHVybiB7SFRNTEVsZW1lbnR9IFRoZSB0YWcgdGhhdCB3YXMgY3JlYXRlZFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9jcmVhdGVUYWcgPSBmdW5jdGlvbihzcmMpIHsgcmV0dXJuIG51bGw7IH07XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoIGEgbG9hZHN0YXJ0IHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LiBQbGVhc2Ugc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9sb2Fkc3RhcnQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgZm9yIGRldGFpbHMgb24gdGhlIGV2ZW50IHBheWxvYWQuXG5cdCAqIEBtZXRob2QgX3NlbmRMb2FkU3RhcnRcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2VuZExvYWRTdGFydCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5faXNDYW5jZWxlZCgpKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcImxvYWRzdGFydFwiKTtcblx0fTtcblxuXHQvKipcblx0ICogRGlzcGF0Y2ggYSB7eyNjcm9zc0xpbmsgXCJQcm9ncmVzc0V2ZW50XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIF9zZW5kUHJvZ3Jlc3Ncblx0ICogQHBhcmFtIHtOdW1iZXIgfCBPYmplY3R9IHZhbHVlIFRoZSBwcm9ncmVzcyBvZiB0aGUgbG9hZGVkIGl0ZW0sIG9yIGFuIG9iamVjdCBjb250YWluaW5nIDxjb2RlPmxvYWRlZDwvY29kZT5cblx0ICogYW5kIDxjb2RlPnRvdGFsPC9jb2RlPiBwcm9wZXJ0aWVzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9zZW5kUHJvZ3Jlc3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRpZiAodGhpcy5faXNDYW5jZWxlZCgpKSB7IHJldHVybjsgfVxuXHRcdHZhciBldmVudCA9IG51bGw7XG5cdFx0aWYgKHR5cGVvZih2YWx1ZSkgPT0gXCJudW1iZXJcIikge1xuXHRcdFx0dGhpcy5wcm9ncmVzcyA9IHZhbHVlO1xuXHRcdFx0ZXZlbnQgPSBuZXcgY3JlYXRlanMuUHJvZ3Jlc3NFdmVudCh0aGlzLnByb2dyZXNzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXZlbnQgPSB2YWx1ZTtcblx0XHRcdHRoaXMucHJvZ3Jlc3MgPSB2YWx1ZS5sb2FkZWQgLyB2YWx1ZS50b3RhbDtcblx0XHRcdGV2ZW50LnByb2dyZXNzID0gdGhpcy5wcm9ncmVzcztcblx0XHRcdGlmIChpc05hTih0aGlzLnByb2dyZXNzKSB8fCB0aGlzLnByb2dyZXNzID09IEluZmluaXR5KSB7IHRoaXMucHJvZ3Jlc3MgPSAwOyB9XG5cdFx0fVxuXHRcdHRoaXMuaGFzRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIpICYmIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoIGEgY29tcGxldGUge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uIFBsZWFzZSBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2NvbXBsZXRlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50XG5cdCAqIEBtZXRob2QgX3NlbmRDb21wbGV0ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9zZW5kQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2lzQ2FuY2VsZWQoKSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMubG9hZGVkID0gdHJ1ZTtcblxuXHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImNvbXBsZXRlXCIpO1xuXHRcdGV2ZW50LnJhd1Jlc3VsdCA9IHRoaXMuX3Jhd1Jlc3VsdDtcblxuXHRcdGlmICh0aGlzLl9yZXN1bHQgIT0gbnVsbCkge1xuXHRcdFx0ZXZlbnQucmVzdWx0ID0gdGhpcy5fcmVzdWx0O1xuXHRcdH1cblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoIGFuIGVycm9yIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LiBQbGVhc2Ugc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9lcnJvcjpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBmb3IgZGV0YWlscyBvbiB0aGUgZXZlbnQgcGF5bG9hZC5cblx0ICogQG1ldGhvZCBfc2VuZEVycm9yXG5cdCAqIEBwYXJhbSB7RXJyb3JFdmVudH0gZXZlbnQgVGhlIGV2ZW50IG9iamVjdCBjb250YWluaW5nIHNwZWNpZmljIGVycm9yIHByb3BlcnRpZXMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3NlbmRFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGlmICh0aGlzLl9pc0NhbmNlbGVkKCkgfHwgIXRoaXMuaGFzRXZlbnRMaXN0ZW5lcihcImVycm9yXCIpKSB7IHJldHVybjsgfVxuXHRcdGlmIChldmVudCA9PSBudWxsKSB7XG5cdFx0XHRldmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9FUlJPUl9FTVBUWVwiKTsgLy8gVE9ETzogUG9wdWxhdGUgZXJyb3Jcblx0XHR9XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIHRoZSBsb2FkIGhhcyBiZWVuIGNhbmNlbGVkLiBUaGlzIGlzIGltcG9ydGFudCB0byBlbnN1cmUgdGhhdCBtZXRob2QgY2FsbHMgb3IgYXN5bmNocm9ub3VzIGV2ZW50c1xuXHQgKiBkbyBub3QgY2F1c2UgaXNzdWVzIGFmdGVyIHRoZSBxdWV1ZSBoYXMgYmVlbiBjbGVhbmVkIHVwLlxuXHQgKiBAbWV0aG9kIF9pc0NhbmNlbGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBsb2FkZXIgaGFzIGJlZW4gY2FuY2VsZWQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2lzQ2FuY2VsZWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHdpbmRvdy5jcmVhdGVqcyA9PSBudWxsIHx8IHRoaXMuY2FuY2VsZWQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIEEgY3VzdG9tIHJlc3VsdCBmb3JtYXR0ZXIgZnVuY3Rpb24sIHdoaWNoIGlzIGNhbGxlZCBqdXN0IGJlZm9yZSBhIHJlcXVlc3QgZGlzcGF0Y2hlcyBpdHMgY29tcGxldGUgZXZlbnQuIE1vc3Rcblx0ICogbG9hZGVyIHR5cGVzIGFscmVhZHkgaGF2ZSBhbiBpbnRlcm5hbCBmb3JtYXR0ZXIsIGJ1dCB0aGlzIGNhbiBiZSB1c2VyLW92ZXJyaWRkZW4gZm9yIGN1c3RvbSBmb3JtYXR0aW5nLiBUaGVcblx0ICogZm9ybWF0dGVkIHJlc3VsdCB3aWxsIGJlIGF2YWlsYWJsZSBvbiBMb2FkZXJzIHVzaW5nIHt7I2Nyb3NzTGluayBcImdldFJlc3VsdFwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHBhc3NpbmcgYHRydWVgLlxuXHQgKiBAcHJvcGVydHkgcmVzdWx0Rm9ybWF0dGVyXG5cdCAqIEB0eXBlIEZ1bmN0aW9uXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGZvcm1hdHRlZCByZXN1bHRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLnJlc3VsdEZvcm1hdHRlciA9IG51bGw7XG5cblx0LyoqXG5cdCAqIEhhbmRsZSBldmVudHMgZnJvbSBpbnRlcm5hbCByZXF1ZXN0cy4gQnkgZGVmYXVsdCwgbG9hZGVycyB3aWxsIGhhbmRsZSwgYW5kIHJlZGlzcGF0Y2ggdGhlIG5lY2Vzc2FyeSBldmVudHMsIGJ1dFxuXHQgKiB0aGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiBmb3IgY3VzdG9tIGJlaGF2aW91cnMuXG5cdCAqIEBtZXRob2QgaGFuZGxlRXZlbnRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRoYXQgdGhlIGludGVybmFsIHJlcXVlc3QgZGlzcGF0Y2hlcy5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcblx0XHRcdGNhc2UgXCJjb21wbGV0ZVwiOlxuXHRcdFx0XHR0aGlzLl9yYXdSZXN1bHQgPSBldmVudC50YXJnZXQuX3Jlc3BvbnNlO1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHRGb3JtYXR0ZXIgJiYgdGhpcy5yZXN1bHRGb3JtYXR0ZXIodGhpcyk7XG5cdFx0XHRcdGlmIChyZXN1bHQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0XHRcdHJlc3VsdC5jYWxsKHRoaXMsXG5cdFx0XHRcdFx0XHRcdGNyZWF0ZWpzLnByb3h5KHRoaXMuX3Jlc3VsdEZvcm1hdFN1Y2Nlc3MsIHRoaXMpLFxuXHRcdFx0XHRcdFx0XHRjcmVhdGVqcy5wcm94eSh0aGlzLl9yZXN1bHRGb3JtYXRGYWlsZWQsIHRoaXMpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9yZXN1bHQgPSAgcmVzdWx0IHx8IHRoaXMuX3Jhd1Jlc3VsdDtcblx0XHRcdFx0XHR0aGlzLl9zZW5kQ29tcGxldGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJwcm9ncmVzc1wiOlxuXHRcdFx0XHR0aGlzLl9zZW5kUHJvZ3Jlc3MoZXZlbnQpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJlcnJvclwiOlxuXHRcdFx0XHR0aGlzLl9zZW5kRXJyb3IoZXZlbnQpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJsb2Fkc3RhcnRcIjpcblx0XHRcdFx0dGhpcy5fc2VuZExvYWRTdGFydCgpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJhYm9ydFwiOlxuXHRcdFx0Y2FzZSBcInRpbWVvdXRcIjpcblx0XHRcdFx0aWYgKCF0aGlzLl9pc0NhbmNlbGVkKCkpIHtcblx0XHRcdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJQUkVMT0FEX1wiICsgZXZlbnQudHlwZS50b1VwcGVyQ2FzZSgpICsgXCJfRVJST1JcIikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVGhlIFwic3VjY2Vzc1wiIGNhbGxiYWNrIHBhc3NlZCB0byB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9yZXN1bHRGb3JtYXR0ZXJcIn19e3svY3Jvc3NMaW5rfX0gYXN5bmNocm9ub3VzXG5cdCAqIGZ1bmN0aW9ucy5cblx0ICogQG1ldGhvZCBfcmVzdWx0Rm9ybWF0U3VjY2Vzc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0IFRoZSBmb3JtYXR0ZWQgcmVzdWx0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9yZXN1bHRGb3JtYXRTdWNjZXNzID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuXHRcdHRoaXMuX3Jlc3VsdCA9IHJlc3VsdDtcblx0XHR0aGlzLl9zZW5kQ29tcGxldGUoKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIFwiZXJyb3JcIiBjYWxsYmFjayBwYXNzZWQgdG8ge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvcmVzdWx0Rm9ybWF0dGVyXCJ9fXt7L2Nyb3NzTGlua319IGFzeW5jaHJvbm91c1xuXHQgKiBmdW5jdGlvbnMuXG5cdCAqIEBtZXRob2QgX3Jlc3VsdEZvcm1hdFN1Y2Nlc3Ncblx0ICogQHBhcmFtIHtPYmplY3R9IGVycm9yIFRoZSBlcnJvciBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fcmVzdWx0Rm9ybWF0RmFpbGVkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dGhpcy5fc2VuZEVycm9yKGV2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBidWlsZFBhdGhcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlJlcXVlc3RVdGlsc1wifX17ey9jcm9zc0xpbmt9fSBtZXRob2Qge3sjY3Jvc3NMaW5rIFwiUmVxdWVzdFV0aWxzL2J1aWxkUGF0aFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBpbnN0ZWFkLlxuXHQgKi9cblx0cC5idWlsZFBhdGggPSBmdW5jdGlvbiAoc3JjLCBkYXRhKSB7XG5cdFx0cmV0dXJuIGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5idWlsZFBhdGgoc3JjLCBkYXRhKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFwiW1ByZWxvYWRKUyBBYnN0cmFjdExvYWRlcl1cIjtcblx0fTtcblxuXHRjcmVhdGVqcy5BYnN0cmFjdExvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoQWJzdHJhY3RMb2FkZXIsIFwiRXZlbnREaXNwYXRjaGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQWJzdHJhY3RNZWRpYUxvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIFRoZSBBYnN0cmFjdE1lZGlhTG9hZGVyIGlzIGEgYmFzZSBjbGFzcyB0aGF0IGhhbmRsZXMgc29tZSBvZiB0aGUgc2hhcmVkIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgb2YgbG9hZGVycyB0aGF0XG5cdCAqIGhhbmRsZSBIVE1MIG1lZGlhIGVsZW1lbnRzLCBzdWNoIGFzIFZpZGVvIGFuZCBBdWRpby5cblx0ICogQGNsYXNzIEFic3RyYWN0TWVkaWFMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZmVyWEhSXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIG1lZGlhIHRvIGxvYWQuIFVzdWFsbHkgXCJ2aWRlb1wiIG9yIFwiYXVkaW9cIi5cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBBYnN0cmFjdE1lZGlhTG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIsIHR5cGUpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIHR5cGUpO1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHR0aGlzLnJlc3VsdEZvcm1hdHRlciA9IHRoaXMuX2Zvcm1hdFJlc3VsdDtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5fdGFnU3JjQXR0cmlidXRlID0gXCJzcmNcIjtcblxuICAgICAgICB0aGlzLm9uKFwiaW5pdGlhbGl6ZVwiLCB0aGlzLl91cGRhdGVYSFIsIHRoaXMpO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEFic3RyYWN0TWVkaWFMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblxuXHQvLyBzdGF0aWMgcHJvcGVydGllc1xuXHQvLyBwdWJsaWMgbWV0aG9kc1xuXHRwLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVGFnUmVxdWVzdCB3aWxsIGhhbmRsZSBtb3N0IG9mIHRoaXMsIGJ1dCBTb3VuZCAvIFZpZGVvIG5lZWQgYSBmZXcgY3VzdG9tIHByb3BlcnRpZXMsIHNvIGp1c3QgaGFuZGxlIHRoZW0gaGVyZS5cblx0XHRpZiAoIXRoaXMuX3RhZykge1xuXHRcdFx0dGhpcy5fdGFnID0gdGhpcy5fY3JlYXRlVGFnKHRoaXMuX2l0ZW0uc3JjKTtcblx0XHR9XG5cblx0XHR0aGlzLl90YWcucHJlbG9hZCA9IFwiYXV0b1wiO1xuXHRcdHRoaXMuX3RhZy5sb2FkKCk7XG5cblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2xvYWQoKTtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyB0YWcgZm9yIGxvYWRpbmcgaWYgaXQgZG9lc24ndCBleGlzdCB5ZXQuXG5cdCAqIEBtZXRob2QgX2NyZWF0ZVRhZ1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY3JlYXRlVGFnID0gZnVuY3Rpb24gKCkge307XG5cblxuXHRwLl9jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9wcmVmZXJYSFIpIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuTWVkaWFUYWdSZXF1ZXN0KHRoaXMuX2l0ZW0sIHRoaXMuX3RhZyB8fCB0aGlzLl9jcmVhdGVUYWcoKSwgdGhpcy5fdGFnU3JjQXR0cmlidXRlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5YSFJSZXF1ZXN0KHRoaXMuX2l0ZW0pO1xuXHRcdH1cblx0fTtcblxuICAgIC8vIHByb3RlY3RlZCBtZXRob2RzXG4gICAgLyoqXG4gICAgICogQmVmb3JlIHRoZSBpdGVtIGxvYWRzLCBzZXQgaXRzIG1pbWVUeXBlIGFuZCByZXNwb25zZVR5cGUuXG4gICAgICogQHByb3BlcnR5IF91cGRhdGVYSFJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcC5fdXBkYXRlWEhSID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIE9ubHkgZXhpc3RzIGZvciBYSFJcbiAgICAgICAgaWYgKGV2ZW50LmxvYWRlci5zZXRSZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgIGV2ZW50LmxvYWRlci5zZXRSZXNwb25zZVR5cGUoXCJibG9iXCIpO1xuICAgICAgICB9XG4gICAgfTtcblxuXHQvKipcblx0ICogVGhlIHJlc3VsdCBmb3JtYXR0ZXIgZm9yIG1lZGlhIGZpbGVzLlxuXHQgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEByZXR1cm5zIHtIVE1MVmlkZW9FbGVtZW50fEhUTUxBdWRpb0VsZW1lbnR9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9mb3JtYXRSZXN1bHQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0dGhpcy5fdGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIgJiYgdGhpcy5fdGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5dGhyb3VnaFwiLCB0aGlzLl9sb2FkZWRIYW5kbGVyKTtcblx0XHR0aGlzLl90YWcub25zdGFsbGVkID0gbnVsbDtcblx0XHRpZiAodGhpcy5fcHJlZmVyWEhSKSB7XG4gICAgICAgICAgICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGxvYWRlci5nZXRSZXN1bHQodHJ1ZSk7XG5cblx0XHRcdGxvYWRlci5nZXRUYWcoKS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHJlc3VsdCk7XG5cdFx0fVxuXHRcdHJldHVybiBsb2FkZXIuZ2V0VGFnKCk7XG5cdH07XG5cblx0Y3JlYXRlanMuQWJzdHJhY3RNZWRpYUxvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoQWJzdHJhY3RNZWRpYUxvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEFic3RyYWN0UmVxdWVzdC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIEEgYmFzZSBjbGFzcyBmb3IgYWN0dWFsIGRhdGEgcmVxdWVzdHMsIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiWEhSUmVxdWVzdFwifX17ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiVGFnUmVxdWVzdFwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogYW5kIHt7I2Nyb3NzTGluayBcIk1lZGlhUmVxdWVzdFwifX17ey9jcm9zc0xpbmt9fS4gUHJlbG9hZEpTIGxvYWRlcnMgd2lsbCB0eXBpY2FsbHkgdXNlIGEgZGF0YSBsb2FkZXIgdW5kZXIgdGhlXG5cdCAqIGhvb2QgdG8gZ2V0IGRhdGEuXG5cdCAqIEBjbGFzcyBBYnN0cmFjdFJlcXVlc3Rcblx0ICogQHBhcmFtIHtMb2FkSXRlbX0gaXRlbVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdHZhciBBYnN0cmFjdFJlcXVlc3QgPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHRoaXMuX2l0ZW0gPSBpdGVtO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEFic3RyYWN0UmVxdWVzdCwgY3JlYXRlanMuRXZlbnREaXNwYXRjaGVyKTtcblxuXHQvLyBwdWJsaWMgbWV0aG9kc1xuXHQvKipcblx0ICogQmVnaW4gYSBsb2FkLlxuXHQgKiBAbWV0aG9kIGxvYWRcblx0ICovXG5cdHAubG9hZCA9ICBmdW5jdGlvbigpIHt9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiB1cCBhIHJlcXVlc3QuXG5cdCAqIEBtZXRob2QgZGVzdHJveVxuXHQgKi9cblx0cC5kZXN0cm95ID0gZnVuY3Rpb24oKSB7fTtcblxuXHQvKipcblx0ICogQ2FuY2VsIGFuIGluLXByb2dyZXNzIHJlcXVlc3QuXG5cdCAqIEBtZXRob2QgY2FuY2VsXG5cdCAqL1xuXHRwLmNhbmNlbCA9IGZ1bmN0aW9uKCkge307XG5cblx0Y3JlYXRlanMuQWJzdHJhY3RSZXF1ZXN0ID0gY3JlYXRlanMucHJvbW90ZShBYnN0cmFjdFJlcXVlc3QsIFwiRXZlbnREaXNwYXRjaGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVGFnUmVxdWVzdC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEFuIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0UmVxdWVzdFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGxvYWRzIEhUTUwgdGFncywgc3VjaCBhcyBpbWFnZXMgYW5kIHNjcmlwdHMuXG5cdCAqIEBjbGFzcyBUYWdSZXF1ZXN0XG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW19IGxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhZ1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjQXR0cmlidXRlIFRoZSB0YWcgYXR0cmlidXRlIHRoYXQgc3BlY2lmaWVzIHRoZSBzb3VyY2UsIHN1Y2ggYXMgXCJzcmNcIiwgXCJocmVmXCIsIGV0Yy5cblx0ICovXG5cdGZ1bmN0aW9uIFRhZ1JlcXVlc3QobG9hZEl0ZW0sIHRhZywgc3JjQXR0cmlidXRlKSB7XG5cdFx0dGhpcy5BYnN0cmFjdFJlcXVlc3RfY29uc3RydWN0b3IobG9hZEl0ZW0pO1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBUaGUgSFRNTCB0YWcgaW5zdGFuY2UgdGhhdCBpcyB1c2VkIHRvIGxvYWQuXG5cdFx0ICogQHByb3BlcnR5IF90YWdcblx0XHQgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3RhZyA9IHRhZztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0YWcgYXR0cmlidXRlIHRoYXQgc3BlY2lmaWVzIHRoZSBzb3VyY2UsIHN1Y2ggYXMgXCJzcmNcIiwgXCJocmVmXCIsIGV0Yy5cblx0XHQgKiBAcHJvcGVydHkgX3RhZ1NyY0F0dHJpYnV0ZVxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSA9IHNyY0F0dHJpYnV0ZTtcblxuXHRcdC8qKlxuXHRcdCAqIEEgbWV0aG9kIGNsb3N1cmUgdXNlZCBmb3IgaGFuZGxpbmcgdGhlIHRhZyBsb2FkIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZGVkSGFuZGxlclxuXHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRlZEhhbmRsZXIgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUYWdDb21wbGV0ZSwgdGhpcyk7XG5cblx0XHQvKipcblx0XHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBlbGVtZW50IHdhcyBhZGRlZCB0byB0aGUgRE9NIGF1dG9tYXRpY2FsbHkgYnkgUHJlbG9hZEpTLCBzbyBpdCBjYW4gYmUgY2xlYW5lZCB1cCBhZnRlci5cblx0XHQgKiBAcHJvcGVydHkgX2FkZGVkVG9ET01cblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2FkZGVkVG9ET00gPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZXMgd2hhdCB0aGUgdGFncyBpbml0aWFsIHN0eWxlLnZpc2liaWxpdHkgd2FzLCBzbyB3ZSBjYW4gc2V0IGl0IGNvcnJlY3RseSBhZnRlciBhIGxvYWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVsbH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3N0YXJ0VGFnVmlzaWJpbGl0eSA9IG51bGw7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoVGFnUmVxdWVzdCwgY3JlYXRlanMuQWJzdHJhY3RSZXF1ZXN0KTtcblxuXHQvLyBwdWJsaWMgbWV0aG9kc1xuXHRwLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdGFnLm9ubG9hZCA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVRhZ0NvbXBsZXRlLCB0aGlzKTtcblx0XHR0aGlzLl90YWcub25yZWFkeXN0YXRlY2hhbmdlID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZSwgdGhpcyk7XG5cdFx0dGhpcy5fdGFnLm9uZXJyb3IgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVFcnJvciwgdGhpcyk7XG5cblx0XHR2YXIgZXZ0ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiaW5pdGlhbGl6ZVwiKTtcblx0XHRldnQubG9hZGVyID0gdGhpcy5fdGFnO1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cblx0XHR0aGlzLl9oaWRlVGFnKCk7XG5cblx0XHR0aGlzLl9sb2FkVGltZW91dCA9IHNldFRpbWVvdXQoY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlVGltZW91dCwgdGhpcyksIHRoaXMuX2l0ZW0ubG9hZFRpbWVvdXQpO1xuXG5cdFx0dGhpcy5fdGFnW3RoaXMuX3RhZ1NyY0F0dHJpYnV0ZV0gPSB0aGlzLl9pdGVtLnNyYztcblxuXHRcdC8vIHdkZzo6IEFwcGVuZCB0aGUgdGFnIEFGVEVSIHNldHRpbmcgdGhlIHNyYywgb3IgU1ZHIGxvYWRpbmcgb24gaU9TIHdpbGwgZmFpbC5cblx0XHRpZiAodGhpcy5fdGFnLnBhcmVudE5vZGUgPT0gbnVsbCkge1xuXHRcdFx0d2luZG93LmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fdGFnKTtcblx0XHRcdHRoaXMuX2FkZGVkVG9ET00gPSB0cnVlO1xuXHRcdH1cblx0fTtcblxuXHRwLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9jbGVhbigpO1xuXHRcdHRoaXMuX3RhZyA9IG51bGw7XG5cblx0XHR0aGlzLkFic3RyYWN0UmVxdWVzdF9kZXN0cm95KCk7XG5cdH07XG5cblx0Ly8gcHJpdmF0ZSBtZXRob2RzXG5cdC8qKlxuXHQgKiBIYW5kbGUgdGhlIHJlYWR5U3RhdGVDaGFuZ2UgZXZlbnQgZnJvbSBhIHRhZy4gV2UgbmVlZCB0aGlzIGluIHBsYWNlIG9mIHRoZSBgb25sb2FkYCBjYWxsYmFjayAobWFpbmx5IFNDUklQVFxuXHQgKiBhbmQgTElOSyB0YWdzKSwgYnV0IG90aGVyIGNhc2VzIG1heSBleGlzdC5cblx0ICogQG1ldGhvZCBfaGFuZGxlUmVhZHlTdGF0ZUNoYW5nZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fbG9hZFRpbWVvdXQpO1xuXHRcdC8vIFRoaXMgaXMgc3RyaWN0bHkgZm9yIHRhZ3MgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBvbmxvYWQuXG5cdFx0dmFyIHRhZyA9IHRoaXMuX3RhZztcblxuXHRcdC8vIENvbXBsZXRlIGlzIGZvciBvbGQgSUUgc3VwcG9ydC5cblx0XHRpZiAodGFnLnJlYWR5U3RhdGUgPT0gXCJsb2FkZWRcIiB8fCB0YWcucmVhZHlTdGF0ZSA9PSBcImNvbXBsZXRlXCIpIHtcblx0XHRcdHRoaXMuX2hhbmRsZVRhZ0NvbXBsZXRlKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBIYW5kbGUgYW55IGVycm9yIGV2ZW50cyBmcm9tIHRoZSB0YWcuXG5cdCAqIEBtZXRob2QgX2hhbmRsZUVycm9yXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2hhbmRsZUVycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fY2xlYW4oKTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJlcnJvclwiKTtcblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlIHRoZSB0YWcncyBvbmxvYWQgY2FsbGJhY2suXG5cdCAqIEBtZXRob2QgX2hhbmRsZVRhZ0NvbXBsZXRlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVUYWdDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yYXdSZXN1bHQgPSB0aGlzLl90YWc7XG5cdFx0dGhpcy5fcmVzdWx0ID0gdGhpcy5yZXN1bHRGb3JtYXR0ZXIgJiYgdGhpcy5yZXN1bHRGb3JtYXR0ZXIodGhpcykgfHwgdGhpcy5fcmF3UmVzdWx0O1xuXG5cdFx0dGhpcy5fY2xlYW4oKTtcblx0XHR0aGlzLl9zaG93VGFnKCk7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIHRhZyByZXF1ZXN0IGhhcyBub3QgbG9hZGVkIHdpdGhpbiB0aGUgdGltZSBzcGVjaWZpZWQgaW4gbG9hZFRpbWVvdXQuXG5cdCAqIEBtZXRob2QgX2hhbmRsZUVycm9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGVycm9yIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jbGVhbigpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXZlbnQoXCJ0aW1lb3V0XCIpKTtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycywgYnV0IGRvbid0IGRlc3Ryb3kgdGhlIHJlcXVlc3Qgb2JqZWN0XG5cdCAqIEBtZXRob2QgX2NsZWFuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jbGVhbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3RhZy5vbmxvYWQgPSBudWxsO1xuXHRcdHRoaXMuX3RhZy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXHRcdHRoaXMuX3RhZy5vbmVycm9yID0gbnVsbDtcblx0XHRpZiAodGhpcy5fYWRkZWRUb0RPTSAmJiB0aGlzLl90YWcucGFyZW50Tm9kZSAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLl90YWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl90YWcpO1xuXHRcdH1cblx0XHRjbGVhclRpbWVvdXQodGhpcy5fbG9hZFRpbWVvdXQpO1xuXHR9O1xuXG5cdHAuX2hpZGVUYWcgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9zdGFydFRhZ1Zpc2liaWxpdHkgPSB0aGlzLl90YWcuc3R5bGUudmlzaWJpbGl0eTtcblx0XHR0aGlzLl90YWcuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG5cdH07XG5cblx0cC5fc2hvd1RhZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3RhZy5zdHlsZS52aXNpYmlsaXR5ID0gdGhpcy5fc3RhcnRUYWdWaXNpYmlsaXR5O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBIYW5kbGUgYSBzdGFsbGVkIGF1ZGlvIGV2ZW50LiBUaGUgbWFpbiBwbGFjZSB0aGlzIGhhcHBlbnMgaXMgd2l0aCBIVE1MQXVkaW8gaW4gQ2hyb21lIHdoZW4gcGxheWluZyBiYWNrIGF1ZGlvXG5cdCAqIHRoYXQgaXMgYWxyZWFkeSBpbiBhIGxvYWQsIGJ1dCBub3QgY29tcGxldGUuXG5cdCAqIEBtZXRob2QgX2hhbmRsZVN0YWxsZWRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVN0YWxsZWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly9JZ25vcmUsIGxldCB0aGUgdGltZW91dCB0YWtlIGNhcmUgb2YgaXQuIFNvbWV0aW1lcyBpdHMgbm90IHJlYWxseSBzdG9wcGVkLlxuXHR9O1xuXG5cdGNyZWF0ZWpzLlRhZ1JlcXVlc3QgPSBjcmVhdGVqcy5wcm9tb3RlKFRhZ1JlcXVlc3QsIFwiQWJzdHJhY3RSZXF1ZXN0XCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gTWVkaWFUYWdSZXF1ZXN0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQW4ge3sjY3Jvc3NMaW5rIFwiVGFnUmVxdWVzdFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGxvYWRzIEhUTUwgdGFncyBmb3IgdmlkZW8gYW5kIGF1ZGlvLlxuXHQgKiBAY2xhc3MgTWVkaWFUYWdSZXF1ZXN0XG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW19IGxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7SFRNTEF1ZGlvRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSB0YWdcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyY0F0dHJpYnV0ZSBUaGUgdGFnIGF0dHJpYnV0ZSB0aGF0IHNwZWNpZmllcyB0aGUgc291cmNlLCBzdWNoIGFzIFwic3JjXCIsIFwiaHJlZlwiLCBldGMuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gTWVkaWFUYWdSZXF1ZXN0KGxvYWRJdGVtLCB0YWcsIHNyY0F0dHJpYnV0ZSkge1xuXHRcdHRoaXMuQWJzdHJhY3RSZXF1ZXN0X2NvbnN0cnVjdG9yKGxvYWRJdGVtKTtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5fdGFnID0gdGFnO1xuXHRcdHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSA9IHNyY0F0dHJpYnV0ZTtcblx0XHR0aGlzLl9sb2FkZWRIYW5kbGVyID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlVGFnQ29tcGxldGUsIHRoaXMpO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKE1lZGlhVGFnUmVxdWVzdCwgY3JlYXRlanMuVGFnUmVxdWVzdCk7XG5cdHZhciBzID0gTWVkaWFUYWdSZXF1ZXN0O1xuXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2MgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVTdGFsbGVkLCB0aGlzKTtcblx0XHR0aGlzLl9zdGFsbGVkQ2FsbGJhY2sgPSBzYztcblxuXHRcdHZhciBwYyA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVByb2dyZXNzLCB0aGlzKTtcblx0XHR0aGlzLl9oYW5kbGVQcm9ncmVzcyA9IHBjO1xuXG5cdFx0dGhpcy5fdGFnLmFkZEV2ZW50TGlzdGVuZXIoXCJzdGFsbGVkXCIsIHNjKTtcblx0XHR0aGlzLl90YWcuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIHBjKTtcblxuXHRcdC8vIFRoaXMgd2lsbCB0ZWxsIHVzIHdoZW4gYXVkaW8gaXMgYnVmZmVyZWQgZW5vdWdoIHRvIHBsYXkgdGhyb3VnaCwgYnV0IG5vdCB3aGVuIGl0cyBsb2FkZWQuXG5cdFx0Ly8gVGhlIHRhZyBkb2Vzbid0IGtlZXAgbG9hZGluZyBpbiBDaHJvbWUgb25jZSBlbm91Z2ggaGFzIGJ1ZmZlcmVkLCBhbmQgd2UgaGF2ZSBkZWNpZGVkIHRoYXQgYmVoYXZpb3VyIGlzIHN1ZmZpY2llbnQuXG5cdFx0dGhpcy5fdGFnLmFkZEV2ZW50TGlzdGVuZXIgJiYgdGhpcy5fdGFnLmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5dGhyb3VnaFwiLCB0aGlzLl9sb2FkZWRIYW5kbGVyLCBmYWxzZSk7IC8vIGNhbnBsYXl0aHJvdWdoIGNhbGxiYWNrIGRvZXNuJ3Qgd29yayBpbiBDaHJvbWUsIHNvIHdlIHVzZSBhbiBldmVudC5cblxuXHRcdHRoaXMuVGFnUmVxdWVzdF9sb2FkKCk7XG5cdH07XG5cblx0Ly8gcHJpdmF0ZSBtZXRob2RzXG5cdHAuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2xvYWRUaW1lb3V0KTtcblx0XHQvLyBUaGlzIGlzIHN0cmljdGx5IGZvciB0YWdzIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgb25sb2FkLlxuXHRcdHZhciB0YWcgPSB0aGlzLl90YWc7XG5cblx0XHQvLyBDb21wbGV0ZSBpcyBmb3Igb2xkIElFIHN1cHBvcnQuXG5cdFx0aWYgKHRhZy5yZWFkeVN0YXRlID09IFwibG9hZGVkXCIgfHwgdGFnLnJlYWR5U3RhdGUgPT0gXCJjb21wbGV0ZVwiKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVUYWdDb21wbGV0ZSgpO1xuXHRcdH1cblx0fTtcblxuXHRwLl9oYW5kbGVTdGFsbGVkID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vSWdub3JlLCBsZXQgdGhlIHRpbWVvdXQgdGFrZSBjYXJlIG9mIGl0LiBTb21ldGltZXMgaXRzIG5vdCByZWFsbHkgc3RvcHBlZC5cblx0fTtcblxuXHQvKipcblx0ICogQW4gWEhSIHJlcXVlc3QgaGFzIHJlcG9ydGVkIHByb2dyZXNzLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVQcm9ncmVzc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIFhIUiBwcm9ncmVzcyBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVByb2dyZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYgKCFldmVudCB8fCBldmVudC5sb2FkZWQgPiAwICYmIGV2ZW50LnRvdGFsID09IDApIHtcblx0XHRcdHJldHVybjsgLy8gU29tZXRpbWVzIHdlIGdldCBubyBcInRvdGFsXCIsIHNvIGp1c3QgaWdub3JlIHRoZSBwcm9ncmVzcyBldmVudC5cblx0XHR9XG5cblx0XHR2YXIgbmV3RXZlbnQgPSBuZXcgY3JlYXRlanMuUHJvZ3Jlc3NFdmVudChldmVudC5sb2FkZWQsIGV2ZW50LnRvdGFsKTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXHR9O1xuXG5cdC8vIHByb3RlY3RlZCBtZXRob2RzXG5cdHAuX2NsZWFuID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3RhZy5yZW1vdmVFdmVudExpc3RlbmVyICYmIHRoaXMuX3RhZy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2FucGxheXRocm91Z2hcIiwgdGhpcy5fbG9hZGVkSGFuZGxlcik7XG5cdFx0dGhpcy5fdGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzdGFsbGVkXCIsIHRoaXMuX3N0YWxsZWRDYWxsYmFjayk7XG5cdFx0dGhpcy5fdGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCB0aGlzLl9wcm9ncmVzc0NhbGxiYWNrKTtcblxuXHRcdHRoaXMuVGFnUmVxdWVzdF9fY2xlYW4oKTtcblx0fTtcblxuXHRjcmVhdGVqcy5NZWRpYVRhZ1JlcXVlc3QgPSBjcmVhdGVqcy5wcm9tb3RlKE1lZGlhVGFnUmVxdWVzdCwgXCJUYWdSZXF1ZXN0XCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gWEhSUmVxdWVzdC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIHByZWxvYWRlciB0aGF0IGxvYWRzIGl0ZW1zIHVzaW5nIFhIUiByZXF1ZXN0cywgdXN1YWxseSBYTUxIdHRwUmVxdWVzdC4gSG93ZXZlciBYRG9tYWluUmVxdWVzdHMgd2lsbCBiZSB1c2VkXG5cdCAqIGZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMgaWYgcG9zc2libGUsIGFuZCBvbGRlciB2ZXJzaW9ucyBvZiBJRSBmYWxsIGJhY2sgb24gdG8gQWN0aXZlWCBvYmplY3RzIHdoZW4gbmVjZXNzYXJ5LlxuXHQgKiBYSFIgcmVxdWVzdHMgbG9hZCB0aGUgY29udGVudCBhcyB0ZXh0IG9yIGJpbmFyeSBkYXRhLCBwcm92aWRlIHByb2dyZXNzIGFuZCBjb25zaXN0ZW50IGNvbXBsZXRpb24gZXZlbnRzLCBhbmRcblx0ICogY2FuIGJlIGNhbmNlbGVkIGR1cmluZyBsb2FkLiBOb3RlIHRoYXQgWEhSIGlzIG5vdCBzdXBwb3J0ZWQgaW4gSUUgNiBvciBlYXJsaWVyLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvclxuXHQgKiBjcm9zcy1kb21haW4gbG9hZGluZy5cblx0ICogQGNsYXNzIFhIUlJlcXVlc3Rcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIFRoZSBvYmplY3QgdGhhdCBkZWZpbmVzIHRoZSBmaWxlIHRvIGxvYWQuIFBsZWFzZSBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgYW4gb3ZlcnZpZXcgb2Ygc3VwcG9ydGVkIGZpbGUgcHJvcGVydGllcy5cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICovXG5cdGZ1bmN0aW9uIFhIUlJlcXVlc3QgKGl0ZW0pIHtcblx0XHR0aGlzLkFic3RyYWN0UmVxdWVzdF9jb25zdHJ1Y3RvcihpdGVtKTtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogQSByZWZlcmVuY2UgdG8gdGhlIFhIUiByZXF1ZXN0IHVzZWQgdG8gbG9hZCB0aGUgY29udGVudC5cblx0XHQgKiBAcHJvcGVydHkgX3JlcXVlc3Rcblx0XHQgKiBAdHlwZSB7WE1MSHR0cFJlcXVlc3QgfCBYRG9tYWluUmVxdWVzdCB8IEFjdGl2ZVguWE1MSFRUUH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBtYW51YWwgbG9hZCB0aW1lb3V0IHRoYXQgaXMgdXNlZCBmb3IgYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCB0aGUgb25UaW1lb3V0IGV2ZW50IG9uIFhIUiAoWEhSIGxldmVsIDEsXG5cdFx0ICogdHlwaWNhbGx5IElFOSkuXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkVGltZW91dFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkVGltZW91dCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYnJvd3NlcidzIFhIUiAoWE1MSFRUUFJlcXVlc3QpIHZlcnNpb24uIFN1cHBvcnRlZCB2ZXJzaW9ucyBhcmUgMSBhbmQgMi4gVGhlcmUgaXMgbm8gb2ZmaWNpYWwgd2F5IHRvIGRldGVjdFxuXHRcdCAqIHRoZSB2ZXJzaW9uLCBzbyB3ZSB1c2UgY2FwYWJpbGl0aWVzIHRvIG1ha2UgYSBiZXN0IGd1ZXNzLlxuXHRcdCAqIEBwcm9wZXJ0eSBfeGhyTGV2ZWxcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3hockxldmVsID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByZXNwb25zZSBvZiBhIGxvYWRlZCBmaWxlLiBUaGlzIGlzIHNldCBiZWNhdXNlIGl0IGlzIGV4cGVuc2l2ZSB0byBsb29rIHVwIGNvbnN0YW50bHkuIFRoaXMgcHJvcGVydHkgd2lsbCBiZVxuXHRcdCAqIG51bGwgdW50aWwgdGhlIGZpbGUgaXMgbG9hZGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmVzcG9uc2Vcblx0XHQgKiBAdHlwZSB7bWl4ZWR9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9yZXNwb25zZSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcmVzcG9uc2Ugb2YgdGhlIGxvYWRlZCBmaWxlIGJlZm9yZSBpdCBpcyBtb2RpZmllZC4gSW4gbW9zdCBjYXNlcywgY29udGVudCBpcyBjb252ZXJ0ZWQgZnJvbSByYXcgdGV4dCB0b1xuXHRcdCAqIGFuIEhUTUwgdGFnIG9yIGEgZm9ybWF0dGVkIG9iamVjdCB3aGljaCBpcyBzZXQgdG8gdGhlIDxjb2RlPnJlc3VsdDwvY29kZT4gcHJvcGVydHksIGJ1dCB0aGUgZGV2ZWxvcGVyIG1heSBzdGlsbFxuXHRcdCAqIHdhbnQgdG8gYWNjZXNzIHRoZSByYXcgY29udGVudCBhcyBpdCB3YXMgbG9hZGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmF3UmVzcG9uc2Vcblx0XHQgKiBAdHlwZSB7U3RyaW5nfE9iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3Jhd1Jlc3BvbnNlID0gbnVsbDtcblxuXHRcdHRoaXMuX2NhbmNlbGVkID0gZmFsc2U7XG5cblx0XHQvLyBTZXR1cCBvdXIgZXZlbnQgaGFuZGxlcnMgbm93LlxuXHRcdHRoaXMuX2hhbmRsZUxvYWRTdGFydFByb3h5ID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlTG9hZFN0YXJ0LCB0aGlzKTtcblx0XHR0aGlzLl9oYW5kbGVQcm9ncmVzc1Byb3h5ID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlUHJvZ3Jlc3MsIHRoaXMpO1xuXHRcdHRoaXMuX2hhbmRsZUFib3J0UHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVBYm9ydCwgdGhpcyk7XG5cdFx0dGhpcy5faGFuZGxlRXJyb3JQcm94eSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZUVycm9yLCB0aGlzKTtcblx0XHR0aGlzLl9oYW5kbGVUaW1lb3V0UHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUaW1lb3V0LCB0aGlzKTtcblx0XHR0aGlzLl9oYW5kbGVMb2FkUHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVMb2FkLCB0aGlzKTtcblx0XHR0aGlzLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlUHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlLCB0aGlzKTtcblxuXHRcdGlmICghdGhpcy5fY3JlYXRlWEhSKGl0ZW0pKSB7XG5cdFx0XHQvL1RPRE86IFRocm93IGVycm9yP1xuXHRcdH1cblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChYSFJSZXF1ZXN0LCBjcmVhdGVqcy5BYnN0cmFjdFJlcXVlc3QpO1xuXG4vLyBzdGF0aWMgcHJvcGVydGllc1xuXHQvKipcblx0ICogQSBsaXN0IG9mIFhNTEhUVFAgb2JqZWN0IElEcyB0byB0cnkgd2hlbiBidWlsZGluZyBhbiBBY3RpdmVYIG9iamVjdCBmb3IgWEhSIHJlcXVlc3RzIGluIGVhcmxpZXIgdmVyc2lvbnMgb2YgSUUuXG5cdCAqIEBwcm9wZXJ0eSBBQ1RJVkVYX1ZFUlNJT05TXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQHNpbmNlIDAuNC4yXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRYSFJSZXF1ZXN0LkFDVElWRVhfVkVSU0lPTlMgPSBbXG5cdFx0XCJNc3htbDIuWE1MSFRUUC42LjBcIixcblx0XHRcIk1zeG1sMi5YTUxIVFRQLjUuMFwiLFxuXHRcdFwiTXN4bWwyLlhNTEhUVFAuNC4wXCIsXG5cdFx0XCJNU1hNTDIuWE1MSFRUUC4zLjBcIixcblx0XHRcIk1TWE1MMi5YTUxIVFRQXCIsXG5cdFx0XCJNaWNyb3NvZnQuWE1MSFRUUFwiXG5cdF07XG5cbi8vIFB1YmxpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBMb29rIHVwIHRoZSBsb2FkZWQgcmVzdWx0LlxuXHQgKiBAbWV0aG9kIGdldFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyYXc9ZmFsc2VdIFJldHVybiBhIHJhdyByZXN1bHQgaW5zdGVhZCBvZiBhIGZvcm1hdHRlZCByZXN1bHQuIFRoaXMgYXBwbGllcyB0byBjb250ZW50XG5cdCAqIGxvYWRlZCB2aWEgWEhSIHN1Y2ggYXMgc2NyaXB0cywgWE1MLCBDU1MsIGFuZCBJbWFnZXMuIElmIHRoZXJlIGlzIG5vIHJhdyByZXN1bHQsIHRoZSBmb3JtYXR0ZWQgcmVzdWx0IHdpbGwgYmVcblx0ICogcmV0dXJuZWQgaW5zdGVhZC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBBIHJlc3VsdCBvYmplY3QgY29udGFpbmluZyB0aGUgY29udGVudCB0aGF0IHdhcyBsb2FkZWQsIHN1Y2ggYXM6XG5cdCAqIDx1bD5cblx0ICogICAgICA8bGk+QW4gaW1hZ2UgdGFnICgmbHQ7aW1hZ2UgLyZndDspIGZvciBpbWFnZXM8L2xpPlxuXHQgKiAgICAgIDxsaT5BIHNjcmlwdCB0YWcgZm9yIEphdmFTY3JpcHQgKCZsdDtzY3JpcHQgLyZndDspLiBOb3RlIHRoYXQgc2NyaXB0cyBsb2FkZWQgd2l0aCB0YWdzIG1heSBiZSBhZGRlZCB0byB0aGVcblx0ICogICAgICBIVE1MIGhlYWQuPC9saT5cblx0ICogICAgICA8bGk+QSBzdHlsZSB0YWcgZm9yIENTUyAoJmx0O3N0eWxlIC8mZ3Q7KTwvbGk+XG5cdCAqICAgICAgPGxpPlJhdyB0ZXh0IGZvciBURVhUPC9saT5cblx0ICogICAgICA8bGk+QSBmb3JtYXR0ZWQgSmF2YVNjcmlwdCBvYmplY3QgZGVmaW5lZCBieSBKU09OPC9saT5cblx0ICogICAgICA8bGk+QW4gWE1MIGRvY3VtZW50PC9saT5cblx0ICogICAgICA8bGk+QW4gYmluYXJ5IGFycmF5YnVmZmVyIGxvYWRlZCBieSBYSFI8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBOb3RlIHRoYXQgaWYgYSByYXcgcmVzdWx0IGlzIHJlcXVlc3RlZCwgYnV0IG5vdCBmb3VuZCwgdGhlIHJlc3VsdCB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQuXG5cdCAqL1xuXHRwLmdldFJlc3VsdCA9IGZ1bmN0aW9uIChyYXcpIHtcblx0XHRpZiAocmF3ICYmIHRoaXMuX3Jhd1Jlc3BvbnNlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmF3UmVzcG9uc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9yZXNwb25zZTtcblx0fTtcblxuXHQvLyBPdmVycmlkZXMgYWJzdHJhY3QgbWV0aG9kIGluIEFic3RyYWN0UmVxdWVzdFxuXHRwLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmNhbmNlbGVkID0gdHJ1ZTtcblx0XHR0aGlzLl9jbGVhbigpO1xuXHRcdHRoaXMuX3JlcXVlc3QuYWJvcnQoKTtcblx0fTtcblxuXHQvLyBPdmVycmlkZXMgYWJzdHJhY3QgbWV0aG9kIGluIEFic3RyYWN0TG9hZGVyXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVxdWVzdCA9PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVFcnJvcigpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vRXZlbnRzXG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2Fkc3RhcnRcIiwgdGhpcy5faGFuZGxlTG9hZFN0YXJ0UHJveHksIGZhbHNlKTtcblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIHRoaXMuX2hhbmRsZVByb2dyZXNzUHJveHksIGZhbHNlKTtcblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHRoaXMuX2hhbmRsZUFib3J0UHJveHksIGZhbHNlKTtcblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHRoaXMuX2hhbmRsZUVycm9yUHJveHksIGZhbHNlKTtcblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcInRpbWVvdXRcIiwgdGhpcy5faGFuZGxlVGltZW91dFByb3h5LCBmYWxzZSk7XG5cblx0XHRcdC8vIE5vdGU6IFdlIGRvbid0IGdldCBvbmxvYWQgaW4gYWxsIGJyb3dzZXJzIChlYXJsaWVyIEZGIGFuZCBJRSkuIG9uUmVhZHlTdGF0ZUNoYW5nZSBoYW5kbGVzIHRoZXNlLlxuXHRcdFx0dGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCB0aGlzLl9oYW5kbGVMb2FkUHJveHksIGZhbHNlKTtcblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIiwgdGhpcy5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZVByb3h5LCBmYWxzZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIElFOSBzdXBwb3J0XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9ubG9hZHN0YXJ0ID0gdGhpcy5faGFuZGxlTG9hZFN0YXJ0UHJveHk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSB0aGlzLl9oYW5kbGVQcm9ncmVzc1Byb3h5O1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbmFib3J0ID0gdGhpcy5faGFuZGxlQWJvcnRQcm94eTtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25lcnJvciA9IHRoaXMuX2hhbmRsZUVycm9yUHJveHk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9udGltZW91dCA9IHRoaXMuX2hhbmRsZVRpbWVvdXRQcm94eTtcblxuXHRcdFx0Ly8gTm90ZTogV2UgZG9uJ3QgZ2V0IG9ubG9hZCBpbiBhbGwgYnJvd3NlcnMgKGVhcmxpZXIgRkYgYW5kIElFKS4gb25SZWFkeVN0YXRlQ2hhbmdlIGhhbmRsZXMgdGhlc2UuXG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9ubG9hZCA9IHRoaXMuX2hhbmRsZUxvYWRQcm94eTtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZVByb3h5O1xuXHRcdH1cblxuXHRcdC8vIFNldCB1cCBhIHRpbWVvdXQgaWYgd2UgZG9uJ3QgaGF2ZSBYSFIyXG5cdFx0aWYgKHRoaXMuX3hockxldmVsID09IDEpIHtcblx0XHRcdHRoaXMuX2xvYWRUaW1lb3V0ID0gc2V0VGltZW91dChjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUaW1lb3V0LCB0aGlzKSwgdGhpcy5faXRlbS5sb2FkVGltZW91dCk7XG5cdFx0fVxuXG5cdFx0Ly8gU29tZXRpbWVzIHdlIGdldCBiYWNrIDQwNHMgaW1tZWRpYXRlbHksIHBhcnRpY3VsYXJseSB3aGVuIHRoZXJlIGlzIGEgY3Jvc3Mgb3JpZ2luIHJlcXVlc3QuICAvLyBub3RlIHRoaXMgZG9lcyBub3QgY2F0Y2ggaW4gQ2hyb21lXG5cdFx0dHJ5IHtcblx0XHRcdGlmICghdGhpcy5faXRlbS52YWx1ZXMgfHwgdGhpcy5faXRlbS5tZXRob2QgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuR0VUKSB7XG5cdFx0XHRcdHRoaXMuX3JlcXVlc3Quc2VuZCgpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9pdGVtLm1ldGhvZCA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5QT1NUKSB7XG5cdFx0XHRcdHRoaXMuX3JlcXVlc3Quc2VuZChjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuZm9ybWF0UXVlcnlTdHJpbmcodGhpcy5faXRlbS52YWx1ZXMpKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiWEhSX1NFTkRcIiwgbnVsbCwgZXJyb3IpKTtcblx0XHR9XG5cdH07XG5cblx0cC5zZXRSZXNwb25zZVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuXHRcdC8vIFNvbWUgb2xkIGJyb3dzZXJzIGRvZXNuJ3Qgc3VwcG9ydCBibG9iLCBzbyB3ZSBjb252ZXJ0IGFycmF5YnVmZmVyIHRvIGJsb2IgYWZ0ZXIgcmVzcG9uc2UgaXMgZG93bmxvYWRlZFxuXHRcdGlmICh0eXBlID09PSAnYmxvYicpIHtcblx0XHRcdHR5cGUgPSB3aW5kb3cuVVJMID8gJ2Jsb2InIDogJ2FycmF5YnVmZmVyJztcblx0XHRcdHRoaXMuX3Jlc3BvbnNlVHlwZSA9IHR5cGU7XG5cdFx0fVxuXHRcdHRoaXMuX3JlcXVlc3QucmVzcG9uc2VUeXBlID0gdHlwZTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IGFsbCB0aGUgcmVzcG9uc2UgaGVhZGVycyBmcm9tIHRoZSBYbWxIdHRwUmVxdWVzdC5cblx0ICpcblx0ICogPHN0cm9uZz5Gcm9tIHRoZSBkb2NzOjwvc3Ryb25nPiBSZXR1cm4gYWxsIHRoZSBIVFRQIGhlYWRlcnMsIGV4Y2x1ZGluZyBoZWFkZXJzIHRoYXQgYXJlIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaFxuXHQgKiBmb3IgU2V0LUNvb2tpZSBvciBTZXQtQ29va2llMiwgYXMgYSBzaW5nbGUgc3RyaW5nLCB3aXRoIGVhY2ggaGVhZGVyIGxpbmUgc2VwYXJhdGVkIGJ5IGEgVSswMDBEIENSIFUrMDAwQSBMRiBwYWlyLFxuXHQgKiBleGNsdWRpbmcgdGhlIHN0YXR1cyBsaW5lLCBhbmQgd2l0aCBlYWNoIGhlYWRlciBuYW1lIGFuZCBoZWFkZXIgdmFsdWUgc2VwYXJhdGVkIGJ5IGEgVSswMDNBIENPTE9OIFUrMDAyMCBTUEFDRVxuXHQgKiBwYWlyLlxuXHQgKiBAbWV0aG9kIGdldEFsbFJlc3BvbnNlSGVhZGVyc1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKi9cblx0cC5nZXRBbGxSZXNwb25zZUhlYWRlcnMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCBhIHNwZWNpZmljIHJlc3BvbnNlIGhlYWRlciBmcm9tIHRoZSBYbWxIdHRwUmVxdWVzdC5cblx0ICpcblx0ICogPHN0cm9uZz5Gcm9tIHRoZSBkb2NzOjwvc3Ryb25nPiBSZXR1cm5zIHRoZSBoZWFkZXIgZmllbGQgdmFsdWUgZnJvbSB0aGUgcmVzcG9uc2Ugb2Ygd2hpY2ggdGhlIGZpZWxkIG5hbWUgbWF0Y2hlc1xuXHQgKiBoZWFkZXIsIHVubGVzcyB0aGUgZmllbGQgbmFtZSBpcyBTZXQtQ29va2llIG9yIFNldC1Db29raWUyLlxuXHQgKiBAbWV0aG9kIGdldFJlc3BvbnNlSGVhZGVyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGhlYWRlciBuYW1lIHRvIHJldHJpZXZlLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKi9cblx0cC5nZXRSZXNwb25zZUhlYWRlciA9IGZ1bmN0aW9uIChoZWFkZXIpIHtcblx0XHRpZiAodGhpcy5fcmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlciBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlcihoZWFkZXIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH07XG5cbi8vIHByb3RlY3RlZCBtZXRob2RzXG5cdC8qKlxuXHQgKiBUaGUgWEhSIHJlcXVlc3QgaGFzIHJlcG9ydGVkIHByb2dyZXNzLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVQcm9ncmVzc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIFhIUiBwcm9ncmVzcyBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVByb2dyZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYgKCFldmVudCB8fCBldmVudC5sb2FkZWQgPiAwICYmIGV2ZW50LnRvdGFsID09IDApIHtcblx0XHRcdHJldHVybjsgLy8gU29tZXRpbWVzIHdlIGdldCBubyBcInRvdGFsXCIsIHNvIGp1c3QgaWdub3JlIHRoZSBwcm9ncmVzcyBldmVudC5cblx0XHR9XG5cblx0XHR2YXIgbmV3RXZlbnQgPSBuZXcgY3JlYXRlanMuUHJvZ3Jlc3NFdmVudChldmVudC5sb2FkZWQsIGV2ZW50LnRvdGFsKTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgWEhSIHJlcXVlc3QgaGFzIHJlcG9ydGVkIGEgbG9hZCBzdGFydC5cblx0ICogQG1ldGhvZCBfaGFuZGxlTG9hZFN0YXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGxvYWRTdGFydCBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZUxvYWRTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9sb2FkVGltZW91dCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwibG9hZHN0YXJ0XCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgWEhSIHJlcXVlc3QgaGFzIHJlcG9ydGVkIGFuIGFib3J0IGV2ZW50LlxuXHQgKiBAbWV0aG9kIGhhbmRsZUFib3J0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGFib3J0IGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlQWJvcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLl9jbGVhbigpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlhIUl9BQk9SVEVEXCIsIG51bGwsIGV2ZW50KSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgcmVwb3J0ZWQgYW4gZXJyb3IgZXZlbnQuXG5cdCAqIEBtZXRob2QgX2hhbmRsZUVycm9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGVycm9yIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLl9jbGVhbigpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXJyb3JFdmVudChldmVudC5tZXNzYWdlKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgcmVwb3J0ZWQgYSByZWFkeVN0YXRlIGNoYW5nZS4gTm90ZSB0aGF0IG9sZGVyIGJyb3dzZXJzIChJRSA3ICYgOCkgZG8gbm90IHByb3ZpZGUgYW4gb25sb2FkXG5cdCAqIGV2ZW50LCBzbyB3ZSBtdXN0IG1vbml0b3IgdGhlIHJlYWR5U3RhdGVDaGFuZ2UgdG8gZGV0ZXJtaW5lIGlmIHRoZSBmaWxlIGlzIGxvYWRlZC5cblx0ICogQG1ldGhvZCBfaGFuZGxlUmVhZHlTdGF0ZUNoYW5nZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIFhIUiByZWFkeVN0YXRlQ2hhbmdlIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGlmICh0aGlzLl9yZXF1ZXN0LnJlYWR5U3RhdGUgPT0gNCkge1xuXHRcdFx0dGhpcy5faGFuZGxlTG9hZCgpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVGhlIFhIUiByZXF1ZXN0IGhhcyBjb21wbGV0ZWQuIFRoaXMgaXMgY2FsbGVkIGJ5IHRoZSBYSFIgcmVxdWVzdCBkaXJlY3RseSwgb3IgYnkgYSByZWFkeVN0YXRlQ2hhbmdlIHRoYXQgaGFzXG5cdCAqIDxjb2RlPnJlcXVlc3QucmVhZHlTdGF0ZSA9PSA0PC9jb2RlPi4gT25seSB0aGUgZmlyc3QgY2FsbCB0byB0aGlzIG1ldGhvZCB3aWxsIGJlIHByb2Nlc3NlZC5cblx0ICogQG1ldGhvZCBfaGFuZGxlTG9hZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIFhIUiBsb2FkIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGlmICh0aGlzLmxvYWRlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLmxvYWRlZCA9IHRydWU7XG5cblx0XHR2YXIgZXJyb3IgPSB0aGlzLl9jaGVja0Vycm9yKCk7XG5cdFx0aWYgKGVycm9yKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVFcnJvcihlcnJvcik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fcmVzcG9uc2UgPSB0aGlzLl9nZXRSZXNwb25zZSgpO1xuXHRcdC8vIENvbnZlcnQgYXJyYXlidWZmZXIgYmFjayB0byBibG9iXG5cdFx0aWYgKHRoaXMuX3Jlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dGhpcy5fcmVzcG9uc2UgPSBuZXcgQmxvYihbdGhpcy5fcmVzcG9uc2VdKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gdXNlIEJsb2JCdWlsZGVyIGlmIEJsb2IgY29uc3RydWN0b3IgaXMgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHQvLyBUZXN0ZWQgb24gQW5kcm9pZCAyLjMgfiA0LjIgYW5kIGlPUzUgc2FmYXJpXG5cdFx0XHRcdHdpbmRvdy5CbG9iQnVpbGRlciA9IHdpbmRvdy5CbG9iQnVpbGRlciB8fCB3aW5kb3cuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1vekJsb2JCdWlsZGVyIHx8IHdpbmRvdy5NU0Jsb2JCdWlsZGVyO1xuXHRcdFx0XHRpZiAoZS5uYW1lID09PSAnVHlwZUVycm9yJyAmJiB3aW5kb3cuQmxvYkJ1aWxkZXIpIHtcblx0XHRcdFx0XHR2YXIgYnVpbGRlciA9IG5ldyBCbG9iQnVpbGRlcigpO1xuXHRcdFx0XHRcdGJ1aWxkZXIuYXBwZW5kKHRoaXMuX3Jlc3BvbnNlKTtcblx0XHRcdFx0XHR0aGlzLl9yZXNwb25zZSA9IGJ1aWxkZXIuZ2V0QmxvYigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2NsZWFuKCk7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3IGNyZWF0ZWpzLkV2ZW50KFwiY29tcGxldGVcIikpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgWEhSIHJlcXVlc3QgaGFzIHRpbWVkIG91dC4gVGhpcyBpcyBjYWxsZWQgYnkgdGhlIFhIUiByZXF1ZXN0IGRpcmVjdGx5LCBvciB2aWEgYSA8Y29kZT5zZXRUaW1lb3V0PC9jb2RlPlxuXHQgKiBjYWxsYmFjay5cblx0ICogQG1ldGhvZCBfaGFuZGxlVGltZW91dFxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2V2ZW50XSBUaGUgWEhSIHRpbWVvdXQgZXZlbnQuIFRoaXMgaXMgb2NjYXNpb25hbGx5IG51bGwgd2hlbiBjYWxsZWQgYnkgdGhlIGJhY2t1cCBzZXRUaW1lb3V0LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlVGltZW91dCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMuX2NsZWFuKCk7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJQUkVMT0FEX1RJTUVPVVRcIiwgbnVsbCwgZXZlbnQpKTtcblx0fTtcblxuLy8gUHJvdGVjdGVkXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgdGhlcmUgaXMgYW4gZXJyb3IgaW4gdGhlIGN1cnJlbnQgbG9hZC4gVGhpcyBjaGVja3MgdGhlIHN0YXR1cyBvZiB0aGUgcmVxdWVzdCBmb3IgcHJvYmxlbSBjb2Rlcy4gTm90ZVxuXHQgKiB0aGF0IHRoaXMgZG9lcyBub3QgY2hlY2sgZm9yIGFuIGFjdHVhbCByZXNwb25zZS4gQ3VycmVudGx5LCBpdCBvbmx5IGNoZWNrcyBmb3IgNDA0IG9yIDAgZXJyb3IgY29kZS5cblx0ICogQG1ldGhvZCBfY2hlY2tFcnJvclxuXHQgKiBAcmV0dXJuIHtpbnR9IElmIHRoZSByZXF1ZXN0IHN0YXR1cyByZXR1cm5zIGFuIGVycm9yIGNvZGUuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jaGVja0Vycm9yID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vTE06IFByb2JhYmx5IG5lZWQgYWRkaXRpb25hbCBoYW5kbGVycyBoZXJlLCBtYXliZSA1MDFcblx0XHR2YXIgc3RhdHVzID0gcGFyc2VJbnQodGhpcy5fcmVxdWVzdC5zdGF0dXMpO1xuXG5cdFx0c3dpdGNoIChzdGF0dXMpIHtcblx0XHRcdGNhc2UgNDA0OiAgIC8vIE5vdCBGb3VuZFxuXHRcdFx0Y2FzZSAwOiAgICAgLy8gTm90IExvYWRlZFxuXHRcdFx0XHRyZXR1cm4gbmV3IEVycm9yKHN0YXR1cyk7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBWYWxpZGF0ZSB0aGUgcmVzcG9uc2UuIERpZmZlcmVudCBicm93c2VycyBoYXZlIGRpZmZlcmVudCBhcHByb2FjaGVzLCBzb21lIG9mIHdoaWNoIHRocm93IGVycm9ycyB3aGVuIGFjY2Vzc2VkXG5cdCAqIGluIG90aGVyIGJyb3dzZXJzLiBJZiB0aGVyZSBpcyBubyByZXNwb25zZSwgdGhlIDxjb2RlPl9yZXNwb25zZTwvY29kZT4gcHJvcGVydHkgd2lsbCByZW1haW4gbnVsbC5cblx0ICogQG1ldGhvZCBfZ2V0UmVzcG9uc2Vcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2dldFJlc3BvbnNlID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZXNwb25zZSAhPSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QucmVzcG9uc2UgIT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JlcXVlc3QucmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQW5kcm9pZCAyLjIgdXNlcyAucmVzcG9uc2VUZXh0XG5cdFx0dHJ5IHtcblx0XHRcdGlmICh0aGlzLl9yZXF1ZXN0LnJlc3BvbnNlVGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXF1ZXN0LnJlc3BvbnNlVGV4dDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiBsb2FkaW5nIFhNTCwgSUU5IGRvZXMgbm90IHJldHVybiAucmVzcG9uc2UsIGluc3RlYWQgaXQgcmV0dXJucyByZXNwb25zZVhNTC54bWxcblx0XHR0cnkge1xuXHRcdFx0aWYgKHRoaXMuX3JlcXVlc3QucmVzcG9uc2VYTUwgIT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVxdWVzdC5yZXNwb25zZVhNTDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhbiBYSFIgcmVxdWVzdC4gRGVwZW5kaW5nIG9uIGEgbnVtYmVyIG9mIGZhY3RvcnMsIHdlIGdldCB0b3RhbGx5IGRpZmZlcmVudCByZXN1bHRzLlxuXHQgKiA8b2w+PGxpPlNvbWUgYnJvd3NlcnMgZ2V0IGFuIDxjb2RlPlhEb21haW5SZXF1ZXN0PC9jb2RlPiB3aGVuIGxvYWRpbmcgY3Jvc3MtZG9tYWluLjwvbGk+XG5cdCAqICAgICAgPGxpPlhNTEh0dHBSZXF1ZXN0IGFyZSBjcmVhdGVkIHdoZW4gYXZhaWxhYmxlLjwvbGk+XG5cdCAqICAgICAgPGxpPkFjdGl2ZVguWE1MSFRUUCBvYmplY3RzIGFyZSB1c2VkIGluIG9sZGVyIElFIGJyb3dzZXJzLjwvbGk+XG5cdCAqICAgICAgPGxpPlRleHQgcmVxdWVzdHMgb3ZlcnJpZGUgdGhlIG1pbWUgdHlwZSBpZiBwb3NzaWJsZTwvbGk+XG5cdCAqICAgICAgPGxpPk9yaWdpbiBoZWFkZXJzIGFyZSBzZW50IGZvciBjcm9zc2RvbWFpbiByZXF1ZXN0cyBpbiBzb21lIGJyb3dzZXJzLjwvbGk+XG5cdCAqICAgICAgPGxpPkJpbmFyeSBsb2FkcyBzZXQgdGhlIHJlc3BvbnNlIHR5cGUgdG8gXCJhcnJheWJ1ZmZlclwiPC9saT48L29sPlxuXHQgKiBAbWV0aG9kIF9jcmVhdGVYSFJcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIHJlcXVlc3RlZCBpdGVtIHRoYXQgaXMgYmVpbmcgbG9hZGVkLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiBhbiBYSFIgcmVxdWVzdCBvciBlcXVpdmFsZW50IHdhcyBzdWNjZXNzZnVsbHkgY3JlYXRlZC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NyZWF0ZVhIUiA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0Ly8gQ2hlY2sgZm9yIGNyb3NzLWRvbWFpbiBsb2Fkcy4gV2UgY2FuJ3QgZnVsbHkgc3VwcG9ydCB0aGVtLCBidXQgd2UgY2FuIHRyeS5cblx0XHR2YXIgY3Jvc3Nkb21haW4gPSBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNDcm9zc0RvbWFpbihpdGVtKTtcblx0XHR2YXIgaGVhZGVycyA9IHt9O1xuXG5cdFx0Ly8gQ3JlYXRlIHRoZSByZXF1ZXN0LiBGYWxsYmFjayB0byB3aGF0ZXZlciBzdXBwb3J0IHdlIGhhdmUuXG5cdFx0dmFyIHJlcSA9IG51bGw7XG5cdFx0aWYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCkge1xuXHRcdFx0cmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0XHQvLyBUaGlzIGlzIDggb3IgOSwgc28gdXNlIFhEb21haW5SZXF1ZXN0IGluc3RlYWQuXG5cdFx0XHRpZiAoY3Jvc3Nkb21haW4gJiYgcmVxLndpdGhDcmVkZW50aWFscyA9PT0gdW5kZWZpbmVkICYmIHdpbmRvdy5YRG9tYWluUmVxdWVzdCkge1xuXHRcdFx0XHRyZXEgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgeyAvLyBPbGQgSUUgdmVyc2lvbnMgdXNlIGEgZGlmZmVyZW50IGFwcHJvYWNoXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHMuQUNUSVZFWF9WRVJTSU9OUy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGF4VmVyc2lvbiA9IHMuQUNUSVZFWF9WRVJTSU9OU1tpXTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXEgPSBuZXcgQWN0aXZlWE9iamVjdChheFZlcnNpb24pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChyZXEgPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRGVmYXVsdCB0byB1dGYtOCBmb3IgVGV4dCByZXF1ZXN0cy5cblx0XHRpZiAoaXRlbS5taW1lVHlwZSA9PSBudWxsICYmIGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc1RleHQoaXRlbS50eXBlKSkge1xuXHRcdFx0aXRlbS5taW1lVHlwZSA9IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiO1xuXHRcdH1cblxuXHRcdC8vIElFOSBkb2Vzbid0IHN1cHBvcnQgb3ZlcnJpZGVNaW1lVHlwZSgpLCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGZvciBpdC5cblx0XHRpZiAoaXRlbS5taW1lVHlwZSAmJiByZXEub3ZlcnJpZGVNaW1lVHlwZSkge1xuXHRcdFx0cmVxLm92ZXJyaWRlTWltZVR5cGUoaXRlbS5taW1lVHlwZSk7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIHRoZSBYSFIgbGV2ZWxcblx0XHR0aGlzLl94aHJMZXZlbCA9ICh0eXBlb2YgcmVxLnJlc3BvbnNlVHlwZSA9PT0gXCJzdHJpbmdcIikgPyAyIDogMTtcblxuXHRcdHZhciBzcmMgPSBudWxsO1xuXHRcdGlmIChpdGVtLm1ldGhvZCA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5HRVQpIHtcblx0XHRcdHNyYyA9IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5idWlsZFBhdGgoaXRlbS5zcmMsIGl0ZW0udmFsdWVzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3JjID0gaXRlbS5zcmM7XG5cdFx0fVxuXG5cdFx0Ly8gT3BlbiB0aGUgcmVxdWVzdC4gIFNldCBjcm9zcy1kb21haW4gZmxhZ3MgaWYgaXQgaXMgc3VwcG9ydGVkIChYSFIgbGV2ZWwgMSBvbmx5KVxuXHRcdHJlcS5vcGVuKGl0ZW0ubWV0aG9kIHx8IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkdFVCwgc3JjLCB0cnVlKTtcblxuXHRcdGlmIChjcm9zc2RvbWFpbiAmJiByZXEgaW5zdGFuY2VvZiBYTUxIdHRwUmVxdWVzdCAmJiB0aGlzLl94aHJMZXZlbCA9PSAxKSB7XG5cdFx0XHRoZWFkZXJzW1wiT3JpZ2luXCJdID0gbG9jYXRpb24ub3JpZ2luO1xuXHRcdH1cblxuXHRcdC8vIFRvIHNlbmQgZGF0YSB3ZSBuZWVkIHRvIHNldCB0aGUgQ29udGVudC10eXBlIGhlYWRlcilcblx0XHRpZiAoaXRlbS52YWx1ZXMgJiYgaXRlbS5tZXRob2QgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuUE9TVCkge1xuXHRcdFx0aGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI7XG5cdFx0fVxuXG5cdFx0aWYgKCFjcm9zc2RvbWFpbiAmJiAhaGVhZGVyc1tcIlgtUmVxdWVzdGVkLVdpdGhcIl0pIHtcblx0XHRcdGhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdH1cblxuXHRcdGlmIChpdGVtLmhlYWRlcnMpIHtcblx0XHRcdGZvciAodmFyIG4gaW4gaXRlbS5oZWFkZXJzKSB7XG5cdFx0XHRcdGhlYWRlcnNbbl0gPSBpdGVtLmhlYWRlcnNbbl07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChuIGluIGhlYWRlcnMpIHtcblx0XHRcdHJlcS5zZXRSZXF1ZXN0SGVhZGVyKG4sIGhlYWRlcnNbbl0pXG5cdFx0fVxuXG5cdFx0aWYgKHJlcSBpbnN0YW5jZW9mIFhNTEh0dHBSZXF1ZXN0ICYmIGl0ZW0ud2l0aENyZWRlbnRpYWxzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJlcS53aXRoQ3JlZGVudGlhbHMgPSBpdGVtLndpdGhDcmVkZW50aWFscztcblx0XHR9XG5cblx0XHR0aGlzLl9yZXF1ZXN0ID0gcmVxO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIEEgcmVxdWVzdCBoYXMgY29tcGxldGVkIChvciBmYWlsZWQgb3IgY2FuY2VsZWQpLCBhbmQgbmVlZHMgdG8gYmUgZGlzcG9zZWQuXG5cdCAqIEBtZXRob2QgX2NsZWFuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jbGVhbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fbG9hZFRpbWVvdXQpO1xuXG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lciAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2Fkc3RhcnRcIiwgdGhpcy5faGFuZGxlTG9hZFN0YXJ0UHJveHkpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgdGhpcy5faGFuZGxlUHJvZ3Jlc3NQcm94eSk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCB0aGlzLl9oYW5kbGVBYm9ydFByb3h5KTtcblx0XHRcdHRoaXMuX3JlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHRoaXMuX2hhbmRsZUVycm9yUHJveHkpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwidGltZW91dFwiLCB0aGlzLl9oYW5kbGVUaW1lb3V0UHJveHkpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCB0aGlzLl9oYW5kbGVMb2FkUHJveHkpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLCB0aGlzLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlUHJveHkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9ubG9hZHN0YXJ0ID0gbnVsbDtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25wcm9ncmVzcyA9IG51bGw7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9uYWJvcnQgPSBudWxsO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbmVycm9yID0gbnVsbDtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub250aW1lb3V0ID0gbnVsbDtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25sb2FkID0gbnVsbDtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbUHJlbG9hZEpTIFhIUlJlcXVlc3RdXCI7XG5cdH07XG5cblx0Y3JlYXRlanMuWEhSUmVxdWVzdCA9IGNyZWF0ZWpzLnByb21vdGUoWEhSUmVxdWVzdCwgXCJBYnN0cmFjdFJlcXVlc3RcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBMb2FkUXVldWUuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbi8qXG4gVE9ETzogV0lORE9XUyBJU1NVRVNcbiAqIE5vIGVycm9yIGZvciBIVE1MIGF1ZGlvIGluIElFIDY3OFxuICogU1ZHIG5vIGZhaWx1cmUgZXJyb3IgaW4gSUUgNjcgKG1heWJlIDgpIFRBR1MgQU5EIFhIUlxuICogTm8gc2NyaXB0IGNvbXBsZXRlIGhhbmRsZXIgaW4gSUUgNjcgVEFHUyAoWEhSIGlzIGZpbmUpXG4gKiBObyBYTUwvSlNPTiBpbiBJRTYgVEFHU1xuICogTmVlZCB0byBoaWRlIGxvYWRpbmcgU1ZHIGluIE9wZXJhIFRBR1NcbiAqIE5vIENTUyBvbmxvYWQvcmVhZHlzdGF0ZWNoYW5nZSBpbiBTYWZhcmkgb3IgQW5kcm9pZCBUQUdTIChyZXF1aXJlcyBydWxlIGNoZWNraW5nKVxuICogU1ZHIG5vIGxvYWQgb3IgZmFpbHVyZSBpbiBPcGVyYSBYSFJcbiAqIFJlcG9ydGVkIGlzc3VlcyB3aXRoIElFNy84XG4gKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBUaGUgTG9hZFF1ZXVlIGNsYXNzIGlzIHRoZSBtYWluIEFQSSBmb3IgcHJlbG9hZGluZyBjb250ZW50LiBMb2FkUXVldWUgaXMgYSBsb2FkIG1hbmFnZXIsIHdoaWNoIGNhbiBwcmVsb2FkIGVpdGhlclxuXHQgKiBhIHNpbmdsZSBmaWxlLCBvciBxdWV1ZSBvZiBmaWxlcy5cblx0ICpcblx0ICogPGI+Q3JlYXRpbmcgYSBRdWV1ZTwvYj48YnIgLz5cblx0ICogVG8gdXNlIExvYWRRdWV1ZSwgY3JlYXRlIGEgTG9hZFF1ZXVlIGluc3RhbmNlLiBJZiB5b3Ugd2FudCB0byBmb3JjZSB0YWcgbG9hZGluZyB3aGVyZSBwb3NzaWJsZSwgc2V0IHRoZSBwcmVmZXJYSFJcblx0ICogYXJndW1lbnQgdG8gZmFsc2UuXG5cdCAqXG5cdCAqICAgICAgdmFyIHF1ZXVlID0gbmV3IGNyZWF0ZWpzLkxvYWRRdWV1ZSh0cnVlKTtcblx0ICpcblx0ICogPGI+TGlzdGVuaW5nIGZvciBFdmVudHM8L2I+PGJyIC8+XG5cdCAqIEFkZCBhbnkgbGlzdGVuZXJzIHlvdSB3YW50IHRvIHRoZSBxdWV1ZS4gU2luY2UgUHJlbG9hZEpTIDAuMy4wLCB0aGUge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGxldHMgeW91IGFkZCBhcyBtYW55IGxpc3RlbmVycyBhcyB5b3Ugd2FudCBmb3IgZXZlbnRzLiBZb3UgY2FuIHN1YnNjcmliZSB0byB0aGUgZm9sbG93aW5nIGV2ZW50czo8dWw+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvY29tcGxldGU6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX06IGZpcmVkIHdoZW4gYSBxdWV1ZSBjb21wbGV0ZXMgbG9hZGluZyBhbGxcblx0ICogICAgIGZpbGVzPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9lcnJvcjpldmVudFwifX17ey9jcm9zc0xpbmt9fTogZmlyZWQgd2hlbiB0aGUgcXVldWUgZW5jb3VudGVycyBhbiBlcnJvciB3aXRoXG5cdCAqICAgICBhbnkgZmlsZS48L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL3Byb2dyZXNzOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319OiBQcm9ncmVzcyBmb3IgdGhlIGVudGlyZSBxdWV1ZSBoYXNcblx0ICogICAgIGNoYW5nZWQuPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZWxvYWQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX06IEEgc2luZ2xlIGZpbGUgaGFzIGNvbXBsZXRlZCBsb2FkaW5nLjwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVwcm9ncmVzczpldmVudFwifX17ey9jcm9zc0xpbmt9fTogUHJvZ3Jlc3MgZm9yIGEgc2luZ2xlIGZpbGUgaGFzIGNoYW5nZXMuIE5vdGVcblx0ICogICAgIHRoYXQgb25seSBmaWxlcyBsb2FkZWQgd2l0aCBYSFIgKG9yIHBvc3NpYmx5IGJ5IHBsdWdpbnMpIHdpbGwgZmlyZSBwcm9ncmVzcyBldmVudHMgb3RoZXIgdGhhbiAwIG9yIDEwMCUuPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogICAgICBxdWV1ZS5vbihcImZpbGVsb2FkXCIsIGhhbmRsZUZpbGVMb2FkLCB0aGlzKTtcblx0ICogICAgICBxdWV1ZS5vbihcImNvbXBsZXRlXCIsIGhhbmRsZUNvbXBsZXRlLCB0aGlzKTtcblx0ICpcblx0ICogPGI+QWRkaW5nIGZpbGVzIGFuZCBtYW5pZmVzdHM8L2I+PGJyIC8+XG5cdCAqIEFkZCBmaWxlcyB5b3Ugd2FudCB0byBsb2FkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fSBvciBhZGQgbXVsdGlwbGUgZmlsZXMgYXQgYVxuXHQgKiB0aW1lIHVzaW5nIGEgbGlzdCBvciBhIG1hbmlmZXN0IGRlZmluaXRpb24gdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fS4gRmlsZXMgYXJlXG5cdCAqIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGFjdGl2ZSBxdWV1ZSwgc28geW91IGNhbiB1c2UgdGhlc2UgbWV0aG9kcyBhcyBtYW55IHRpbWVzIGFzIHlvdSBsaWtlLCB3aGVuZXZlciB5b3Vcblx0ICogbGlrZS5cblx0ICpcblx0ICogICAgICBxdWV1ZS5sb2FkRmlsZShcImZpbGVQYXRoL2ZpbGUuanBnXCIpO1xuXHQgKiAgICAgIHF1ZXVlLmxvYWRGaWxlKHtpZDpcImltYWdlXCIsIHNyYzpcImZpbGVQYXRoL2ZpbGUuanBnXCJ9KTtcblx0ICogICAgICBxdWV1ZS5sb2FkTWFuaWZlc3QoW1wiZmlsZVBhdGgvZmlsZS5qcGdcIiwge2lkOlwiaW1hZ2VcIiwgc3JjOlwiZmlsZVBhdGgvZmlsZS5qcGdcIn1dKTtcblx0ICpcblx0ICogICAgICAvLyBVc2UgYW4gZXh0ZXJuYWwgbWFuaWZlc3Rcblx0ICogICAgICBxdWV1ZS5sb2FkTWFuaWZlc3QoXCJwYXRoL3RvL21hbmlmZXN0Lmpzb25cIik7XG5cdCAqICAgICAgcXVldWUubG9hZE1hbmlmZXN0KHtzcmM6XCJtYW5pZmVzdC5qc29uXCIsIHR5cGU6XCJtYW5pZmVzdFwifSk7XG5cdCAqXG5cdCAqIElmIHlvdSBwYXNzIGBmYWxzZWAgYXMgdGhlIGBsb2FkTm93YCBwYXJhbWV0ZXIsIHRoZSBxdWV1ZSB3aWxsIG5vdCBraWNrIG9mIHRoZSBsb2FkIG9mIHRoZSBmaWxlcywgYnV0IGl0IHdpbGwgbm90XG5cdCAqIHN0b3AgaWYgaXQgaGFzIGFscmVhZHkgYmVlbiBzdGFydGVkLiBDYWxsIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9sb2FkXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCB0byBiZWdpblxuXHQgKiBhIHBhdXNlZCBxdWV1ZS4gTm90ZSB0aGF0IGEgcGF1c2VkIHF1ZXVlIHdpbGwgYXV0b21hdGljYWxseSByZXN1bWUgd2hlbiBuZXcgZmlsZXMgYXJlIGFkZGVkIHRvIGl0IHdpdGggYVxuXHQgKiBgbG9hZE5vd2AgYXJndW1lbnQgb2YgYHRydWVgLlxuXHQgKlxuXHQgKiAgICAgIHF1ZXVlLmxvYWQoKTtcblx0ICpcblx0ICogPGI+RmlsZSBUeXBlczwvYj48YnIgLz5cblx0ICogVGhlIGZpbGUgdHlwZSBvZiBhIG1hbmlmZXN0IGl0ZW0gaXMgYXV0by1kZXRlcm1pbmVkIGJ5IHRoZSBmaWxlIGV4dGVuc2lvbi4gVGhlIHBhdHRlcm4gbWF0Y2hpbmcgaW4gUHJlbG9hZEpTXG5cdCAqIHNob3VsZCBoYW5kbGUgdGhlIG1ham9yaXR5IG9mIHN0YW5kYXJkIGZpbGUgYW5kIHVybCBmb3JtYXRzLCBhbmQgd29ya3Mgd2l0aCBjb21tb24gZmlsZSBleHRlbnNpb25zLiBJZiB5b3UgaGF2ZVxuXHQgKiBlaXRoZXIgYSBub24tc3RhbmRhcmQgZmlsZSBleHRlbnNpb24sIG9yIGFyZSBzZXJ2aW5nIHRoZSBmaWxlIHVzaW5nIGEgcHJveHkgc2NyaXB0LCB0aGVuIHlvdSBjYW4gcGFzcyBpbiBhXG5cdCAqIDxjb2RlPnR5cGU8L2NvZGU+IHByb3BlcnR5IHdpdGggYW55IG1hbmlmZXN0IGl0ZW0uXG5cdCAqXG5cdCAqICAgICAgcXVldWUubG9hZEZpbGUoe3NyYzpcInBhdGgvdG8vbXlGaWxlLm1wM3hcIiwgdHlwZTpjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TT1VORH0pO1xuXHQgKlxuXHQgKiAgICAgIC8vIE5vdGUgdGhhdCBQcmVsb2FkSlMgd2lsbCBub3QgcmVhZCBhIGZpbGUgZXh0ZW5zaW9uIGZyb20gdGhlIHF1ZXJ5IHN0cmluZ1xuXHQgKiAgICAgIHF1ZXVlLmxvYWRGaWxlKHtzcmM6XCJodHRwOi8vc2VydmVyLmNvbS9wcm94eT9maWxlPWltYWdlLmpwZ1wiLCB0eXBlOmNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLklNQUdFfSk7XG5cdCAqXG5cdCAqIFN1cHBvcnRlZCB0eXBlcyBhcmUgZGVmaW5lZCBvbiB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MsIGFuZCBpbmNsdWRlOlxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvQklOQVJZOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBSYXcgYmluYXJ5IGRhdGEgdmlhIFhIUjwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvQ1NTOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBDU1MgZmlsZXM8L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0lNQUdFOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBDb21tb24gaW1hZ2UgZm9ybWF0czwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSkFWQVNDUklQVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogSmF2YVNjcmlwdCBmaWxlczwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSlNPTjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogSlNPTiBkYXRhPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9KU09OUDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogSlNPTiBmaWxlcyBjcm9zcy1kb21haW48L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL01BTklGRVNUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBBIGxpc3Qgb2YgZmlsZXMgdG8gbG9hZCBpbiBKU09OIGZvcm1hdCwgc2VlXG5cdCAqICAgICB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX08L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1NPVU5EOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBBdWRpbyBmaWxlIGZvcm1hdHM8L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1NQUklURVNIRUVUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBKU09OIFNwcml0ZVNoZWV0IGRlZmluaXRpb25zLiBUaGlzXG5cdCAqICAgICB3aWxsIGFsc28gbG9hZCBzdWItaW1hZ2VzLCBhbmQgcHJvdmlkZSBhIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0XCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlLjwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvU1ZHOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBTVkcgZmlsZXM8L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1RFWFQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IFRleHQgZmlsZXMgLSBYSFIgb25seTwvbGk+XG4gICAgICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9WSURFTzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogVmlkZW8gb2JqZWN0czwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvWE1MOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBYTUwgZGF0YTwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqIDxlbT5Ob3RlOiBMb2FkZXIgdHlwZXMgdXNlZCB0byBiZSBkZWZpbmVkIG9uIExvYWRRdWV1ZSwgYnV0IGhhdmUgYmVlbiBtb3ZlZCB0byBBYnN0cmFjdExvYWRlciBmb3IgYmV0dGVyXG5cdCAqIHBvcnRhYmlsaXR5IG9mIGxvYWRlciBjbGFzc2VzLCB3aGljaCBjYW4gYmUgdXNlZCBpbmRpdmlkdWFsbHkgbm93LiBUaGUgcHJvcGVydGllcyBvbiBMb2FkUXVldWUgc3RpbGwgZXhpc3QsIGJ1dFxuXHQgKiBhcmUgZGVwcmVjYXRlZC48L2VtPlxuXHQgKlxuXHQgKiA8Yj5IYW5kbGluZyBSZXN1bHRzPC9iPjxiciAvPlxuXHQgKiBXaGVuIGEgZmlsZSBpcyBmaW5pc2hlZCBkb3dubG9hZGluZywgYSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZWxvYWQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgaXNcblx0ICogZGlzcGF0Y2hlZC4gSW4gYW4gZXhhbXBsZSBhYm92ZSwgdGhlcmUgaXMgYW4gZXZlbnQgbGlzdGVuZXIgc25pcHBldCBmb3IgZmlsZWxvYWQuIExvYWRlZCBmaWxlcyBhcmUgdXN1YWxseSBhXG5cdCAqIGZvcm1hdHRlZCBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBpbW1lZGlhdGVseSwgaW5jbHVkaW5nOlxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+QmluYXJ5OiBUaGUgYmluYXJ5IGxvYWRlZCByZXN1bHQ8L2xpPlxuXHQgKiAgICAgPGxpPkNTUzogQSAmbHQ7bGluayAvJmd0OyB0YWc8L2xpPlxuXHQgKiAgICAgPGxpPkltYWdlOiBBbiAmbHQ7aW1nIC8mZ3Q7IHRhZzwvbGk+XG5cdCAqICAgICA8bGk+SmF2YVNjcmlwdDogQSAmbHQ7c2NyaXB0IC8mZ3Q7IHRhZzwvbGk+XG5cdCAqICAgICA8bGk+SlNPTi9KU09OUDogQSBmb3JtYXR0ZWQgSmF2YVNjcmlwdCBPYmplY3Q8L2xpPlxuXHQgKiAgICAgPGxpPk1hbmlmZXN0OiBBIEphdmFTY3JpcHQgb2JqZWN0LlxuXHQgKiAgICAgPGxpPlNvdW5kOiBBbiAmbHQ7YXVkaW8gLyZndDsgdGFnPC9hPlxuXHQgKiAgICAgPGxpPlNwcml0ZVNoZWV0OiBBIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0XCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlLCBjb250YWluaW5nIGxvYWRlZCBpbWFnZXMuXG5cdCAqICAgICA8bGk+U1ZHOiBBbiAmbHQ7b2JqZWN0IC8mZ3Q7IHRhZzwvbGk+XG5cdCAqICAgICA8bGk+VGV4dDogUmF3IHRleHQ8L2xpPlxuICAgICAqICAgICA8bGk+VmlkZW86IEEgVmlkZW8gRE9NIG5vZGU8L2xpPlxuXHQgKiAgICAgPGxpPlhNTDogQW4gWE1MIERPTSBub2RlPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVGaWxlTG9hZChldmVudCkge1xuXHQgKiAgICAgICAgICB2YXIgaXRlbSA9IGV2ZW50Lml0ZW07IC8vIEEgcmVmZXJlbmNlIHRvIHRoZSBpdGVtIHRoYXQgd2FzIHBhc3NlZCBpbiB0byB0aGUgTG9hZFF1ZXVlXG5cdCAqICAgICAgICAgIHZhciB0eXBlID0gaXRlbS50eXBlO1xuXHQgKlxuXHQgKiAgICAgICAgICAvLyBBZGQgYW55IGltYWdlcyB0byB0aGUgcGFnZSBib2R5LlxuXHQgKiAgICAgICAgICBpZiAodHlwZSA9PSBjcmVhdGVqcy5Mb2FkUXVldWUuSU1BR0UpIHtcblx0ICogICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZXZlbnQucmVzdWx0KTtcblx0ICogICAgICAgICAgfVxuXHQgKiAgICAgIH1cblx0ICpcblx0ICogQXQgYW55IHRpbWUgYWZ0ZXIgdGhlIGZpbGUgaGFzIGJlZW4gbG9hZGVkICh1c3VhbGx5IGFmdGVyIHRoZSBxdWV1ZSBoYXMgY29tcGxldGVkKSwgYW55IHJlc3VsdCBjYW4gYmUgbG9va2VkIHVwXG5cdCAqIHZpYSBpdHMgXCJpZFwiIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9nZXRSZXN1bHRcIn19e3svY3Jvc3NMaW5rfX0uIElmIG5vIGlkIHdhcyBwcm92aWRlZCwgdGhlbiB0aGVcblx0ICogXCJzcmNcIiBvciBmaWxlIHBhdGggY2FuIGJlIHVzZWQgaW5zdGVhZCwgaW5jbHVkaW5nIHRoZSBgcGF0aGAgZGVmaW5lZCBieSBhIG1hbmlmZXN0LCBidXQgPHN0cm9uZz5ub3QgaW5jbHVkaW5nPC9zdHJvbmc+XG5cdCAqIGEgYmFzZSBwYXRoIGRlZmluZWQgb24gdGhlIExvYWRRdWV1ZS4gSXQgaXMgcmVjb21tZW5kZWQgdG8gYWx3YXlzIHBhc3MgYW4gaWQgaWYgeW91IHdhbnQgdG8gbG9vayB1cCBjb250ZW50LlxuXHQgKlxuXHQgKiAgICAgIHZhciBpbWFnZSA9IHF1ZXVlLmdldFJlc3VsdChcImltYWdlXCIpO1xuXHQgKiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW1hZ2UpO1xuXHQgKlxuXHQgKiBSYXcgbG9hZGVkIGNvbnRlbnQgY2FuIGJlIGFjY2Vzc2VkIHVzaW5nIHRoZSA8Y29kZT5yYXdSZXN1bHQ8L2NvZGU+IHByb3BlcnR5IG9mIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZWxvYWQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQsIG9yIGNhbiBiZSBsb29rZWQgdXAgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2dldFJlc3VsdFwifX17ey9jcm9zc0xpbmt9fSwgcGFzc2luZyBgdHJ1ZWAgYXMgdGhlIDJuZFxuXHQgKiBhcmd1bWVudC4gVGhpcyBpcyBvbmx5IGFwcGxpY2FibGUgZm9yIGNvbnRlbnQgdGhhdCBoYXMgYmVlbiBwYXJzZWQgZm9yIHRoZSBicm93c2VyLCBzcGVjaWZpY2FsbHk6IEphdmFTY3JpcHQsXG5cdCAqIENTUywgWE1MLCBTVkcsIGFuZCBKU09OIG9iamVjdHMsIG9yIGFueXRoaW5nIGxvYWRlZCB3aXRoIFhIUi5cblx0ICpcblx0ICogICAgICB2YXIgaW1hZ2UgPSBxdWV1ZS5nZXRSZXN1bHQoXCJpbWFnZVwiLCB0cnVlKTsgLy8gbG9hZCB0aGUgYmluYXJ5IGltYWdlIGRhdGEgbG9hZGVkIHdpdGggWEhSLlxuXHQgKlxuXHQgKiA8Yj5QbHVnaW5zPC9iPjxiciAvPlxuXHQgKiBMb2FkUXVldWUgaGFzIGEgc2ltcGxlIHBsdWdpbiBhcmNoaXRlY3R1cmUgdG8gaGVscCBwcm9jZXNzIGFuZCBwcmVsb2FkIGNvbnRlbnQuIEZvciBleGFtcGxlLCB0byBwcmVsb2FkIGF1ZGlvLFxuXHQgKiBtYWtlIHN1cmUgdG8gaW5zdGFsbCB0aGUgPGEgaHJlZj1cImh0dHA6Ly9zb3VuZGpzLmNvbVwiPlNvdW5kSlM8L2E+IFNvdW5kIGNsYXNzLCB3aGljaCB3aWxsIGhlbHAgbG9hZCBIVE1MIGF1ZGlvLFxuXHQgKiBGbGFzaCBhdWRpbywgYW5kIFdlYkF1ZGlvIGZpbGVzLiBUaGlzIHNob3VsZCBiZSBpbnN0YWxsZWQgPHN0cm9uZz5iZWZvcmU8L3N0cm9uZz4gbG9hZGluZyBhbnkgYXVkaW8gZmlsZXMuXG5cdCAqXG5cdCAqICAgICAgcXVldWUuaW5zdGFsbFBsdWdpbihjcmVhdGVqcy5Tb3VuZCk7XG5cdCAqXG5cdCAqIDxoND5Lbm93biBCcm93c2VyIElzc3VlczwvaDQ+XG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT5Ccm93c2VycyB3aXRob3V0IGF1ZGlvIHN1cHBvcnQgY2FuIG5vdCBsb2FkIGF1ZGlvIGZpbGVzLjwvbGk+XG5cdCAqICAgICA8bGk+U2FmYXJpIG9uIE1hYyBPUyBYIGNhbiBvbmx5IHBsYXkgSFRNTCBhdWRpbyBpZiBRdWlja1RpbWUgaXMgaW5zdGFsbGVkPC9saT5cblx0ICogICAgIDxsaT5IVE1MIEF1ZGlvIHRhZ3Mgd2lsbCBvbmx5IGRvd25sb2FkIHVudGlsIHRoZWlyIDxjb2RlPmNhblBsYXlUaHJvdWdoPC9jb2RlPiBldmVudCBpcyBmaXJlZC4gQnJvd3NlcnMgb3RoZXJcblx0ICogICAgIHRoYW4gQ2hyb21lIHdpbGwgY29udGludWUgdG8gZG93bmxvYWQgaW4gdGhlIGJhY2tncm91bmQuPC9saT5cblx0ICogICAgIDxsaT5XaGVuIGxvYWRpbmcgc2NyaXB0cyB1c2luZyB0YWdzLCB0aGV5IGFyZSBhdXRvbWF0aWNhbGx5IGFkZGVkIHRvIHRoZSBkb2N1bWVudC48L2xpPlxuXHQgKiAgICAgPGxpPlNjcmlwdHMgbG9hZGVkIHZpYSBYSFIgbWF5IG5vdCBiZSBwcm9wZXJseSBpbnNwZWN0YWJsZSB3aXRoIGJyb3dzZXIgdG9vbHMuPC9saT5cblx0ICogICAgIDxsaT5JRTYgYW5kIElFNyAoYW5kIHNvbWUgb3RoZXIgYnJvd3NlcnMpIG1heSBub3QgYmUgYWJsZSB0byBsb2FkIFhNTCwgVGV4dCwgb3IgSlNPTiwgc2luY2UgdGhleSByZXF1aXJlXG5cdCAqICAgICBYSFIgdG8gd29yay48L2xpPlxuXHQgKiAgICAgPGxpPkNvbnRlbnQgbG9hZGVkIHZpYSB0YWdzIHdpbGwgbm90IHNob3cgcHJvZ3Jlc3MsIGFuZCB3aWxsIGNvbnRpbnVlIHRvIGRvd25sb2FkIGluIHRoZSBiYWNrZ3JvdW5kIHdoZW5cblx0ICogICAgIGNhbmNlbGVkLCBhbHRob3VnaCBubyBldmVudHMgd2lsbCBiZSBkaXNwYXRjaGVkLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqIEBjbGFzcyBMb2FkUXVldWVcblx0ICogQHBhcmFtIHtCb29sZWFufSBbcHJlZmVyWEhSPXRydWVdIERldGVybWluZXMgd2hldGhlciB0aGUgcHJlbG9hZCBpbnN0YW5jZSB3aWxsIGZhdm9yIGxvYWRpbmcgd2l0aCBYSFIgKFhNTCBIVFRQXG5cdCAqIFJlcXVlc3RzKSwgb3IgSFRNTCB0YWdzLiBXaGVuIHRoaXMgaXMgYGZhbHNlYCwgdGhlIHF1ZXVlIHdpbGwgdXNlIHRhZyBsb2FkaW5nIHdoZW4gcG9zc2libGUsIGFuZCBmYWxsIGJhY2sgb24gWEhSXG5cdCAqIHdoZW4gbmVjZXNzYXJ5LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2Jhc2VQYXRoPVwiXCJdIEEgcGF0aCB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIG9uIHRvIHRoZSBzb3VyY2UgcGFyYW1ldGVyIG9mIGFsbCBpdGVtcyBpbiB0aGUgcXVldWVcblx0ICogYmVmb3JlIHRoZXkgYXJlIGxvYWRlZC4gIFNvdXJjZXMgYmVnaW5uaW5nIHdpdGggYSBwcm90b2NvbCBzdWNoIGFzIGBodHRwOi8vYCBvciBhIHJlbGF0aXZlIHBhdGggc3VjaCBhcyBgLi4vYFxuXHQgKiB3aWxsIG5vdCByZWNlaXZlIGEgYmFzZSBwYXRoLlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xCb29sZWFufSBbY3Jvc3NPcmlnaW49XCJcIl0gQW4gb3B0aW9uYWwgZmxhZyB0byBzdXBwb3J0IGltYWdlcyBsb2FkZWQgZnJvbSBhIENPUlMtZW5hYmxlZCBzZXJ2ZXIuIFRvXG5cdCAqIHVzZSBpdCwgc2V0IHRoaXMgdmFsdWUgdG8gYHRydWVgLCB3aGljaCB3aWxsIGRlZmF1bHQgdGhlIGNyb3NzT3JpZ2luIHByb3BlcnR5IG9uIGltYWdlcyB0byBcIkFub255bW91c1wiLiBBbnlcblx0ICogc3RyaW5nIHZhbHVlIHdpbGwgYmUgcGFzc2VkIHRocm91Z2gsIGJ1dCBvbmx5IFwiXCIgYW5kIFwiQW5vbnltb3VzXCIgYXJlIHJlY29tbWVuZGVkLiA8c3Ryb25nPk5vdGU6IFRoZSBjcm9zc09yaWdpblxuXHQgKiBwYXJhbWV0ZXIgaXMgZGVwcmVjYXRlZC4gVXNlIExvYWRJdGVtLmNyb3NzT3JpZ2luIGluc3RlYWQ8L3N0cm9uZz5cblx0ICpcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqL1xuXHRmdW5jdGlvbiBMb2FkUXVldWUgKHByZWZlclhIUiwgYmFzZVBhdGgsIGNyb3NzT3JpZ2luKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3RvcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgb2YgdGhlIHBsdWdpbnMgcmVnaXN0ZXJlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvaW5zdGFsbFBsdWdpblwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgX3BsdWdpbnNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAc2luY2UgMC42LjFcblx0XHQgKi9cblx0XHR0aGlzLl9wbHVnaW5zID0gW107XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3QgaGFzaCBvZiBjYWxsYmFja3MgdGhhdCBhcmUgZmlyZWQgZm9yIGVhY2ggZmlsZSB0eXBlIGJlZm9yZSB0aGUgZmlsZSBpcyBsb2FkZWQsIGdpdmluZyBwbHVnaW5zIHRoZVxuXHRcdCAqIGFiaWxpdHkgdG8gb3ZlcnJpZGUgcHJvcGVydGllcyBvZiB0aGUgbG9hZC4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2luc3RhbGxQbHVnaW5cIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBtZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdFx0ICogQHByb3BlcnR5IF90eXBlQ2FsbGJhY2tzXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3R5cGVDYWxsYmFja3MgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBoYXNoIG9mIGNhbGxiYWNrcyB0aGF0IGFyZSBmaXJlZCBmb3IgZWFjaCBmaWxlIGV4dGVuc2lvbiBiZWZvcmUgdGhlIGZpbGUgaXMgbG9hZGVkLCBnaXZpbmcgcGx1Z2lucyB0aGVcblx0XHQgKiBhYmlsaXR5IHRvIG92ZXJyaWRlIHByb3BlcnRpZXMgb2YgdGhlIGxvYWQuIFBsZWFzZSBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9pbnN0YWxsUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogbWV0aG9kIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSBfZXh0ZW5zaW9uQ2FsbGJhY2tzXG5cdFx0ICogQHR5cGUge251bGx9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9leHRlbnNpb25DYWxsYmFja3MgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBuZXh0IHByZWxvYWQgcXVldWUgdG8gcHJvY2VzcyB3aGVuIHRoaXMgb25lIGlzIGNvbXBsZXRlLiBJZiBhbiBlcnJvciBpcyB0aHJvd24gaW4gdGhlIGN1cnJlbnQgcXVldWUsIGFuZFxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zdG9wT25FcnJvcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpcyBgdHJ1ZWAsIHRoZSBuZXh0IHF1ZXVlIHdpbGwgbm90IGJlIHByb2Nlc3NlZC5cblx0XHQgKiBAcHJvcGVydHkgbmV4dFxuXHRcdCAqIEB0eXBlIHtMb2FkUXVldWV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMubmV4dCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBFbnN1cmUgbG9hZGVkIHNjcmlwdHMgXCJjb21wbGV0ZVwiIGluIHRoZSBvcmRlciB0aGV5IGFyZSBzcGVjaWZpZWQuIExvYWRlZCBzY3JpcHRzIGFyZSBhZGRlZCB0byB0aGUgZG9jdW1lbnQgaGVhZFxuXHRcdCAqIG9uY2UgdGhleSBhcmUgbG9hZGVkLiBTY3JpcHRzIGxvYWRlZCB2aWEgdGFncyB3aWxsIGxvYWQgb25lLWF0LWEtdGltZSB3aGVuIHRoaXMgcHJvcGVydHkgaXMgYHRydWVgLCB3aGVyZWFzXG5cdFx0ICogc2NyaXB0cyBsb2FkZWQgdXNpbmcgWEhSIGNhbiBsb2FkIGluIGFueSBvcmRlciwgYnV0IHdpbGwgXCJmaW5pc2hcIiBhbmQgYmUgYWRkZWQgdG8gdGhlIGRvY3VtZW50IGluIHRoZSBvcmRlclxuXHRcdCAqIHNwZWNpZmllZC5cblx0XHQgKlxuXHRcdCAqIEFueSBpdGVtcyBjYW4gYmUgc2V0IHRvIGxvYWQgaW4gb3JkZXIgYnkgc2V0dGluZyB0aGUge3sjY3Jvc3NMaW5rIFwibWFpbnRhaW5PcmRlcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIHByb3BlcnR5IG9uIHRoZSBsb2FkIGl0ZW0sIG9yIGJ5IGVuc3VyaW5nIHRoYXQgb25seSBvbmUgY29ubmVjdGlvbiBjYW4gYmUgb3BlbiBhdCBhIHRpbWUgdXNpbmdcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc2V0TWF4Q29ubmVjdGlvbnNcIn19e3svY3Jvc3NMaW5rfX0uIE5vdGUgdGhhdCB3aGVuIHRoZSBgbWFpbnRhaW5TY3JpcHRPcmRlcmAgcHJvcGVydHlcblx0XHQgKiBpcyBzZXQgdG8gYHRydWVgLCBzY3JpcHRzIGl0ZW1zIGFyZSBhdXRvbWF0aWNhbGx5IHNldCB0byBgbWFpbnRhaW5PcmRlcj10cnVlYCwgYW5kIGNoYW5naW5nIHRoZVxuXHRcdCAqIGBtYWludGFpblNjcmlwdE9yZGVyYCB0byBgZmFsc2VgIGR1cmluZyBhIGxvYWQgd2lsbCBub3QgY2hhbmdlIGl0ZW1zIGFscmVhZHkgaW4gYSBxdWV1ZS5cblx0XHQgKlxuXHRcdCAqIDxoND5FeGFtcGxlPC9oND5cblx0XHQgKlxuXHRcdCAqICAgICAgdmFyIHF1ZXVlID0gbmV3IGNyZWF0ZWpzLkxvYWRRdWV1ZSgpO1xuXHRcdCAqICAgICAgcXVldWUuc2V0TWF4Q29ubmVjdGlvbnMoMyk7IC8vIFNldCBhIGhpZ2hlciBudW1iZXIgdG8gbG9hZCBtdWx0aXBsZSBpdGVtcyBhdCBvbmNlXG5cdFx0ICogICAgICBxdWV1ZS5tYWludGFpblNjcmlwdE9yZGVyID0gdHJ1ZTsgLy8gRW5zdXJlIHNjcmlwdHMgYXJlIGxvYWRlZCBpbiBvcmRlclxuXHRcdCAqICAgICAgcXVldWUubG9hZE1hbmlmZXN0KFtcblx0XHQgKiAgICAgICAgICBcInNjcmlwdDEuanNcIixcblx0XHQgKiAgICAgICAgICBcInNjcmlwdDIuanNcIixcblx0XHQgKiAgICAgICAgICBcImltYWdlLnBuZ1wiLCAvLyBMb2FkIGFueSB0aW1lXG5cdFx0ICogICAgICAgICAge3NyYzogXCJpbWFnZTIucG5nXCIsIG1haW50YWluT3JkZXI6IHRydWV9IC8vIFdpbGwgd2FpdCBmb3Igc2NyaXB0Mi5qc1xuXHRcdCAqICAgICAgICAgIFwiaW1hZ2UzLnBuZ1wiLFxuXHRcdCAqICAgICAgICAgIFwic2NyaXB0My5qc1wiIC8vIFdpbGwgd2FpdCBmb3IgaW1hZ2UyLnBuZyBiZWZvcmUgbG9hZGluZyAob3IgY29tcGxldGluZyB3aGVuIGxvYWRpbmcgd2l0aCBYSFIpXG5cdFx0ICogICAgICBdKTtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBtYWludGFpblNjcmlwdE9yZGVyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdHRoaXMubWFpbnRhaW5TY3JpcHRPcmRlciA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBMb2FkUXVldWUgd2lsbCBzdG9wIHByb2Nlc3NpbmcgdGhlIGN1cnJlbnQgcXVldWUgd2hlbiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZC5cblx0XHQgKiBAcHJvcGVydHkgc3RvcE9uRXJyb3Jcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMuc3RvcE9uRXJyb3IgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBudW1iZXIgb2YgbWF4aW11bSBvcGVuIGNvbm5lY3Rpb25zIHRoYXQgYSBsb2FkUXVldWUgdHJpZXMgdG8gbWFpbnRhaW4uIFBsZWFzZSBzZWVcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc2V0TWF4Q29ubmVjdGlvbnNcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdFx0ICogQHByb3BlcnR5IF9tYXhDb25uZWN0aW9uc1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbWF4Q29ubmVjdGlvbnMgPSAxO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gaW50ZXJuYWwgbGlzdCBvZiBhbGwgdGhlIGRlZmF1bHQgTG9hZGVycyB0aGF0IGFyZSBpbmNsdWRlZCB3aXRoIFByZWxvYWRKUy4gQmVmb3JlIGFuIGl0ZW0gaXMgbG9hZGVkLCB0aGVcblx0XHQgKiBhdmFpbGFibGUgbG9hZGVyIGxpc3QgaXMgaXRlcmF0ZWQsIGluIHRoZSBvcmRlciB0aGV5IGFyZSBpbmNsdWRlZCwgYW5kIGFzIHNvb24gYXMgYSBsb2FkZXIgaW5kaWNhdGVzIGl0IGNhblxuXHRcdCAqIGhhbmRsZSB0aGUgY29udGVudCwgaXQgd2lsbCBiZSBzZWxlY3RlZC4gVGhlIGRlZmF1bHQgbG9hZGVyLCAoe3sjY3Jvc3NMaW5rIFwiVGV4dExvYWRlclwifX17ey9jcm9zc0xpbmt9fSBpc1xuXHRcdCAqIGxhc3QgaW4gdGhlIGxpc3QsIHNvIGl0IHdpbGwgYmUgdXNlZCBpZiBubyBvdGhlciBtYXRjaCBpcyBmb3VuZC4gVHlwaWNhbGx5LCBsb2FkZXJzIHdpbGwgbWF0Y2ggYmFzZWQgb24gdGhlXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vdHlwZVwifX17ey9jcm9zc0xpbmt9fSwgd2hpY2ggaXMgYXV0b21hdGljYWxseSBkZXRlcm1pbmVkIHVzaW5nIHRoZSBmaWxlIGV4dGVuc2lvbiBvZlxuXHRcdCAqIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS9zcmM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICpcblx0XHQgKiBMb2FkZXJzIGNhbiBiZSByZW1vdmVkIGZyb20gUHJlbG9hZEpTIGJ5IHNpbXBseSBub3QgaW5jbHVkaW5nIHRoZW0uXG5cdFx0ICpcblx0XHQgKiBDdXN0b20gbG9hZGVycyBpbnN0YWxsZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwicmVnaXN0ZXJMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gd2lsbCBiZSBwcmVwZW5kZWQgdG8gdGhpcyBsaXN0XG5cdFx0ICogc28gdGhhdCB0aGV5IGFyZSBjaGVja2VkIGZpcnN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBfYXZhaWxhYmxlTG9hZGVyc1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBzaW5jZSAwLjYuMFxuXHRcdCAqL1xuXHRcdHRoaXMuX2F2YWlsYWJsZUxvYWRlcnMgPSBbXG5cdFx0XHRjcmVhdGVqcy5JbWFnZUxvYWRlcixcblx0XHRcdGNyZWF0ZWpzLkphdmFTY3JpcHRMb2FkZXIsXG5cdFx0XHRjcmVhdGVqcy5DU1NMb2FkZXIsXG5cdFx0XHRjcmVhdGVqcy5KU09OTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuSlNPTlBMb2FkZXIsXG5cdFx0XHRjcmVhdGVqcy5Tb3VuZExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLk1hbmlmZXN0TG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuU3ByaXRlU2hlZXRMb2FkZXIsXG5cdFx0XHRjcmVhdGVqcy5YTUxMb2FkZXIsXG5cdFx0XHRjcmVhdGVqcy5TVkdMb2FkZXIsXG5cdFx0XHRjcmVhdGVqcy5CaW5hcnlMb2FkZXIsXG5cdFx0XHRjcmVhdGVqcy5WaWRlb0xvYWRlcixcblx0XHRcdGNyZWF0ZWpzLlRleHRMb2FkZXJcblx0XHRdO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBidWlsdCBpbiBsb2FkZXJzLCBzbyB0aGV5IGNhbid0IGJlIHJlbW92ZWQgYnkge3sjY3Jvc3NMaW5rIFwidW5yZWdpc3RlckxvYWRlclwifX17ey9jcm9zc0xpbmt9LlxuXHRcdFx0XHQgKiBAcHJvcGVydHkgX2RlZmF1bHRMb2FkZXJMZW5ndGhcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHNpbmNlIDAuNi4wXG5cdFx0ICovXG5cdFx0dGhpcy5fZGVmYXVsdExvYWRlckxlbmd0aCA9IHRoaXMuX2F2YWlsYWJsZUxvYWRlcnMubGVuZ3RoO1xuXG5cdFx0dGhpcy5pbml0KHByZWZlclhIUiwgYmFzZVBhdGgsIGNyb3NzT3JpZ2luKTtcblx0fVxuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKExvYWRRdWV1ZSwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IExvYWRRdWV1ZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblx0LyoqXG5cdCAqIEFuIGludGVybmFsIGluaXRpYWxpemF0aW9uIG1ldGhvZCwgd2hpY2ggaXMgdXNlZCBmb3IgaW5pdGlhbCBzZXQgdXAsIGJ1dCBhbHNvIHRvIHJlc2V0IHRoZSBMb2FkUXVldWUuXG5cdCAqIEBtZXRob2QgaW5pdFxuXHQgKiBAcGFyYW0gcHJlZmVyWEhSXG5cdCAqIEBwYXJhbSBiYXNlUGF0aFxuXHQgKiBAcGFyYW0gY3Jvc3NPcmlnaW5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuaW5pdCA9IGZ1bmN0aW9uIChwcmVmZXJYSFIsIGJhc2VQYXRoLCBjcm9zc09yaWdpbikge1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgdXNlWEhSXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqIEBkZXByZWNhdGVkIFVzZSBwcmVmZXJYSFIgaW5zdGVhZC5cblx0XHQgKi9cblx0XHR0aGlzLnVzZVhIUiA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBUcnkgYW5kIHVzZSBYTUxIdHRwUmVxdWVzdCAoWEhSKSB3aGVuIHBvc3NpYmxlLiBOb3RlIHRoYXQgTG9hZFF1ZXVlIHdpbGwgZGVmYXVsdCB0byB0YWcgbG9hZGluZyBvciBYSFJcblx0XHQgKiBsb2FkaW5nIGRlcGVuZGluZyBvbiB0aGUgcmVxdWlyZW1lbnRzIGZvciBhIG1lZGlhIHR5cGUuIEZvciBleGFtcGxlLCBIVE1MIGF1ZGlvIGNhbiBub3QgYmUgbG9hZGVkIHdpdGggWEhSLFxuXHRcdCAqIGFuZCBwbGFpbiB0ZXh0IGNhbiBub3QgYmUgbG9hZGVkIHdpdGggdGFncywgc28gaXQgd2lsbCBkZWZhdWx0IHRoZSB0aGUgY29ycmVjdCB0eXBlIGluc3RlYWQgb2YgdXNpbmcgdGhlXG5cdFx0ICogdXNlci1kZWZpbmVkIHR5cGUuXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqIEBzaW5jZSAwLjYuMFxuXHRcdCAqL1xuXHRcdHRoaXMucHJlZmVyWEhSID0gdHJ1ZTsgLy9UT0RPOiBHZXQvU2V0XG5cdFx0dGhpcy5fcHJlZmVyWEhSID0gdHJ1ZTtcblx0XHR0aGlzLnNldFByZWZlclhIUihwcmVmZXJYSFIpO1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRoZSBxdWV1ZSBpcyBjdXJyZW50bHkgcGF1c2VkIG9yIG5vdC5cblx0XHQgKiBAcHJvcGVydHkgX3BhdXNlZFxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBBIHBhdGggdGhhdCB3aWxsIGJlIHByZXBlbmRlZCBvbiB0byB0aGUgaXRlbSdzIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL3NyYzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS4gVGhlXG5cdFx0ICogYF9iYXNlUGF0aGAgcHJvcGVydHkgd2lsbCBvbmx5IGJlIHVzZWQgaWYgYW4gaXRlbSdzIHNvdXJjZSBpcyByZWxhdGl2ZSwgYW5kIGRvZXMgbm90IGluY2x1ZGUgYSBwcm90b2NvbCBzdWNoXG5cdFx0ICogYXMgYGh0dHA6Ly9gLCBvciBhIHJlbGF0aXZlIHBhdGggc3VjaCBhcyBgLi4vYC5cblx0XHQgKiBAcHJvcGVydHkgX2Jhc2VQYXRoXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBzaW5jZSAwLjMuMVxuXHRcdCAqL1xuXHRcdHRoaXMuX2Jhc2VQYXRoID0gYmFzZVBhdGg7XG5cblx0XHQvKipcblx0XHQgKiBBbiBvcHRpb25hbCBmbGFnIHRvIHNldCBvbiBpbWFnZXMgdGhhdCBhcmUgbG9hZGVkIHVzaW5nIFByZWxvYWRKUywgd2hpY2ggZW5hYmxlcyBDT1JTIHN1cHBvcnQuIEltYWdlcyBsb2FkZWRcblx0XHQgKiBjcm9zcy1kb21haW4gYnkgc2VydmVycyB0aGF0IHN1cHBvcnQgQ09SUyByZXF1aXJlIHRoZSBjcm9zc09yaWdpbiBmbGFnIHRvIGJlIGxvYWRlZCBhbmQgaW50ZXJhY3RlZCB3aXRoIGJ5XG5cdFx0ICogYSBjYW52YXMuIFdoZW4gbG9hZGluZyBsb2NhbGx5LCBvciB3aXRoIGEgc2VydmVyIHdpdGggbm8gQ09SUyBzdXBwb3J0LCB0aGlzIGZsYWcgY2FuIGNhdXNlIG90aGVyIHNlY3VyaXR5IGlzc3Vlcyxcblx0XHQgKiBzbyBpdCBpcyByZWNvbW1lbmRlZCB0byBvbmx5IHNldCBpdCBpZiB5b3UgYXJlIHN1cmUgdGhlIHNlcnZlciBzdXBwb3J0cyBpdC4gQ3VycmVudGx5LCBzdXBwb3J0ZWQgdmFsdWVzIGFyZSBcIlwiXG5cdFx0ICogYW5kIFwiQW5vbnltb3VzXCIuXG5cdFx0ICogQHByb3BlcnR5IF9jcm9zc09yaWdpblxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgXCJcIlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHNpbmNlIDAuNC4xXG5cdFx0ICovXG5cdFx0dGhpcy5fY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcblxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRTdGFydCBldmVudCB3YXMgZGlzcGF0Y2hlZCBhbHJlYWR5LiBUaGlzIGV2ZW50IGlzIG9ubHkgZmlyZWQgb25lIHRpbWUsIHdoZW4gdGhlIGZpcnN0XG5cdFx0ICogZmlsZSBpcyByZXF1ZXN0ZWQuXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkU3RhcnRXYXNEaXNwYXRjaGVkXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRTdGFydFdhc0Rpc3BhdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZXMgaWYgdGhlcmUgaXMgY3VycmVudGx5IGEgc2NyaXB0IGxvYWRpbmcuIFRoaXMgaGVscHMgZW5zdXJlIHRoYXQgb25seSBhIHNpbmdsZSBzY3JpcHQgbG9hZHMgYXQgb25jZSB3aGVuXG5cdFx0ICogdXNpbmcgYSBzY3JpcHQgdGFnIHRvIGRvIHByZWxvYWRpbmcuXG5cdFx0ICogQHByb3BlcnR5IF9jdXJyZW50bHlMb2FkaW5nU2NyaXB0XG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9jdXJyZW50bHlMb2FkaW5nU2NyaXB0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGN1cnJlbnRseSBkb3dubG9hZGluZyBmaWxlcy5cblx0XHQgKiBAcHJvcGVydHkgX2N1cnJlbnRMb2Fkc1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2N1cnJlbnRMb2FkcyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgY29udGFpbmluZyB0aGUgcXVldWVkIGl0ZW1zIHRoYXQgaGF2ZSBub3QgeWV0IHN0YXJ0ZWQgZG93bmxvYWRpbmcuXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkUXVldWVcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkUXVldWUgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IGNvbnRhaW5pbmcgZG93bmxvYWRzIHRoYXQgaGF2ZSBub3QgY29tcGxldGVkLCBzbyB0aGF0IHRoZSBMb2FkUXVldWUgY2FuIGJlIHByb3Blcmx5IHJlc2V0LlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZFF1ZXVlQmFja3VwXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZFF1ZXVlQmFja3VwID0gW107XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3QgaGFzaCBvZiBpdGVtcyB0aGF0IGhhdmUgZmluaXNoZWQgZG93bmxvYWRpbmcsIGluZGV4ZWQgYnkgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogaWQuXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkSXRlbXNCeUlkXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRJdGVtc0J5SWQgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBoYXNoIG9mIGl0ZW1zIHRoYXQgaGF2ZSBmaW5pc2hlZCBkb3dubG9hZGluZywgaW5kZXhlZCBieSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIHNvdXJjZS5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRJdGVtc0J5U3JjXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRJdGVtc0J5U3JjID0ge307XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3QgaGFzaCBvZiBsb2FkZWQgaXRlbXMsIGluZGV4ZWQgYnkgdGhlIElEIG9mIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRlZFJlc3VsdHNcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZGVkUmVzdWx0cyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IGhhc2ggb2YgdW4tcGFyc2VkIGxvYWRlZCBpdGVtcywgaW5kZXhlZCBieSB0aGUgSUQgb2YgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZGVkUmF3UmVzdWx0c1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkZWRSYXdSZXN1bHRzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRoYXQgaGF2ZSBiZWVuIHJlcXVlc3RlZC4gVGhpcyBoZWxwcyBtYW5hZ2UgYW4gb3ZlcmFsbCBwcm9ncmVzcyB3aXRob3V0IGtub3dpbmcgaG93IGxhcmdlXG5cdFx0ICogdGhlIGZpbGVzIGFyZSBiZWZvcmUgdGhleSBhcmUgZG93bmxvYWRlZC4gVGhpcyBkb2VzIG5vdCBpbmNsdWRlIGl0ZW1zIGluc2lkZSBvZiBsb2FkZXJzIHN1Y2ggYXMgdGhlXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IF9udW1JdGVtc1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbnVtSXRlbXMgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBpdGVtcyB0aGF0IGhhdmUgY29tcGxldGVkIGxvYWRlZC4gVGhpcyBoZWxwcyBtYW5hZ2UgYW4gb3ZlcmFsbCBwcm9ncmVzcyB3aXRob3V0IGtub3dpbmcgaG93IGxhcmdlXG5cdFx0ICogdGhlIGZpbGVzIGFyZSBiZWZvcmUgdGhleSBhcmUgZG93bmxvYWRlZC5cblx0XHQgKiBAcHJvcGVydHkgX251bUl0ZW1zTG9hZGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9udW1JdGVtc0xvYWRlZCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBBIGxpc3Qgb2Ygc2NyaXB0cyBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIHJlcXVlc3RlZC4gVGhpcyBoZWxwcyBlbnN1cmUgdGhhdCBzY3JpcHRzIGFyZSBcImNvbXBsZXRlZFwiIGluIHRoZSByaWdodFxuXHRcdCAqIG9yZGVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBfc2NyaXB0T3JkZXJcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9zY3JpcHRPcmRlciA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBsaXN0IG9mIHNjcmlwdHMgdGhhdCBoYXZlIGJlZW4gbG9hZGVkLiBJdGVtcyBhcmUgYWRkZWQgdG8gdGhpcyBsaXN0IGFzIDxjb2RlPm51bGw8L2NvZGU+IHdoZW4gdGhleSBhcmVcblx0XHQgKiByZXF1ZXN0ZWQsIGNvbnRhaW4gdGhlIGxvYWRlZCBpdGVtIGlmIGl0IGhhcyBjb21wbGV0ZWQsIGJ1dCBub3QgYmVlbiBkaXNwYXRjaGVkIHRvIHRoZSB1c2VyLCBhbmQgPGNvZGU+dHJ1ZTwvdHJ1ZT5cblx0XHQgKiBvbmNlIHRoZXkgYXJlIGNvbXBsZXRlIGFuZCBoYXZlIGJlZW4gZGlzcGF0Y2hlZC5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRlZFNjcmlwdHNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkZWRTY3JpcHRzID0gW107XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbGFzdCBwcm9ncmVzcyBhbW91bnQuIFRoaXMgaXMgdXNlZCB0byBzdXBwcmVzcyBkdXBsaWNhdGUgcHJvZ3Jlc3MgZXZlbnRzLlxuXHRcdCAqIEBwcm9wZXJ0eSBfbGFzdFByb2dyZXNzXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBzaW5jZSAwLjYuMFxuXHRcdCAqL1xuXHRcdHRoaXMuX2xhc3RQcm9ncmVzcyA9IE5hTjtcblxuXHR9O1xuXG4vLyBzdGF0aWMgcHJvcGVydGllc1xuXHQvKipcblx0ICogVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIGFzc3VtZSBhIGxvYWQgaGFzIGZhaWxlZC4gQW4ge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvZXJyb3I6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgaXMgZGlzcGF0Y2hlZCBpZiB0aGUgdGltZW91dCBpcyByZWFjaGVkIGJlZm9yZSBhbnkgZGF0YSBpcyByZWNlaXZlZC5cblx0ICogQHByb3BlcnR5IGxvYWRUaW1lb3V0XG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDgwMDBcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC40LjFcblx0ICogQGRlcHJlY2F0ZWQgSW4gZmF2b3VyIG9mIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL0xPQURfVElNRU9VVF9ERUZBVUxUOnByb3BlcnR5fX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eS5cblx0ICovXG5cdHMubG9hZFRpbWVvdXQgPSA4MDAwO1xuXG5cdC8qKlxuXHQgKiBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdG8gYXNzdW1lIGEgbG9hZCBoYXMgZmFpbGVkLlxuXHQgKiBAcHJvcGVydHkgTE9BRF9USU1FT1VUXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDBcblx0ICogQGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkVGltZW91dDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eS5cblx0ICovXG5cdHMuTE9BRF9USU1FT1VUID0gMDtcblxuLy8gUHJlbG9hZCBUeXBlc1xuXHQvKipcblx0ICogQHByb3BlcnR5IEJJTkFSWVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBiaW5hcnlcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0JJTkFSWTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5CSU5BUlkgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5CSU5BUlk7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBDU1Ncblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgY3NzXG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9DU1M6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuQ1NTID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuQ1NTO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgSU1BR0Vcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgaW1hZ2Vcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0NTUzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5JTUFHRSA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLklNQUdFO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgSkFWQVNDUklQVFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBqYXZhc2NyaXB0XG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9KQVZBU0NSSVBUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLkpBVkFTQ1JJUFQgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KQVZBU0NSSVBUO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgSlNPTlxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBqc29uXG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9KU09OOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLkpTT04gPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KU09OO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgSlNPTlBcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQganNvbnBcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pTT05QOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLkpTT05QID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSlNPTlA7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBNQU5JRkVTVFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBtYW5pZmVzdFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL01BTklGRVNUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLk1BTklGRVNUID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuTUFOSUZFU1Q7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBTT1VORFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBzb3VuZFxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSkFWQVNDUklQVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5TT1VORCA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNPVU5EO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgVklERU9cblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgdmlkZW9cblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pBVkFTQ1JJUFQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuVklERU8gPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5WSURFTztcblxuXHQvKipcblx0ICogQHByb3BlcnR5IFNWR1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBzdmdcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1NWRzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5TVkcgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TVkc7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBURVhUXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHRleHRcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1RFWFQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuVEVYVCA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlRFWFQ7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBYTUxcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgeG1sXG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9YTUw6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuWE1MID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuWE1MO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgUE9TVFxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1BPU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuUE9TVCA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlBPU1Q7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBHRVRcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9HRVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuR0VUID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuR0VUO1xuXG4vLyBldmVudHNcblx0LyoqXG5cdCAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhbiBpbmRpdmlkdWFsIGZpbGUgaGFzIGxvYWRlZCwgYW5kIGJlZW4gcHJvY2Vzc2VkLlxuXHQgKiBAZXZlbnQgZmlsZWxvYWRcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBUaGUgZmlsZSBpdGVtIHdoaWNoIHdhcyBzcGVjaWZpZWQgaW4gdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBvciB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319IGNhbGwuIElmIG9ubHkgYSBzdHJpbmcgcGF0aCBvciB0YWcgd2FzIHNwZWNpZmllZCwgdGhlXG5cdCAqIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhhdCB2YWx1ZSBhcyBhIGBzcmNgIHByb3BlcnR5LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0IFRoZSBIVE1MIHRhZyBvciBwYXJzZWQgcmVzdWx0IG9mIHRoZSBsb2FkZWQgaXRlbS5cblx0ICogQHBhcmFtIHtPYmplY3R9IHJhd1Jlc3VsdCBUaGUgdW5wcm9jZXNzZWQgcmVzdWx0LCB1c3VhbGx5IHRoZSByYXcgdGV4dCBvciBiaW5hcnkgZGF0YSBiZWZvcmUgaXQgaXMgY29udmVydGVkXG5cdCAqIHRvIGEgdXNhYmxlIG9iamVjdC5cblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGlzIHt7I2Nyb3NzTGluayBcIlByb2dyZXNzRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCB3aGVuIGFuIGFuIGluZGl2aWR1YWwgZmlsZSdzIHByb2dyZXNzIGNoYW5nZXMuXG5cdCAqIEBldmVudCBmaWxlcHJvZ3Jlc3Ncblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gYW4gaW5kaXZpZHVhbCBmaWxlIHN0YXJ0cyB0byBsb2FkLlxuXHQgKiBAZXZlbnQgZmlsZXN0YXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBUaGUgZmlsZSBpdGVtIHdoaWNoIHdhcyBzcGVjaWZpZWQgaW4gdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBvciB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319IGNhbGwuIElmIG9ubHkgYSBzdHJpbmcgcGF0aCBvciB0YWcgd2FzIHNwZWNpZmllZCwgdGhlXG5cdCAqIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhhdCB2YWx1ZSBhcyBhIHByb3BlcnR5LlxuXHQgKi9cblxuXHQvKipcblx0ICogQWx0aG91Z2ggaXQgZXh0ZW5kcyB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlclwifX17ey9jcm9zc0xpbmt9fSwgdGhlIGBpbml0aWFsaXplYCBldmVudCBpcyBuZXZlciBmaXJlZCBmcm9tXG5cdCAqIGEgTG9hZFF1ZXVlIGluc3RhbmNlLlxuXHQgKiBAZXZlbnQgaW5pdGlhbGl6ZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblxuLy8gcHVibGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIFJlZ2lzdGVyIGEgY3VzdG9tIGxvYWRlcnMgY2xhc3MuIE5ldyBsb2FkZXJzIGFyZSBnaXZlbiBwcmVjZWRlbmNlIG92ZXIgbG9hZGVycyBhZGRlZCBlYXJsaWVyIGFuZCBkZWZhdWx0IGxvYWRlcnMuXG5cdCAqIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgbG9hZGVycyBleHRlbmQge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uIExvYWRlcnMgY2FuIG9ubHkgYmUgYWRkZWRcblx0ICogb25jZSwgYW5kIHdpbGwgYmUgcHJlcGVuZGVkIHRvIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSBsb2FkZXJzLlxuXHQgKiBAbWV0aG9kIHJlZ2lzdGVyTG9hZGVyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb258QWJzdHJhY3RMb2FkZXJ9IGxvYWRlciBUaGUgQWJzdHJhY3RMb2FkZXIgY2xhc3MgdG8gYWRkLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAucmVnaXN0ZXJMb2FkZXIgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0aWYgKCFsb2FkZXIgfHwgIWxvYWRlci5jYW5Mb2FkSXRlbSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibG9hZGVyIGlzIG9mIGFuIGluY29ycmVjdCB0eXBlLlwiKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMuX2F2YWlsYWJsZUxvYWRlcnMuaW5kZXhPZihsb2FkZXIpICE9IC0xKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJsb2FkZXIgYWxyZWFkeSBleGlzdHMuXCIpOyAvL0xNOiBNYXliZSBqdXN0IHNpbGVudGx5IGZhaWwgaGVyZVxuXHRcdH1cblxuXHRcdHRoaXMuX2F2YWlsYWJsZUxvYWRlcnMudW5zaGlmdChsb2FkZXIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYSBjdXN0b20gbG9hZGVyIGFkZGVkIHVzaW5nIHt7I2Nyb3NzTGluayBcInJlZ2lzdGVyTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LiBPbmx5IGN1c3RvbSBsb2FkZXJzIGNhbiBiZVxuXHQgKiB1bnJlZ2lzdGVyZWQsIHRoZSBkZWZhdWx0IGxvYWRlcnMgd2lsbCBhbHdheXMgYmUgYXZhaWxhYmxlLlxuXHQgKiBAbWV0aG9kIHVucmVnaXN0ZXJMb2FkZXJcblx0ICogQHBhcmFtIHtGdW5jdGlvbnxBYnN0cmFjdExvYWRlcn0gbG9hZGVyIFRoZSBBYnN0cmFjdExvYWRlciBjbGFzcyB0byByZW1vdmVcblx0ICovXG5cdHAudW5yZWdpc3RlckxvYWRlciA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHR2YXIgaWR4ID0gdGhpcy5fYXZhaWxhYmxlTG9hZGVycy5pbmRleE9mKGxvYWRlcik7XG5cdFx0aWYgKGlkeCAhPSAtMSAmJiBpZHggPCB0aGlzLl9kZWZhdWx0TG9hZGVyTGVuZ3RoIC0gMSkge1xuXHRcdFx0dGhpcy5fYXZhaWxhYmxlTG9hZGVycy5zcGxpY2UoaWR4LCAxKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2Qgc2V0VXNlWEhSXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgVGhlIG5ldyB1c2VYSFIgdmFsdWUgdG8gc2V0LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUaGUgbmV3IHVzZVhIUiB2YWx1ZS4gSWYgWEhSIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIsIHRoaXMgd2lsbCByZXR1cm4gZmFsc2UsIGV2ZW4gaWZcblx0ICogdGhlIHByb3ZpZGVkIHZhbHVlIGFyZ3VtZW50IHdhcyB0cnVlLlxuXHQgKiBAc2luY2UgMC4zLjBcblx0ICogQGRlcHJlY2F0ZWQgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvcHJlZmVyWEhSOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5LCBvciB0aGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldFVzZVhIUlwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgaW5zdGVhZC5cblx0ICovXG5cdHAuc2V0VXNlWEhSID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0UHJlZmVyWEhSKHZhbHVlKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2hhbmdlIHRoZSB7eyNjcm9zc0xpbmsgXCJwcmVmZXJYSFI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gdmFsdWUuIE5vdGUgdGhhdCBpZiB0aGlzIGlzIHNldCB0byBgdHJ1ZWAsIGl0IG1heVxuXHQgKiBmYWlsLCBvciBiZSBpZ25vcmVkIGRlcGVuZGluZyBvbiB0aGUgYnJvd3NlcidzIGNhcGFiaWxpdGllcyBhbmQgdGhlIGxvYWQgdHlwZS5cblx0ICogQG1ldGhvZCBzZXRQcmVmZXJYSFJcblx0ICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVGhlIHZhbHVlIG9mIHt7I2Nyb3NzTGluayBcInByZWZlclhIUlwifX17ey9jcm9zc0xpbmt9fSB0aGF0IHdhcyBzdWNjZXNzZnVsbHkgc2V0LlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuc2V0UHJlZmVyWEhSID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHdlIGNhbiB1c2UgWEhSLiBYSFIgZGVmYXVsdHMgdG8gVFJVRSwgYnV0IHRoZSBicm93c2VyIG1heSBub3Qgc3VwcG9ydCBpdC5cblx0XHQvL1RPRE86IFNob3VsZCB3ZSBiZSBjaGVja2luZyBmb3IgdGhlIG90aGVyIFhIUiB0eXBlcz8gTWlnaHQgaGF2ZSB0byBkbyBhIHRyeS9jYXRjaCBvbiB0aGUgZGlmZmVyZW50IHR5cGVzIHNpbWlsYXIgdG8gY3JlYXRlWEhSLlxuXHRcdHRoaXMucHJlZmVyWEhSID0gKHZhbHVlICE9IGZhbHNlICYmIHdpbmRvdy5YTUxIdHRwUmVxdWVzdCAhPSBudWxsKTtcblx0XHRyZXR1cm4gdGhpcy5wcmVmZXJYSFI7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3BzIGFsbCBxdWV1ZWQgYW5kIGxvYWRpbmcgaXRlbXMsIGFuZCBjbGVhcnMgdGhlIHF1ZXVlLiBUaGlzIGFsc28gcmVtb3ZlcyBhbGwgaW50ZXJuYWwgcmVmZXJlbmNlcyB0byBsb2FkZWRcblx0ICogY29udGVudCwgYW5kIGFsbG93cyB0aGUgcXVldWUgdG8gYmUgdXNlZCBhZ2Fpbi5cblx0ICogQG1ldGhvZCByZW1vdmVBbGxcblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXHRwLnJlbW92ZUFsbCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnJlbW92ZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdG9wcyBhbiBpdGVtIGZyb20gYmVpbmcgbG9hZGVkLCBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBxdWV1ZS4gSWYgbm90aGluZyBpcyBwYXNzZWQsIGFsbCBpdGVtcyBhcmUgcmVtb3ZlZC5cblx0ICogVGhpcyBhbHNvIHJlbW92ZXMgaW50ZXJuYWwgcmVmZXJlbmNlcyB0byBsb2FkZWQgaXRlbShzKS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHF1ZXVlLmxvYWRNYW5pZmVzdChbXG5cdCAqICAgICAgICAgIHtzcmM6XCJ0ZXN0LnBuZ1wiLCBpZDpcInBuZ1wifSxcblx0ICogICAgICAgICAge3NyYzpcInRlc3QuanBnXCIsIGlkOlwianBnXCJ9LFxuXHQgKiAgICAgICAgICB7c3JjOlwidGVzdC5tcDNcIiwgaWQ6XCJtcDNcIn1cblx0ICogICAgICBdKTtcblx0ICogICAgICBxdWV1ZS5yZW1vdmUoXCJwbmdcIik7IC8vIFNpbmdsZSBpdGVtIGJ5IElEXG5cdCAqICAgICAgcXVldWUucmVtb3ZlKFwicG5nXCIsIFwidGVzdC5qcGdcIik7IC8vIEl0ZW1zIGFzIGFyZ3VtZW50cy4gTWl4ZWQgaWQgYW5kIHNyYy5cblx0ICogICAgICBxdWV1ZS5yZW1vdmUoW1widGVzdC5wbmdcIiwgXCJqcGdcIl0pOyAvLyBJdGVtcyBpbiBhbiBBcnJheS4gTWl4ZWQgaWQgYW5kIHNyYy5cblx0ICpcblx0ICogQG1ldGhvZCByZW1vdmVcblx0ICogQHBhcmFtIHtTdHJpbmcgfCBBcnJheX0gaWRzT3JVcmxzKiBUaGUgaWQgb3IgaWRzIHRvIHJlbW92ZSBmcm9tIHRoaXMgcXVldWUuIFlvdSBjYW4gcGFzcyBhbiBpdGVtLCBhbiBhcnJheSBvZlxuXHQgKiBpdGVtcywgb3IgbXVsdGlwbGUgaXRlbXMgYXMgYXJndW1lbnRzLlxuXHQgKiBAc2luY2UgMC4zLjBcblx0ICovXG5cdHAucmVtb3ZlID0gZnVuY3Rpb24gKGlkc09yVXJscykge1xuXHRcdHZhciBhcmdzID0gbnVsbDtcblxuXHRcdGlmIChpZHNPclVybHMgJiYgIUFycmF5LmlzQXJyYXkoaWRzT3JVcmxzKSkge1xuXHRcdFx0YXJncyA9IFtpZHNPclVybHNdO1xuXHRcdH0gZWxzZSBpZiAoaWRzT3JVcmxzKSB7XG5cdFx0XHRhcmdzID0gaWRzT3JVcmxzO1xuXHRcdH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgaXRlbXNXZXJlUmVtb3ZlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gRGVzdHJveSBldmVyeXRoaW5nXG5cdFx0aWYgKCFhcmdzKSB7XG5cdFx0XHR0aGlzLmNsb3NlKCk7XG5cdFx0XHRmb3IgKHZhciBuIGluIHRoaXMuX2xvYWRJdGVtc0J5SWQpIHtcblx0XHRcdFx0dGhpcy5fZGlzcG9zZUl0ZW0odGhpcy5fbG9hZEl0ZW1zQnlJZFtuXSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmluaXQodGhpcy5wcmVmZXJYSFIsIHRoaXMuX2Jhc2VQYXRoKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIHNwZWNpZmljIGl0ZW1zXG5cdFx0fSBlbHNlIHtcblx0XHRcdHdoaWxlIChhcmdzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgaXRlbSA9IGFyZ3MucG9wKCk7XG5cdFx0XHRcdHZhciByID0gdGhpcy5nZXRSZXN1bHQoaXRlbSk7XG5cblx0XHRcdFx0Ly9SZW1vdmUgZnJvbSB0aGUgbWFpbiBsb2FkIFF1ZXVlXG5cdFx0XHRcdGZvciAoaSA9IHRoaXMuX2xvYWRRdWV1ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdGxvYWRJdGVtID0gdGhpcy5fbG9hZFF1ZXVlW2ldLmdldEl0ZW0oKTtcblx0XHRcdFx0XHRpZiAobG9hZEl0ZW0uaWQgPT0gaXRlbSB8fCBsb2FkSXRlbS5zcmMgPT0gaXRlbSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fbG9hZFF1ZXVlLnNwbGljZShpLCAxKVswXS5jYW5jZWwoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vUmVtb3ZlIGZyb20gdGhlIGJhY2t1cCBxdWV1ZVxuXHRcdFx0XHRmb3IgKGkgPSB0aGlzLl9sb2FkUXVldWVCYWNrdXAubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRsb2FkSXRlbSA9IHRoaXMuX2xvYWRRdWV1ZUJhY2t1cFtpXS5nZXRJdGVtKCk7XG5cdFx0XHRcdFx0aWYgKGxvYWRJdGVtLmlkID09IGl0ZW0gfHwgbG9hZEl0ZW0uc3JjID09IGl0ZW0pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2xvYWRRdWV1ZUJhY2t1cC5zcGxpY2UoaSwgMSlbMF0uY2FuY2VsKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAocikge1xuXHRcdFx0XHRcdHRoaXMuX2Rpc3Bvc2VJdGVtKHRoaXMuZ2V0SXRlbShpdGVtKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IHRoaXMuX2N1cnJlbnRMb2Fkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdFx0dmFyIGxvYWRJdGVtID0gdGhpcy5fY3VycmVudExvYWRzW2ldLmdldEl0ZW0oKTtcblx0XHRcdFx0XHRcdGlmIChsb2FkSXRlbS5pZCA9PSBpdGVtIHx8IGxvYWRJdGVtLnNyYyA9PSBpdGVtKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2N1cnJlbnRMb2Fkcy5zcGxpY2UoaSwgMSlbMF0uY2FuY2VsKCk7XG5cdFx0XHRcdFx0XHRcdGl0ZW1zV2VyZVJlbW92ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyB3YXMgY2FsbGVkIGR1cmluZyBhIGxvYWQsIHRyeSB0byBsb2FkIHRoZSBuZXh0IGl0ZW0uXG5cdFx0XHRpZiAoaXRlbXNXZXJlUmVtb3ZlZCkge1xuXHRcdFx0XHR0aGlzLl9sb2FkTmV4dCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogU3RvcHMgYWxsIG9wZW4gbG9hZHMsIGRlc3Ryb3lzIGFueSBsb2FkZWQgaXRlbXMsIGFuZCByZXNldHMgdGhlIHF1ZXVlLCBzbyBhbGwgaXRlbXMgY2FuXG5cdCAqIGJlIHJlbG9hZGVkIGFnYWluIGJ5IGNhbGxpbmcge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvbG9hZFwifX17ey9jcm9zc0xpbmt9fS4gSXRlbXMgYXJlIG5vdCByZW1vdmVkIGZyb20gdGhlXG5cdCAqIHF1ZXVlLiBUbyByZW1vdmUgaXRlbXMgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvcmVtb3ZlXCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9yZW1vdmVBbGxcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuXHQgKiBAbWV0aG9kIHJlc2V0XG5cdCAqIEBzaW5jZSAwLjMuMFxuXHQgKi9cblx0cC5yZXNldCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmNsb3NlKCk7XG5cdFx0Zm9yICh2YXIgbiBpbiB0aGlzLl9sb2FkSXRlbXNCeUlkKSB7XG5cdFx0XHR0aGlzLl9kaXNwb3NlSXRlbSh0aGlzLl9sb2FkSXRlbXNCeUlkW25dKTtcblx0XHR9XG5cblx0XHQvL1Jlc2V0IHRoZSBxdWV1ZSB0byBpdHMgc3RhcnQgc3RhdGVcblx0XHR2YXIgYSA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fbG9hZFF1ZXVlQmFja3VwLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0YS5wdXNoKHRoaXMuX2xvYWRRdWV1ZUJhY2t1cFtpXS5nZXRJdGVtKCkpO1xuXHRcdH1cblxuXHRcdHRoaXMubG9hZE1hbmlmZXN0KGEsIGZhbHNlKTtcblx0fTtcblxuXHQvKipcblx0ICogUmVnaXN0ZXIgYSBwbHVnaW4uIFBsdWdpbnMgY2FuIG1hcCB0byBsb2FkIHR5cGVzIChzb3VuZCwgaW1hZ2UsIGV0YyksIG9yIHNwZWNpZmljIGV4dGVuc2lvbnMgKHBuZywgbXAzLCBldGMpLlxuXHQgKiBDdXJyZW50bHksIG9ubHkgb25lIHBsdWdpbiBjYW4gZXhpc3QgcGVyIHR5cGUvZXh0ZW5zaW9uLlxuXHQgKlxuXHQgKiBXaGVuIGEgcGx1Z2luIGlzIGluc3RhbGxlZCwgYSA8Y29kZT5nZXRQcmVsb2FkSGFuZGxlcnMoKTwvY29kZT4gbWV0aG9kIHdpbGwgYmUgY2FsbGVkIG9uIGl0LiBGb3IgbW9yZSBpbmZvcm1hdGlvblxuXHQgKiBvbiB0aGlzIG1ldGhvZCwgY2hlY2sgb3V0IHRoZSB7eyNjcm9zc0xpbmsgXCJTYW1wbGVQbHVnaW4vZ2V0UHJlbG9hZEhhbmRsZXJzXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCBpbiB0aGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiU2FtcGxlUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzLlxuXHQgKlxuXHQgKiBCZWZvcmUgYSBmaWxlIGlzIGxvYWRlZCwgYSBtYXRjaGluZyBwbHVnaW4gaGFzIGFuIG9wcG9ydHVuaXR5IHRvIG1vZGlmeSB0aGUgbG9hZC4gSWYgYSBgY2FsbGJhY2tgIGlzIHJldHVybmVkXG5cdCAqIGZyb20gdGhlIHt7I2Nyb3NzTGluayBcIlNhbXBsZVBsdWdpbi9nZXRQcmVsb2FkSGFuZGxlcnNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLCBpdCB3aWxsIGJlIGludm9rZWQgZmlyc3QsIGFuZCBpdHNcblx0ICogcmVzdWx0IG1heSBjYW5jZWwgb3IgbW9kaWZ5IHRoZSBpdGVtLiBUaGUgY2FsbGJhY2sgbWV0aG9kIGNhbiBhbHNvIHJldHVybiBhIGBjb21wbGV0ZUhhbmRsZXJgIHRvIGJlIGZpcmVkIHdoZW5cblx0ICogdGhlIGZpbGUgaXMgbG9hZGVkLCBvciBhIGB0YWdgIG9iamVjdCwgd2hpY2ggd2lsbCBtYW5hZ2UgdGhlIGFjdHVhbCBkb3dubG9hZC4gRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2Vcblx0ICogbWV0aG9kcywgY2hlY2sgb3V0IHRoZSB7eyNjcm9zc0xpbmsgXCJTYW1wbGVQbHVnaW4vcHJlbG9hZEhhbmRsZXJcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlNhbXBsZVBsdWdpbi9maWxlTG9hZEhhbmRsZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kcyBvbiB0aGUge3sjY3Jvc3NMaW5rIFwiU2FtcGxlUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluc3RhbGxQbHVnaW5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gcGx1Z2luIFRoZSBwbHVnaW4gY2xhc3MgdG8gaW5zdGFsbC5cblx0ICovXG5cdHAuaW5zdGFsbFBsdWdpbiA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcblx0XHRpZiAocGx1Z2luID09IG51bGwpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAocGx1Z2luLmdldFByZWxvYWRIYW5kbGVycyAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLl9wbHVnaW5zLnB1c2gocGx1Z2luKTtcblx0XHRcdHZhciBtYXAgPSBwbHVnaW4uZ2V0UHJlbG9hZEhhbmRsZXJzKCk7XG5cdFx0XHRtYXAuc2NvcGUgPSBwbHVnaW47XG5cblx0XHRcdGlmIChtYXAudHlwZXMgIT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG1hcC50eXBlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR0aGlzLl90eXBlQ2FsbGJhY2tzW21hcC50eXBlc1tpXV0gPSBtYXA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG1hcC5leHRlbnNpb25zICE9IG51bGwpIHtcblx0XHRcdFx0Zm9yIChpID0gMCwgbCA9IG1hcC5leHRlbnNpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHRoaXMuX2V4dGVuc2lvbkNhbGxiYWNrc1ttYXAuZXh0ZW5zaW9uc1tpXV0gPSBtYXA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgbWF4aW11bSBudW1iZXIgb2YgY29uY3VycmVudCBjb25uZWN0aW9ucy4gTm90ZSB0aGF0IGJyb3dzZXJzIGFuZCBzZXJ2ZXJzIG1heSBoYXZlIGEgYnVpbHQtaW4gbWF4aW11bVxuXHQgKiBudW1iZXIgb2Ygb3BlbiBjb25uZWN0aW9ucywgc28gYW55IGFkZGl0aW9uYWwgY29ubmVjdGlvbnMgbWF5IHJlbWFpbiBpbiBhIHBlbmRpbmcgc3RhdGUgdW50aWwgdGhlIGJyb3dzZXJcblx0ICogb3BlbnMgdGhlIGNvbm5lY3Rpb24uIFdoZW4gbG9hZGluZyBzY3JpcHRzIHVzaW5nIHRhZ3MsIGFuZCB3aGVuIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9tYWludGFpblNjcmlwdE9yZGVyOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGlzIGB0cnVlYCwgb25seSBvbmUgc2NyaXB0IGlzIGxvYWRlZCBhdCBhIHRpbWUgZHVlIHRvIGJyb3dzZXIgbGltaXRhdGlvbnMuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgcXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG5cdCAqICAgICAgcXVldWUuc2V0TWF4Q29ubmVjdGlvbnMoMTApOyAvLyBBbGxvdyAxMCBjb25jdXJyZW50IGxvYWRzXG5cdCAqXG5cdCAqIEBtZXRob2Qgc2V0TWF4Q29ubmVjdGlvbnNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgb2YgY29uY3VycmVudCBsb2FkcyB0byBhbGxvdy4gQnkgZGVmYXVsdCwgb25seSBhIHNpbmdsZSBjb25uZWN0aW9uIHBlciBMb2FkUXVldWVcblx0ICogaXMgb3BlbiBhdCBhbnkgdGltZS5cblx0ICovXG5cdHAuc2V0TWF4Q29ubmVjdGlvbnMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR0aGlzLl9tYXhDb25uZWN0aW9ucyA9IHZhbHVlO1xuXHRcdGlmICghdGhpcy5fcGF1c2VkICYmIHRoaXMuX2xvYWRRdWV1ZS5sZW5ndGggPiAwKSB7XG5cdFx0XHR0aGlzLl9sb2FkTmV4dCgpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogTG9hZCBhIHNpbmdsZSBmaWxlLiBUbyBhZGQgbXVsdGlwbGUgZmlsZXMgYXQgb25jZSwgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZC5cblx0ICpcblx0ICogRmlsZXMgYXJlIGFsd2F5cyBhcHBlbmRlZCB0byB0aGUgY3VycmVudCBxdWV1ZSwgc28gdGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgbXVsdGlwbGUgdGltZXMgdG8gYWRkIGZpbGVzLlxuXHQgKiBUbyBjbGVhciB0aGUgcXVldWUgZmlyc3QsIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvY2xvc2VcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuXHQgKiBAbWV0aG9kIGxvYWRGaWxlXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fFN0cmluZ30gZmlsZSBUaGUgZmlsZSBvYmplY3Qgb3IgcGF0aCB0byBsb2FkLiBBIGZpbGUgY2FuIGJlIGVpdGhlclxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+QSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZTwvbGk+XG5cdCAqICAgICA8bGk+QW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBkZWZpbmVkIGJ5IHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319PC9saT5cblx0ICogICAgIDxsaT5PUiBBIHN0cmluZyBwYXRoIHRvIGEgcmVzb3VyY2UuIE5vdGUgdGhhdCB0aGlzIGtpbmQgb2YgbG9hZCBpdGVtIHdpbGwgYmUgY29udmVydGVkIHRvIGEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX1cblx0ICogICAgIGluIHRoZSBiYWNrZ3JvdW5kLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2xvYWROb3c9dHJ1ZV0gS2ljayBvZmYgYW4gaW1tZWRpYXRlIGxvYWQgKHRydWUpIG9yIHdhaXQgZm9yIGEgbG9hZCBjYWxsIChmYWxzZSkuIFRoZSBkZWZhdWx0XG5cdCAqIHZhbHVlIGlzIHRydWUuIElmIHRoZSBxdWV1ZSBpcyBwYXVzZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldFBhdXNlZFwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHRoZSB2YWx1ZSBpc1xuXHQgKiBgdHJ1ZWAsIHRoZSBxdWV1ZSB3aWxsIHJlc3VtZSBhdXRvbWF0aWNhbGx5LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2Jhc2VQYXRoXSBBIGJhc2UgcGF0aCB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIHRvIGVhY2ggZmlsZS4gVGhlIGJhc2VQYXRoIGFyZ3VtZW50IG92ZXJyaWRlcyB0aGVcblx0ICogcGF0aCBzcGVjaWZpZWQgaW4gdGhlIGNvbnN0cnVjdG9yLiBOb3RlIHRoYXQgaWYgeW91IGxvYWQgYSBtYW5pZmVzdCB1c2luZyBhIGZpbGUgb2YgdHlwZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9NQU5JRkVTVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogaXRzIGZpbGVzIHdpbGwgPHN0cm9uZz5OT1Q8L3N0cm9uZz4gdXNlIHRoZSBiYXNlUGF0aCBwYXJhbWV0ZXIuIDxzdHJvbmc+VGhlIGJhc2VQYXRoIHBhcmFtZXRlciBpcyBkZXByZWNhdGVkLjwvc3Ryb25nPlxuXHQgKiBUaGlzIHBhcmFtZXRlciB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4gUGxlYXNlIGVpdGhlciB1c2UgdGhlIGBiYXNlUGF0aGAgcGFyYW1ldGVyIGluIHRoZSBMb2FkUXVldWVcblx0ICogY29uc3RydWN0b3IsIG9yIGEgYHBhdGhgIHByb3BlcnR5IGluIGEgbWFuaWZlc3QgZGVmaW5pdGlvbi5cblx0ICovXG5cdHAubG9hZEZpbGUgPSBmdW5jdGlvbiAoZmlsZSwgbG9hZE5vdywgYmFzZVBhdGgpIHtcblx0XHRpZiAoZmlsZSA9PSBudWxsKSB7XG5cdFx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlBSRUxPQURfTk9fRklMRVwiKTtcblx0XHRcdHRoaXMuX3NlbmRFcnJvcihldmVudCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuX2FkZEl0ZW0oZmlsZSwgbnVsbCwgYmFzZVBhdGgpO1xuXG5cdFx0aWYgKGxvYWROb3cgIT09IGZhbHNlKSB7XG5cdFx0XHR0aGlzLnNldFBhdXNlZChmYWxzZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2V0UGF1c2VkKHRydWUpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogTG9hZCBhbiBhcnJheSBvZiBmaWxlcy4gVG8gbG9hZCBhIHNpbmdsZSBmaWxlLCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG5cdCAqIFRoZSBmaWxlcyBpbiB0aGUgbWFuaWZlc3QgYXJlIHJlcXVlc3RlZCBpbiB0aGUgc2FtZSBvcmRlciwgYnV0IG1heSBjb21wbGV0ZSBpbiBhIGRpZmZlcmVudCBvcmRlciBpZiB0aGUgbWF4XG5cdCAqIGNvbm5lY3Rpb25zIGFyZSBzZXQgYWJvdmUgMSB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc2V0TWF4Q29ubmVjdGlvbnNcIn19e3svY3Jvc3NMaW5rfX0uIFNjcmlwdHMgd2lsbCBsb2FkXG5cdCAqIGluIHRoZSByaWdodCBvcmRlciBhcyBsb25nIGFzIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9tYWludGFpblNjcmlwdE9yZGVyXCJ9fXt7L2Nyb3NzTGlua319IGlzIHRydWUgKHdoaWNoIGlzXG5cdCAqIGRlZmF1bHQpLlxuXHQgKlxuXHQgKiBGaWxlcyBhcmUgYWx3YXlzIGFwcGVuZGVkIHRvIHRoZSBjdXJyZW50IHF1ZXVlLCBzbyB0aGlzIG1ldGhvZCBjYW4gYmUgdXNlZCBtdWx0aXBsZSB0aW1lcyB0byBhZGQgZmlsZXMuXG5cdCAqIFRvIGNsZWFyIHRoZSBxdWV1ZSBmaXJzdCwgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9jbG9zZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG5cdCAqIEBtZXRob2QgbG9hZE1hbmlmZXN0XG5cdCAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfE9iamVjdH0gbWFuaWZlc3QgQW4gbGlzdCBvZiBmaWxlcyB0byBsb2FkLiBUaGUgbG9hZE1hbmlmZXN0IGNhbGwgc3VwcG9ydHMgZm91ciB0eXBlcyBvZlxuXHQgKiBtYW5pZmVzdHM6XG5cdCAqIDxvbD5cblx0ICogICAgIDxsaT5BIHN0cmluZyBwYXRoLCB3aGljaCBwb2ludHMgdG8gYSBtYW5pZmVzdCBmaWxlLCB3aGljaCBpcyBhIEpTT04gZmlsZSB0aGF0IGNvbnRhaW5zIGEgXCJtYW5pZmVzdFwiIHByb3BlcnR5LFxuXHQgKiAgICAgd2hpY2ggZGVmaW5lcyB0aGUgbGlzdCBvZiBmaWxlcyB0byBsb2FkLCBhbmQgY2FuIG9wdGlvbmFsbHkgY29udGFpbiBhIFwicGF0aFwiIHByb3BlcnR5LCB3aGljaCB3aWxsIGJlXG5cdCAqICAgICBwcmVwZW5kZWQgdG8gZWFjaCBmaWxlIGluIHRoZSBsaXN0LjwvbGk+XG5cdCAqICAgICA8bGk+QW4gb2JqZWN0IHdoaWNoIGRlZmluZXMgYSBcInNyY1wiLCB3aGljaCBpcyBhIEpTT04gb3IgSlNPTlAgZmlsZS4gQSBcImNhbGxiYWNrXCIgY2FuIGJlIGRlZmluZWQgZm9yIEpTT05QXG5cdCAqICAgICBmaWxlLiBUaGUgSlNPTi9KU09OUCBmaWxlIHNob3VsZCBjb250YWluIGEgXCJtYW5pZmVzdFwiIHByb3BlcnR5LCB3aGljaCBkZWZpbmVzIHRoZSBsaXN0IG9mIGZpbGVzIHRvIGxvYWQsXG5cdCAqICAgICBhbmQgY2FuIG9wdGlvbmFsbHkgY29udGFpbiBhIFwicGF0aFwiIHByb3BlcnR5LCB3aGljaCB3aWxsIGJlIHByZXBlbmRlZCB0byBlYWNoIGZpbGUgaW4gdGhlIGxpc3QuPC9saT5cblx0ICogICAgIDxsaT5BbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgYSBcIm1hbmlmZXN0XCIgcHJvcGVydHksIHdoaWNoIGRlZmluZXMgdGhlIGxpc3Qgb2YgZmlsZXMgdG8gbG9hZCwgYW5kIGNhblxuXHQgKiAgICAgb3B0aW9uYWxseSBjb250YWluIGEgXCJwYXRoXCIgcHJvcGVydHksIHdoaWNoIHdpbGwgYmUgcHJlcGVuZGVkIHRvIGVhY2ggZmlsZSBpbiB0aGUgbGlzdC48L2xpPlxuXHQgKiAgICAgPGxpPkFuIEFycmF5IG9mIGZpbGVzIHRvIGxvYWQuPC9saT5cblx0ICogPC9vbD5cblx0ICpcblx0ICogRWFjaCBcImZpbGVcIiBpbiBhIG1hbmlmZXN0IGNhbiBiZSBlaXRoZXI6XG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT5BIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlPC9saT5cblx0ICogICAgIDxsaT5BbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGRlZmluZWQgYnkge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX08L2xpPlxuXHQgKiAgICAgPGxpPk9SIEEgc3RyaW5nIHBhdGggdG8gYSByZXNvdXJjZS4gTm90ZSB0aGF0IHRoaXMga2luZCBvZiBsb2FkIGl0ZW0gd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiAgICAgaW4gdGhlIGJhY2tncm91bmQuPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogQHBhcmFtIHtCb29sZWFufSBbbG9hZE5vdz10cnVlXSBLaWNrIG9mZiBhbiBpbW1lZGlhdGUgbG9hZCAodHJ1ZSkgb3Igd2FpdCBmb3IgYSBsb2FkIGNhbGwgKGZhbHNlKS4gVGhlIGRlZmF1bHRcblx0ICogdmFsdWUgaXMgdHJ1ZS4gSWYgdGhlIHF1ZXVlIGlzIHBhdXNlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc2V0UGF1c2VkXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB0aGlzIHZhbHVlIGlzXG5cdCAqIGB0cnVlYCwgdGhlIHF1ZXVlIHdpbGwgcmVzdW1lIGF1dG9tYXRpY2FsbHkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbYmFzZVBhdGhdIEEgYmFzZSBwYXRoIHRoYXQgd2lsbCBiZSBwcmVwZW5kZWQgdG8gZWFjaCBmaWxlLiBUaGUgYmFzZVBhdGggYXJndW1lbnQgb3ZlcnJpZGVzIHRoZVxuXHQgKiBwYXRoIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IuIE5vdGUgdGhhdCBpZiB5b3UgbG9hZCBhIG1hbmlmZXN0IHVzaW5nIGEgZmlsZSBvZiB0eXBlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9NQU5JRkVTVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogaXRzIGZpbGVzIHdpbGwgPHN0cm9uZz5OT1Q8L3N0cm9uZz4gdXNlIHRoZSBiYXNlUGF0aCBwYXJhbWV0ZXIuIDxzdHJvbmc+VGhlIGJhc2VQYXRoIHBhcmFtZXRlciBpcyBkZXByZWNhdGVkLjwvc3Ryb25nPlxuXHQgKiBUaGlzIHBhcmFtZXRlciB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4gUGxlYXNlIGVpdGhlciB1c2UgdGhlIGBiYXNlUGF0aGAgcGFyYW1ldGVyIGluIHRoZSBMb2FkUXVldWVcblx0ICogY29uc3RydWN0b3IsIG9yIGEgYHBhdGhgIHByb3BlcnR5IGluIGEgbWFuaWZlc3QgZGVmaW5pdGlvbi5cblx0ICovXG5cdHAubG9hZE1hbmlmZXN0ID0gZnVuY3Rpb24gKG1hbmlmZXN0LCBsb2FkTm93LCBiYXNlUGF0aCkge1xuXHRcdHZhciBmaWxlTGlzdCA9IG51bGw7XG5cdFx0dmFyIHBhdGggPSBudWxsO1xuXG5cdFx0Ly8gQXJyYXktYmFzZWQgbGlzdCBvZiBpdGVtc1xuXHRcdGlmIChBcnJheS5pc0FycmF5KG1hbmlmZXN0KSkge1xuXHRcdFx0aWYgKG1hbmlmZXN0Lmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9NQU5JRkVTVF9FTVBUWVwiKTtcblx0XHRcdFx0dGhpcy5fc2VuZEVycm9yKGV2ZW50KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0ZmlsZUxpc3QgPSBtYW5pZmVzdDtcblxuXHRcdFx0Ly8gU3RyaW5nLWJhc2VkLiBPbmx5IGZpbGUgbWFuaWZlc3RzIGNhbiBiZSBzcGVjaWZpZWQgdGhpcyB3YXkuIEFueSBvdGhlciB0eXBlcyB3aWxsIGNhdXNlIGFuIGVycm9yIHdoZW4gbG9hZGVkLlxuXHRcdH0gZWxzZSBpZiAodHlwZW9mKG1hbmlmZXN0KSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0ZmlsZUxpc3QgPSBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzcmM6IG1hbmlmZXN0LFxuXHRcdFx0XHRcdHR5cGU6IHMuTUFOSUZFU1Rcblx0XHRcdFx0fVxuXHRcdFx0XTtcblxuXHRcdH0gZWxzZSBpZiAodHlwZW9mKG1hbmlmZXN0KSA9PSBcIm9iamVjdFwiKSB7XG5cblx0XHRcdC8vIEFuIG9iamVjdCB0aGF0IGRlZmluZXMgYSBtYW5pZmVzdCBwYXRoXG5cdFx0XHRpZiAobWFuaWZlc3Quc3JjICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKG1hbmlmZXN0LnR5cGUgPT0gbnVsbCkge1xuXHRcdFx0XHRcdG1hbmlmZXN0LnR5cGUgPSBzLk1BTklGRVNUO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG1hbmlmZXN0LnR5cGUgIT0gcy5NQU5JRkVTVCkge1xuXHRcdFx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9NQU5JRkVTVF9UWVBFXCIpO1xuXHRcdFx0XHRcdHRoaXMuX3NlbmRFcnJvcihldmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZmlsZUxpc3QgPSBbbWFuaWZlc3RdO1xuXG5cdFx0XHRcdC8vIEFuIG9iamVjdCB0aGF0IGRlZmluZXMgYSBtYW5pZmVzdFxuXHRcdFx0fSBlbHNlIGlmIChtYW5pZmVzdC5tYW5pZmVzdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGZpbGVMaXN0ID0gbWFuaWZlc3QubWFuaWZlc3Q7XG5cdFx0XHRcdHBhdGggPSBtYW5pZmVzdC5wYXRoO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVbnN1cHBvcnRlZC4gVGhpcyB3aWxsIHRocm93IGFuIGVycm9yLlxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlBSRUxPQURfTUFOSUZFU1RfTlVMTFwiKTtcblx0XHRcdHRoaXMuX3NlbmRFcnJvcihldmVudCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBmaWxlTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHRoaXMuX2FkZEl0ZW0oZmlsZUxpc3RbaV0sIHBhdGgsIGJhc2VQYXRoKTtcblx0XHR9XG5cblx0XHRpZiAobG9hZE5vdyAhPT0gZmFsc2UpIHtcblx0XHRcdHRoaXMuc2V0UGF1c2VkKGZhbHNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZXRQYXVzZWQodHJ1ZSk7XG5cdFx0fVxuXG5cdH07XG5cblx0LyoqXG5cdCAqIFN0YXJ0IGEgTG9hZFF1ZXVlIHRoYXQgd2FzIGNyZWF0ZWQsIGJ1dCBub3QgYXV0b21hdGljYWxseSBzdGFydGVkLlxuXHQgKiBAbWV0aG9kIGxvYWRcblx0ICovXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnNldFBhdXNlZChmYWxzZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIExvb2sgdXAgYSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fSB1c2luZyBlaXRoZXIgdGhlIFwiaWRcIiBvciBcInNyY1wiIHRoYXQgd2FzIHNwZWNpZmllZCB3aGVuIGxvYWRpbmcgaXQuIE5vdGUgdGhhdCBpZiBubyBcImlkXCIgd2FzXG5cdCAqIHN1cHBsaWVkIHdpdGggdGhlIGxvYWQgaXRlbSwgdGhlIElEIHdpbGwgYmUgdGhlIFwic3JjXCIsIGluY2x1ZGluZyBhIGBwYXRoYCBwcm9wZXJ0eSBkZWZpbmVkIGJ5IGEgbWFuaWZlc3QuIFRoZVxuXHQgKiBgYmFzZVBhdGhgIHdpbGwgbm90IGJlIHBhcnQgb2YgdGhlIElELlxuXHQgKiBAbWV0aG9kIGdldEl0ZW1cblx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSA8Y29kZT5pZDwvY29kZT4gb3IgPGNvZGU+c3JjPC9jb2RlPiBvZiB0aGUgbG9hZCBpdGVtLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBsb2FkIGl0ZW0gdGhhdCB3YXMgaW5pdGlhbGx5IHJlcXVlc3RlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogb3Ige3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fS4gVGhpcyBvYmplY3QgaXMgYWxzbyByZXR1cm5lZCB2aWEgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBhcyB0aGUgYGl0ZW1gIHBhcmFtZXRlci5cblx0ICovXG5cdHAuZ2V0SXRlbSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHJldHVybiB0aGlzLl9sb2FkSXRlbXNCeUlkW3ZhbHVlXSB8fCB0aGlzLl9sb2FkSXRlbXNCeVNyY1t2YWx1ZV07XG5cdH07XG5cblx0LyoqXG5cdCAqIExvb2sgdXAgYSBsb2FkZWQgcmVzdWx0IHVzaW5nIGVpdGhlciB0aGUgXCJpZFwiIG9yIFwic3JjXCIgdGhhdCB3YXMgc3BlY2lmaWVkIHdoZW4gbG9hZGluZyBpdC4gTm90ZSB0aGF0IGlmIG5vIFwiaWRcIlxuXHQgKiB3YXMgc3VwcGxpZWQgd2l0aCB0aGUgbG9hZCBpdGVtLCB0aGUgSUQgd2lsbCBiZSB0aGUgXCJzcmNcIiwgaW5jbHVkaW5nIGEgYHBhdGhgIHByb3BlcnR5IGRlZmluZWQgYnkgYSBtYW5pZmVzdC4gVGhlXG5cdCAqIGBiYXNlUGF0aGAgd2lsbCBub3QgYmUgcGFydCBvZiB0aGUgSUQuXG5cdCAqIEBtZXRob2QgZ2V0UmVzdWx0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgPGNvZGU+aWQ8L2NvZGU+IG9yIDxjb2RlPnNyYzwvY29kZT4gb2YgdGhlIGxvYWQgaXRlbS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcmF3UmVzdWx0PWZhbHNlXSBSZXR1cm4gYSByYXcgcmVzdWx0IGluc3RlYWQgb2YgYSBmb3JtYXR0ZWQgcmVzdWx0LiBUaGlzIGFwcGxpZXMgdG8gY29udGVudFxuXHQgKiBsb2FkZWQgdmlhIFhIUiBzdWNoIGFzIHNjcmlwdHMsIFhNTCwgQ1NTLCBhbmQgSW1hZ2VzLiBJZiB0aGVyZSBpcyBubyByYXcgcmVzdWx0LCB0aGUgZm9ybWF0dGVkIHJlc3VsdCB3aWxsIGJlXG5cdCAqIHJldHVybmVkIGluc3RlYWQuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQSByZXN1bHQgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNvbnRlbnQgdGhhdCB3YXMgbG9hZGVkLCBzdWNoIGFzOlxuXHQgKiA8dWw+XG5cdCAqICAgICAgPGxpPkFuIGltYWdlIHRhZyAoJmx0O2ltYWdlIC8mZ3Q7KSBmb3IgaW1hZ2VzPC9saT5cblx0ICogICAgICA8bGk+QSBzY3JpcHQgdGFnIGZvciBKYXZhU2NyaXB0ICgmbHQ7c2NyaXB0IC8mZ3Q7KS4gTm90ZSB0aGF0IHNjcmlwdHMgYXJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG8gdGhlIEhUTUxcblx0ICogICAgICBET00uPC9saT5cblx0ICogICAgICA8bGk+QSBzdHlsZSB0YWcgZm9yIENTUyAoJmx0O3N0eWxlIC8mZ3Q7IG9yICZsdDtsaW5rICZndDspPC9saT5cblx0ICogICAgICA8bGk+UmF3IHRleHQgZm9yIFRFWFQ8L2xpPlxuXHQgKiAgICAgIDxsaT5BIGZvcm1hdHRlZCBKYXZhU2NyaXB0IG9iamVjdCBkZWZpbmVkIGJ5IEpTT048L2xpPlxuXHQgKiAgICAgIDxsaT5BbiBYTUwgZG9jdW1lbnQ8L2xpPlxuXHQgKiAgICAgIDxsaT5BIGJpbmFyeSBhcnJheWJ1ZmZlciBsb2FkZWQgYnkgWEhSPC9saT5cblx0ICogICAgICA8bGk+QW4gYXVkaW8gdGFnICgmbHQ7YXVkaW8gJmd0OykgZm9yIEhUTUwgYXVkaW8uIE5vdGUgdGhhdCBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgU291bmRKUyBBUElzIHRvIHBsYXlcblx0ICogICAgICBsb2FkZWQgYXVkaW8uIFNwZWNpZmljYWxseSwgYXVkaW8gbG9hZGVkIGJ5IEZsYXNoIGFuZCBXZWJBdWRpbyB3aWxsIHJldHVybiBhIGxvYWRlciBvYmplY3QgdXNpbmcgdGhpcyBtZXRob2Rcblx0ICogICAgICB3aGljaCBjYW4gbm90IGJlIHVzZWQgdG8gcGxheSBhdWRpbyBiYWNrLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqIFRoaXMgb2JqZWN0IGlzIGFsc28gcmV0dXJuZWQgdmlhIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZWxvYWQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgYXMgdGhlICdpdGVtYFxuXHQgKiBwYXJhbWV0ZXIuIE5vdGUgdGhhdCBpZiBhIHJhdyByZXN1bHQgaXMgcmVxdWVzdGVkLCBidXQgbm90IGZvdW5kLCB0aGUgcmVzdWx0IHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZC5cblx0ICovXG5cdHAuZ2V0UmVzdWx0ID0gZnVuY3Rpb24gKHZhbHVlLCByYXdSZXN1bHQpIHtcblx0XHR2YXIgaXRlbSA9IHRoaXMuX2xvYWRJdGVtc0J5SWRbdmFsdWVdIHx8IHRoaXMuX2xvYWRJdGVtc0J5U3JjW3ZhbHVlXTtcblx0XHRpZiAoaXRlbSA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0dmFyIGlkID0gaXRlbS5pZDtcblx0XHRpZiAocmF3UmVzdWx0ICYmIHRoaXMuX2xvYWRlZFJhd1Jlc3VsdHNbaWRdKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbG9hZGVkUmF3UmVzdWx0c1tpZF07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9sb2FkZWRSZXN1bHRzW2lkXTtcblx0fTtcblxuXHQvKipcblx0ICogR2VuZXJhdGUgYW4gbGlzdCBvZiBpdGVtcyBsb2FkZWQgYnkgdGhpcyBxdWV1ZS5cblx0ICogQG1ldGhvZCBnZXRJdGVtc1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGxvYWRlZCBEZXRlcm1pbmVzIGlmIG9ubHkgaXRlbXMgdGhhdCBoYXZlIGJlZW4gbG9hZGVkIHNob3VsZCBiZSByZXR1cm5lZC4gSWYgZmFsc2UsIGluLXByb2dyZXNzXG5cdCAqIGFuZCBmYWlsZWQgbG9hZCBpdGVtcyB3aWxsIGFsc28gYmUgaW5jbHVkZWQuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBsaXN0IG9mIG9iamVjdHMgdGhhdCBoYXZlIGJlZW4gbG9hZGVkLiBFYWNoIGl0ZW0gaW5jbHVkZXMgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiByZXN1bHQsIGFuZCByYXdSZXN1bHQuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5nZXRJdGVtcyA9IGZ1bmN0aW9uIChsb2FkZWQpIHtcblx0XHR2YXIgYXJyID0gW107XG5cdFx0Zm9yICh2YXIgbiBpbiB0aGlzLl9sb2FkSXRlbXNCeUlkKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHRoaXMuX2xvYWRJdGVtc0J5SWRbbl07XG5cdFx0XHR2YXIgcmVzdWx0ID0gdGhpcy5nZXRSZXN1bHQobik7XG5cdFx0XHRpZiAobG9hZGVkID09PSB0cnVlICYmIHJlc3VsdCA9PSBudWxsKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0YXJyLnB1c2goe1xuXHRcdFx0XHRpdGVtOiBpdGVtLFxuXHRcdFx0XHRyZXN1bHQ6IHJlc3VsdCxcblx0XHRcdFx0cmF3UmVzdWx0OiB0aGlzLmdldFJlc3VsdChuLCB0cnVlKVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBhcnI7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhdXNlIG9yIHJlc3VtZSB0aGUgY3VycmVudCBsb2FkLiBBY3RpdmUgbG9hZHMgd2lsbCBub3QgYmUgY2FuY2VsbGVkLCBidXQgdGhlIG5leHQgaXRlbXMgaW4gdGhlIHF1ZXVlIHdpbGwgbm90XG5cdCAqIGJlIHByb2Nlc3NlZCB3aGVuIGFjdGl2ZSBsb2FkcyBjb21wbGV0ZS4gTG9hZFF1ZXVlcyBhcmUgbm90IHBhdXNlZCBieSBkZWZhdWx0LlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgaWYgbmV3IGl0ZW1zIGFyZSBhZGRlZCB0byB0aGUgcXVldWUgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX0sIGEgcGF1c2VkIHF1ZXVlIHdpbGwgYmUgcmVzdW1lZCwgdW5sZXNzIHRoZSBgbG9hZE5vd2Bcblx0ICogYXJndW1lbnQgaXMgYGZhbHNlYC5cblx0ICogQG1ldGhvZCBzZXRQYXVzZWRcblx0ICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBXaGV0aGVyIHRoZSBxdWV1ZSBzaG91bGQgYmUgcGF1c2VkIG9yIG5vdC5cblx0ICovXG5cdHAuc2V0UGF1c2VkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dGhpcy5fcGF1c2VkID0gdmFsdWU7XG5cdFx0aWYgKCF0aGlzLl9wYXVzZWQpIHtcblx0XHRcdHRoaXMuX2xvYWROZXh0KCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbG9zZSB0aGUgYWN0aXZlIHF1ZXVlLiBDbG9zaW5nIGEgcXVldWUgY29tcGxldGVseSBlbXB0aWVzIHRoZSBxdWV1ZSwgYW5kIHByZXZlbnRzIGFueSByZW1haW5pbmcgaXRlbXMgZnJvbVxuXHQgKiBzdGFydGluZyB0byBkb3dubG9hZC4gTm90ZSB0aGF0IGN1cnJlbnRseSBhbnkgYWN0aXZlIGxvYWRzIHdpbGwgcmVtYWluIG9wZW4sIGFuZCBldmVudHMgbWF5IGJlIHByb2Nlc3NlZC5cblx0ICpcblx0ICogVG8gc3RvcCBhbmQgcmVzdGFydCBhIHF1ZXVlLCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRQYXVzZWRcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGluc3RlYWQuXG5cdCAqIEBtZXRob2QgY2xvc2Vcblx0ICovXG5cdHAuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0d2hpbGUgKHRoaXMuX2N1cnJlbnRMb2Fkcy5sZW5ndGgpIHtcblx0XHRcdHRoaXMuX2N1cnJlbnRMb2Fkcy5wb3AoKS5jYW5jZWwoKTtcblx0XHR9XG5cdFx0dGhpcy5fc2NyaXB0T3JkZXIubGVuZ3RoID0gMDtcblx0XHR0aGlzLl9sb2FkZWRTY3JpcHRzLmxlbmd0aCA9IDA7XG5cdFx0dGhpcy5sb2FkU3RhcnRXYXNEaXNwYXRjaGVkID0gZmFsc2U7XG5cdFx0dGhpcy5faXRlbUNvdW50ID0gMDtcblx0XHR0aGlzLl9sYXN0UHJvZ3Jlc3MgPSBOYU47XG5cdH07XG5cbi8vIHByb3RlY3RlZCBtZXRob2RzXG5cdC8qKlxuXHQgKiBBZGQgYW4gaXRlbSB0byB0aGUgcXVldWUuIEl0ZW1zIGFyZSBmb3JtYXR0ZWQgaW50byBhIHVzYWJsZSBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHByb3BlcnRpZXMgbmVjZXNzYXJ5IHRvXG5cdCAqIGxvYWQgdGhlIGNvbnRlbnQuIFRoZSBsb2FkIHF1ZXVlIGlzIHBvcHVsYXRlZCB3aXRoIHRoZSBsb2FkZXIgaW5zdGFuY2UgdGhhdCBoYW5kbGVzIHByZWxvYWRpbmcsIGFuZCBub3QgdGhlIGxvYWRcblx0ICogaXRlbSB0aGF0IHdhcyBwYXNzZWQgaW4gYnkgdGhlIHVzZXIuIFRvIGxvb2sgdXAgdGhlIGxvYWQgaXRlbSBieSBpZCBvciBzcmMsIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlLmdldEl0ZW1cIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLlxuXHQgKiBAbWV0aG9kIF9hZGRJdGVtXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdmFsdWUgVGhlIGl0ZW0gdG8gYWRkIHRvIHRoZSBxdWV1ZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXSBBbiBvcHRpb25hbCBwYXRoIHByZXBlbmRlZCB0byB0aGUgYHNyY2AuIFRoZSBwYXRoIHdpbGwgb25seSBiZSBwcmVwZW5kZWQgaWYgdGhlIHNyYyBpc1xuXHQgKiByZWxhdGl2ZSwgYW5kIGRvZXMgbm90IHN0YXJ0IHdpdGggYSBwcm90b2NvbCBzdWNoIGFzIGBodHRwOi8vYCwgb3IgYSBwYXRoIGxpa2UgYC4uL2AuIElmIHRoZSBMb2FkUXVldWUgd2FzXG5cdCAqIHByb3ZpZGVkIGEge3sjY3Jvc3NMaW5rIFwiX2Jhc2VQYXRoXCJ9fXt7L2Nyb3NzTGlua319LCB0aGVuIGl0IHdpbGwgb3B0aW9uYWxseSBiZSBwcmVwZW5kZWQgYWZ0ZXIuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbYmFzZVBhdGhdIDxzdHJvbmc+RGVwcmVjYXRlZDwvc3Ryb25nPkFuIG9wdGlvbmFsIGJhc2VQYXRoIHBhc3NlZCBpbnRvIGEge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBvciB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX0gY2FsbC4gVGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHRhZ2dlZFxuXHQgKiB2ZXJzaW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fYWRkSXRlbSA9IGZ1bmN0aW9uICh2YWx1ZSwgcGF0aCwgYmFzZVBhdGgpIHtcblx0XHR2YXIgaXRlbSA9IHRoaXMuX2NyZWF0ZUxvYWRJdGVtKHZhbHVlLCBwYXRoLCBiYXNlUGF0aCk7IC8vIGJhc2VQYXRoIGFuZCBtYW5pZmVzdCBwYXRoIGFyZSBhZGRlZCB0byB0aGUgc3JjLlxuXHRcdGlmIChpdGVtID09IG51bGwpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vIFNvbWV0aW1lcyBwbHVnaW5zIG9yIHR5cGVzIHNob3VsZCBiZSBza2lwcGVkLlxuXHRcdHZhciBsb2FkZXIgPSB0aGlzLl9jcmVhdGVMb2FkZXIoaXRlbSk7XG5cdFx0aWYgKGxvYWRlciAhPSBudWxsKSB7XG5cdFx0XHRpZiAoXCJwbHVnaW5zXCIgaW4gbG9hZGVyKSB7XG5cdFx0XHRcdGxvYWRlci5wbHVnaW5zID0gdGhpcy5fcGx1Z2lucztcblx0XHRcdH1cblx0XHRcdGl0ZW0uX2xvYWRlciA9IGxvYWRlcjtcblx0XHRcdHRoaXMuX2xvYWRRdWV1ZS5wdXNoKGxvYWRlcik7XG5cdFx0XHR0aGlzLl9sb2FkUXVldWVCYWNrdXAucHVzaChsb2FkZXIpO1xuXG5cdFx0XHR0aGlzLl9udW1JdGVtcysrO1xuXHRcdFx0dGhpcy5fdXBkYXRlUHJvZ3Jlc3MoKTtcblxuXHRcdFx0Ly8gT25seSB3b3JyeSBhYm91dCBzY3JpcHQgb3JkZXIgd2hlbiB1c2luZyBYSFIgdG8gbG9hZCBzY3JpcHRzLiBUYWdzIGFyZSBvbmx5IGxvYWRpbmcgb25lIGF0IGEgdGltZS5cblx0XHRcdGlmICgodGhpcy5tYWludGFpblNjcmlwdE9yZGVyXG5cdFx0XHRcdFx0JiYgaXRlbS50eXBlID09IGNyZWF0ZWpzLkxvYWRRdWV1ZS5KQVZBU0NSSVBUXG5cdFx0XHRcdFx0XHQvLyYmIGxvYWRlciBpbnN0YW5jZW9mIGNyZWF0ZWpzLlhIUkxvYWRlciAvL05PVEU6IEhhdmUgdG8gdHJhY2sgYWxsIEpTIGZpbGVzIHRoaXMgd2F5XG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdHx8IGl0ZW0ubWFpbnRhaW5PcmRlciA9PT0gdHJ1ZSkge1xuXHRcdFx0XHR0aGlzLl9zY3JpcHRPcmRlci5wdXNoKGl0ZW0pO1xuXHRcdFx0XHR0aGlzLl9sb2FkZWRTY3JpcHRzLnB1c2gobnVsbCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSByZWZpbmVkIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319LCB3aGljaCBjb250YWlucyBhbGwgdGhlIHJlcXVpcmVkIHByb3BlcnRpZXMuIFRoZSB0eXBlIG9mXG5cdCAqIGl0ZW0gaXMgZGV0ZXJtaW5lZCBieSBicm93c2VyIHN1cHBvcnQsIHJlcXVpcmVtZW50cyBiYXNlZCBvbiB0aGUgZmlsZSB0eXBlLCBhbmQgZGV2ZWxvcGVyIHNldHRpbmdzLiBGb3IgZXhhbXBsZSxcblx0ICogWEhSIGlzIG9ubHkgdXNlZCBmb3IgZmlsZSB0eXBlcyB0aGF0IHN1cHBvcnQgaXQgaW4gbmV3IGJyb3dzZXJzLlxuXHQgKlxuXHQgKiBCZWZvcmUgdGhlIGl0ZW0gaXMgcmV0dXJuZWQsIGFueSBwbHVnaW5zIHJlZ2lzdGVyZWQgdG8gaGFuZGxlIHRoZSB0eXBlIG9yIGV4dGVuc2lvbiB3aWxsIGJlIGZpcmVkLCB3aGljaCBtYXlcblx0ICogYWx0ZXIgdGhlIGxvYWQgaXRlbS5cblx0ICogQG1ldGhvZCBfY3JlYXRlTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtTdHJpbmcgfCBPYmplY3QgfCBIVE1MQXVkaW9FbGVtZW50IHwgSFRNTEltYWdlRWxlbWVudH0gdmFsdWUgVGhlIGl0ZW0gdGhhdCBuZWVkcyB0byBiZSBwcmVsb2FkZWQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF0gQSBwYXRoIHRvIHByZXBlbmQgdG8gdGhlIGl0ZW0ncyBzb3VyY2UuIFNvdXJjZXMgYmVnaW5uaW5nIHdpdGggaHR0cDovLyBvciBzaW1pbGFyIHdpbGxcblx0ICogbm90IHJlY2VpdmUgYSBwYXRoLiBTaW5jZSBQcmVsb2FkSlMgMC40LjEsIHRoZSBzcmMgd2lsbCBiZSBtb2RpZmllZCB0byBpbmNsdWRlIHRoZSBgcGF0aGAgYW5kIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9fYmFzZVBhdGg6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2hlbiBpdCBpcyBhZGRlZC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtiYXNlUGF0aF0gPHN0cm9uZz5EZXByZWN0YXRlZDwvc3Ryb25nPiBBIGJhc2UgcGF0aCB0byBwcmVwZW5kIHRvIHRoZSBpdGVtcyBzb3VyY2UgaW4gYWRkaXRpb24gdG9cblx0ICogdGhlIHBhdGggYXJndW1lbnQuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGxvYWRlciBpbnN0YW5jZSB0aGF0IHdpbGwgYmUgdXNlZC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NyZWF0ZUxvYWRJdGVtID0gZnVuY3Rpb24gKHZhbHVlLCBwYXRoLCBiYXNlUGF0aCkge1xuXHRcdHZhciBpdGVtID0gY3JlYXRlanMuTG9hZEl0ZW0uY3JlYXRlKHZhbHVlKTtcblx0XHRpZiAoaXRlbSA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR2YXIgYnAgPSBcIlwiOyAvLyBTdG9yZSB0aGUgZ2VuZXJhdGVkIGJhc2VQYXRoXG5cdFx0dmFyIHVzZUJhc2VQYXRoID0gYmFzZVBhdGggfHwgdGhpcy5fYmFzZVBhdGg7XG5cblx0XHRpZiAoaXRlbS5zcmMgaW5zdGFuY2VvZiBPYmplY3QpIHtcblx0XHRcdGlmICghaXRlbS50eXBlKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSAvLyB0aGUgdGhlIHNyYyBpcyBhbiBvYmplY3QsIHR5cGUgaXMgcmVxdWlyZWQgdG8gcGFzcyBvZmYgdG8gcGx1Z2luXG5cdFx0XHRpZiAocGF0aCkge1xuXHRcdFx0XHRicCA9IHBhdGg7XG5cdFx0XHRcdHZhciBwYXRoTWF0Y2ggPSBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMucGFyc2VVUkkocGF0aCk7XG5cdFx0XHRcdC8vIEFsc28gYXBwZW5kIGJhc2VQYXRoXG5cdFx0XHRcdGlmICh1c2VCYXNlUGF0aCAhPSBudWxsICYmICFwYXRoTWF0Y2guYWJzb2x1dGUgJiYgIXBhdGhNYXRjaC5yZWxhdGl2ZSkge1xuXHRcdFx0XHRcdGJwID0gdXNlQmFzZVBhdGggKyBicDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh1c2VCYXNlUGF0aCAhPSBudWxsKSB7XG5cdFx0XHRcdGJwID0gdXNlQmFzZVBhdGg7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIERldGVybWluZSBFeHRlbnNpb24sIGV0Yy5cblx0XHRcdHZhciBtYXRjaCA9IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5wYXJzZVVSSShpdGVtLnNyYyk7XG5cdFx0XHRpZiAobWF0Y2guZXh0ZW5zaW9uKSB7XG5cdFx0XHRcdGl0ZW0uZXh0ID0gbWF0Y2guZXh0ZW5zaW9uO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGl0ZW0udHlwZSA9PSBudWxsKSB7XG5cdFx0XHRcdGl0ZW0udHlwZSA9IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5nZXRUeXBlQnlFeHRlbnNpb24oaXRlbS5leHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmplY3QgcGF0aCAmIGJhc2VQYXRoXG5cdFx0XHR2YXIgYXV0b0lkID0gaXRlbS5zcmM7XG5cdFx0XHRpZiAoIW1hdGNoLmFic29sdXRlICYmICFtYXRjaC5yZWxhdGl2ZSkge1xuXHRcdFx0XHRpZiAocGF0aCkge1xuXHRcdFx0XHRcdGJwID0gcGF0aDtcblx0XHRcdFx0XHR2YXIgcGF0aE1hdGNoID0gY3JlYXRlanMuUmVxdWVzdFV0aWxzLnBhcnNlVVJJKHBhdGgpO1xuXHRcdFx0XHRcdGF1dG9JZCA9IHBhdGggKyBhdXRvSWQ7XG5cdFx0XHRcdFx0Ly8gQWxzbyBhcHBlbmQgYmFzZVBhdGhcblx0XHRcdFx0XHRpZiAodXNlQmFzZVBhdGggIT0gbnVsbCAmJiAhcGF0aE1hdGNoLmFic29sdXRlICYmICFwYXRoTWF0Y2gucmVsYXRpdmUpIHtcblx0XHRcdFx0XHRcdGJwID0gdXNlQmFzZVBhdGggKyBicDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAodXNlQmFzZVBhdGggIT0gbnVsbCkge1xuXHRcdFx0XHRcdGJwID0gdXNlQmFzZVBhdGg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGl0ZW0uc3JjID0gYnAgKyBpdGVtLnNyYztcblx0XHR9XG5cdFx0aXRlbS5wYXRoID0gYnA7XG5cblx0XHQvLyBJZiB0aGVyZSdzIG5vIGlkLCBzZXQgb25lIG5vdy5cblx0XHRpZiAoaXRlbS5pZCA9PT0gdW5kZWZpbmVkIHx8IGl0ZW0uaWQgPT09IG51bGwgfHwgaXRlbS5pZCA9PT0gXCJcIikge1xuXHRcdFx0aXRlbS5pZCA9IGF1dG9JZDtcblx0XHR9XG5cblx0XHQvLyBHaXZlIHBsdWdpbnMgYSBjaGFuY2UgdG8gbW9kaWZ5IHRoZSBsb2FkSXRlbTpcblx0XHR2YXIgY3VzdG9tSGFuZGxlciA9IHRoaXMuX3R5cGVDYWxsYmFja3NbaXRlbS50eXBlXSB8fCB0aGlzLl9leHRlbnNpb25DYWxsYmFja3NbaXRlbS5leHRdO1xuXHRcdGlmIChjdXN0b21IYW5kbGVyKSB7XG5cdFx0XHQvLyBQbHVnaW5zIGFyZSBub3cgcGFzc2VkIGJvdGggdGhlIGZ1bGwgc291cmNlLCBhcyB3ZWxsIGFzIGEgY29tYmluZWQgcGF0aCtiYXNlUGF0aCAoYXBwcm9wcmlhdGVseSlcblx0XHRcdHZhciByZXN1bHQgPSBjdXN0b21IYW5kbGVyLmNhbGxiYWNrLmNhbGwoY3VzdG9tSGFuZGxlci5zY29wZSwgaXRlbSwgdGhpcyk7XG5cblx0XHRcdC8vIFRoZSBwbHVnaW4gd2lsbCBoYW5kbGUgdGhlIGxvYWQsIG9yIGhhcyBjYW5jZWxlZCBpdC4gSWdub3JlIGl0LlxuXHRcdFx0aWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdFx0Ly8gTG9hZCBhcyBub3JtYWw6XG5cdFx0XHR9IGVsc2UgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHQvLyBEbyBOb3RoaW5nXG5cblx0XHRcdFx0Ly8gUmVzdWx0IGlzIGEgbG9hZGVyIGNsYXNzOlxuXHRcdFx0fSBlbHNlIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuXHRcdFx0XHRpdGVtLl9sb2FkZXIgPSByZXN1bHQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZSB0aGUgZXh0ZW5zaW9uIGluIGNhc2UgdGhlIHR5cGUgY2hhbmdlZDpcblx0XHRcdG1hdGNoID0gY3JlYXRlanMuUmVxdWVzdFV0aWxzLnBhcnNlVVJJKGl0ZW0uc3JjKTtcblx0XHRcdGlmIChtYXRjaC5leHRlbnNpb24gIT0gbnVsbCkge1xuXHRcdFx0XHRpdGVtLmV4dCA9IG1hdGNoLmV4dGVuc2lvbjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdG9yZSB0aGUgaXRlbSBmb3IgbG9va3VwLiBUaGlzIGFsc28gaGVscHMgY2xlYW4tdXAgbGF0ZXIuXG5cdFx0dGhpcy5fbG9hZEl0ZW1zQnlJZFtpdGVtLmlkXSA9IGl0ZW07XG5cdFx0dGhpcy5fbG9hZEl0ZW1zQnlTcmNbaXRlbS5zcmNdID0gaXRlbTtcblxuXHRcdGlmIChpdGVtLmNyb3NzT3JpZ2luID09IG51bGwpIHtcblx0XHRcdGl0ZW0uY3Jvc3NPcmlnaW4gPSB0aGlzLl9jcm9zc09yaWdpbjtcblx0XHR9XG5cblx0XHRyZXR1cm4gaXRlbTtcblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgbG9hZGVyIGZvciBhIGxvYWQgaXRlbS5cblx0ICogQG1ldGhvZCBfY3JlYXRlTG9hZGVyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIEEgZm9ybWF0dGVkIGxvYWQgaXRlbSB0aGF0IGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIGEgbG9hZGVyLlxuXHQgKiBAcmV0dXJuIHtBYnN0cmFjdExvYWRlcn0gQSBsb2FkZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBsb2FkIGNvbnRlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jcmVhdGVMb2FkZXIgPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdGlmIChpdGVtLl9sb2FkZXIgIT0gbnVsbCkgeyAvLyBBIHBsdWdpbiBhbHJlYWR5IHNwZWNpZmllZCBhIGxvYWRlclxuXHRcdFx0cmV0dXJuIGl0ZW0uX2xvYWRlcjtcblx0XHR9XG5cblx0XHQvLyBJbml0aWFsbHksIHRyeSBhbmQgdXNlIHRoZSBwcm92aWRlZC9zdXBwb3J0ZWQgWEhSIG1vZGU6XG5cdFx0dmFyIHByZWZlclhIUiA9IHRoaXMucHJlZmVyWEhSO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9hdmFpbGFibGVMb2FkZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgbG9hZGVyID0gdGhpcy5fYXZhaWxhYmxlTG9hZGVyc1tpXTtcblx0XHRcdGlmIChsb2FkZXIgJiYgbG9hZGVyLmNhbkxvYWRJdGVtKGl0ZW0pKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgbG9hZGVyKGl0ZW0sIHByZWZlclhIUik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gVE9ETzogTG9nIGVycm9yIChyZXF1aXJlcyBjcmVhdGVqcy5sb2cpXG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIExvYWQgdGhlIG5leHQgaXRlbSBpbiB0aGUgcXVldWUuIElmIHRoZSBxdWV1ZSBpcyBlbXB0eSAoYWxsIGl0ZW1zIGhhdmUgYmVlbiBsb2FkZWQpLCB0aGVuIHRoZSBjb21wbGV0ZSBldmVudFxuXHQgKiBpcyBwcm9jZXNzZWQuIFRoZSBxdWV1ZSB3aWxsIFwiZmlsbCB1cFwiIGFueSBlbXB0eSBzbG90cywgdXAgdG8gdGhlIG1heCBjb25uZWN0aW9uIHNwZWNpZmllZCB1c2luZ1xuXHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUuc2V0TWF4Q29ubmVjdGlvbnNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLiBUaGUgb25seSBleGNlcHRpb24gaXMgc2NyaXB0cyB0aGF0IGFyZSBsb2FkZWRcblx0ICogdXNpbmcgdGFncywgd2hpY2ggaGF2ZSB0byBiZSBsb2FkZWQgb25lIGF0IGEgdGltZSB0byBtYWludGFpbiBsb2FkIG9yZGVyLlxuXHQgKiBAbWV0aG9kIF9sb2FkTmV4dFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fbG9hZE5leHQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3BhdXNlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9ubHkgZGlzcGF0Y2ggbG9hZHN0YXJ0IGV2ZW50IHdoZW4gdGhlIGZpcnN0IGZpbGUgaXMgbG9hZGVkLlxuXHRcdGlmICghdGhpcy5fbG9hZFN0YXJ0V2FzRGlzcGF0Y2hlZCkge1xuXHRcdFx0dGhpcy5fc2VuZExvYWRTdGFydCgpO1xuXHRcdFx0dGhpcy5fbG9hZFN0YXJ0V2FzRGlzcGF0Y2hlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHF1ZXVlIGhhcyBjb21wbGV0ZWQuXG5cdFx0aWYgKHRoaXMuX251bUl0ZW1zID09IHRoaXMuX251bUl0ZW1zTG9hZGVkKSB7XG5cdFx0XHR0aGlzLmxvYWRlZCA9IHRydWU7XG5cdFx0XHR0aGlzLl9zZW5kQ29tcGxldGUoKTtcblxuXHRcdFx0Ly8gTG9hZCB0aGUgbmV4dCBxdWV1ZSwgaWYgaXQgaGFzIGJlZW4gZGVmaW5lZC5cblx0XHRcdGlmICh0aGlzLm5leHQgJiYgdGhpcy5uZXh0LmxvYWQpIHtcblx0XHRcdFx0dGhpcy5uZXh0LmxvYWQoKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5sb2FkZWQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBNdXN0IGl0ZXJhdGUgZm9yd2FyZHMgdG8gbG9hZCBpbiB0aGUgcmlnaHQgb3JkZXIuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sb2FkUXVldWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLl9jdXJyZW50TG9hZHMubGVuZ3RoID49IHRoaXMuX21heENvbm5lY3Rpb25zKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGxvYWRlciA9IHRoaXMuX2xvYWRRdWV1ZVtpXTtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBiZSBvbmx5IGxvYWRpbmcgb25lIHRhZy1zY3JpcHQgYXQgYSB0aW1lOlxuXHRcdFx0Ly8gTm90ZTogbWFpbnRhaW5PcmRlciBpdGVtcyBkb24ndCBkbyBhbnl0aGluZyBoZXJlIGJlY2F1c2Ugd2UgY2FuIGhvbGQgb250byB0aGVpciBsb2FkZWQgdmFsdWVcblx0XHRcdGlmICghdGhpcy5fY2FuU3RhcnRMb2FkKGxvYWRlcikpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9sb2FkUXVldWUuc3BsaWNlKGksIDEpO1xuXHRcdFx0aS0tO1xuXHRcdFx0dGhpcy5fbG9hZEl0ZW0obG9hZGVyKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2luIGxvYWRpbmcgYW4gaXRlbS4gRXZlbnQgbGlzdGVuZXJzIGFyZSBub3QgYWRkZWQgdG8gdGhlIGxvYWRlcnMgdW50aWwgdGhlIGxvYWQgc3RhcnRzLlxuXHQgKiBAbWV0aG9kIF9sb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXIgVGhlIGxvYWRlciBpbnN0YW5jZSB0byBzdGFydC4gQ3VycmVudGx5LCB0aGlzIHdpbGwgYmUgYW4gWEhSTG9hZGVyIG9yIFRhZ0xvYWRlci5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2xvYWRJdGVtID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdGxvYWRlci5vbihcImZpbGVsb2FkXCIsIHRoaXMuX2hhbmRsZUZpbGVMb2FkLCB0aGlzKTtcblx0XHRsb2FkZXIub24oXCJwcm9ncmVzc1wiLCB0aGlzLl9oYW5kbGVQcm9ncmVzcywgdGhpcyk7XG5cdFx0bG9hZGVyLm9uKFwiY29tcGxldGVcIiwgdGhpcy5faGFuZGxlRmlsZUNvbXBsZXRlLCB0aGlzKTtcblx0XHRsb2FkZXIub24oXCJlcnJvclwiLCB0aGlzLl9oYW5kbGVFcnJvciwgdGhpcyk7XG5cdFx0bG9hZGVyLm9uKFwiZmlsZWVycm9yXCIsIHRoaXMuX2hhbmRsZUZpbGVFcnJvciwgdGhpcyk7XG5cdFx0dGhpcy5fY3VycmVudExvYWRzLnB1c2gobG9hZGVyKTtcblx0XHR0aGlzLl9zZW5kRmlsZVN0YXJ0KGxvYWRlci5nZXRJdGVtKCkpO1xuXHRcdGxvYWRlci5sb2FkKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBjYWxsYmFjayB0aGF0IGlzIGZpcmVkIHdoZW4gYSBsb2FkZXIgbG9hZHMgYSBmaWxlLiBUaGlzIGVuYWJsZXMgbG9hZGVycyBsaWtlIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHRvIG1haW50YWluIGludGVybmFsIHF1ZXVlcywgYnV0IGZvciB0aGlzIHF1ZXVlIHRvIGRpc3BhdGNoIHRoZSB7eyNjcm9zc0xpbmsgXCJmaWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudHMuXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBmcm9tIHRoZSBsb2FkZXIuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5faGFuZGxlRmlsZUxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC50YXJnZXQgPSBudWxsO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBjYWxsYmFjayB0aGF0IGlzIGZpcmVkIHdoZW4gYSBsb2FkZXIgZW5jb3VudGVycyBhbiBlcnJvciBmcm9tIGFuIGludGVybmFsIGZpbGUgbG9hZCBvcGVyYXRpb24uIFRoaXMgZW5hYmxlc1xuXHQgKiBsb2FkZXJzIGxpa2UgTVxuXHQgKiBAcGFyYW0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZUZpbGVFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiRklMRV9MT0FEX0VSUk9SXCIsIG51bGwsIGV2ZW50Lml0ZW0pO1xuXHRcdHRoaXMuX3NlbmRFcnJvcihuZXdFdmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBjYWxsYmFjayB0aGF0IGlzIGZpcmVkIHdoZW4gYSBsb2FkZXIgZW5jb3VudGVycyBhbiBlcnJvci4gVGhlIHF1ZXVlIHdpbGwgY29udGludWUgbG9hZGluZyB1bmxlc3Mge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3N0b3BPbkVycm9yOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGlzIHNldCB0byBgdHJ1ZWAuXG5cdCAqIEBtZXRob2QgX2hhbmRsZUVycm9yXG5cdCAqIEBwYXJhbSB7RXJyb3JFdmVudH0gZXZlbnQgVGhlIGVycm9yIGV2ZW50LCBjb250YWluaW5nIHJlbGV2YW50IGVycm9yIGluZm9ybWF0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgbG9hZGVyID0gZXZlbnQudGFyZ2V0O1xuXHRcdHRoaXMuX251bUl0ZW1zTG9hZGVkKys7XG5cblx0XHR0aGlzLl9maW5pc2hPcmRlcmVkSXRlbShsb2FkZXIsIHRydWUpO1xuXHRcdHRoaXMuX3VwZGF0ZVByb2dyZXNzKCk7XG5cblx0XHR2YXIgbmV3RXZlbnQgPSBuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIkZJTEVfTE9BRF9FUlJPUlwiLCBudWxsLCBsb2FkZXIuZ2V0SXRlbSgpKTtcblx0XHQvLyBUT0RPOiBQcm9wYWdhdGUgYWN0dWFsIGVycm9yIG1lc3NhZ2UuXG5cblx0XHR0aGlzLl9zZW5kRXJyb3IobmV3RXZlbnQpO1xuXG5cdFx0aWYgKCF0aGlzLnN0b3BPbkVycm9yKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVMb2FkSXRlbShsb2FkZXIpO1xuXHRcdFx0dGhpcy5fY2xlYW5Mb2FkSXRlbShsb2FkZXIpO1xuXHRcdFx0dGhpcy5fbG9hZE5leHQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZXRQYXVzZWQodHJ1ZSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbiBpdGVtIGhhcyBmaW5pc2hlZCBsb2FkaW5nLiBXZSBjYW4gYXNzdW1lIHRoYXQgaXQgaXMgdG90YWxseSBsb2FkZWQsIGhhcyBiZWVuIHBhcnNlZCBmb3IgaW1tZWRpYXRlIHVzZSwgYW5kXG5cdCAqIGlzIGF2YWlsYWJsZSBhcyB0aGUgXCJyZXN1bHRcIiBwcm9wZXJ0eSBvbiB0aGUgbG9hZCBpdGVtLiBUaGUgcmF3IHRleHQgcmVzdWx0IGZvciBhIHBhcnNlZCBpdGVtIChzdWNoIGFzIEpTT04sIFhNTCxcblx0ICogQ1NTLCBKYXZhU2NyaXB0LCBldGMpIGlzIGF2YWlsYWJsZSBhcyB0aGUgXCJyYXdSZXN1bHRcIiBwcm9wZXJ0eSwgYW5kIGNhbiBhbHNvIGJlIGxvb2tlZCB1cCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZ2V0UmVzdWx0XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVGaWxlQ29tcGxldGVcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IG9iamVjdCBmcm9tIHRoZSBsb2FkZXIuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVGaWxlQ29tcGxldGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgbG9hZGVyID0gZXZlbnQudGFyZ2V0O1xuXHRcdHZhciBpdGVtID0gbG9hZGVyLmdldEl0ZW0oKTtcblxuXHRcdHZhciByZXN1bHQgPSBsb2FkZXIuZ2V0UmVzdWx0KCk7XG5cdFx0dGhpcy5fbG9hZGVkUmVzdWx0c1tpdGVtLmlkXSA9IHJlc3VsdDtcblx0XHR2YXIgcmF3UmVzdWx0ID0gbG9hZGVyLmdldFJlc3VsdCh0cnVlKTtcblx0XHRpZiAocmF3UmVzdWx0ICE9IG51bGwgJiYgcmF3UmVzdWx0ICE9PSByZXN1bHQpIHtcblx0XHRcdHRoaXMuX2xvYWRlZFJhd1Jlc3VsdHNbaXRlbS5pZF0gPSByYXdSZXN1bHQ7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2F2ZUxvYWRlZEl0ZW1zKGxvYWRlcik7XG5cblx0XHQvLyBSZW1vdmUgdGhlIGxvYWQgaXRlbVxuXHRcdHRoaXMuX3JlbW92ZUxvYWRJdGVtKGxvYWRlcik7XG5cblx0XHRpZiAoIXRoaXMuX2ZpbmlzaE9yZGVyZWRJdGVtKGxvYWRlcikpIHtcblx0XHRcdC8vIFRoZSBpdGVtIHdhcyBOT1QgbWFuYWdlZCwgc28gcHJvY2VzcyBpdCBub3dcblx0XHRcdHRoaXMuX3Byb2Nlc3NGaW5pc2hlZExvYWQoaXRlbSwgbG9hZGVyKTtcblx0XHR9XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgbG9hZCBpdGVtXG5cdFx0dGhpcy5fY2xlYW5Mb2FkSXRlbShsb2FkZXIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTb21lIGxvYWRlcnMgbWlnaHQgbG9hZCBhZGRpdGlvbmFsIGNvbnRlbnQsIG90aGVyIHRoYW4gdGhlIGl0ZW0gdGhleSB3ZXJlIHBhc3NlZCAoc3VjaCBhcyB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fSkuXG5cdCAqIEFueSBpdGVtcyBleHBvc2VkIGJ5IHRoZSBsb2FkZXIgdXNpbmcge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvZ2V0TG9hZEl0ZW1zXCJ9fXt7L2Nyb3NzTGlua319IGFyZSBhZGRlZCB0byB0aGVcblx0ICogTG9hZFF1ZXVlJ3MgbG9vay11cHMsIGluY2x1ZGluZyB7eyNjcm9zc0xpbmsgXCJnZXRJdGVtXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJnZXRSZXN1bHRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kcy5cblx0ICogQG1ldGhvZCBfc2F2ZUxvYWRlZEl0ZW1zXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5fc2F2ZUxvYWRlZEl0ZW1zID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdC8vIFRPRE86IE5vdCBzdXJlIGhvdyB0byBoYW5kbGUgdGhpcy4gV291bGQgYmUgbmljZSB0byBleHBvc2UgdGhlIGl0ZW1zLlxuXHRcdC8vIExvYWRlcnMgbWF5IGxvYWQgc3ViLWl0ZW1zLiBUaGlzIGFkZHMgdGhlbSB0byB0aGlzIHF1ZXVlXG5cdFx0dmFyIGxpc3QgPSBsb2FkZXIuZ2V0TG9hZGVkSXRlbXMoKTtcblx0XHRpZiAobGlzdCA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBsaXN0W2ldLml0ZW07XG5cblx0XHRcdC8vIFN0b3JlIGl0ZW0gbG9va3Vwc1xuXHRcdFx0dGhpcy5fbG9hZEl0ZW1zQnlTcmNbaXRlbS5zcmNdID0gaXRlbTtcblx0XHRcdHRoaXMuX2xvYWRJdGVtc0J5SWRbaXRlbS5pZF0gPSBpdGVtO1xuXG5cdFx0XHQvLyBTdG9yZSBsb2FkZWQgY29udGVudFxuXHRcdFx0dGhpcy5fbG9hZGVkUmVzdWx0c1tpdGVtLmlkXSA9IGxpc3RbaV0ucmVzdWx0O1xuXHRcdFx0dGhpcy5fbG9hZGVkUmF3UmVzdWx0c1tpdGVtLmlkXSA9IGxpc3RbaV0ucmF3UmVzdWx0O1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRmxhZyBhbiBpdGVtIGFzIGZpbmlzaGVkLiBJZiB0aGUgaXRlbSdzIG9yZGVyIGlzIGJlaW5nIG1hbmFnZWQsIHRoZW4gZW5zdXJlIHRoYXQgaXQgaXMgYWxsb3dlZCB0byBmaW5pc2gsIGFuZCBpZlxuXHQgKiBzbywgdHJpZ2dlciBwcmlvciBpdGVtcyB0byB0cmlnZ2VyIGFzIHdlbGwuXG5cdCAqIEBtZXRob2QgX2ZpbmlzaE9yZGVyZWRJdGVtXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGxvYWRGYWlsZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIGl0ZW0ncyBvcmRlciBpcyBiZWluZyBtYW5hZ2VkLiBUaGlzIGFsbG93cyB0aGUgY2FsbGVyIHRvIHRha2UgYW4gYWx0ZXJuYXRlXG5cdCAqIGJlaGF2aW91ciBpZiBpdCBpcy5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2ZpbmlzaE9yZGVyZWRJdGVtID0gZnVuY3Rpb24gKGxvYWRlciwgbG9hZEZhaWxlZCkge1xuXHRcdHZhciBpdGVtID0gbG9hZGVyLmdldEl0ZW0oKTtcblxuXHRcdGlmICgodGhpcy5tYWludGFpblNjcmlwdE9yZGVyICYmIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5Mb2FkUXVldWUuSkFWQVNDUklQVClcblx0XHRcdFx0fHwgaXRlbS5tYWludGFpbk9yZGVyKSB7XG5cblx0XHRcdC8vVE9ETzogRXZhbHVhdGUgcmVtb3ZhbCBvZiB0aGUgX2N1cnJlbnRseUxvYWRpbmdTY3JpcHRcblx0XHRcdGlmIChsb2FkZXIgaW5zdGFuY2VvZiBjcmVhdGVqcy5KYXZhU2NyaXB0TG9hZGVyKSB7XG5cdFx0XHRcdHRoaXMuX2N1cnJlbnRseUxvYWRpbmdTY3JpcHQgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGluZGV4ID0gY3JlYXRlanMuaW5kZXhPZih0aGlzLl9zY3JpcHRPcmRlciwgaXRlbSk7XG5cdFx0XHRpZiAoaW5kZXggPT0gLTEpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSAvLyBUaGlzIGxvYWRlciBubyBsb25nZXIgZXhpc3RzXG5cdFx0XHR0aGlzLl9sb2FkZWRTY3JpcHRzW2luZGV4XSA9IChsb2FkRmFpbGVkID09PSB0cnVlKSA/IHRydWUgOiBpdGVtO1xuXG5cdFx0XHR0aGlzLl9jaGVja1NjcmlwdExvYWRPcmRlcigpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbnN1cmUgdGhlIHNjcmlwdHMgbG9hZCBhbmQgZGlzcGF0Y2ggaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIFdoZW4gdXNpbmcgWEhSLCBzY3JpcHRzIGFyZSBzdG9yZWQgaW4gYW4gYXJyYXkgaW4gdGhlXG5cdCAqIG9yZGVyIHRoZXkgd2VyZSBhZGRlZCwgYnV0IHdpdGggYSBcIm51bGxcIiB2YWx1ZS4gV2hlbiB0aGV5IGFyZSBjb21wbGV0ZWQsIHRoZSB2YWx1ZSBpcyBzZXQgdG8gdGhlIGxvYWQgaXRlbSxcblx0ICogYW5kIHRoZW4gd2hlbiB0aGV5IGFyZSBwcm9jZXNzZWQgYW5kIGRpc3BhdGNoZWQsIHRoZSB2YWx1ZSBpcyBzZXQgdG8gYHRydWVgLiBUaGlzIG1ldGhvZCBzaW1wbHlcblx0ICogaXRlcmF0ZXMgdGhlIGFycmF5LCBhbmQgZW5zdXJlcyB0aGF0IGFueSBsb2FkZWQgaXRlbXMgdGhhdCBhcmUgbm90IHByZWNlZGVkIGJ5IGEgYG51bGxgIHZhbHVlIGFyZVxuXHQgKiBkaXNwYXRjaGVkLlxuXHQgKiBAbWV0aG9kIF9jaGVja1NjcmlwdExvYWRPcmRlclxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY2hlY2tTY3JpcHRMb2FkT3JkZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGwgPSB0aGlzLl9sb2FkZWRTY3JpcHRzLmxlbmd0aDtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHRoaXMuX2xvYWRlZFNjcmlwdHNbaV07XG5cdFx0XHRpZiAoaXRlbSA9PT0gbnVsbCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH0gLy8gVGhpcyBpcyBzdGlsbCBsb2FkaW5nLiBEbyBub3QgcHJvY2VzcyBmdXJ0aGVyLlxuXHRcdFx0aWYgKGl0ZW0gPT09IHRydWUpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9IC8vIFRoaXMgaGFzIGNvbXBsZXRlZCwgYW5kIGJlZW4gcHJvY2Vzc2VkLiBNb3ZlIG9uLlxuXG5cdFx0XHR2YXIgbG9hZEl0ZW0gPSB0aGlzLl9sb2FkZWRSZXN1bHRzW2l0ZW0uaWRdO1xuXHRcdFx0aWYgKGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5Mb2FkUXVldWUuSkFWQVNDUklQVCkge1xuXHRcdFx0XHQvLyBBcHBlbmQgc2NyaXB0IHRhZ3MgdG8gdGhlIGhlYWQgYXV0b21hdGljYWxseS5cblx0XHRcdFx0Y3JlYXRlanMuRG9tVXRpbHMuYXBwZW5kVG9IZWFkKGxvYWRJdGVtKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGxvYWRlciA9IGl0ZW0uX2xvYWRlcjtcblx0XHRcdHRoaXMuX3Byb2Nlc3NGaW5pc2hlZExvYWQoaXRlbSwgbG9hZGVyKTtcblx0XHRcdHRoaXMuX2xvYWRlZFNjcmlwdHNbaV0gPSB0cnVlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQSBmaWxlIGhhcyBjb21wbGV0ZWQgbG9hZGluZywgYW5kIHRoZSBMb2FkUXVldWUgY2FuIG1vdmUgb24uIFRoaXMgdHJpZ2dlcnMgdGhlIGNvbXBsZXRlIGV2ZW50LCBhbmQga2ljay1zdGFydHNcblx0ICogdGhlIG5leHQgaXRlbS5cblx0ICogQG1ldGhvZCBfcHJvY2Vzc0ZpbmlzaGVkTG9hZFxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbVxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fcHJvY2Vzc0ZpbmlzaGVkTG9hZCA9IGZ1bmN0aW9uIChpdGVtLCBsb2FkZXIpIHtcblx0XHR0aGlzLl9udW1JdGVtc0xvYWRlZCsrO1xuXG5cdFx0Ly8gU2luY2UgTG9hZFF1ZXVlIG5lZWRzIG1haW50YWluIG9yZGVyLCB3ZSBjYW4ndCBhcHBlbmQgc2NyaXB0cyBpbiB0aGUgbG9hZGVyLlxuXHRcdC8vIFNvIHdlIGRvIGl0IGhlcmUgaW5zdGVhZC4gT3IgaW4gX2NoZWNrU2NyaXB0TG9hZE9yZGVyKCk7XG5cdFx0aWYgKCF0aGlzLm1haW50YWluU2NyaXB0T3JkZXIgJiYgaXRlbS50eXBlID09IGNyZWF0ZWpzLkxvYWRRdWV1ZS5KQVZBU0NSSVBUKSB7XG5cdFx0XHR2YXIgdGFnID0gbG9hZGVyLmdldFRhZygpO1xuXHRcdFx0Y3JlYXRlanMuRG9tVXRpbHMuYXBwZW5kVG9IZWFkKHRhZyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlUHJvZ3Jlc3MoKTtcblx0XHR0aGlzLl9zZW5kRmlsZUNvbXBsZXRlKGl0ZW0sIGxvYWRlcik7XG5cdFx0dGhpcy5fbG9hZE5leHQoKTtcblx0fTtcblxuXHQvKipcblx0ICogRW5zdXJlIGl0ZW1zIHdpdGggYG1haW50YWluT3JkZXI9dHJ1ZWAgdGhhdCBhcmUgYmVmb3JlIHRoZSBzcGVjaWZpZWQgaXRlbSBoYXZlIGxvYWRlZC4gVGhpcyBvbmx5IGFwcGxpZXMgdG9cblx0ICogSmF2YVNjcmlwdCBpdGVtcyB0aGF0IGFyZSBiZWluZyBsb2FkZWQgd2l0aCBhIFRhZ0xvYWRlciwgc2luY2UgdGhleSBoYXZlIHRvIGJlIGxvYWRlZCBhbmQgY29tcGxldGVkIDxzdHJvbmc+YmVmb3JlPC9zdHJvbmc+XG5cdCAqIHRoZSBzY3JpcHQgY2FuIGV2ZW4gYmUgc3RhcnRlZCwgc2luY2UgaXQgZXhpc3QgaW4gdGhlIERPTSB3aGlsZSBsb2FkaW5nLlxuXHQgKiBAbWV0aG9kIF9jYW5TdGFydExvYWRcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyIFRoZSBsb2FkZXIgZm9yIHRoZSBpdGVtXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGl0ZW0gY2FuIHN0YXJ0IGEgbG9hZCBvciBub3QuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jYW5TdGFydExvYWQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0aWYgKCF0aGlzLm1haW50YWluU2NyaXB0T3JkZXIgfHwgbG9hZGVyLnByZWZlclhIUikge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHZhciBpdGVtID0gbG9hZGVyLmdldEl0ZW0oKTtcblx0XHRpZiAoaXRlbS50eXBlICE9IGNyZWF0ZWpzLkxvYWRRdWV1ZS5KQVZBU0NSSVBUKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX2N1cnJlbnRseUxvYWRpbmdTY3JpcHQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgaW5kZXggPSB0aGlzLl9zY3JpcHRPcmRlci5pbmRleE9mKGl0ZW0pO1xuXHRcdHZhciBpID0gMDtcblx0XHR3aGlsZSAoaSA8IGluZGV4KSB7XG5cdFx0XHR2YXIgY2hlY2tJdGVtID0gdGhpcy5fbG9hZGVkU2NyaXB0c1tpXTtcblx0XHRcdGlmIChjaGVja0l0ZW0gPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpKys7XG5cdFx0fVxuXHRcdHRoaXMuX2N1cnJlbnRseUxvYWRpbmdTY3JpcHQgPSB0cnVlO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBIGxvYWQgaXRlbSBpcyBjb21wbGV0ZWQgb3Igd2FzIGNhbmNlbGVkLCBhbmQgbmVlZHMgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBMb2FkUXVldWUuXG5cdCAqIEBtZXRob2QgX3JlbW92ZUxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlciBBIGxvYWRlciBpbnN0YW5jZSB0byByZW1vdmUuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9yZW1vdmVMb2FkSXRlbSA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHR2YXIgbCA9IHRoaXMuX2N1cnJlbnRMb2Fkcy5sZW5ndGg7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLl9jdXJyZW50TG9hZHNbaV0gPT0gbG9hZGVyKSB7XG5cdFx0XHRcdHRoaXMuX2N1cnJlbnRMb2Fkcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlIHVubmVlZGVkIHJlZmVyZW5jZXMgZnJvbSBhIGxvYWRlci5cblx0ICpcblx0ICogQHBhcmFtIGxvYWRlclxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY2xlYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uKGxvYWRlcikge1xuXHRcdHZhciBpdGVtID0gbG9hZGVyLmdldEl0ZW0oKTtcblx0XHRpZiAoaXRlbSkge1xuXHRcdFx0ZGVsZXRlIGl0ZW0uX2xvYWRlcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQW4gaXRlbSBoYXMgZGlzcGF0Y2hlZCBwcm9ncmVzcy4gUHJvcGFnYXRlIHRoYXQgcHJvZ3Jlc3MsIGFuZCB1cGRhdGUgdGhlIExvYWRRdWV1ZSdzIG92ZXJhbGwgcHJvZ3Jlc3MuXG5cdCAqIEBtZXRob2QgX2hhbmRsZVByb2dyZXNzXG5cdCAqIEBwYXJhbSB7UHJvZ3Jlc3NFdmVudH0gZXZlbnQgVGhlIHByb2dyZXNzIGV2ZW50IGZyb20gdGhlIGl0ZW0uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVQcm9ncmVzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBsb2FkZXIgPSBldmVudC50YXJnZXQ7XG5cdFx0dGhpcy5fc2VuZEZpbGVQcm9ncmVzcyhsb2FkZXIuZ2V0SXRlbSgpLCBsb2FkZXIucHJvZ3Jlc3MpO1xuXHRcdHRoaXMuX3VwZGF0ZVByb2dyZXNzKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIE92ZXJhbGwgcHJvZ3Jlc3MgaGFzIGNoYW5nZWQsIHNvIGRldGVybWluZSB0aGUgbmV3IHByb2dyZXNzIGFtb3VudCBhbmQgZGlzcGF0Y2ggaXQuIFRoaXMgY2hhbmdlcyBhbnkgdGltZSBhblxuXHQgKiBpdGVtIGRpc3BhdGNoZXMgcHJvZ3Jlc3Mgb3IgY29tcGxldGVzLiBOb3RlIHRoYXQgc2luY2Ugd2UgZG9uJ3QgYWx3YXlzIGtub3cgdGhlIGFjdHVhbCBmaWxlc2l6ZSBvZiBpdGVtcyBiZWZvcmVcblx0ICogdGhleSBhcmUgbG9hZGVkLiBJbiB0aGlzIGNhc2UsIHdlIGRlZmluZSBhIFwic2xvdFwiIGZvciBlYWNoIGl0ZW0gKDEgaXRlbSBpbiAxMCB3b3VsZCBnZXQgMTAlKSwgYW5kIHRoZW4gYXBwZW5kXG5cdCAqIGxvYWRlZCBwcm9ncmVzcyBvbiB0b3Agb2YgdGhlIGFscmVhZHktbG9hZGVkIGl0ZW1zLlxuXHQgKlxuXHQgKiBGb3IgZXhhbXBsZSwgaWYgNS8xMCBpdGVtcyBoYXZlIGxvYWRlZCwgYW5kIGl0ZW0gNiBpcyAyMCUgbG9hZGVkLCB0aGUgdG90YWwgcHJvZ3Jlc3Mgd291bGQgYmU6XG5cdCAqIDx1bD5cblx0ICogICAgICA8bGk+NS8xMCBvZiB0aGUgaXRlbXMgaW4gdGhlIHF1ZXVlICg1MCUpPC9saT5cblx0ICogICAgICA8bGk+cGx1cyAyMCUgb2YgaXRlbSA2J3Mgc2xvdCAoMiUpPC9saT5cblx0ICogICAgICA8bGk+ZXF1YWxzIDUyJTwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqIEBtZXRob2QgX3VwZGF0ZVByb2dyZXNzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl91cGRhdGVQcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbG9hZGVkID0gdGhpcy5fbnVtSXRlbXNMb2FkZWQgLyB0aGlzLl9udW1JdGVtczsgLy8gRnVsbHkgTG9hZGVkIFByb2dyZXNzXG5cdFx0dmFyIHJlbWFpbmluZyA9IHRoaXMuX251bUl0ZW1zIC0gdGhpcy5fbnVtSXRlbXNMb2FkZWQ7XG5cdFx0aWYgKHJlbWFpbmluZyA+IDApIHtcblx0XHRcdHZhciBjaHVuayA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2N1cnJlbnRMb2Fkcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y2h1bmsgKz0gdGhpcy5fY3VycmVudExvYWRzW2ldLnByb2dyZXNzO1xuXHRcdFx0fVxuXHRcdFx0bG9hZGVkICs9IChjaHVuayAvIHJlbWFpbmluZykgKiAocmVtYWluaW5nIC8gdGhpcy5fbnVtSXRlbXMpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9sYXN0UHJvZ3Jlc3MgIT0gbG9hZGVkKSB7XG5cdFx0XHR0aGlzLl9zZW5kUHJvZ3Jlc3MobG9hZGVkKTtcblx0XHRcdHRoaXMuX2xhc3RQcm9ncmVzcyA9IGxvYWRlZDtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENsZWFuIG91dCBpdGVtIHJlc3VsdHMsIHRvIGZyZWUgdGhlbSBmcm9tIG1lbW9yeS4gTWFpbmx5LCB0aGUgbG9hZGVkIGl0ZW0gYW5kIHJlc3VsdHMgYXJlIGNsZWFyZWQgZnJvbSBpbnRlcm5hbFxuXHQgKiBoYXNoZXMuXG5cdCAqIEBtZXRob2QgX2Rpc3Bvc2VJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBpdGVtIHRoYXQgd2FzIHBhc3NlZCBpbiBmb3IgcHJlbG9hZGluZy5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Rpc3Bvc2VJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRkZWxldGUgdGhpcy5fbG9hZGVkUmVzdWx0c1tpdGVtLmlkXTtcblx0XHRkZWxldGUgdGhpcy5fbG9hZGVkUmF3UmVzdWx0c1tpdGVtLmlkXTtcblx0XHRkZWxldGUgdGhpcy5fbG9hZEl0ZW1zQnlJZFtpdGVtLmlkXTtcblx0XHRkZWxldGUgdGhpcy5fbG9hZEl0ZW1zQnlTcmNbaXRlbS5zcmNdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhIFwiZmlsZXByb2dyZXNzXCIge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uIFBsZWFzZSBzZWUgdGhlIExvYWRRdWV1ZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZXByb2dyZXNzOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IGZvciBkZXRhaWxzIG9uIHRoZSBldmVudCBwYXlsb2FkLlxuXHQgKiBAbWV0aG9kIF9zZW5kRmlsZVByb2dyZXNzXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBpdGVtIHRoYXQgaXMgYmVpbmcgbG9hZGVkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcHJvZ3Jlc3MgVGhlIGFtb3VudCB0aGUgaXRlbSBoYXMgYmVlbiBsb2FkZWQgKGJldHdlZW4gMCBhbmQgMSkuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3NlbmRGaWxlUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoaXRlbSwgcHJvZ3Jlc3MpIHtcblx0XHRpZiAodGhpcy5faXNDYW5jZWxlZCgpIHx8IHRoaXMuX3BhdXNlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoIXRoaXMuaGFzRXZlbnRMaXN0ZW5lcihcImZpbGVwcm9ncmVzc1wiKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vTE06IFJld29yayBQcm9ncmVzc0V2ZW50IHRvIHN1cHBvcnQgdGhpcz9cblx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJmaWxlcHJvZ3Jlc3NcIik7XG5cdFx0ZXZlbnQucHJvZ3Jlc3MgPSBwcm9ncmVzcztcblx0XHRldmVudC5sb2FkZWQgPSBwcm9ncmVzcztcblx0XHRldmVudC50b3RhbCA9IDE7XG5cdFx0ZXZlbnQuaXRlbSA9IGl0ZW07XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhIGZpbGVsb2FkIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LiBQbGVhc2Ugc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZWxvYWQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgZm9yXG5cdCAqIGRldGFpbHMgb24gdGhlIGV2ZW50IHBheWxvYWQuXG5cdCAqIEBtZXRob2QgX3NlbmRGaWxlQ29tcGxldGVcblx0ICogQHBhcmFtIHtMb2FkSXRlbU9iamVjdH0gaXRlbSBUaGUgaXRlbSB0aGF0IGlzIGJlaW5nIGxvYWRlZC5cblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3NlbmRGaWxlQ29tcGxldGUgPSBmdW5jdGlvbiAoaXRlbSwgbG9hZGVyKSB7XG5cdFx0aWYgKHRoaXMuX2lzQ2FuY2VsZWQoKSB8fCB0aGlzLl9wYXVzZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJmaWxlbG9hZFwiKTtcblx0XHRldmVudC5sb2FkZXIgPSBsb2FkZXI7XG5cdFx0ZXZlbnQuaXRlbSA9IGl0ZW07XG5cdFx0ZXZlbnQucmVzdWx0ID0gdGhpcy5fbG9hZGVkUmVzdWx0c1tpdGVtLmlkXTtcblx0XHRldmVudC5yYXdSZXN1bHQgPSB0aGlzLl9sb2FkZWRSYXdSZXN1bHRzW2l0ZW0uaWRdO1xuXG5cdFx0Ly8gVGhpcyBjYWxscyBhIGhhbmRsZXIgc3BlY2lmaWVkIG9uIHRoZSBhY3R1YWwgbG9hZCBpdGVtLiBDdXJyZW50bHksIHRoZSBTb3VuZEpTIHBsdWdpbiB1c2VzIHRoaXMuXG5cdFx0aWYgKGl0ZW0uY29tcGxldGVIYW5kbGVyKSB7XG5cdFx0XHRpdGVtLmNvbXBsZXRlSGFuZGxlcihldmVudCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5oYXNFdmVudExpc3RlbmVyKFwiZmlsZWxvYWRcIikgJiYgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRGlzcGF0Y2ggYSBmaWxlc3RhcnQge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gaW1tZWRpYXRlbHkgYmVmb3JlIGEgZmlsZSBzdGFydHMgdG8gbG9hZC4gUGxlYXNlIHNlZVxuXHQgKiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVzdGFydDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBmb3IgZGV0YWlscyBvbiB0aGUgZXZlbnQgcGF5bG9hZC5cblx0ICogQG1ldGhvZCBfc2VuZEZpbGVTdGFydFxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgaXRlbSB0aGF0IGlzIGJlaW5nIGxvYWRlZC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2VuZEZpbGVTdGFydCA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiZmlsZXN0YXJ0XCIpO1xuXHRcdGV2ZW50Lml0ZW0gPSBpdGVtO1xuXHRcdHRoaXMuaGFzRXZlbnRMaXN0ZW5lcihcImZpbGVzdGFydFwiKSAmJiB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFwiW1ByZWxvYWRKUyBMb2FkUXVldWVdXCI7XG5cdH07XG5cblx0Y3JlYXRlanMuTG9hZFF1ZXVlID0gY3JlYXRlanMucHJvbW90ZShMb2FkUXVldWUsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVGV4dExvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBUZXh0IGZpbGVzLlxuXHQgKiBAY2xhc3MgVGV4dExvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBUZXh0TG9hZGVyKGxvYWRJdGVtKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgdHJ1ZSwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVEVYVCk7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoVGV4dExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IFRleHRMb2FkZXI7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGxvYWRzIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvVEVYVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogYnV0IGlzIGFsc28gdGhlIGRlZmF1bHQgbG9hZGVyIGlmIGEgZmlsZSB0eXBlIGNhbiBub3QgYmUgZGV0ZXJtaW5lZC5cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5URVhUO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLlRleHRMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKFRleHRMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBCaW5hcnlMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgYmluYXJ5IGZpbGVzLiBUaGlzIGlzIHVzZWZ1bCBmb3IgbG9hZGluZyB3ZWIgYXVkaW8sIG9yIGNvbnRlbnQgdGhhdCByZXF1aXJlcyBhbiBBcnJheUJ1ZmZlci5cblx0ICogQGNsYXNzIEJpbmFyeUxvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBCaW5hcnlMb2FkZXIobG9hZEl0ZW0pIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCB0cnVlLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5CSU5BUlkpO1xuXHRcdHRoaXMub24oXCJpbml0aWFsaXplXCIsIHRoaXMuX3VwZGF0ZVhIUiwgdGhpcyk7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQmluYXJ5TG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gQmluYXJ5TG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvQklOQVJZOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuQklOQVJZO1xuXHR9O1xuXG5cdC8vIHByaXZhdGUgbWV0aG9kc1xuXHQvKipcblx0ICogQmVmb3JlIHRoZSBpdGVtIGxvYWRzLCBzZXQgdGhlIHJlc3BvbnNlIHR5cGUgdG8gXCJhcnJheWJ1ZmZlclwiXG5cdCAqIEBwcm9wZXJ0eSBfdXBkYXRlWEhSXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl91cGRhdGVYSFIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC5sb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIik7XG5cdH07XG5cblx0Y3JlYXRlanMuQmluYXJ5TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShCaW5hcnlMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBDU1NMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgQ1NTIGZpbGVzLlxuXHQgKiBAY2xhc3MgQ1NTTG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZlclhIUlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIENTU0xvYWRlcihsb2FkSXRlbSwgcHJlZmVyWEhSKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgcHJlZmVyWEhSLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5DU1MpO1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHR0aGlzLnJlc3VsdEZvcm1hdHRlciA9IHRoaXMuX2Zvcm1hdFJlc3VsdDtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5fdGFnU3JjQXR0cmlidXRlID0gXCJocmVmXCI7XG5cblx0XHRpZiAocHJlZmVyWEhSKSB7XG5cdFx0XHR0aGlzLl90YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3RhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3RhZy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblx0XHR0aGlzLl90YWcudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChDU1NMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBDU1NMb2FkZXI7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9DU1M6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuQ1NTO1xuXHR9O1xuXG5cdC8vIHByb3RlY3RlZCBtZXRob2RzXG5cdC8qKlxuXHQgKiBUaGUgcmVzdWx0IGZvcm1hdHRlciBmb3IgQ1NTIGZpbGVzLlxuXHQgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEByZXR1cm5zIHtIVE1MTGlua0VsZW1lbnR8SFRNTFN0eWxlRWxlbWVudH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHRpZiAodGhpcy5fcHJlZmVyWEhSKSB7XG5cdFx0XHR2YXIgdGFnID0gbG9hZGVyLmdldFRhZygpO1xuXG5cdFx0XHRpZiAodGFnLnN0eWxlU2hlZXQpIHsgLy8gSUVcblx0XHRcdFx0dGFnLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGxvYWRlci5nZXRSZXN1bHQodHJ1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsb2FkZXIuZ2V0UmVzdWx0KHRydWUpKTtcblx0XHRcdFx0dGFnLmFwcGVuZENoaWxkKHRleHROb2RlKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFnID0gdGhpcy5fdGFnO1xuXHRcdH1cblxuXHRcdGNyZWF0ZWpzLkRvbVV0aWxzLmFwcGVuZFRvSGVhZCh0YWcpO1xuXG5cdFx0cmV0dXJuIHRhZztcblx0fTtcblxuXHRjcmVhdGVqcy5DU1NMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKENTU0xvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEltYWdlTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIGltYWdlIGZpbGVzLlxuXHQgKiBAY2xhc3MgSW1hZ2VMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZmVyWEhSXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gSW1hZ2VMb2FkZXIgKGxvYWRJdGVtLCBwcmVmZXJYSFIpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLklNQUdFKTtcblxuXHRcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5yZXN1bHRGb3JtYXR0ZXIgPSB0aGlzLl9mb3JtYXRSZXN1bHQ7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSA9IFwic3JjXCI7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgcHJlbG9hZCBpdGVtIGlzIGFscmVhZHkgYSB0YWcuXG5cdFx0aWYgKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc0ltYWdlVGFnKGxvYWRJdGVtKSkge1xuXHRcdFx0dGhpcy5fdGFnID0gbG9hZEl0ZW07XG5cdFx0fSBlbHNlIGlmIChjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNJbWFnZVRhZyhsb2FkSXRlbS5zcmMpKSB7XG5cdFx0XHR0aGlzLl90YWcgPSBsb2FkSXRlbS5zcmM7XG5cdFx0fSBlbHNlIGlmIChjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNJbWFnZVRhZyhsb2FkSXRlbS50YWcpKSB7XG5cdFx0XHR0aGlzLl90YWcgPSBsb2FkSXRlbS50YWc7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3RhZyAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLl9wcmVmZXJYSFIgPSBmYWxzZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcblx0XHR9XG5cblx0XHR0aGlzLm9uKFwiaW5pdGlhbGl6ZVwiLCB0aGlzLl91cGRhdGVYSFIsIHRoaXMpO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEltYWdlTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gSW1hZ2VMb2FkZXI7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9JTUFHRTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5JTUFHRTtcblx0fTtcblxuXHQvLyBwdWJsaWMgbWV0aG9kc1xuXHRwLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3RhZy5zcmMgIT0gXCJcIiAmJiB0aGlzLl90YWcuY29tcGxldGUpIHtcblx0XHRcdHRoaXMuX3NlbmRDb21wbGV0ZSgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBjcm9zc09yaWdpbiA9IHRoaXMuX2l0ZW0uY3Jvc3NPcmlnaW47XG5cdFx0aWYgKGNyb3NzT3JpZ2luID09IHRydWUpIHsgY3Jvc3NPcmlnaW4gPSBcIkFub255bW91c1wiOyB9XG5cdFx0aWYgKGNyb3NzT3JpZ2luICE9IG51bGwgJiYgIWNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc0xvY2FsKHRoaXMuX2l0ZW0uc3JjKSkge1xuXHRcdFx0dGhpcy5fdGFnLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG5cdFx0fVxuXG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9sb2FkKCk7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIEJlZm9yZSB0aGUgaXRlbSBsb2Fkcywgc2V0IGl0cyBtaW1lVHlwZSBhbmQgcmVzcG9uc2VUeXBlLlxuXHQgKiBAcHJvcGVydHkgX3VwZGF0ZVhIUlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fdXBkYXRlWEhSID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ZXZlbnQubG9hZGVyLm1pbWVUeXBlID0gJ3RleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWQtYmluYXJ5JztcblxuXHRcdC8vIE9ubHkgZXhpc3RzIGZvciBYSFJcblx0XHRpZiAoZXZlbnQubG9hZGVyLnNldFJlc3BvbnNlVHlwZSkge1xuXHRcdFx0ZXZlbnQubG9hZGVyLnNldFJlc3BvbnNlVHlwZShcImJsb2JcIik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgcmVzdWx0IGZvcm1hdHRlciBmb3IgSW1hZ2UgZmlsZXMuXG5cdCAqIEBtZXRob2QgX2Zvcm1hdFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHJldHVybnMge0hUTUxJbWFnZUVsZW1lbnR9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9mb3JtYXRSZXN1bHQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Zvcm1hdEltYWdlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgYXN5bmNocm9ub3VzIGltYWdlIGZvcm1hdHRlciBmdW5jdGlvbi4gVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIGltYWdlcyBoYXZlXG5cdCAqIGEgc2hvcnQgZGVsYXkgYmVmb3JlIHRoZXkgYXJlIHJlYWR5LlxuXHQgKiBAbWV0aG9kIF9mb3JtYXRJbWFnZVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWNjZXNzQ2FsbGJhY2sgVGhlIG1ldGhvZCB0byBjYWxsIHdoZW4gdGhlIHJlc3VsdCBoYXMgZmluaXNoZWQgZm9ybWF0dGluZ1xuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvckNhbGxiYWNrIFRoZSBtZXRob2QgdG8gY2FsbCBpZiBhbiBlcnJvciBvY2N1cnMgZHVyaW5nIGZvcm1hdHRpbmdcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdEltYWdlID0gZnVuY3Rpb24gKHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuXHRcdHZhciB0YWcgPSB0aGlzLl90YWc7XG5cdFx0dmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcblxuXHRcdGlmICghdGhpcy5fcHJlZmVyWEhSKSB7XG5cdFx0XHQvL2RvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGFnKTtcblx0XHR9IGVsc2UgaWYgKFVSTCkge1xuXHRcdFx0dmFyIG9ialVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwodGhpcy5nZXRSZXN1bHQodHJ1ZSkpO1xuXHRcdFx0dGFnLnNyYyA9IG9ialVSTDtcblxuXHRcdFx0dGFnLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHRoaXMuX2NsZWFuVXBVUkwsIGZhbHNlKTtcblx0XHRcdHRhZy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5fY2xlYW5VcFVSTCwgZmFsc2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YWcuc3JjID0gdGhpcy5faXRlbS5zcmM7XG5cdFx0fVxuXG5cdFx0aWYgKHRhZy5jb21wbGV0ZSkge1xuXHRcdFx0c3VjY2Vzc0NhbGxiYWNrKHRhZyk7XG5cdFx0fSBlbHNlIHtcbiAgICAgICAgICAgIHRhZy5vbmxvYWQgPSBjcmVhdGVqcy5wcm94eShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2sodGhpcy5fdGFnKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICB0YWcub25lcnJvciA9IGNyZWF0ZWpzLnByb3h5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soX3RoaXMuX3RhZyk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENsZWFuIHVwIHRoZSBPYmplY3RVUkwsIHRoZSB0YWcgaXMgZG9uZSB3aXRoIGl0LiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBpcyBydW5cblx0ICogYXMgYW4gZXZlbnQgbGlzdGVuZXIgd2l0aG91dCBhIHByb3h5L2Nsb3N1cmUsIGFzIGl0IGRvZXNuJ3QgcmVxdWlyZSBpdCAtIHNvIGRvIG5vdFxuXHQgKiBpbmNsdWRlIGFueSBmdW5jdGlvbmFsaXR5IHRoYXQgcmVxdWlyZXMgc2NvcGUgd2l0aG91dCBjaGFuZ2luZyBpdC5cblx0ICogQG1ldGhvZCBfY2xlYW5VcFVSTFxuXHQgKiBAcGFyYW0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NsZWFuVXBVUkwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwoZXZlbnQudGFyZ2V0LnNyYyk7XG5cdH07XG5cblx0Y3JlYXRlanMuSW1hZ2VMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEltYWdlTG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gSmF2YVNjcmlwdExvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBKYXZhU2NyaXB0IGZpbGVzLlxuXHQgKiBAY2xhc3MgSmF2YVNjcmlwdExvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmVmZXJYSFJcblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBKYXZhU2NyaXB0TG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpBVkFTQ1JJUFQpO1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHR0aGlzLnJlc3VsdEZvcm1hdHRlciA9IHRoaXMuX2Zvcm1hdFJlc3VsdDtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5fdGFnU3JjQXR0cmlidXRlID0gXCJzcmNcIjtcblx0XHR0aGlzLnNldFRhZyhkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKTtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChKYXZhU2NyaXB0TG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gSmF2YVNjcmlwdExvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pBVkFTQ1JJUFQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KQVZBU0NSSVBUO1xuXHR9O1xuXG5cdC8vIHByb3RlY3RlZCBtZXRob2RzXG5cdC8qKlxuXHQgKiBUaGUgcmVzdWx0IGZvcm1hdHRlciBmb3IgSmF2YVNjcmlwdCBmaWxlcy5cblx0ICogQG1ldGhvZCBfZm9ybWF0UmVzdWx0XG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcmV0dXJucyB7SFRNTExpbmtFbGVtZW50fEhUTUxTdHlsZUVsZW1lbnR9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9mb3JtYXRSZXN1bHQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0dmFyIHRhZyA9IGxvYWRlci5nZXRUYWcoKTtcblx0XHRpZiAodGhpcy5fcHJlZmVyWEhSKSB7XG5cdFx0XHR0YWcudGV4dCA9IGxvYWRlci5nZXRSZXN1bHQodHJ1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiB0YWc7XG5cdH07XG5cblx0Y3JlYXRlanMuSmF2YVNjcmlwdExvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoSmF2YVNjcmlwdExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEpTT05Mb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgSlNPTiBmaWxlcy4gVG8gbG9hZCBKU09OIGNyb3NzLWRvbWFpbiwgdXNlIEpTT05QIGFuZCB0aGUge3sjY3Jvc3NMaW5rIFwiSlNPTlBMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaW5zdGVhZC4gVG8gbG9hZCBKU09OLWZvcm1hdHRlZCBtYW5pZmVzdHMsIHVzZSB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHRvXG5cdCAqIGxvYWQgRWFzZWxKUyBTcHJpdGVTaGVldHMsIHVzZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldExvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQGNsYXNzIEpTT05Mb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gSlNPTkxvYWRlcihsb2FkSXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHRydWUsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpTT04pO1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHR0aGlzLnJlc3VsdEZvcm1hdHRlciA9IHRoaXMuX2Zvcm1hdFJlc3VsdDtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChKU09OTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gSlNPTkxvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pTT046cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSlNPTjtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogVGhlIHJlc3VsdCBmb3JtYXR0ZXIgZm9yIEpTT04gZmlsZXMuXG5cdCAqIEBtZXRob2QgX2Zvcm1hdFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHJldHVybnMge0hUTUxMaW5rRWxlbWVudHxIVE1MU3R5bGVFbGVtZW50fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZm9ybWF0UmVzdWx0ID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdHZhciBqc29uID0gbnVsbDtcblx0XHR0cnkge1xuXHRcdFx0anNvbiA9IGNyZWF0ZWpzLkRhdGFVdGlscy5wYXJzZUpTT04obG9hZGVyLmdldFJlc3VsdCh0cnVlKSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJKU09OX0ZPUk1BVFwiLCBudWxsLCBlKTtcblx0XHRcdHRoaXMuX3NlbmRFcnJvcihldmVudCk7XG5cdFx0XHRyZXR1cm4gZTtcblx0XHR9XG5cblx0XHRyZXR1cm4ganNvbjtcblx0fTtcblxuXHRjcmVhdGVqcy5KU09OTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShKU09OTG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gSlNPTlBMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgSlNPTlAgZmlsZXMsIHdoaWNoIGFyZSBKU09OLWZvcm1hdHRlZCB0ZXh0IGZpbGVzLCB3cmFwcGVkIGluIGEgY2FsbGJhY2suIFRvIGxvYWQgcmVndWxhciBKU09OXG5cdCAqIHdpdGhvdXQgYSBjYWxsYmFjayB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkpTT05Mb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC4gVG8gbG9hZCBKU09OLWZvcm1hdHRlZCBtYW5pZmVzdHMsXG5cdCAqIHVzZSB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHRvIGxvYWQgRWFzZWxKUyBTcHJpdGVTaGVldHMsIHVzZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldExvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogSlNPTlAgaXMgYSBmb3JtYXQgdGhhdCBwcm92aWRlcyBhIHNvbHV0aW9uIGZvciBsb2FkaW5nIEpTT04gZmlsZXMgY3Jvc3MtZG9tYWluIDxlbT53aXRob3V0PC9lbT4gcmVxdWlyaW5nIENPUlMuXG5cdCAqIEpTT05QIGZpbGVzIGFyZSBsb2FkZWQgYXMgSmF2YVNjcmlwdCwgYW5kIHRoZSBcImNhbGxiYWNrXCIgaXMgZXhlY3V0ZWQgb25jZSB0aGV5IGFyZSBsb2FkZWQuIFRoZSBjYWxsYmFjayBpbiB0aGVcblx0ICogSlNPTlAgbXVzdCBtYXRjaCB0aGUgY2FsbGJhY2sgcGFzc2VkIHRvIHRoZSBsb2FkSXRlbS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGUgSlNPTlA8L2g0PlxuXHQgKlxuXHQgKiBcdFx0Y2FsbGJhY2tOYW1lKHtcblx0ICogXHRcdFx0XCJuYW1lXCI6IFwidmFsdWVcIixcblx0ICpcdCBcdFx0XCJudW1cIjogMyxcblx0ICpcdFx0XHRcIm9ialwiOiB7IFwiYm9vbFwiOnRydWUgfVxuXHQgKiBcdFx0fSk7XG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogXHRcdHZhciBsb2FkSXRlbSA9IHtpZDpcImpzb25cIiwgdHlwZTpcImpzb25wXCIsIHNyYzpcImh0dHA6Ly9zZXJ2ZXIuY29tL3RleHQuanNvblwiLCBjYWxsYmFjazpcImNhbGxiYWNrTmFtZVwifVxuXHQgKiBcdFx0dmFyIHF1ZXVlID0gbmV3IGNyZWF0ZWpzLkxvYWRRdWV1ZSgpO1xuXHQgKiBcdFx0cXVldWUub24oXCJjb21wbGV0ZVwiLCBoYW5kbGVDb21wbGV0ZSk7XG5cdCAqIFx0XHRxdWV1ZS5sb2FkSXRlbShsb2FkSXRlbSk7XG5cdCAqXG5cdCAqIFx0XHRmdW5jdGlvbiBoYW5kbGVDb21wbGV0ZShldmVudCkgfVxuXHQgKiBcdFx0XHR2YXIganNvbiA9IHF1ZXVlLmdldFJlc3VsdChcImpzb25cIik7XG5cdCAqIFx0XHRcdGNvbnNvbGUubG9nKGpzb24ub2JqLmJvb2wpOyAvLyB0cnVlXG5cdCAqIFx0XHR9XG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBKU09OUCBmaWxlcyBsb2FkZWQgY29uY3VycmVudGx5IHJlcXVpcmUgYSA8ZW0+dW5pcXVlPC9lbT4gY2FsbGJhY2suIFRvIGVuc3VyZSBKU09OUCBmaWxlcyBhcmUgbG9hZGVkXG5cdCAqIGluIG9yZGVyLCBlaXRoZXIgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc2V0TWF4Q29ubmVjdGlvbnNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIChzZXQgdG8gMSksXG5cdCAqIG9yIHNldCB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS9tYWludGFpbk9yZGVyOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IG9uIGl0ZW1zIHdpdGggdGhlIHNhbWUgY2FsbGJhY2suXG5cdCAqXG5cdCAqIEBjbGFzcyBKU09OUExvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBKU09OUExvYWRlcihsb2FkSXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIGZhbHNlLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KU09OUCk7XG5cdFx0dGhpcy5zZXRUYWcoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSk7XG5cdFx0dGhpcy5nZXRUYWcoKS50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChKU09OUExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IEpTT05QTG9hZGVyO1xuXG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9KU09OUDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KU09OUDtcblx0fTtcblxuXHQvLyBwdWJsaWMgbWV0aG9kc1xuXHRwLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NhbmNlbCgpO1xuXHRcdHRoaXMuX2Rpc3Bvc2UoKTtcblx0fTtcblxuXHQvKipcblx0ICogTG9hZHMgdGhlIEpTT05wIGZpbGUuICBCZWNhdXNlIG9mIHRoZSB1bmlxdWUgbG9hZGluZyBuZWVkcyBvZiBKU09OcFxuXHQgKiB3ZSBkb24ndCB1c2UgdGhlIEFic3RyYWN0TG9hZGVyLmxvYWQoKSBtZXRob2QuXG5cdCAqXG5cdCAqIEBtZXRob2QgbG9hZFxuXHQgKlxuXHQgKi9cblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9pdGVtLmNhbGxiYWNrID09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignY2FsbGJhY2sgaXMgcmVxdWlyZWQgZm9yIGxvYWRpbmcgSlNPTlAgcmVxdWVzdHMuJyk7XG5cdFx0fVxuXG5cdFx0Ly8gVE9ETzogTG9vayBpbnRvIGNyZWF0aW5nIG91ciBvd24gaUZyYW1lIHRvIGhhbmRsZSB0aGUgbG9hZFxuXHRcdC8vIEluIHRoZSBmaXJzdCBhdHRlbXB0LCBGRiBkaWQgbm90IGdldCB0aGUgcmVzdWx0XG5cdFx0Ly8gICByZXN1bHQgaW5zdGFuY2VvZiBPYmplY3QgZGlkIG5vdCB3b3JrIGVpdGhlclxuXHRcdC8vICAgc28gd2Ugd291bGQgbmVlZCB0byBjbG9uZSB0aGUgcmVzdWx0LlxuXHRcdGlmICh3aW5kb3dbdGhpcy5faXRlbS5jYWxsYmFja10gIT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcIkpTT05QIGNhbGxiYWNrICdcIiArXG5cdFx0XHRcdHRoaXMuX2l0ZW0uY2FsbGJhY2sgK1xuXHRcdFx0XHRcIicgYWxyZWFkeSBleGlzdHMgb24gd2luZG93LiBZb3UgbmVlZCB0byBzcGVjaWZ5IGEgZGlmZmVyZW50IGNhbGxiYWNrIG9yIHJlLW5hbWUgdGhlIGN1cnJlbnQgb25lLlwiKTtcblx0XHR9XG5cblx0XHR3aW5kb3dbdGhpcy5faXRlbS5jYWxsYmFja10gPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVMb2FkLCB0aGlzKTtcblx0XHR3aW5kb3cuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl90YWcpO1xuXG5cdFx0dGhpcy5fbG9hZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVRpbWVvdXQsIHRoaXMpLCB0aGlzLl9pdGVtLmxvYWRUaW1lb3V0KTtcblxuXHRcdC8vIExvYWQgdGhlIHRhZ1xuXHRcdHRoaXMuX3RhZy5zcmMgPSB0aGlzLl9pdGVtLnNyYztcblx0fTtcblxuXHQvLyBwcml2YXRlIG1ldGhvZHNcblx0LyoqXG5cdCAqIEhhbmRsZSB0aGUgSlNPTlAgY2FsbGJhY2ssIHdoaWNoIGlzIGEgcHVibGljIG1ldGhvZCBkZWZpbmVkIG9uIGB3aW5kb3dgLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVMb2FkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBmb3JtYXR0ZWQgSlNPTiBkYXRhLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTG9hZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0dGhpcy5fcmVzdWx0ID0gdGhpcy5fcmF3UmVzdWx0ID0gZGF0YTtcblx0XHR0aGlzLl9zZW5kQ29tcGxldGUoKTtcblxuXHRcdHRoaXMuX2Rpc3Bvc2UoKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIHRhZyByZXF1ZXN0IGhhcyBub3QgbG9hZGVkIHdpdGhpbiB0aGUgdGltZSBzcGVjZmllZCBpbiBsb2FkVGltZW91dC5cblx0ICogQG1ldGhvZCBfaGFuZGxlRXJyb3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBYSFIgZXJyb3IgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2Rpc3Bvc2UoKTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJ0aW1lb3V0XCIpKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2xlYW4gdXAgdGhlIEpTT05QIGxvYWQuIFRoaXMgY2xlYXJzIG91dCB0aGUgY2FsbGJhY2sgYW5kIHNjcmlwdCB0YWcgdGhhdCB0aGlzIGxvYWRlciBjcmVhdGVzLlxuXHQgKiBAbWV0aG9kIF9kaXNwb3NlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHRcdHdpbmRvdy5kb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuX3RhZyk7XG5cdFx0ZGVsZXRlIHdpbmRvd1t0aGlzLl9pdGVtLmNhbGxiYWNrXTtcblxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9sb2FkVGltZW91dCk7XG5cdH07XG5cblx0Y3JlYXRlanMuSlNPTlBMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEpTT05QTG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gTWFuaWZlc3RMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgSlNPTiBtYW5pZmVzdHMuIEl0ZW1zIGluc2lkZSB0aGUgbWFuaWZlc3QgYXJlIGxvYWRlZCBiZWZvcmUgdGhlIGxvYWRlciBjb21wbGV0ZXMuIFRvIGxvYWQgbWFuaWZlc3RzXG5cdCAqIHVzaW5nIEpTT05QLCBzcGVjaWZ5IGEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vY2FsbGJhY2s6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gYXMgcGFydCBvZiB0aGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIFRoZSBsaXN0IG9mIGZpbGVzIGluIHRoZSBtYW5pZmVzdCBtdXN0IGJlIGRlZmluZWQgb24gdGhlIHRvcC1sZXZlbCBKU09OIG9iamVjdCBpbiBhIGBtYW5pZmVzdGAgcHJvcGVydHkuIFRoaXNcblx0ICogZXhhbXBsZSBzaG93cyBhIHNhbXBsZSBtYW5pZmVzdCBkZWZpbml0aW9uLCBhcyB3ZWxsIGFzIGhvdyB0byB0byBpbmNsdWRlIGEgc3ViLW1hbmlmZXN0LlxuXHQgKlxuXHQgKiBcdFx0e1xuXHQgKiBcdFx0XHRcInBhdGhcIjogXCJhc3NldHMvXCIsXG5cdCAqXHQgXHQgICAgXCJtYW5pZmVzdFwiOiBbXG5cdCAqXHRcdFx0XHRcImltYWdlLnBuZ1wiLFxuXHQgKlx0XHRcdFx0e1wic3JjXCI6IFwiaW1hZ2UyLnBuZ1wiLCBcImlkXCI6XCJpbWFnZTJcIn0sXG5cdCAqXHRcdFx0XHR7XCJzcmNcIjogXCJzdWItbWFuaWZlc3QuanNvblwiLCBcInR5cGVcIjpcIm1hbmlmZXN0XCIsIFwiY2FsbGJhY2tcIjpcImpzb25DYWxsYmFja1wifVxuXHQgKlx0IFx0ICAgIF1cblx0ICpcdCBcdH1cblx0ICpcblx0ICogV2hlbiBhIE1hbmlmZXN0TG9hZGVyIGhhcyBjb21wbGV0ZWQgbG9hZGluZywgdGhlIHBhcmVudCBsb2FkZXIgKHVzdWFsbHkgYSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIGJ1dCBjb3VsZCBhbHNvIGJlIGFub3RoZXIgTWFuaWZlc3RMb2FkZXIpIHdpbGwgaW5oZXJpdCBhbGwgdGhlIGxvYWRlZCBpdGVtcywgc28geW91IGNhbiBhY2Nlc3MgdGhlbSBkaXJlY3RseS5cblx0ICpcblx0ICogTm90ZSB0aGF0IHRoZSB7eyNjcm9zc0xpbmsgXCJKU09OTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJKU09OUExvYWRlclwifX17ey9jcm9zc0xpbmt9fSBhcmVcblx0ICogaGlnaGVyIHByaW9yaXR5IGxvYWRlcnMsIHNvIG1hbmlmZXN0cyA8c3Ryb25nPm11c3Q8L3N0cm9uZz4gc2V0IHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS90eXBlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IHRvIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL01BTklGRVNUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAY2xhc3MgTWFuaWZlc3RMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gTWFuaWZlc3RMb2FkZXIobG9hZEl0ZW0pIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBudWxsLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5NQU5JRkVTVCk7XG5cblx0Ly8gUHVibGljIFByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBvZiB0aGUgcGx1Z2lucyByZWdpc3RlcmVkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9pbnN0YWxsUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319LFxuXHRcdCAqIHVzZWQgdG8gcGFzcyBwbHVnaW5zIHRvIG5ldyBMb2FkUXVldWVzIHRoYXQgbWF5IGJlIGNyZWF0ZWQuXG5cdFx0ICogQHByb3BlcnR5IF9wbHVnaW5zXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHNpbmNlIDAuNi4xXG5cdFx0ICovXG5cdFx0dGhpcy5wbHVnaW5zID0gbnVsbDtcblxuXG5cdC8vIFByb3RlY3RlZCBQcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogQW4gaW50ZXJuYWwge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgbG9hZHMgdGhlIGNvbnRlbnRzIG9mIHRoZSBtYW5pZmVzdC5cblx0XHQgKiBAcHJvcGVydHkgX21hbmlmZXN0UXVldWVcblx0XHQgKiBAdHlwZSB7TG9hZFF1ZXVlfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbWFuaWZlc3RRdWV1ZSA9IG51bGw7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoTWFuaWZlc3RMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBNYW5pZmVzdExvYWRlcjtcblxuXHQvLyBzdGF0aWMgcHJvcGVydGllc1xuXHQvKipcblx0ICogVGhlIGFtb3VudCBvZiBwcm9ncmVzcyB0aGF0IHRoZSBtYW5pZmVzdCBpdHNlbGYgdGFrZXMgdXAuXG5cdCAqIEBwcm9wZXJ0eSBNQU5JRkVTVF9QUk9HUkVTU1xuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAwLjI1ICgyNSUpXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuTUFOSUZFU1RfUFJPR1JFU1MgPSAwLjI1O1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvTUFOSUZFU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5NQU5JRkVTVDtcblx0fTtcblxuXHQvLyBwdWJsaWMgbWV0aG9kc1xuXHRwLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9sb2FkKCk7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0cC5fY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IHRoaXMuX2l0ZW0uY2FsbGJhY2s7XG5cdFx0aWYgKGNhbGxiYWNrICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuSlNPTlBMb2FkZXIodGhpcy5faXRlbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuSlNPTkxvYWRlcih0aGlzLl9pdGVtKTtcblx0XHR9XG5cdH07XG5cblx0cC5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHN3aXRjaCAoZXZlbnQudHlwZSkge1xuXHRcdFx0Y2FzZSBcImNvbXBsZXRlXCI6XG5cdFx0XHRcdHRoaXMuX3Jhd1Jlc3VsdCA9IGV2ZW50LnRhcmdldC5nZXRSZXN1bHQodHJ1ZSk7XG5cdFx0XHRcdHRoaXMuX3Jlc3VsdCA9IGV2ZW50LnRhcmdldC5nZXRSZXN1bHQoKTtcblx0XHRcdFx0dGhpcy5fc2VuZFByb2dyZXNzKHMuTUFOSUZFU1RfUFJPR1JFU1MpO1xuXHRcdFx0XHR0aGlzLl9sb2FkTWFuaWZlc3QodGhpcy5fcmVzdWx0KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0Y2FzZSBcInByb2dyZXNzXCI6XG5cdFx0XHRcdGV2ZW50LmxvYWRlZCAqPSBzLk1BTklGRVNUX1BST0dSRVNTO1xuXHRcdFx0XHR0aGlzLnByb2dyZXNzID0gZXZlbnQubG9hZGVkIC8gZXZlbnQudG90YWw7XG5cdFx0XHRcdGlmIChpc05hTih0aGlzLnByb2dyZXNzKSB8fCB0aGlzLnByb2dyZXNzID09IEluZmluaXR5KSB7IHRoaXMucHJvZ3Jlc3MgPSAwOyB9XG5cdFx0XHRcdHRoaXMuX3NlbmRQcm9ncmVzcyhldmVudCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9oYW5kbGVFdmVudChldmVudCk7XG5cdH07XG5cblx0cC5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9kZXN0cm95KCk7XG5cdFx0dGhpcy5fbWFuaWZlc3RRdWV1ZS5jbG9zZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW5kIGxvYWQgdGhlIG1hbmlmZXN0IGl0ZW1zIG9uY2UgdGhlIGFjdHVhbCBtYW5pZmVzdCBoYXMgYmVlbiBsb2FkZWQuXG5cdCAqIEBtZXRob2QgX2xvYWRNYW5pZmVzdFxuXHQgKiBAcGFyYW0ge09iamVjdH0ganNvblxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fbG9hZE1hbmlmZXN0ID0gZnVuY3Rpb24gKGpzb24pIHtcblx0XHRpZiAoanNvbiAmJiBqc29uLm1hbmlmZXN0KSB7XG5cdFx0XHR2YXIgcXVldWUgPSB0aGlzLl9tYW5pZmVzdFF1ZXVlID0gbmV3IGNyZWF0ZWpzLkxvYWRRdWV1ZSgpO1xuXHRcdFx0cXVldWUub24oXCJmaWxlbG9hZFwiLCB0aGlzLl9oYW5kbGVNYW5pZmVzdEZpbGVMb2FkLCB0aGlzKTtcblx0XHRcdHF1ZXVlLm9uKFwicHJvZ3Jlc3NcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RQcm9ncmVzcywgdGhpcyk7XG5cdFx0XHRxdWV1ZS5vbihcImNvbXBsZXRlXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0Q29tcGxldGUsIHRoaXMsIHRydWUpO1xuXHRcdFx0cXVldWUub24oXCJlcnJvclwiLCB0aGlzLl9oYW5kbGVNYW5pZmVzdEVycm9yLCB0aGlzLCB0cnVlKTtcblx0XHRcdGZvcih2YXIgaSA9IDAsIGwgPSB0aGlzLnBsdWdpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHQvLyBjb25zZXJ2ZSBvcmRlciBvZiBwbHVnaW5zXG5cdFx0XHRcdHF1ZXVlLmluc3RhbGxQbHVnaW4odGhpcy5wbHVnaW5zW2ldKTtcblx0XHRcdH1cblx0XHRcdHF1ZXVlLmxvYWRNYW5pZmVzdChqc29uKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbiBpdGVtIGZyb20gdGhlIHt7I2Nyb3NzTGluayBcIl9tYW5pZmVzdFF1ZXVlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGhhcyBjb21wbGV0ZWQuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0RmlsZUxvYWRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZU1hbmlmZXN0RmlsZUxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC50YXJnZXQgPSBudWxsO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBtYW5pZmVzdCBoYXMgY29tcGxldGVkIGxvYWRpbmcuIFRoaXMgdHJpZ2dlcnMgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2NvbXBsZXRlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGZyb20gdGhlIE1hbmlmZXN0TG9hZGVyLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNYW5pZmVzdENvbXBsZXRlXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVNYW5pZmVzdENvbXBsZXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dGhpcy5fbG9hZGVkSXRlbXMgPSB0aGlzLl9tYW5pZmVzdFF1ZXVlLmdldEl0ZW1zKHRydWUpO1xuXHRcdHRoaXMuX3NlbmRDb21wbGV0ZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbWFuaWZlc3QgaGFzIHJlcG9ydGVkIHByb2dyZXNzLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNYW5pZmVzdFByb2dyZXNzXG5cdCAqIEBwYXJhbSB7UHJvZ3Jlc3NFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZU1hbmlmZXN0UHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLnByb2dyZXNzID0gZXZlbnQucHJvZ3Jlc3MgKiAoMSAtIHMuTUFOSUZFU1RfUFJPR1JFU1MpICsgcy5NQU5JRkVTVF9QUk9HUkVTUztcblx0XHR0aGlzLl9zZW5kUHJvZ3Jlc3ModGhpcy5wcm9ncmVzcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBtYW5pZmVzdCBoYXMgcmVwb3J0ZWQgYW4gZXJyb3Igd2l0aCBvbmUgb2YgdGhlIGZpbGVzLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNYW5pZmVzdEVycm9yXG5cdCAqIEBwYXJhbSB7RXJyb3JFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZU1hbmlmZXN0RXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgbmV3RXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJmaWxlZXJyb3JcIik7XG5cdFx0bmV3RXZlbnQuaXRlbSA9IGV2ZW50LmRhdGE7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcblx0fTtcblxuXHRjcmVhdGVqcy5NYW5pZmVzdExvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoTWFuaWZlc3RMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTb3VuZExvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBIVE1MIGF1ZGlvIGZpbGVzLiBQcmVsb2FkSlMgY2FuIG5vdCBsb2FkIFdlYkF1ZGlvIGZpbGVzLCBhcyBhIFdlYkF1ZGlvIGNvbnRleHQgaXMgcmVxdWlyZWQsIHdoaWNoXG5cdCAqIHNob3VsZCBiZSBjcmVhdGVkIGJ5IGVpdGhlciBhIGxpYnJhcnkgcGxheWluZyB0aGUgc291bmQgKHN1Y2ggYXMgPGEgaHJlZj1cImh0dHA6Ly9zb3VuZGpzLmNvbVwiPlNvdW5kSlM8L2E+LCBvciBhblxuXHQgKiBleHRlcm5hbCBmcmFtZXdvcmsgdGhhdCBoYW5kbGVzIGF1ZGlvIHBsYXliYWNrLiBUbyBsb2FkIGNvbnRlbnQgdGhhdCBjYW4gYmUgcGxheWVkIGJ5IFdlYkF1ZGlvLCB1c2UgdGhlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkJpbmFyeUxvYWRlclwifX17ey9jcm9zc0xpbmt9fSwgYW5kIGhhbmRsZSB0aGUgYXVkaW8gY29udGV4dCBkZWNvZGluZyBtYW51YWxseS5cblx0ICogQGNsYXNzIFNvdW5kTG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZlclhIUlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdE1lZGlhTG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gU291bmRMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUikge1xuXHRcdHRoaXMuQWJzdHJhY3RNZWRpYUxvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgcHJlZmVyWEhSLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TT1VORCk7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdGlmIChjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNBdWRpb1RhZyhsb2FkSXRlbSkpIHtcblx0XHRcdHRoaXMuX3RhZyA9IGxvYWRJdGVtO1xuXHRcdH0gZWxzZSBpZiAoY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzQXVkaW9UYWcobG9hZEl0ZW0uc3JjKSkge1xuXHRcdFx0dGhpcy5fdGFnID0gbG9hZEl0ZW07XG5cdFx0fSBlbHNlIGlmIChjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNBdWRpb1RhZyhsb2FkSXRlbS50YWcpKSB7XG5cdFx0XHR0aGlzLl90YWcgPSBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNBdWRpb1RhZyhsb2FkSXRlbSkgPyBsb2FkSXRlbSA6IGxvYWRJdGVtLnNyYztcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fdGFnICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3ByZWZlclhIUiA9IGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChTb3VuZExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RNZWRpYUxvYWRlcik7XG5cdHZhciBzID0gU291bmRMb2FkZXI7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TT1VORDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TT1VORDtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHRwLl9jcmVhdGVUYWcgPSBmdW5jdGlvbiAoc3JjKSB7XG5cdFx0dmFyIHRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhdWRpb1wiKTtcblx0XHR0YWcuYXV0b3BsYXkgPSBmYWxzZTtcblx0XHR0YWcucHJlbG9hZCA9IFwibm9uZVwiO1xuXG5cdFx0Ly9MTTogRmlyZWZveCBmYWlscyB3aGVuIHRoaXMgdGhlIHByZWxvYWQ9XCJub25lXCIgZm9yIG90aGVyIHRhZ3MsIGJ1dCBpdCBuZWVkcyB0byBiZSBcIm5vbmVcIiB0byBlbnN1cmUgUHJlbG9hZEpTIHdvcmtzLlxuXHRcdHRhZy5zcmMgPSBzcmM7XG5cdFx0cmV0dXJuIHRhZztcblx0fTtcblxuXHRjcmVhdGVqcy5Tb3VuZExvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoU291bmRMb2FkZXIsIFwiQWJzdHJhY3RNZWRpYUxvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFZpZGVvTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIHZpZGVvIGZpbGVzLlxuXHQgKiBAY2xhc3MgVmlkZW9Mb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZmVyWEhSXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TWVkaWFMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBWaWRlb0xvYWRlcihsb2FkSXRlbSwgcHJlZmVyWEhSKSB7XG5cdFx0dGhpcy5BYnN0cmFjdE1lZGlhTG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlZJREVPKTtcblxuXHRcdGlmIChjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNWaWRlb1RhZyhsb2FkSXRlbSkgfHwgY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzVmlkZW9UYWcobG9hZEl0ZW0uc3JjKSkge1xuXHRcdFx0dGhpcy5zZXRUYWcoY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzVmlkZW9UYWcobG9hZEl0ZW0pP2xvYWRJdGVtOmxvYWRJdGVtLnNyYyk7XG5cblx0XHRcdC8vIFdlIGNhbid0IHVzZSBYSFIgZm9yIGEgdGFnIHRoYXQncyBwYXNzZWQgaW4uXG5cdFx0XHR0aGlzLl9wcmVmZXJYSFIgPSBmYWxzZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZXRUYWcodGhpcy5fY3JlYXRlVGFnKCkpO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChWaWRlb0xvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RNZWRpYUxvYWRlcik7XG5cdHZhciBzID0gVmlkZW9Mb2FkZXI7XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIG5ldyB2aWRlbyB0YWdcblx0ICpcblx0ICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY3JlYXRlVGFnID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XG5cdH07XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9WSURFTzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5WSURFTztcblx0fTtcblxuXHRjcmVhdGVqcy5WaWRlb0xvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoVmlkZW9Mb2FkZXIsIFwiQWJzdHJhY3RNZWRpYUxvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNwcml0ZVNoZWV0TG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIEVhc2VsSlMgU3ByaXRlU2hlZXRzLiBJbWFnZXMgaW5zaWRlIHRoZSBzcHJpdGVzaGVldCBkZWZpbml0aW9uIGFyZSBsb2FkZWQgYmVmb3JlIHRoZSBsb2FkZXJcblx0ICogY29tcGxldGVzLiBUbyBsb2FkIFNwcml0ZVNoZWV0cyB1c2luZyBKU09OUCwgc3BlY2lmeSBhIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL2NhbGxiYWNrOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGFzIHBhcnQgb2YgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319LiBOb3RlIHRoYXQgdGhlIHt7I2Nyb3NzTGluayBcIkpTT05Mb2FkZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogYW5kIHt7I2Nyb3NzTGluayBcIkpTT05QTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGFyZSBoaWdoZXIgcHJpb3JpdHkgbG9hZGVycywgc28gU3ByaXRlU2hlZXRzIDxzdHJvbmc+bXVzdDwvc3Ryb25nPlxuXHQgKiBzZXQgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319IHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL3R5cGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHlcblx0ICogdG8ge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvU1BSSVRFU0hFRVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS9jcm9zc09yaWdpbjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBhcyB3ZWxsXG5cdCAqIGFzIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUnc1wifX17ey9jcm9zc0xpbmt9fSBgYmFzZVBhdGhgIGFyZ3VtZW50IGFuZCB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvX3ByZWZlclhIUlwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBwcm9wZXJ0eSBzdXBwbGllZCB0byB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319IGFyZSBwYXNzZWQgb24gdG8gdGhlIHN1Yi1tYW5pZmVzdCB0aGF0IGxvYWRzXG5cdCAqIHRoZSBTcHJpdGVTaGVldCBpbWFnZXMuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUgU3ByaXRlU2hlZXQgSlNPTiBkb2VzIG5vdCByZXNwZWN0IHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvX3ByZWZlclhIUjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBwcm9wZXJ0eSwgd2hpY2ggc2hvdWxkIGluc3RlYWQgYmUgZGV0ZXJtaW5lZCBieSB0aGUgcHJlc2VuY2Ugb2YgYSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS9jYWxsYmFjazpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBwcm9wZXJ0eSBvbiB0aGUgU3ByaXRlU2hlZXQgbG9hZCBpdGVtLiBUaGlzIGlzIGJlY2F1c2UgdGhlIEpTT04gbG9hZGVkIHdpbGwgaGF2ZSBhIGRpZmZlcmVudCBmb3JtYXQgZGVwZW5kaW5nIG9uXG5cdCAqIGlmIGl0IGlzIGxvYWRlZCBhcyBKU09OLCBzbyBqdXN0IGNoYW5naW5nIGBwcmVmZXJYSFJgIGlzIG5vdCBlbm91Z2ggdG8gY2hhbmdlIGhvdyBpdCBpcyBsb2FkZWQuXG5cdCAqIEBjbGFzcyBTcHJpdGVTaGVldExvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBTcHJpdGVTaGVldExvYWRlcihsb2FkSXRlbSwgcHJlZmVyWEhSKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgcHJlZmVyWEhSLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TUFJJVEVTSEVFVCk7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEFuIGludGVybmFsIHF1ZXVlIHdoaWNoIGxvYWRzIHRoZSBTcHJpdGVTaGVldCdzIGltYWdlcy5cblx0XHQgKiBAbWV0aG9kIF9tYW5pZmVzdFF1ZXVlXG5cdFx0ICogQHR5cGUge0xvYWRRdWV1ZX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX21hbmlmZXN0UXVldWUgPSBudWxsO1xuXHR9XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoU3ByaXRlU2hlZXRMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBTcHJpdGVTaGVldExvYWRlcjtcblxuXHQvLyBzdGF0aWMgcHJvcGVydGllc1xuXHQvKipcblx0ICogVGhlIGFtb3VudCBvZiBwcm9ncmVzcyB0aGF0IHRoZSBtYW5pZmVzdCBpdHNlbGYgdGFrZXMgdXAuXG5cdCAqIEBwcm9wZXJ0eSBTUFJJVEVTSEVFVF9QUk9HUkVTU1xuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAwLjI1ICgyNSUpXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuU1BSSVRFU0hFRVRfUFJPR1JFU1MgPSAwLjI1O1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvU1BSSVRFU0hFRVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TUFJJVEVTSEVFVDtcblx0fTtcblxuXHQvLyBwdWJsaWMgbWV0aG9kc1xuXHRwLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2Rlc3Ryb3k7XG5cdFx0dGhpcy5fbWFuaWZlc3RRdWV1ZS5jbG9zZSgpO1xuXHR9O1xuXG5cdC8vIHByb3RlY3RlZCBtZXRob2RzXG5cdHAuX2NyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSB0aGlzLl9pdGVtLmNhbGxiYWNrO1xuXHRcdGlmIChjYWxsYmFjayAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLkpTT05QTG9hZGVyKHRoaXMuX2l0ZW0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLkpTT05Mb2FkZXIodGhpcy5faXRlbSk7XG5cdFx0fVxuXHR9O1xuXG5cdHAuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcblx0XHRcdGNhc2UgXCJjb21wbGV0ZVwiOlxuXHRcdFx0XHR0aGlzLl9yYXdSZXN1bHQgPSBldmVudC50YXJnZXQuZ2V0UmVzdWx0KHRydWUpO1xuXHRcdFx0XHR0aGlzLl9yZXN1bHQgPSBldmVudC50YXJnZXQuZ2V0UmVzdWx0KCk7XG5cdFx0XHRcdHRoaXMuX3NlbmRQcm9ncmVzcyhzLlNQUklURVNIRUVUX1BST0dSRVNTKTtcblx0XHRcdFx0dGhpcy5fbG9hZE1hbmlmZXN0KHRoaXMuX3Jlc3VsdCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdGNhc2UgXCJwcm9ncmVzc1wiOlxuXHRcdFx0XHRldmVudC5sb2FkZWQgKj0gcy5TUFJJVEVTSEVFVF9QUk9HUkVTUztcblx0XHRcdFx0dGhpcy5wcm9ncmVzcyA9IGV2ZW50LmxvYWRlZCAvIGV2ZW50LnRvdGFsO1xuXHRcdFx0XHRpZiAoaXNOYU4odGhpcy5wcm9ncmVzcykgfHwgdGhpcy5wcm9ncmVzcyA9PSBJbmZpbml0eSkgeyB0aGlzLnByb2dyZXNzID0gMDsgfVxuXHRcdFx0XHR0aGlzLl9zZW5kUHJvZ3Jlc3MoZXZlbnQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfaGFuZGxlRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW5kIGxvYWQgdGhlIGltYWdlcyBvbmNlIHRoZSBTcHJpdGVTaGVldCBKU09OIGhhcyBiZWVuIGxvYWRlZC5cblx0ICogQG1ldGhvZCBfbG9hZE1hbmlmZXN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBqc29uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9sb2FkTWFuaWZlc3QgPSBmdW5jdGlvbiAoanNvbikge1xuXHRcdGlmIChqc29uICYmIGpzb24uaW1hZ2VzKSB7XG5cdFx0XHR2YXIgcXVldWUgPSB0aGlzLl9tYW5pZmVzdFF1ZXVlID0gbmV3IGNyZWF0ZWpzLkxvYWRRdWV1ZSh0aGlzLl9wcmVmZXJYSFIsIHRoaXMuX2l0ZW0ucGF0aCwgdGhpcy5faXRlbS5jcm9zc09yaWdpbik7XG5cdFx0XHRxdWV1ZS5vbihcImNvbXBsZXRlXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0Q29tcGxldGUsIHRoaXMsIHRydWUpO1xuXHRcdFx0cXVldWUub24oXCJmaWxlbG9hZFwiLCB0aGlzLl9oYW5kbGVNYW5pZmVzdEZpbGVMb2FkLCB0aGlzKTtcblx0XHRcdHF1ZXVlLm9uKFwicHJvZ3Jlc3NcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RQcm9ncmVzcywgdGhpcyk7XG5cdFx0XHRxdWV1ZS5vbihcImVycm9yXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0RXJyb3IsIHRoaXMsIHRydWUpO1xuXHRcdFx0cXVldWUubG9hZE1hbmlmZXN0KGpzb24uaW1hZ2VzKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEFuIGl0ZW0gZnJvbSB0aGUge3sjY3Jvc3NMaW5rIFwiX21hbmlmZXN0UXVldWU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaGFzIGNvbXBsZXRlZC5cblx0ICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RGaWxlTG9hZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RGaWxlTG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBpbWFnZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRpZiAoaW1hZ2UgIT0gbnVsbCkge1xuXHRcdFx0dmFyIGltYWdlcyA9IHRoaXMuZ2V0UmVzdWx0KCkuaW1hZ2VzO1xuXHRcdFx0dmFyIHBvcyA9IGltYWdlcy5pbmRleE9mKGV2ZW50Lml0ZW0uc3JjKTtcblx0XHRcdGltYWdlc1twb3NdID0gaW1hZ2U7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgaW1hZ2VzIGhhdmUgY29tcGxldGVkIGxvYWRpbmcuIFRoaXMgdHJpZ2dlcnMgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2NvbXBsZXRlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGZyb20gdGhlIFNwcml0ZVNoZWV0TG9hZGVyLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNYW5pZmVzdENvbXBsZXRlXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVNYW5pZmVzdENvbXBsZXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dGhpcy5fcmVzdWx0ID0gbmV3IGNyZWF0ZWpzLlNwcml0ZVNoZWV0KHRoaXMuX3Jlc3VsdCk7XG5cdFx0dGhpcy5fbG9hZGVkSXRlbXMgPSB0aGlzLl9tYW5pZmVzdFF1ZXVlLmdldEl0ZW1zKHRydWUpO1xuXHRcdHRoaXMuX3NlbmRDb21wbGV0ZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgaW1hZ2VzIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSBoYXMgcmVwb3J0ZWQgcHJvZ3Jlc3MuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0UHJvZ3Jlc3Ncblx0ICogQHBhcmFtIHtQcm9ncmVzc0V2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RQcm9ncmVzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSBldmVudC5wcm9ncmVzcyAqICgxIC0gcy5TUFJJVEVTSEVFVF9QUk9HUkVTUykgKyBzLlNQUklURVNIRUVUX1BST0dSRVNTO1xuXHRcdHRoaXMuX3NlbmRQcm9ncmVzcyh0aGlzLnByb2dyZXNzKTtcblx0fTtcblxuXHQvKipcblx0ICogQW4gaW1hZ2UgaGFzIHJlcG9ydGVkIGFuIGVycm9yLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNYW5pZmVzdEVycm9yXG5cdCAqIEBwYXJhbSB7RXJyb3JFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZU1hbmlmZXN0RXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgbmV3RXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJmaWxlZXJyb3JcIik7XG5cdFx0bmV3RXZlbnQuaXRlbSA9IGV2ZW50LmRhdGE7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcblx0fTtcblxuXHRjcmVhdGVqcy5TcHJpdGVTaGVldExvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoU3ByaXRlU2hlZXRMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTVkdMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgU1ZHIGZpbGVzLlxuXHQgKiBAY2xhc3MgU1ZHTG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZlclhIUlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFNWR0xvYWRlcihsb2FkSXRlbSwgcHJlZmVyWEhSKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgcHJlZmVyWEhSLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TVkcpO1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHR0aGlzLnJlc3VsdEZvcm1hdHRlciA9IHRoaXMuX2Zvcm1hdFJlc3VsdDtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5fdGFnU3JjQXR0cmlidXRlID0gXCJkYXRhXCI7XG5cblx0XHRpZiAocHJlZmVyWEhSKSB7XG5cdFx0XHR0aGlzLnNldFRhZyhkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3ZnXCIpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZXRUYWcoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9iamVjdFwiKSk7XG5cdFx0XHR0aGlzLmdldFRhZygpLnR5cGUgPSBcImltYWdlL3N2Zyt4bWxcIjtcblx0XHR9XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoU1ZHTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gU1ZHTG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvU1ZHOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU1ZHO1xuXHR9O1xuXG5cdC8vIHByb3RlY3RlZCBtZXRob2RzXG5cdC8qKlxuXHQgKiBUaGUgcmVzdWx0IGZvcm1hdHRlciBmb3IgU1ZHIGZpbGVzLlxuXHQgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9mb3JtYXRSZXN1bHQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0Ly8gbWltZSBzaG91bGQgYmUgaW1hZ2Uvc3ZnK3htbCwgYnV0IE9wZXJhIHJlcXVpcmVzIHRleHQveG1sXG5cdFx0dmFyIHhtbCA9IGNyZWF0ZWpzLkRhdGFVdGlscy5wYXJzZVhNTChsb2FkZXIuZ2V0UmVzdWx0KHRydWUpLCBcInRleHQveG1sXCIpO1xuXHRcdHZhciB0YWcgPSBsb2FkZXIuZ2V0VGFnKCk7XG5cblx0XHRpZiAoIXRoaXMuX3ByZWZlclhIUiAmJiBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRhZykpIHtcblx0XHRcdGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGFnKTtcblx0XHR9XG5cblx0XHRpZiAoeG1sLmRvY3VtZW50RWxlbWVudCAhPSBudWxsKSB7XG5cdFx0XHR0YWcuYXBwZW5kQ2hpbGQoeG1sLmRvY3VtZW50RWxlbWVudCk7XG5cdFx0XHR0YWcuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuXHRcdFx0cmV0dXJuIHRhZztcblx0XHR9IGVsc2UgeyAvLyBGb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IFNWRywganVzdCBnaXZlIHRoZW0gdGhlIFhNTC4gKElFIDktOClcblx0XHRcdHJldHVybiB4bWw7XG5cdFx0fVxuXHR9O1xuXG5cdGNyZWF0ZWpzLlNWR0xvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoU1ZHTG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gWE1MTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIENTUyBmaWxlcy5cblx0ICogQGNsYXNzIFhNTExvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBYTUxMb2FkZXIobG9hZEl0ZW0pIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCB0cnVlLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5YTUwpO1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHR0aGlzLnJlc3VsdEZvcm1hdHRlciA9IHRoaXMuX2Zvcm1hdFJlc3VsdDtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChYTUxMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBYTUxMb2FkZXI7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9YTUw6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuWE1MO1xuXHR9O1xuXG5cdC8vIHByb3RlY3RlZCBtZXRob2RzXG5cdC8qKlxuXHQgKiBUaGUgcmVzdWx0IGZvcm1hdHRlciBmb3IgWE1MIGZpbGVzLlxuXHQgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEByZXR1cm5zIHtYTUxEb2N1bWVudH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHRyZXR1cm4gY3JlYXRlanMuRGF0YVV0aWxzLnBhcnNlWE1MKGxvYWRlci5nZXRSZXN1bHQodHJ1ZSksIFwidGV4dC94bWxcIik7XG5cdH07XG5cblx0Y3JlYXRlanMuWE1MTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShYTUxMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyB2ZXJzaW9uLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXG5cdC8qKlxuXHQgKiBTdGF0aWMgY2xhc3MgaG9sZGluZyBsaWJyYXJ5IHNwZWNpZmljIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHZlcnNpb24gYW5kIGJ1aWxkRGF0ZSBvZiB0aGUgbGlicmFyeS5cblx0ICogVGhlIFNvdW5kSlMgY2xhc3MgaGFzIGJlZW4gcmVuYW1lZCB7eyNjcm9zc0xpbmsgXCJTb3VuZFwifX17ey9jcm9zc0xpbmt9fS4gIFBsZWFzZSBzZWUge3sjY3Jvc3NMaW5rIFwiU291bmRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGluZm9ybWF0aW9uIG9uIHVzaW5nIHNvdW5kLlxuXHQgKiBAY2xhc3MgU291bmRKU1xuXHQgKiovXG5cdHZhciBzID0gY3JlYXRlanMuU291bmRKUyA9IGNyZWF0ZWpzLlNvdW5kSlMgfHwge307XG5cblx0LyoqXG5cdCAqIFRoZSB2ZXJzaW9uIHN0cmluZyBmb3IgdGhpcyByZWxlYXNlLlxuXHQgKiBAcHJvcGVydHkgdmVyc2lvblxuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdHMudmVyc2lvbiA9IC8qPXZlcnNpb24qL1wiMC42LjJcIjsgLy8gaW5qZWN0ZWQgYnkgYnVpbGQgcHJvY2Vzc1xuXG5cdC8qKlxuXHQgKiBUaGUgYnVpbGQgZGF0ZSBmb3IgdGhpcyByZWxlYXNlIGluIFVUQyBmb3JtYXQuXG5cdCAqIEBwcm9wZXJ0eSBidWlsZERhdGVcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRzLmJ1aWxkRGF0ZSA9IC8qPWRhdGUqL1wiVGh1LCAyNiBOb3YgMjAxNSAyMDo0NDozMSBHTVRcIjsgLy8gaW5qZWN0ZWQgYnkgYnVpbGQgcHJvY2Vzc1xuXG59KSgpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gSW5kZXhPZi5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuLyoqXG4gKiBAY2xhc3MgVXRpbGl0eSBNZXRob2RzXG4gKi9cblxuLyoqXG4gKiBGaW5kcyB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhIHNwZWNpZmllZCB2YWx1ZSBzZWFyY2hFbGVtZW50IGluIHRoZSBwYXNzZWQgaW4gYXJyYXksIGFuZCByZXR1cm5zIHRoZSBpbmRleCBvZlxuICogdGhhdCB2YWx1ZS4gIFJldHVybnMgLTEgaWYgdmFsdWUgaXMgbm90IGZvdW5kLlxuICpcbiAqICAgICAgdmFyIGkgPSBjcmVhdGVqcy5pbmRleE9mKG15QXJyYXksIG15RWxlbWVudFRvRmluZCk7XG4gKlxuICogQG1ldGhvZCBpbmRleE9mXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBBcnJheSB0byBzZWFyY2ggZm9yIHNlYXJjaEVsZW1lbnRcbiAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gZmluZCBpbiBhcnJheS5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIGZpcnN0IGluZGV4IG9mIHNlYXJjaEVsZW1lbnQgaW4gYXJyYXkuXG4gKi9cbmNyZWF0ZWpzLmluZGV4T2YgPSBmdW5jdGlvbiAoYXJyYXksIHNlYXJjaEVsZW1lbnQpe1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRmb3IgKHZhciBpID0gMCxsPWFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGlmIChzZWFyY2hFbGVtZW50ID09PSBhcnJheVtpXSkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn07XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBQcm94eS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuLyoqXG4gKiBWYXJpb3VzIHV0aWxpdGllcyB0aGF0IHRoZSBDcmVhdGVKUyBTdWl0ZSB1c2VzLiBVdGlsaXRpZXMgYXJlIGNyZWF0ZWQgYXMgc2VwYXJhdGUgZmlsZXMsIGFuZCB3aWxsIGJlIGF2YWlsYWJsZSBvbiB0aGVcbiAqIGNyZWF0ZWpzIG5hbWVzcGFjZSBkaXJlY3RseS5cbiAqXG4gKiA8aDQ+RXhhbXBsZTwvaDQ+XG4gKlxuICogICAgICBteU9iamVjdC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGNyZWF0ZWpzLnByb3h5KG15TWV0aG9kLCBzY29wZSkpO1xuICpcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqIEBtYWluIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIEEgZnVuY3Rpb24gcHJveHkgZm9yIG1ldGhvZHMuIEJ5IGRlZmF1bHQsIEphdmFTY3JpcHQgbWV0aG9kcyBkbyBub3QgbWFpbnRhaW4gc2NvcGUsIHNvIHBhc3NpbmcgYSBtZXRob2QgYXMgYVxuXHQgKiBjYWxsYmFjayB3aWxsIHJlc3VsdCBpbiB0aGUgbWV0aG9kIGdldHRpbmcgY2FsbGVkIGluIHRoZSBzY29wZSBvZiB0aGUgY2FsbGVyLiBVc2luZyBhIHByb3h5IGVuc3VyZXMgdGhhdCB0aGVcblx0ICogbWV0aG9kIGdldHMgY2FsbGVkIGluIHRoZSBjb3JyZWN0IHNjb3BlLlxuXHQgKlxuXHQgKiBBZGRpdGlvbmFsIGFyZ3VtZW50cyBjYW4gYmUgcGFzc2VkIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBmdW5jdGlvbiB3aGVuIGl0IGlzIGNhbGxlZC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIG15T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJldmVudFwiLCBjcmVhdGVqcy5wcm94eShteUhhbmRsZXIsIHRoaXMsIGFyZzEsIGFyZzIpKTtcblx0ICpcblx0ICogICAgICBmdW5jdGlvbiBteUhhbmRsZXIoYXJnMSwgYXJnMikge1xuXHQgKiAgICAgICAgICAgLy8gVGhpcyBnZXRzIGNhbGxlZCB3aGVuIG15T2JqZWN0Lm15Q2FsbGJhY2sgaXMgZXhlY3V0ZWQuXG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBAbWV0aG9kIHByb3h5XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBUaGUgZnVuY3Rpb24gdG8gY2FsbFxuXHQgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgVGhlIHNjb3BlIHRvIGNhbGwgdGhlIG1ldGhvZCBuYW1lIG9uXG5cdCAqIEBwYXJhbSB7bWl4ZWR9IFthcmddICogQXJndW1lbnRzIHRoYXQgYXJlIGFwcGVuZGVkIHRvIHRoZSBjYWxsYmFjayBmb3IgYWRkaXRpb25hbCBwYXJhbXMuXG5cdCAqIEBwdWJsaWNcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0Y3JlYXRlanMucHJveHkgPSBmdW5jdGlvbiAobWV0aG9kLCBzY29wZSkge1xuXHRcdHZhciBhQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBtZXRob2QuYXBwbHkoc2NvcGUsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkuY29uY2F0KGFBcmdzKSk7XG5cdFx0fTtcblx0fVxuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQnJvd3NlckRldGVjdC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuLyoqXG4gKiBAY2xhc3MgVXRpbGl0eSBNZXRob2RzXG4gKi9cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIEFuIG9iamVjdCB0aGF0IGRldGVybWluZXMgdGhlIGN1cnJlbnQgYnJvd3NlciwgdmVyc2lvbiwgb3BlcmF0aW5nIHN5c3RlbSwgYW5kIG90aGVyIGVudmlyb25tZW50XG5cdCAqIHZhcmlhYmxlcyB2aWEgdXNlciBhZ2VudCBzdHJpbmcuXG5cdCAqXG5cdCAqIFVzZWQgZm9yIGF1ZGlvIGJlY2F1c2UgZmVhdHVyZSBkZXRlY3Rpb24gaXMgdW5hYmxlIHRvIGRldGVjdCB0aGUgbWFueSBsaW1pdGF0aW9ucyBvZiBtb2JpbGUgZGV2aWNlcy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGlmIChjcmVhdGVqcy5Ccm93c2VyRGV0ZWN0LmlzSU9TKSB7IC8vIGRvIHN0dWZmIH1cblx0ICpcblx0ICogQHByb3BlcnR5IEJyb3dzZXJEZXRlY3Rcblx0ICogQHR5cGUge09iamVjdH1cblx0ICogQHBhcmFtIHtCb29sZWFufSBpc0ZpcmVmb3ggVHJ1ZSBpZiBvdXIgYnJvd3NlciBpcyBGaXJlZm94LlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzT3BlcmEgVHJ1ZSBpZiBvdXIgYnJvd3NlciBpcyBvcGVyYS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBpc0Nocm9tZSBUcnVlIGlmIG91ciBicm93c2VyIGlzIENocm9tZS4gIE5vdGUgdGhhdCBDaHJvbWUgZm9yIEFuZHJvaWQgcmV0dXJucyB0cnVlLCBidXQgaXMgYVxuXHQgKiBjb21wbGV0ZWx5IGRpZmZlcmVudCBicm93c2VyIHdpdGggZGlmZmVyZW50IGFiaWxpdGllcy5cblx0ICogQHBhcmFtIHtCb29sZWFufSBpc0lPUyBUcnVlIGlmIG91ciBicm93c2VyIGlzIHNhZmFyaSBmb3IgaU9TIGRldmljZXMgKGlQYWQsIGlQaG9uZSwgYW5kIGlQb2QpLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQW5kcm9pZCBUcnVlIGlmIG91ciBicm93c2VyIGlzIEFuZHJvaWQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNCbGFja2JlcnJ5IFRydWUgaWYgb3VyIGJyb3dzZXIgaXMgQmxhY2tiZXJyeS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdGZ1bmN0aW9uIEJyb3dzZXJEZXRlY3QoKSB7XG5cdFx0dGhyb3cgXCJCcm93c2VyRGV0ZWN0IGNhbm5vdCBiZSBpbnN0YW50aWF0ZWRcIjtcblx0fTtcblxuXHR2YXIgYWdlbnQgPSBCcm93c2VyRGV0ZWN0LmFnZW50ID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cdEJyb3dzZXJEZXRlY3QuaXNXaW5kb3dQaG9uZSA9IChhZ2VudC5pbmRleE9mKFwiSUVNb2JpbGVcIikgPiAtMSkgfHwgKGFnZW50LmluZGV4T2YoXCJXaW5kb3dzIFBob25lXCIpID4gLTEpO1xuXHRCcm93c2VyRGV0ZWN0LmlzRmlyZWZveCA9IChhZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSA+IC0xKTtcblx0QnJvd3NlckRldGVjdC5pc09wZXJhID0gKHdpbmRvdy5vcGVyYSAhPSBudWxsKTtcblx0QnJvd3NlckRldGVjdC5pc0Nocm9tZSA9IChhZ2VudC5pbmRleE9mKFwiQ2hyb21lXCIpID4gLTEpOyAgLy8gTk9URSB0aGF0IENocm9tZSBvbiBBbmRyb2lkIHJldHVybnMgdHJ1ZSBidXQgaXMgYSBjb21wbGV0ZWx5IGRpZmZlcmVudCBicm93c2VyIHdpdGggZGlmZmVyZW50IGFiaWxpdGllc1xuXHRCcm93c2VyRGV0ZWN0LmlzSU9TID0gKGFnZW50LmluZGV4T2YoXCJpUG9kXCIpID4gLTEgfHwgYWdlbnQuaW5kZXhPZihcImlQaG9uZVwiKSA+IC0xIHx8IGFnZW50LmluZGV4T2YoXCJpUGFkXCIpID4gLTEpICYmICFCcm93c2VyRGV0ZWN0LmlzV2luZG93UGhvbmU7XG5cdEJyb3dzZXJEZXRlY3QuaXNBbmRyb2lkID0gKGFnZW50LmluZGV4T2YoXCJBbmRyb2lkXCIpID4gLTEpICYmICFCcm93c2VyRGV0ZWN0LmlzV2luZG93UGhvbmU7XG5cdEJyb3dzZXJEZXRlY3QuaXNCbGFja2JlcnJ5ID0gKGFnZW50LmluZGV4T2YoXCJCbGFja2JlcnJ5XCIpID4gLTEpO1xuXG5cdGNyZWF0ZWpzLkJyb3dzZXJEZXRlY3QgPSBCcm93c2VyRGV0ZWN0O1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQXVkaW9TcHJpdGUuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbi8vICBOT1RFIHRoaXMgaXMgXCJDbGFzc1wiIGlzIHB1cmVseSB0byBkb2N1bWVudCBhdWRpb1Nwcml0ZSBTZXR1cCBhbmQgdXNhZ2UuXG5cblxuLyoqXG4gKiA8c3Ryb25nPk5vdGU6IEF1ZGlvU3ByaXRlIGlzIG5vdCBhIGNsYXNzLCBidXQgaXRzIHVzYWdlIGlzIGVhc2lseSBsb3N0IGluIHRoZSBkb2N1bWVudGF0aW9uLCBzbyBpdCBoYXMgYmVlbiBjYWxsZWRcbiAqIG91dCBoZXJlIGZvciBxdWljayByZWZlcmVuY2UuPC9zdHJvbmc+XG4gKlxuICogQXVkaW8gc3ByaXRlcyBhcmUgbXVjaCBsaWtlIENTUyBzcHJpdGVzIG9yIGltYWdlIHNwcml0ZSBzaGVldHM6IG11bHRpcGxlIGF1ZGlvIGFzc2V0cyBncm91cGVkIGludG8gYSBzaW5nbGUgZmlsZS5cbiAqIEF1ZGlvIHNwcml0ZXMgd29yayBhcm91bmQgbGltaXRhdGlvbnMgaW4gY2VydGFpbiBicm93c2Vycywgd2hlcmUgb25seSBhIHNpbmdsZSBzb3VuZCBjYW4gYmUgbG9hZGVkIGFuZCBwbGF5ZWQgYXQgYVxuICogdGltZS4gV2UgcmVjb21tZW5kIGF0IGxlYXN0IDMwMG1zIG9mIHNpbGVuY2UgYmV0d2VlbiBhdWRpbyBjbGlwcyB0byBkZWFsIHdpdGggSFRNTCBhdWRpbyB0YWcgaW5hY2N1cmFjeSwgYW5kIHRvIHByZXZlbnRcbiAqIGFjY2lkZW50YWxseSBwbGF5aW5nIGJpdHMgb2YgdGhlIG5laWdoYm91cmluZyBjbGlwcy5cbiAqXG4gKiA8c3Ryb25nPkJlbmVmaXRzIG9mIEF1ZGlvIFNwcml0ZXM6PC9zdHJvbmc+XG4gKiA8dWw+XG4gKiAgICAgPGxpPk1vcmUgcm9idXN0IHN1cHBvcnQgZm9yIG9sZGVyIGJyb3dzZXJzIGFuZCBkZXZpY2VzIHRoYXQgb25seSBhbGxvdyBhIHNpbmdsZSBhdWRpbyBpbnN0YW5jZSwgc3VjaCBhcyBpT1MgNS48L2xpPlxuICogICAgIDxsaT5UaGV5IHByb3ZpZGUgYSB3b3JrIGFyb3VuZCBmb3IgdGhlIEludGVybmV0IEV4cGxvcmVyIDkgYXVkaW8gdGFnIGxpbWl0LCB3aGljaCByZXN0cmljdHMgaG93IG1hbnkgZGlmZmVyZW50XG4gKiAgICAgc291bmRzIHRoYXQgY291bGQgYmUgbG9hZGVkIGF0IG9uY2UuPC9saT5cbiAqICAgICA8bGk+RmFzdGVyIGxvYWRpbmcgYnkgb25seSByZXF1aXJpbmcgYSBzaW5nbGUgbmV0d29yayByZXF1ZXN0IGZvciBzZXZlcmFsIHNvdW5kcywgZXNwZWNpYWxseSBvbiBtb2JpbGUgZGV2aWNlc1xuICogd2hlcmUgdGhlIG5ldHdvcmsgcm91bmQgdHJpcCBmb3IgZWFjaCBmaWxlIGNhbiBhZGQgc2lnbmlmaWNhbnQgbGF0ZW5jeS48L2xpPlxuICogPC91bD5cbiAqXG4gKiA8c3Ryb25nPkRyYXdiYWNrcyBvZiBBdWRpbyBTcHJpdGVzPC9zdHJvbmc+XG4gKiA8dWw+XG4gKiAgICAgPGxpPk5vIGd1YXJhbnRlZSBvZiBzbW9vdGggbG9vcGluZyB3aGVuIHVzaW5nIEhUTUwgb3IgRmxhc2ggYXVkaW8uIElmIHlvdSBoYXZlIGEgdHJhY2sgdGhhdCBuZWVkcyB0byBsb29wXG4gKiBcdFx0c21vb3RobHkgYW5kIHlvdSBhcmUgc3VwcG9ydGluZyBub24td2ViIGF1ZGlvIGJyb3dzZXJzLCBkbyBub3QgdXNlIGF1ZGlvIHNwcml0ZXMgZm9yIHRoYXQgc291bmQgaWYgeW91IGNhbiBhdm9pZFxuICogXHRcdGl0LjwvbGk+XG4gKiAgICAgPGxpPk5vIGd1YXJhbnRlZSB0aGF0IEhUTUwgYXVkaW8gd2lsbCBwbGF5IGJhY2sgaW1tZWRpYXRlbHksIGVzcGVjaWFsbHkgdGhlIGZpcnN0IHRpbWUuIEluIHNvbWUgYnJvd3NlcnNcbiAqICAgICAoQ2hyb21lISksIEhUTUwgYXVkaW8gd2lsbCBvbmx5IGxvYWQgZW5vdWdoIHRvIHBsYXkgdGhyb3VnaCBhdCB0aGUgY3VycmVudCBkb3dubG9hZCBzcGVlZCDDouKCrOKAnCBzbyB3ZSByZWx5IG9uIHRoZVxuICogICAgIGBjYW5wbGF5dGhyb3VnaGAgZXZlbnQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBhdWRpbyBpcyBsb2FkZWQuIFNpbmNlIGF1ZGlvIHNwcml0ZXMgbXVzdCBqdW1wIGFoZWFkIHRvIHBsYXkgc3BlY2lmaWNcbiAqICAgICBzb3VuZHMsIHRoZSBhdWRpbyBtYXkgbm90IHlldCBoYXZlIGRvd25sb2FkZWQgZnVsbHkuPC9saT5cbiAqICAgICA8bGk+QXVkaW8gc3ByaXRlcyBzaGFyZSB0aGUgc2FtZSBjb3JlIHNvdXJjZSwgc28gaWYgeW91IGhhdmUgYSBzcHJpdGUgd2l0aCA1IHNvdW5kcyBhbmQgYXJlIGxpbWl0ZWQgdG8gMlxuICogXHRcdGNvbmN1cnJlbnRseSBwbGF5aW5nIGluc3RhbmNlcywgeW91IGNhbiBvbmx5IHBsYXkgMiBvZiB0aGUgc291bmRzIGF0IHRoZSBzYW1lIHRpbWUuPC9saT5cbiAqIDwvdWw+XG4gKlxuICogPGg0PkV4YW1wbGU8L2g0PlxuICpcbiAqXHRcdGNyZWF0ZWpzLlNvdW5kLmluaXRpYWxpemVEZWZhdWx0UGx1Z2lucygpO1xuICpcdFx0dmFyIGFzc2V0c1BhdGggPSBcIi4vYXNzZXRzL1wiO1xuICpcdFx0dmFyIHNvdW5kcyA9IFt7XG4gKlx0XHRcdHNyYzpcIk15QXVkaW9TcHJpdGUub2dnXCIsIGRhdGE6IHtcbiAqXHRcdFx0XHRhdWRpb1Nwcml0ZTogW1xuICpcdFx0XHRcdFx0e2lkOlwic291bmQxXCIsIHN0YXJ0VGltZTowLCBkdXJhdGlvbjo1MDB9LFxuICpcdFx0XHRcdFx0e2lkOlwic291bmQyXCIsIHN0YXJ0VGltZToxMDAwLCBkdXJhdGlvbjo0MDB9LFxuICpcdFx0XHRcdFx0e2lkOlwic291bmQzXCIsIHN0YXJ0VGltZToxNzAwLCBkdXJhdGlvbjogMTAwMH1cbiAqXHRcdFx0XHRdfVxuICpcdFx0XHR9XG4gKlx0XHRdO1xuICpcdFx0Y3JlYXRlanMuU291bmQuYWx0ZXJuYXRlRXh0ZW5zaW9ucyA9IFtcIm1wM1wiXTtcbiAqXHRcdGNyZWF0ZWpzLlNvdW5kLm9uKFwiZmlsZWxvYWRcIiwgbG9hZFNvdW5kKTtcbiAqXHRcdGNyZWF0ZWpzLlNvdW5kLnJlZ2lzdGVyU291bmRzKHNvdW5kcywgYXNzZXRzUGF0aCk7XG4gKlx0XHQvLyBhZnRlciBsb2FkIGlzIGNvbXBsZXRlXG4gKlx0XHRjcmVhdGVqcy5Tb3VuZC5wbGF5KFwic291bmQyXCIpO1xuICpcbiAqIFlvdSBjYW4gYWxzbyBjcmVhdGUgYXVkaW8gc3ByaXRlcyBvbiB0aGUgZmx5IGJ5IHNldHRpbmcgdGhlIHN0YXJ0VGltZSBhbmQgZHVyYXRpb24gd2hlbiBjcmVhdGluZyBhbiBuZXcgQWJzdHJhY3RTb3VuZEluc3RhbmNlLlxuICpcbiAqIFx0XHRjcmVhdGVqcy5Tb3VuZC5wbGF5KFwiTXlBdWRpb1Nwcml0ZVwiLCB7c3RhcnRUaW1lOiAxMDAwLCBkdXJhdGlvbjogNDAwfSk7XG4gKlxuICogVGhlIGV4Y2VsbGVudCBDcmVhdGVKUyBjb21tdW5pdHkgaGFzIGNyZWF0ZWQgYSB0b29sIHRvIGNyZWF0ZSBhdWRpbyBzcHJpdGVzLCBhdmFpbGFibGUgYXRcbiAqIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vdG9uaXN0aWlnaS9hdWRpb3Nwcml0ZVwiIHRhcmdldD1cIl9ibGFua1wiPmh0dHBzOi8vZ2l0aHViLmNvbS90b25pc3RpaWdpL2F1ZGlvc3ByaXRlPC9hPixcbiAqIGFzIHdlbGwgYXMgYSA8YSBocmVmPVwiaHR0cDovL2pzZmlkZGxlLm5ldC9iaGFyYXRfYmF0dHUvZzhmRlAvMTIvXCIgdGFyZ2V0PVwiX2JsYW5rXCI+anNmaWRkbGU8L2E+IHRvIGNvbnZlcnQgdGhlIG91dHB1dFxuICogdG8gU291bmRKUyBmb3JtYXQuXG4gKlxuICogQGNsYXNzIEF1ZGlvU3ByaXRlXG4gKiBAc2luY2UgMC42LjBcbiAqL1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gUGxheVByb3BzQ29uZmlnLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0LyoqXG5cdCAqIEEgY2xhc3MgdG8gc3RvcmUgdGhlIG9wdGlvbmFsIHBsYXkgcHJvcGVydGllcyBwYXNzZWQgaW4ge3sjY3Jvc3NMaW5rIFwiU291bmQvcGxheVwifX17ey9jcm9zc0xpbmt9fSBhbmRcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3BsYXlcIn19e3svY3Jvc3NMaW5rfX0gY2FsbHMuXG5cdCAqXG5cdCAqIE9wdGlvbmFsIFBsYXkgUHJvcGVydGllcyBJbmNsdWRlOlxuXHQgKiA8dWw+XG5cdCAqIDxsaT5pbnRlcnJ1cHQgLSBIb3cgdG8gaW50ZXJydXB0IGFueSBjdXJyZW50bHkgcGxheWluZyBpbnN0YW5jZXMgb2YgYXVkaW8gd2l0aCB0aGUgc2FtZSBzb3VyY2UsXG5cdCAqIGlmIHRoZSBtYXhpbXVtIG51bWJlciBvZiBpbnN0YW5jZXMgb2YgdGhlIHNvdW5kIGFyZSBhbHJlYWR5IHBsYXlpbmcuIFZhbHVlcyBhcmUgZGVmaW5lZCBhcyA8Y29kZT5JTlRFUlJVUFRfVFlQRTwvY29kZT5cblx0ICogY29uc3RhbnRzIG9uIHRoZSBTb3VuZCBjbGFzcywgd2l0aCB0aGUgZGVmYXVsdCBkZWZpbmVkIGJ5IHt7I2Nyb3NzTGluayBcIlNvdW5kL2RlZmF1bHRJbnRlcnJ1cHRCZWhhdmlvcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS48L2xpPlxuXHQgKiA8bGk+ZGVsYXkgLSBUaGUgYW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgdGhlIHN0YXJ0IG9mIGF1ZGlvIHBsYXliYWNrLCBpbiBtaWxsaXNlY29uZHMuPC9saT5cblx0ICogPGxpPm9mZnNldCAtIFRoZSBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGF1ZGlvIHRvIGJlZ2luIHBsYXliYWNrLCBpbiBtaWxsaXNlY29uZHMuPC9saT5cblx0ICogPGxpPmxvb3AgLSBIb3cgbWFueSB0aW1lcyB0aGUgYXVkaW8gbG9vcHMgd2hlbiBpdCByZWFjaGVzIHRoZSBlbmQgb2YgcGxheWJhY2suIFRoZSBkZWZhdWx0IGlzIDAgKG5vXG5cdCAqIGxvb3BzKSwgYW5kIC0xIGNhbiBiZSB1c2VkIGZvciBpbmZpbml0ZSBwbGF5YmFjay48L2xpPlxuXHQgKiA8bGk+dm9sdW1lIC0gVGhlIHZvbHVtZSBvZiB0aGUgc291bmQsIGJldHdlZW4gMCBhbmQgMS4gTm90ZSB0aGF0IHRoZSBtYXN0ZXIgdm9sdW1lIGlzIGFwcGxpZWRcblx0ICogYWdhaW5zdCB0aGUgaW5kaXZpZHVhbCB2b2x1bWUuPC9saT5cblx0ICogPGxpPnBhbiAtIFRoZSBsZWZ0LXJpZ2h0IHBhbiBvZiB0aGUgc291bmQgKGlmIHN1cHBvcnRlZCksIGJldHdlZW4gLTEgKGxlZnQpIGFuZCAxIChyaWdodCkuPC9saT5cblx0ICogPGxpPnN0YXJ0VGltZSAtIFRvIGNyZWF0ZSBhbiBhdWRpbyBzcHJpdGUgKHdpdGggZHVyYXRpb24pLCB0aGUgaW5pdGlhbCBvZmZzZXQgdG8gc3RhcnQgcGxheWJhY2sgYW5kIGxvb3AgZnJvbSwgaW4gbWlsbGlzZWNvbmRzLjwvbGk+XG5cdCAqIDxsaT5kdXJhdGlvbiAtIFRvIGNyZWF0ZSBhbiBhdWRpbyBzcHJpdGUgKHdpdGggc3RhcnRUaW1lKSwgdGhlIGFtb3VudCBvZiB0aW1lIHRvIHBsYXkgdGhlIGNsaXAgZm9yLCBpbiBtaWxsaXNlY29uZHMuPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiBcdHZhciBwcGMgPSBuZXcgY3JlYXRlanMuUGxheVByb3BzQ29uZmlnKCkuc2V0KHtpbnRlcnJ1cHQ6IGNyZWF0ZWpzLlNvdW5kLklOVEVSUlVQVF9BTlksIGxvb3A6IC0xLCB2b2x1bWU6IDAuNX0pXG5cdCAqIFx0Y3JlYXRlanMuU291bmQucGxheShcIm15U291bmRcIiwgcHBjKTtcblx0ICogXHRteVNvdW5kSW5zdGFuY2UucGxheShwcGMpO1xuXHQgKlxuXHQgKiBAY2xhc3MgUGxheVByb3BzQ29uZmlnXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAc2luY2UgMC42LjFcblx0ICovXG5cdC8vIFRPRE8gdGhpbmsgb2YgYSBiZXR0ZXIgbmFtZSBmb3IgdGhpcyBjbGFzc1xuXHR2YXIgUGxheVByb3BzQ29uZmlnID0gZnVuY3Rpb24gKCkge1xuLy8gUHVibGljIFByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBIb3cgdG8gaW50ZXJydXB0IGFueSBjdXJyZW50bHkgcGxheWluZyBpbnN0YW5jZXMgb2YgYXVkaW8gd2l0aCB0aGUgc2FtZSBzb3VyY2UsXG5cdFx0ICogaWYgdGhlIG1heGltdW0gbnVtYmVyIG9mIGluc3RhbmNlcyBvZiB0aGUgc291bmQgYXJlIGFscmVhZHkgcGxheWluZy4gVmFsdWVzIGFyZSBkZWZpbmVkIGFzXG5cdFx0ICogPGNvZGU+SU5URVJSVVBUX1RZUEU8L2NvZGU+IGNvbnN0YW50cyBvbiB0aGUgU291bmQgY2xhc3MsIHdpdGggdGhlIGRlZmF1bHQgZGVmaW5lZCBieVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIlNvdW5kL2RlZmF1bHRJbnRlcnJ1cHRCZWhhdmlvcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgaW50ZXJydXB0XG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5pbnRlcnJ1cHQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IHRoZSBzdGFydCBvZiBhdWRpbyBwbGF5YmFjaywgaW4gbWlsbGlzZWNvbmRzLlxuXHRcdCAqIEBwcm9wZXJ0eSBkZWxheVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuZGVsYXkgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgYXVkaW8gdG8gYmVnaW4gcGxheWJhY2ssIGluIG1pbGxpc2Vjb25kcy5cblx0XHQgKiBAcHJvcGVydHkgb2Zmc2V0XG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5vZmZzZXQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogSG93IG1hbnkgdGltZXMgdGhlIGF1ZGlvIGxvb3BzIHdoZW4gaXQgcmVhY2hlcyB0aGUgZW5kIG9mIHBsYXliYWNrLiBUaGUgZGVmYXVsdCBpcyAwIChub1xuXHRcdCAqIGxvb3BzKSwgYW5kIC0xIGNhbiBiZSB1c2VkIGZvciBpbmZpbml0ZSBwbGF5YmFjay5cblx0XHQgKiBAcHJvcGVydHkgbG9vcFxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMubG9vcCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdm9sdW1lIG9mIHRoZSBzb3VuZCwgYmV0d2VlbiAwIGFuZCAxLiBOb3RlIHRoYXQgdGhlIG1hc3RlciB2b2x1bWUgaXMgYXBwbGllZFxuXHRcdCAqIGFnYWluc3QgdGhlIGluZGl2aWR1YWwgdm9sdW1lLlxuXHRcdCAqIEBwcm9wZXJ0eSB2b2x1bWVcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnZvbHVtZSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbGVmdC1yaWdodCBwYW4gb2YgdGhlIHNvdW5kIChpZiBzdXBwb3J0ZWQpLCBiZXR3ZWVuIC0xIChsZWZ0KSBhbmQgMSAocmlnaHQpLlxuXHRcdCAqIEBwcm9wZXJ0eSBwYW5cblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnBhbiA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBVc2VkIHRvIGNyZWF0ZSBhbiBhdWRpbyBzcHJpdGUgKHdpdGggZHVyYXRpb24pLCB0aGUgaW5pdGlhbCBvZmZzZXQgdG8gc3RhcnQgcGxheWJhY2sgYW5kIGxvb3AgZnJvbSwgaW4gbWlsbGlzZWNvbmRzLlxuXHRcdCAqIEBwcm9wZXJ0eSBzdGFydFRpbWVcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBVc2VkIHRvIGNyZWF0ZSBhbiBhdWRpbyBzcHJpdGUgKHdpdGggc3RhcnRUaW1lKSwgdGhlIGFtb3VudCBvZiB0aW1lIHRvIHBsYXkgdGhlIGNsaXAgZm9yLCBpbiBtaWxsaXNlY29uZHMuXG5cdFx0ICogQHByb3BlcnR5IGR1cmF0aW9uXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5kdXJhdGlvbiA9IG51bGw7XG5cdH07XG5cdHZhciBwID0gUGxheVByb3BzQ29uZmlnLnByb3RvdHlwZSA9IHt9O1xuXHR2YXIgcyA9IFBsYXlQcm9wc0NvbmZpZztcblxuXG4vLyBTdGF0aWMgTWV0aG9kc1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIFBsYXlQcm9wc0NvbmZpZyBmcm9tIGFub3RoZXIgUGxheVByb3BzQ29uZmlnIG9yIGFuIE9iamVjdC5cblx0ICpcblx0ICogQG1ldGhvZCBjcmVhdGVcblx0ICogQHBhcmFtIHtQbGF5UHJvcHNDb25maWd8T2JqZWN0fSB2YWx1ZSBUaGUgcGxheSBwcm9wZXJ0aWVzXG5cdCAqIEByZXR1cm5zIHtQbGF5UHJvcHNDb25maWd9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY3JlYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgcyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuXHRcdFx0dmFyIHBwYyA9IG5ldyBjcmVhdGVqcy5QbGF5UHJvcHNDb25maWcoKTtcblx0XHRcdHBwYy5zZXQodmFsdWUpO1xuXHRcdFx0cmV0dXJuIHBwYztcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVHlwZSBub3QgcmVjb2duaXplZC5cIik7XG5cdFx0fVxuXHR9O1xuXG4vLyBQdWJsaWMgTWV0aG9kc1xuXHQvKipcblx0ICogUHJvdmlkZXMgYSBjaGFpbmFibGUgc2hvcnRjdXQgbWV0aG9kIGZvciBzZXR0aW5nIGEgbnVtYmVyIG9mIHByb3BlcnRpZXMgb24gdGhlIGluc3RhbmNlLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIFBsYXlQcm9wc0NvbmZpZyA9IG5ldyBjcmVhdGVqcy5QbGF5UHJvcHNDb25maWcoKS5zZXQoe2xvb3A6LTEsIHZvbHVtZTowLjd9KTtcblx0ICpcblx0ICogQG1ldGhvZCBzZXRcblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEEgZ2VuZXJpYyBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRvIGNvcHkgdG8gdGhlIFBsYXlQcm9wc0NvbmZpZyBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7UGxheVByb3BzQ29uZmlnfSBSZXR1cm5zIHRoZSBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCovXG5cdHAuc2V0ID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRmb3IgKHZhciBuIGluIHByb3BzKSB7IHRoaXNbbl0gPSBwcm9wc1tuXTsgfVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbUGxheVByb3BzQ29uZmlnXVwiO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLlBsYXlQcm9wc0NvbmZpZyA9IHM7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTb3VuZC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIFRoZSBTb3VuZCBjbGFzcyBpcyB0aGUgcHVibGljIEFQSSBmb3IgY3JlYXRpbmcgc291bmRzLCBjb250cm9sbGluZyB0aGUgb3ZlcmFsbCBzb3VuZCBsZXZlbHMsIGFuZCBtYW5hZ2luZyBwbHVnaW5zLlxuXHQgKiBBbGwgU291bmQgQVBJcyBvbiB0aGlzIGNsYXNzIGFyZSBzdGF0aWMuXG5cdCAqXG5cdCAqIDxiPlJlZ2lzdGVyaW5nIGFuZCBQcmVsb2FkaW5nPC9iPjxiciAvPlxuXHQgKiBCZWZvcmUgeW91IGNhbiBwbGF5IGEgc291bmQsIGl0IDxiPm11c3Q8L2I+IGJlIHJlZ2lzdGVyZWQuIFlvdSBjYW4gZG8gdGhpcyB3aXRoIHt7I2Nyb3NzTGluayBcIlNvdW5kL3JlZ2lzdGVyU291bmRcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIG9yIHJlZ2lzdGVyIG11bHRpcGxlIHNvdW5kcyB1c2luZyB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZWdpc3RlclNvdW5kc1wifX17ey9jcm9zc0xpbmt9fS4gSWYgeW91IGRvbid0IHJlZ2lzdGVyIGFcblx0ICogc291bmQgcHJpb3IgdG8gYXR0ZW1wdGluZyB0byBwbGF5IGl0IHVzaW5nIHt7I2Nyb3NzTGluayBcIlNvdW5kL3BsYXlcIn19e3svY3Jvc3NMaW5rfX0gb3IgY3JlYXRlIGl0IHVzaW5nIHt7I2Nyb3NzTGluayBcIlNvdW5kL2NyZWF0ZUluc3RhbmNlXCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiB0aGUgc291bmQgc291cmNlIHdpbGwgYmUgYXV0b21hdGljYWxseSByZWdpc3RlcmVkIGJ1dCBwbGF5YmFjayB3aWxsIGZhaWwgYXMgdGhlIHNvdXJjZSB3aWxsIG5vdCBiZSByZWFkeS4gSWYgeW91IHVzZVxuXHQgKiA8YSBocmVmPVwiaHR0cDovL3ByZWxvYWRqcy5jb21cIiB0YXJnZXQ9XCJfYmxhbmtcIj5QcmVsb2FkSlM8L2E+LCByZWdpc3RyYXRpb24gaXMgaGFuZGxlZCBmb3IgeW91IHdoZW4gdGhlIHNvdW5kIGlzXG5cdCAqIHByZWxvYWRlZC4gSXQgaXMgcmVjb21tZW5kZWQgdG8gcHJlbG9hZCBzb3VuZHMgZWl0aGVyIGludGVybmFsbHkgdXNpbmcgdGhlIHJlZ2lzdGVyIGZ1bmN0aW9ucyBvciBleHRlcm5hbGx5IHVzaW5nXG5cdCAqIFByZWxvYWRKUyBzbyB0aGV5IGFyZSByZWFkeSB3aGVuIHlvdSB3YW50IHRvIHVzZSB0aGVtLlxuXHQgKlxuXHQgKiA8Yj5QbGF5YmFjazwvYj48YnIgLz5cblx0ICogVG8gcGxheSBhIHNvdW5kIG9uY2UgaXQncyBiZWVuIHJlZ2lzdGVyZWQgYW5kIHByZWxvYWRlZCwgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9wbGF5XCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cblx0ICogVGhpcyBtZXRob2QgcmV0dXJucyBhIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fSB3aGljaCBjYW4gYmUgcGF1c2VkLCByZXN1bWVkLCBtdXRlZCwgZXRjLlxuXHQgKiBQbGVhc2Ugc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2VcIn19e3svY3Jvc3NMaW5rfX0gZG9jdW1lbnRhdGlvbiBmb3IgbW9yZSBvbiB0aGUgaW5zdGFuY2UgY29udHJvbCBBUElzLlxuXHQgKlxuXHQgKiA8Yj5QbHVnaW5zPC9iPjxiciAvPlxuXHQgKiBCeSBkZWZhdWx0LCB0aGUge3sjY3Jvc3NMaW5rIFwiV2ViQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0gb3IgdGhlIHt7I2Nyb3NzTGluayBcIkhUTUxBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBhcmUgdXNlZCAod2hlbiBhdmFpbGFibGUpLCBhbHRob3VnaCBkZXZlbG9wZXJzIGNhbiBjaGFuZ2UgcGx1Z2luIHByaW9yaXR5IG9yIGFkZCBuZXcgcGx1Z2lucyAoc3VjaCBhcyB0aGVcblx0ICogcHJvdmlkZWQge3sjY3Jvc3NMaW5rIFwiRmxhc2hBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fSkuIFBsZWFzZSBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIlNvdW5kXCJ9fXt7L2Nyb3NzTGlua319IEFQSVxuXHQgKiBtZXRob2RzIGZvciBtb3JlIG9uIHRoZSBwbGF5YmFjayBhbmQgcGx1Z2luIEFQSXMuIFRvIGluc3RhbGwgcGx1Z2lucywgb3Igc3BlY2lmeSBhIGRpZmZlcmVudCBwbHVnaW4gb3JkZXIsIHNlZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9pbnN0YWxsUGx1Z2luc1wifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLkZsYXNoQXVkaW9QbHVnaW4uc3dmUGF0aCA9IFwiLi4vc3JjL3NvdW5kanMvZmxhc2hhdWRpb1wiO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLnJlZ2lzdGVyUGx1Z2lucyhbY3JlYXRlanMuV2ViQXVkaW9QbHVnaW4sIGNyZWF0ZWpzLkZsYXNoQXVkaW9QbHVnaW5dKTtcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5hbHRlcm5hdGVFeHRlbnNpb25zID0gW1wibXAzXCJdO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLm9uKFwiZmlsZWxvYWRcIiwgdGhpcy5sb2FkSGFuZGxlciwgdGhpcyk7XG5cdCAqICAgICAgY3JlYXRlanMuU291bmQucmVnaXN0ZXJTb3VuZChcInBhdGgvdG8vbXlTb3VuZC5vZ2dcIiwgXCJzb3VuZFwiKTtcblx0ICogICAgICBmdW5jdGlvbiBsb2FkSGFuZGxlcihldmVudCkge1xuICAgICAqICAgICAgICAgIC8vIFRoaXMgaXMgZmlyZWQgZm9yIGVhY2ggc291bmQgdGhhdCBpcyByZWdpc3RlcmVkLlxuICAgICAqICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZWpzLlNvdW5kLnBsYXkoXCJzb3VuZFwiKTsgIC8vIHBsYXkgdXNpbmcgaWQuICBDb3VsZCBhbHNvIHVzZSBmdWxsIHNvdXJjZSBwYXRoIG9yIGV2ZW50LnNyYy5cbiAgICAgKiAgICAgICAgICBpbnN0YW5jZS5vbihcImNvbXBsZXRlXCIsIHRoaXMuaGFuZGxlQ29tcGxldGUsIHRoaXMpO1xuICAgICAqICAgICAgICAgIGluc3RhbmNlLnZvbHVtZSA9IDAuNTtcblx0ICogICAgICB9XG5cdCAqXG5cdCAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjb25jdXJyZW50bHkgcGxheWluZyBpbnN0YW5jZXMgb2YgdGhlIHNhbWUgc291bmQgY2FuIGJlIHNwZWNpZmllZCBpbiB0aGUgXCJkYXRhXCIgYXJndW1lbnRcblx0ICogb2Yge3sjY3Jvc3NMaW5rIFwiU291bmQvcmVnaXN0ZXJTb3VuZFwifX17ey9jcm9zc0xpbmt9fS4gIE5vdGUgdGhhdCBpZiBub3Qgc3BlY2lmaWVkLCB0aGUgYWN0aXZlIHBsdWdpbiB3aWxsIGFwcGx5XG5cdCAqIGEgZGVmYXVsdCBsaW1pdC4gIEN1cnJlbnRseSBIVE1MQXVkaW9QbHVnaW4gc2V0cyBhIGRlZmF1bHQgbGltaXQgb2YgMiwgd2hpbGUgV2ViQXVkaW9QbHVnaW4gYW5kIEZsYXNoQXVkaW9QbHVnaW4gc2V0IGFcblx0ICogZGVmYXVsdCBsaW1pdCBvZiAxMDAuXG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuU291bmQucmVnaXN0ZXJTb3VuZChcInNvdW5kLm1wM1wiLCBcInNvdW5kSWRcIiwgNCk7XG5cdCAqXG5cdCAqIFNvdW5kIGNhbiBiZSB1c2VkIGFzIGEgcGx1Z2luIHdpdGggUHJlbG9hZEpTIHRvIGhlbHAgcHJlbG9hZCBhdWRpbyBwcm9wZXJseS4gQXVkaW8gcHJlbG9hZGVkIHdpdGggUHJlbG9hZEpTIGlzXG5cdCAqIGF1dG9tYXRpY2FsbHkgcmVnaXN0ZXJlZCB3aXRoIHRoZSBTb3VuZCBjbGFzcy4gV2hlbiBhdWRpbyBpcyBub3QgcHJlbG9hZGVkLCBTb3VuZCB3aWxsIGRvIGFuIGF1dG9tYXRpYyBpbnRlcm5hbFxuXHQgKiBsb2FkLiBBcyBhIHJlc3VsdCwgaXQgbWF5IGZhaWwgdG8gcGxheSB0aGUgZmlyc3QgdGltZSBwbGF5IGlzIGNhbGxlZCBpZiB0aGUgYXVkaW8gaXMgbm90IGZpbmlzaGVkIGxvYWRpbmcuIFVzZVxuXHQgKiB0aGUge3sjY3Jvc3NMaW5rIFwiU291bmQvZmlsZWxvYWQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgdG8gZGV0ZXJtaW5lIHdoZW4gYSBzb3VuZCBoYXMgZmluaXNoZWQgaW50ZXJuYWxseVxuXHQgKiBwcmVsb2FkaW5nLiBJdCBpcyByZWNvbW1lbmRlZCB0aGF0IGFsbCBhdWRpbyBpcyBwcmVsb2FkZWQgYmVmb3JlIGl0IGlzIHBsYXllZC5cblx0ICpcblx0ICogICAgICB2YXIgcXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG5cdCAqXHRcdHF1ZXVlLmluc3RhbGxQbHVnaW4oY3JlYXRlanMuU291bmQpO1xuXHQgKlxuXHQgKiA8Yj5BdWRpbyBTcHJpdGVzPC9iPjxiciAvPlxuXHQgKiBTb3VuZEpTIGhhcyBhZGRlZCBzdXBwb3J0IGZvciB7eyNjcm9zc0xpbmsgXCJBdWRpb1Nwcml0ZVwifX17ey9jcm9zc0xpbmt9fSwgYXZhaWxhYmxlIGFzIG9mIHZlcnNpb24gMC42LjAuXG5cdCAqIEZvciB0aG9zZSB1bmZhbWlsaWFyIHdpdGggYXVkaW8gc3ByaXRlcywgdGhleSBhcmUgbXVjaCBsaWtlIENTUyBzcHJpdGVzIG9yIHNwcml0ZSBzaGVldHM6IG11bHRpcGxlIGF1ZGlvIGFzc2V0c1xuXHQgKiBncm91cGVkIGludG8gYSBzaW5nbGUgZmlsZS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKlx0XHR2YXIgYXNzZXRzUGF0aCA9IFwiLi9hc3NldHMvXCI7XG5cdCAqXHRcdHZhciBzb3VuZHMgPSBbe1xuXHQgKlx0XHRcdHNyYzpcIk15QXVkaW9TcHJpdGUub2dnXCIsIGRhdGE6IHtcblx0ICpcdFx0XHRcdGF1ZGlvU3ByaXRlOiBbXG5cdCAqXHRcdFx0XHRcdHtpZDpcInNvdW5kMVwiLCBzdGFydFRpbWU6MCwgZHVyYXRpb246NTAwfSxcblx0ICpcdFx0XHRcdFx0e2lkOlwic291bmQyXCIsIHN0YXJ0VGltZToxMDAwLCBkdXJhdGlvbjo0MDB9LFxuXHQgKlx0XHRcdFx0XHR7aWQ6XCJzb3VuZDNcIiwgc3RhcnRUaW1lOjE3MDAsIGR1cmF0aW9uOiAxMDAwfVxuXHQgKlx0XHRcdFx0XX1cbiBcdCAqXHRcdFx0fVxuXHQgKlx0XHRdO1xuXHQgKlx0XHRjcmVhdGVqcy5Tb3VuZC5hbHRlcm5hdGVFeHRlbnNpb25zID0gW1wibXAzXCJdO1xuXHQgKlx0XHRjcmVhdGVqcy5Tb3VuZC5vbihcImZpbGVsb2FkXCIsIGxvYWRTb3VuZCk7XG5cdCAqXHRcdGNyZWF0ZWpzLlNvdW5kLnJlZ2lzdGVyU291bmRzKHNvdW5kcywgYXNzZXRzUGF0aCk7XG5cdCAqXHRcdC8vIGFmdGVyIGxvYWQgaXMgY29tcGxldGVcblx0ICpcdFx0Y3JlYXRlanMuU291bmQucGxheShcInNvdW5kMlwiKTtcblx0ICpcblx0ICogPGI+TW9iaWxlIFBsYXliYWNrPC9iPjxiciAvPlxuXHQgKiBEZXZpY2VzIHJ1bm5pbmcgaU9TIHJlcXVpcmUgdGhlIFdlYkF1ZGlvIGNvbnRleHQgdG8gYmUgXCJ1bmxvY2tlZFwiIGJ5IHBsYXlpbmcgYXQgbGVhc3Qgb25lIHNvdW5kIGluc2lkZSBvZiBhIHVzZXItXG5cdCAqIGluaXRpYXRlZCBldmVudCAoc3VjaCBhcyB0b3VjaC9jbGljaykuIEVhcmxpZXIgdmVyc2lvbnMgb2YgU291bmRKUyBpbmNsdWRlZCBhIFwiTW9iaWxlU2FmZVwiIHNhbXBsZSwgYnV0IHRoaXMgaXMgbm9cblx0ICogbG9uZ2VyIG5lY2Vzc2FyeSBhcyBvZiBTb3VuZEpTIDAuNi4yLlxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+XG5cdCAqICAgICAgICAgSW4gU291bmRKUyAwLjQuMSBhbmQgYWJvdmUsIHlvdSBjYW4gZWl0aGVyIGluaXRpYWxpemUgcGx1Z2lucyBvciB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIldlYkF1ZGlvUGx1Z2luL3BsYXlFbXB0eVNvdW5kXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqICAgICAgICAgbWV0aG9kIGluIHRoZSBjYWxsIHN0YWNrIG9mIGEgdXNlciBpbnB1dCBldmVudCB0byBtYW51YWxseSB1bmxvY2sgdGhlIGF1ZGlvIGNvbnRleHQuXG5cdCAqICAgICA8L2xpPlxuXHQgKiAgICAgPGxpPlxuXHQgKiAgICAgICAgIEluIFNvdW5kSlMgMC42LjIgYW5kIGFib3ZlLCBTb3VuZEpTIHdpbGwgYXV0b21hdGljYWxseSBsaXN0ZW4gZm9yIHRoZSBmaXJzdCBkb2N1bWVudC1sZXZlbCBcIm1vdXNlZG93blwiXG5cdCAqICAgICAgICAgYW5kIFwidG91Y2hlbmRcIiBldmVudCwgYW5kIHVubG9jayBXZWJBdWRpby4gVGhpcyB3aWxsIGNvbnRpbnVlIHRvIGNoZWNrIHRoZXNlIGV2ZW50cyB1bnRpbCB0aGUgV2ViQXVkaW9cblx0ICogICAgICAgICBjb250ZXh0IGJlY29tZXMgXCJ1bmxvY2tlZFwiIChjaGFuZ2VzIGZyb20gXCJzdXNwZW5kZWRcIiB0byBcInJ1bm5pbmdcIilcblx0ICogICAgIDwvbGk+XG5cdCAqICAgICA8bGk+XG5cdCAqICAgICAgICAgQm90aCB0aGUgXCJtb3VzZWRvd25cIiBhbmQgXCJ0b3VjaGVuZFwiIGV2ZW50cyBjYW4gYmUgdXNlZCB0byB1bmxvY2sgYXVkaW8gaW4gaU9TOSssIHRoZSBcInRvdWNoc3RhcnRcIiBldmVudFxuXHQgKiAgICAgICAgIHdpbGwgd29yayBpbiBpT1M4IGFuZCBiZWxvdy4gVGhlIFwidG91Y2hlbmRcIiBldmVudCB3aWxsIG9ubHkgd29yayBpbiBpT1M5IHdoZW4gdGhlIGdlc3R1cmUgaXMgaW50ZXJwcmV0ZWRcblx0ICogICAgICAgICBhcyBhIFwiY2xpY2tcIiwgc28gaWYgdGhlIHVzZXIgbG9uZy1wcmVzc2VzIHRoZSBidXR0b24sIGl0IHdpbGwgbm8gbG9uZ2VyIHdvcmsuXG5cdCAqICAgICA8L2xpPlxuXHQgKiAgICAgPGxpPlxuXHQgKiAgICAgICAgIFdoZW4gdXNpbmcgdGhlIDxhIGhyZWY9XCJodHRwOi8vd3d3LmNyZWF0ZWpzLmNvbS9kb2NzL2Vhc2VsanMvY2xhc3Nlcy9Ub3VjaC5odG1sXCI+RWFzZWxKUyBUb3VjaCBjbGFzczwvYT4sXG5cdCAqICAgICAgICAgdGhlIFwibW91c2Vkb3duXCIgZXZlbnQgd2lsbCBub3QgZmlyZSB3aGVuIGEgY2FudmFzIGlzIGNsaWNrZWQsIHNpbmNlIE1vdXNlRXZlbnRzIGFyZSBwcmV2ZW50ZWQsIHRvIGVuc3VyZVxuXHQgKiAgICAgICAgIG9ubHkgdG91Y2ggZXZlbnRzIGZpcmUuIFRvIGdldCBhcm91bmQgdGhpcywgeW91IGNhbiBlaXRoZXIgcmVseSBvbiBcInRvdWNoZW5kXCIsIG9yOlxuXHQgKiAgICAgICAgIDxvbD5cblx0ICogICAgICAgICAgICAgPGxpPlNldCB0aGUgYGFsbG93RGVmYXVsdGAgcHJvcGVydHkgb24gdGhlIFRvdWNoIGNsYXNzIGNvbnN0cnVjdG9yIHRvIGB0cnVlYCAoZGVmYXVsdHMgdG8gYGZhbHNlYCkuPC9saT5cblx0ICogICAgICAgICAgICAgPGxpPlNldCB0aGUgYHByZXZlbnRTZWxlY3Rpb25gIHByb3BlcnR5IG9uIHRoZSBFYXNlbEpTIGBTdGFnZWAgdG8gYGZhbHNlYC48L2xpPlxuXHQgKiAgICAgICAgIDwvb2w+XG5cdCAqICAgICAgICAgVGhlc2Ugc2V0dGluZ3MgbWF5IGNoYW5nZSBob3cgeW91ciBhcHBsaWNhdGlvbiBiZWhhdmVzLCBhbmQgYXJlIG5vdCByZWNvbW1lbmRlZC5cblx0ICogICAgIDwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqIDxiPkxvYWRpbmcgQWx0ZXJuYXRlIFBhdGhzIGFuZCBFeHRlbnNpb24tbGVzcyBGaWxlczwvYj48YnIgLz5cblx0ICogU291bmRKUyBzdXBwb3J0cyBsb2FkaW5nIGFsdGVybmF0ZSBwYXRocyBhbmQgZXh0ZW5zaW9uLWxlc3MgZmlsZXMgYnkgcGFzc2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhIHN0cmluZyBmb3Jcblx0ICogdGhlIGBzcmNgIHByb3BlcnR5LCB3aGljaCBpcyBhIGhhc2ggdXNpbmcgdGhlIGZvcm1hdCBge2V4dGVuc2lvbjpcInBhdGhcIiwgZXh0ZW5zaW9uMjpcInBhdGgyXCJ9YC4gVGhlc2UgbGFiZWxzIGFyZVxuXHQgKiBob3cgU291bmRKUyBkZXRlcm1pbmVzIGlmIHRoZSBicm93c2VyIHdpbGwgc3VwcG9ydCB0aGUgc291bmQuIFRoaXMgYWxzbyBlbmFibGVzIG11bHRpcGxlIGZvcm1hdHMgdG8gbGl2ZSBpblxuXHQgKiBkaWZmZXJlbnQgZm9sZGVycywgb3Igb24gQ0ROcywgd2hpY2ggb2Z0ZW4gaGFzIGNvbXBsZXRlbHkgZGlmZmVyZW50IGZpbGVuYW1lcyBmb3IgZWFjaCBmaWxlLlxuXHQgKlxuXHQgKiBQcmlvcml0eSBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBwcm9wZXJ0eSBvcmRlciAoZmlyc3QgcHJvcGVydHkgaXMgdHJpZWQgZmlyc3QpLiAgVGhpcyBpcyBzdXBwb3J0ZWQgYnkgYm90aCBpbnRlcm5hbCBsb2FkaW5nXG5cdCAqIGFuZCBsb2FkaW5nIHdpdGggUHJlbG9hZEpTLlxuXHQgKlxuXHQgKiA8ZW0+Tm90ZTogYW4gaWQgaXMgcmVxdWlyZWQgZm9yIHBsYXliYWNrLjwvZW0+XG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICpcdFx0dmFyIHNvdW5kcyA9IHtwYXRoOlwiLi9hdWRpb1BhdGgvXCIsXG5cdCAqIFx0XHRcdFx0bWFuaWZlc3Q6IFtcblx0ICpcdFx0XHRcdHtpZDogXCJjb29sXCIsIHNyYzoge21wMzpcIm1wMy9hd2Vzb21lLm1wM1wiLCBvZ2c6XCJub0V4dGVuc2lvbk9nZ0ZpbGVcIn19XG5cdCAqXHRcdF19O1xuXHQgKlxuXHQgKlx0XHRjcmVhdGVqcy5Tb3VuZC5hbHRlcm5hdGVFeHRlbnNpb25zID0gW1wibXAzXCJdO1xuXHQgKlx0XHRjcmVhdGVqcy5Tb3VuZC5hZGRFdmVudExpc3RlbmVyKFwiZmlsZWxvYWRcIiwgaGFuZGxlTG9hZCk7XG5cdCAqXHRcdGNyZWF0ZWpzLlNvdW5kLnJlZ2lzdGVyU291bmRzKHNvdW5kcyk7XG5cdCAqXG5cdCAqIDxoMz5Lbm93biBCcm93c2VyIGFuZCBPUyBpc3N1ZXM8L2gzPlxuXHQgKiA8Yj5JRSA5IEhUTUwgQXVkaW8gbGltaXRhdGlvbnM8L2I+PGJyIC8+XG5cdCAqIDx1bD48bGk+VGhlcmUgaXMgYSBkZWxheSBpbiBhcHBseWluZyB2b2x1bWUgY2hhbmdlcyB0byB0YWdzIHRoYXQgb2NjdXJzIG9uY2UgcGxheWJhY2sgaXMgc3RhcnRlZC4gU28gaWYgeW91IGhhdmVcblx0ICogbXV0ZWQgYWxsIHNvdW5kcywgdGhleSB3aWxsIGFsbCBwbGF5IGR1cmluZyB0aGlzIGRlbGF5IHVudGlsIHRoZSBtdXRlIGFwcGxpZXMgaW50ZXJuYWxseS4gVGhpcyBoYXBwZW5zIHJlZ2FyZGxlc3Mgb2Zcblx0ICogd2hlbiBvciBob3cgeW91IGFwcGx5IHRoZSB2b2x1bWUgY2hhbmdlLCBhcyB0aGUgdGFnIHNlZW1zIHRvIG5lZWQgdG8gcGxheSB0byBhcHBseSBpdC48L2xpPlxuICAgICAqIDxsaT5NUDMgZW5jb2Rpbmcgd2lsbCBub3QgYWx3YXlzIHdvcmsgZm9yIGF1ZGlvIHRhZ3MsIHBhcnRpY3VsYXJseSBpbiBJbnRlcm5ldCBFeHBsb3Jlci4gV2UndmUgZm91bmQgZGVmYXVsdFxuXHQgKiBlbmNvZGluZyB3aXRoIDY0a2JwcyB3b3Jrcy48L2xpPlxuXHQgKiA8bGk+T2NjYXNpb25hbGx5IHZlcnkgc2hvcnQgc2FtcGxlcyB3aWxsIGdldCBjdXQgb2ZmLjwvbGk+XG5cdCAqIDxsaT5UaGVyZSBpcyBhIGxpbWl0IHRvIGhvdyBtYW55IGF1ZGlvIHRhZ3MgeW91IGNhbiBsb2FkIGFuZCBwbGF5IGF0IG9uY2UsIHdoaWNoIGFwcGVhcnMgdG8gYmUgZGV0ZXJtaW5lZCBieVxuXHQgKiBoYXJkd2FyZSBhbmQgYnJvd3NlciBzZXR0aW5ncy4gIFNlZSB7eyNjcm9zc0xpbmsgXCJIVE1MQXVkaW9QbHVnaW4uTUFYX0lOU1RBTkNFU1wifX17ey9jcm9zc0xpbmt9fSBmb3IgYSBzYWZlXG5cdCAqIGVzdGltYXRlLjwvbGk+PC91bD5cblx0ICpcblx0ICogPGI+RmlyZWZveCAyNSBXZWIgQXVkaW8gbGltaXRhdGlvbnM8L2I+XG5cdCAqIDx1bD48bGk+bXAzIGF1ZGlvIGZpbGVzIGRvIG5vdCBsb2FkIHByb3Blcmx5IG9uIGFsbCB3aW5kb3dzIG1hY2hpbmVzLCByZXBvcnRlZFxuXHQgKiA8YSBocmVmPVwiaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTI5OTY5XCIgdGFyZ2V0PVwiX2JsYW5rXCI+aGVyZTwvYT4uIDwvYnI+XG5cdCAqIEZvciB0aGlzIHJlYXNvbiBpdCBpcyByZWNvbW1lbmRlZCB0byBwYXNzIGFub3RoZXIgRkYgc3VwcG9ydGVkIHR5cGUgKGllIG9nZykgZmlyc3QgdW50aWwgdGhpcyBidWcgaXMgcmVzb2x2ZWQsIGlmXG5cdCAqIHBvc3NpYmxlLjwvbGk+PC91bD5cblxuXHQgKiA8Yj5TYWZhcmkgbGltaXRhdGlvbnM8L2I+PGJyIC8+XG5cdCAqIDx1bD48bGk+U2FmYXJpIHJlcXVpcmVzIFF1aWNrdGltZSB0byBiZSBpbnN0YWxsZWQgZm9yIGF1ZGlvIHBsYXliYWNrLjwvbGk+PC91bD5cblx0ICpcblx0ICogPGI+aU9TIDYgV2ViIEF1ZGlvIGxpbWl0YXRpb25zPC9iPjxiciAvPlxuXHQgKiA8dWw+PGxpPlNvdW5kIGlzIGluaXRpYWxseSBsb2NrZWQsIGFuZCBtdXN0IGJlIHVubG9ja2VkIHZpYSBhIHVzZXItaW5pdGlhdGVkIGV2ZW50LiBQbGVhc2Ugc2VlIHRoZSBzZWN0aW9uIG9uXG5cdCAqIE1vYmlsZSBQbGF5YmFjayBhYm92ZS48L2xpPlxuXHQgKiA8bGk+QSBidWcgZXhpc3RzIHRoYXQgd2lsbCBkaXN0b3J0IHVuLWNhY2hlZCB3ZWIgYXVkaW8gd2hlbiBhIHZpZGVvIGVsZW1lbnQgaXMgcHJlc2VudCBpbiB0aGUgRE9NIHRoYXQgaGFzIGF1ZGlvXG5cdCAqIGF0IGEgZGlmZmVyZW50IHNhbXBsZVJhdGUuPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogPGI+QW5kcm9pZCBIVE1MIEF1ZGlvIGxpbWl0YXRpb25zPC9iPjxiciAvPlxuXHQgKiA8dWw+PGxpPldlIGhhdmUgbm8gY29udHJvbCBvdmVyIGF1ZGlvIHZvbHVtZS4gT25seSB0aGUgdXNlciBjYW4gc2V0IHZvbHVtZSBvbiB0aGVpciBkZXZpY2UuPC9saT5cblx0ICogPGxpPldlIGNhbiBvbmx5IHBsYXkgYXVkaW8gaW5zaWRlIGEgdXNlciBldmVudCAodG91Y2gvY2xpY2spLiAgVGhpcyBjdXJyZW50bHkgbWVhbnMgeW91IGNhbm5vdCBsb29wIHNvdW5kIG9yIHVzZVxuXHQgKiBhIGRlbGF5LjwvbGk+PC91bD5cblx0ICpcblx0ICogPGI+V2ViIEF1ZGlvIGFuZCBQcmVsb2FkSlM8L2I+PGJyIC8+XG5cdCAqIDx1bD48bGk+V2ViIEF1ZGlvIG11c3QgYmUgbG9hZGVkIHRocm91Z2ggWEhSLCB0aGVyZWZvcmUgd2hlbiB1c2VkIHdpdGggUHJlbG9hZEpTLCB0YWcgbG9hZGluZyBpcyBub3QgcG9zc2libGUuXG5cdCAqIFRoaXMgbWVhbnMgdGhhdCB0YWcgbG9hZGluZyBjYW4gbm90IGJlIHVzZWQgdG8gYXZvaWQgY3Jvc3MgZG9tYWluIGlzc3Vlcy48L2xpPjx1bD5cblx0ICpcblx0ICogQGNsYXNzIFNvdW5kXG5cdCAqIEBzdGF0aWNcblx0ICogQHVzZXMgRXZlbnREaXNwYXRjaGVyXG5cdCAqL1xuXHRmdW5jdGlvbiBTb3VuZCgpIHtcblx0XHR0aHJvdyBcIlNvdW5kIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWRcIjtcblx0fVxuXG5cdHZhciBzID0gU291bmQ7XG5cblxuLy8gU3RhdGljIFByb3BlcnRpZXNcblx0LyoqXG5cdCAqIFRoZSBpbnRlcnJ1cHQgdmFsdWUgdG8gaW50ZXJydXB0IGFueSBjdXJyZW50bHkgcGxheWluZyBpbnN0YW5jZSB3aXRoIHRoZSBzYW1lIHNvdXJjZSwgaWYgdGhlIG1heGltdW0gbnVtYmVyIG9mXG5cdCAqIGluc3RhbmNlcyBvZiB0aGUgc291bmQgYXJlIGFscmVhZHkgcGxheWluZy5cblx0ICogQHByb3BlcnR5IElOVEVSUlVQVF9BTllcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgYW55XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuSU5URVJSVVBUX0FOWSA9IFwiYW55XCI7XG5cblx0LyoqXG5cdCAqIFRoZSBpbnRlcnJ1cHQgdmFsdWUgdG8gaW50ZXJydXB0IHRoZSBlYXJsaWVzdCBjdXJyZW50bHkgcGxheWluZyBpbnN0YW5jZSB3aXRoIHRoZSBzYW1lIHNvdXJjZSB0aGF0IHByb2dyZXNzZWQgdGhlXG5cdCAqIGxlYXN0IGRpc3RhbmNlIGluIHRoZSBhdWRpbyB0cmFjaywgaWYgdGhlIG1heGltdW0gbnVtYmVyIG9mIGluc3RhbmNlcyBvZiB0aGUgc291bmQgYXJlIGFscmVhZHkgcGxheWluZy5cblx0ICogQHByb3BlcnR5IElOVEVSUlVQVF9FQVJMWVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBlYXJseVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLklOVEVSUlVQVF9FQVJMWSA9IFwiZWFybHlcIjtcblxuXHQvKipcblx0ICogVGhlIGludGVycnVwdCB2YWx1ZSB0byBpbnRlcnJ1cHQgdGhlIGN1cnJlbnRseSBwbGF5aW5nIGluc3RhbmNlIHdpdGggdGhlIHNhbWUgc291cmNlIHRoYXQgcHJvZ3Jlc3NlZCB0aGUgbW9zdFxuXHQgKiBkaXN0YW5jZSBpbiB0aGUgYXVkaW8gdHJhY2ssIGlmIHRoZSBtYXhpbXVtIG51bWJlciBvZiBpbnN0YW5jZXMgb2YgdGhlIHNvdW5kIGFyZSBhbHJlYWR5IHBsYXlpbmcuXG5cdCAqIEBwcm9wZXJ0eSBJTlRFUlJVUFRfTEFURVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBsYXRlXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuSU5URVJSVVBUX0xBVEUgPSBcImxhdGVcIjtcblxuXHQvKipcblx0ICogVGhlIGludGVycnVwdCB2YWx1ZSB0byBub3QgaW50ZXJydXB0IGFueSBjdXJyZW50bHkgcGxheWluZyBpbnN0YW5jZXMgd2l0aCB0aGUgc2FtZSBzb3VyY2UsIGlmIHRoZSBtYXhpbXVtIG51bWJlciBvZlxuXHQgKiBpbnN0YW5jZXMgb2YgdGhlIHNvdW5kIGFyZSBhbHJlYWR5IHBsYXlpbmcuXG5cdCAqIEBwcm9wZXJ0eSBJTlRFUlJVUFRfTk9ORVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBub25lXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuSU5URVJSVVBUX05PTkUgPSBcIm5vbmVcIjtcblxuXHQvKipcblx0ICogRGVmaW5lcyB0aGUgcGxheVN0YXRlIG9mIGFuIGluc3RhbmNlIHRoYXQgaXMgc3RpbGwgaW5pdGlhbGl6aW5nLlxuXHQgKiBAcHJvcGVydHkgUExBWV9JTklURURcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgcGxheUluaXRlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLlBMQVlfSU5JVEVEID0gXCJwbGF5SW5pdGVkXCI7XG5cblx0LyoqXG5cdCAqIERlZmluZXMgdGhlIHBsYXlTdGF0ZSBvZiBhbiBpbnN0YW5jZSB0aGF0IGlzIGN1cnJlbnRseSBwbGF5aW5nIG9yIHBhdXNlZC5cblx0ICogQHByb3BlcnR5IFBMQVlfU1VDQ0VFREVEXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHBsYXlTdWNjZWVkZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5QTEFZX1NVQ0NFRURFRCA9IFwicGxheVN1Y2NlZWRlZFwiO1xuXG5cdC8qKlxuXHQgKiBEZWZpbmVzIHRoZSBwbGF5U3RhdGUgb2YgYW4gaW5zdGFuY2UgdGhhdCB3YXMgaW50ZXJydXB0ZWQgYnkgYW5vdGhlciBpbnN0YW5jZS5cblx0ICogQHByb3BlcnR5IFBMQVlfSU5URVJSVVBURURcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgcGxheUludGVycnVwdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuUExBWV9JTlRFUlJVUFRFRCA9IFwicGxheUludGVycnVwdGVkXCI7XG5cblx0LyoqXG5cdCAqIERlZmluZXMgdGhlIHBsYXlTdGF0ZSBvZiBhbiBpbnN0YW5jZSB0aGF0IGNvbXBsZXRlZCBwbGF5YmFjay5cblx0ICogQHByb3BlcnR5IFBMQVlfRklOSVNIRURcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgcGxheUZpbmlzaGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuUExBWV9GSU5JU0hFRCA9IFwicGxheUZpbmlzaGVkXCI7XG5cblx0LyoqXG5cdCAqIERlZmluZXMgdGhlIHBsYXlTdGF0ZSBvZiBhbiBpbnN0YW5jZSB0aGF0IGZhaWxlZCB0byBwbGF5LiBUaGlzIGlzIHVzdWFsbHkgY2F1c2VkIGJ5IGEgbGFjayBvZiBhdmFpbGFibGUgY2hhbm5lbHNcblx0ICogd2hlbiB0aGUgaW50ZXJydXB0IG1vZGUgd2FzIFwiSU5URVJSVVBUX05PTkVcIiwgdGhlIHBsYXliYWNrIHN0YWxsZWQsIG9yIHRoZSBzb3VuZCBjb3VsZCBub3QgYmUgZm91bmQuXG5cdCAqIEBwcm9wZXJ0eSBQTEFZX0ZBSUxFRFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBwbGF5RmFpbGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuUExBWV9GQUlMRUQgPSBcInBsYXlGYWlsZWRcIjtcblxuXHQvKipcblx0ICogQSBsaXN0IG9mIHRoZSBkZWZhdWx0IHN1cHBvcnRlZCBleHRlbnNpb25zIHRoYXQgU291bmQgd2lsbCA8aT50cnk8L2k+IHRvIHBsYXkuIFBsdWdpbnMgd2lsbCBjaGVjayBpZiB0aGUgYnJvd3NlclxuXHQgKiBjYW4gcGxheSB0aGVzZSB0eXBlcywgc28gbW9kaWZ5aW5nIHRoaXMgbGlzdCBiZWZvcmUgYSBwbHVnaW4gaXMgaW5pdGlhbGl6ZWQgd2lsbCBhbGxvdyB0aGUgcGx1Z2lucyB0byB0cnkgdG9cblx0ICogc3VwcG9ydCBhZGRpdGlvbmFsIG1lZGlhIHR5cGVzLlxuXHQgKlxuXHQgKiBOT1RFIHRoaXMgZG9lcyBub3QgY3VycmVudGx5IHdvcmsgZm9yIHt7I2Nyb3NzTGluayBcIkZsYXNoQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIE1vcmUgZGV0YWlscyBvbiBmaWxlIGZvcm1hdHMgY2FuIGJlIGZvdW5kIGF0IDxhIGhyZWY9XCJodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0F1ZGlvX2ZpbGVfZm9ybWF0XCIgdGFyZ2V0PVwiX2JsYW5rXCI+aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BdWRpb19maWxlX2Zvcm1hdDwvYT4uPGJyIC8+XG5cdCAqIEEgdmVyeSBkZXRhaWxlZCBsaXN0IG9mIGZpbGUgZm9ybWF0cyBjYW4gYmUgZm91bmQgYXQgPGEgaHJlZj1cImh0dHA6Ly93d3cuZmlsZWluZm8uY29tL2ZpbGV0eXBlcy9hdWRpb1wiIHRhcmdldD1cIl9ibGFua1wiPmh0dHA6Ly93d3cuZmlsZWluZm8uY29tL2ZpbGV0eXBlcy9hdWRpbzwvYT4uXG5cdCAqIEBwcm9wZXJ0eSBTVVBQT1JURURfRVhURU5TSU9OU1xuXHQgKiBAdHlwZSB7QXJyYXlbU3RyaW5nXX1cblx0ICogQGRlZmF1bHQgW1wibXAzXCIsIFwib2dnXCIsIFwib3B1c1wiLCBcIm1wZWdcIiwgXCJ3YXZcIiwgXCJtNGFcIiwgXCJtcDRcIiwgXCJhaWZmXCIsIFwid21hXCIsIFwibWlkXCJdXG5cdCAqIEBzaW5jZSAwLjQuMFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLlNVUFBPUlRFRF9FWFRFTlNJT05TID0gW1wibXAzXCIsIFwib2dnXCIsIFwib3B1c1wiLCBcIm1wZWdcIiwgXCJ3YXZcIiwgXCJtNGFcIiwgXCJtcDRcIiwgXCJhaWZmXCIsIFwid21hXCIsIFwibWlkXCJdO1xuXG5cdC8qKlxuXHQgKiBTb21lIGV4dGVuc2lvbnMgdXNlIGFub3RoZXIgdHlwZSBvZiBleHRlbnNpb24gc3VwcG9ydCB0byBwbGF5IChvbmUgb2YgdGhlbSBpcyBhIGNvZGV4KS4gIFRoaXMgYWxsb3dzIHlvdSB0byBtYXBcblx0ICogdGhhdCBzdXBwb3J0IHNvIHBsdWdpbnMgY2FuIGFjY3VyYXRlbHkgZGV0ZXJtaW5lIGlmIGFuIGV4dGVuc2lvbiBpcyBzdXBwb3J0ZWQuICBBZGRpbmcgdG8gdGhpcyBsaXN0IGNhbiBoZWxwXG5cdCAqIHBsdWdpbnMgZGV0ZXJtaW5lIG1vcmUgYWNjdXJhdGVseSBpZiBhbiBleHRlbnNpb24gaXMgc3VwcG9ydGVkLlxuXHQgKlxuIFx0ICogQSB1c2VmdWwgbGlzdCBvZiBleHRlbnNpb25zIGZvciBlYWNoIGZvcm1hdCBjYW4gYmUgZm91bmQgYXQgPGEgaHJlZj1cImh0dHA6Ly9odG1sNWRvY3Rvci5jb20vaHRtbDUtYXVkaW8tdGhlLXN0YXRlLW9mLXBsYXkvXCIgdGFyZ2V0PVwiX2JsYW5rXCI+aHR0cDovL2h0bWw1ZG9jdG9yLmNvbS9odG1sNS1hdWRpby10aGUtc3RhdGUtb2YtcGxheS88L2E+LlxuXHQgKiBAcHJvcGVydHkgRVhURU5TSU9OX01BUFxuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKiBAc2luY2UgMC40LjBcblx0ICogQGRlZmF1bHQge200YTpcIm1wNFwifVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLkVYVEVOU0lPTl9NQVAgPSB7XG5cdFx0bTRhOlwibXA0XCJcblx0fTtcblxuXHQvKipcblx0ICogVGhlIFJlZ0V4cCBwYXR0ZXJuIHVzZWQgdG8gcGFyc2UgZmlsZSBVUklzLiBUaGlzIHN1cHBvcnRzIHNpbXBsZSBmaWxlIG5hbWVzLCBhcyB3ZWxsIGFzIGZ1bGwgZG9tYWluIFVSSXMgd2l0aFxuXHQgKiBxdWVyeSBzdHJpbmdzLiBUaGUgcmVzdWx0aW5nIG1hdGNoIGlzOiBwcm90b2NvbDokMSBkb21haW46JDIgcGF0aDokMyBmaWxlOiQ0IGV4dGVuc2lvbjokNSBxdWVyeTokNi5cblx0ICogQHByb3BlcnR5IEZJTEVfUEFUVEVSTlxuXHQgKiBAdHlwZSB7UmVnRXhwfVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHMuRklMRV9QQVRURVJOID0gL14oPzooXFx3KzopXFwvezJ9KFxcdysoPzpcXC5cXHcrKSpcXC8/KSk/KFsvLl0qPyg/OlteP10rKT9cXC8pPygoPzpbXi8/XSspXFwuKFxcdyspKSg/OlxcPyhcXFMrKT8pPyQvO1xuXG5cbi8vIENsYXNzIFB1YmxpYyBwcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGZvciBpbnRlcnJ1cHRpbmcgb3RoZXIgY3VycmVudGx5IHBsYXlpbmcgaW5zdGFuY2VzIHdpdGggdGhlIHNhbWUgc291cmNlLCBpZiB0aGVcblx0ICogbWF4aW11bSBudW1iZXIgb2YgaW5zdGFuY2VzIG9mIHRoZSBzb3VuZCBhcmUgYWxyZWFkeSBwbGF5aW5nLiAgQ3VycmVudGx5IHRoZSBkZWZhdWx0IGlzIHt7I2Nyb3NzTGluayBcIlNvdW5kL0lOVEVSUlVQVF9OT05FOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGJ1dCB0aGlzIGNhbiBiZSBzZXQgYW5kIHdpbGwgY2hhbmdlIHBsYXliYWNrIGJlaGF2aW9yIGFjY29yZGluZ2x5LiAgVGhpcyBpcyBvbmx5IHVzZWQgd2hlbiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9wbGF5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGlzIGNhbGxlZCB3aXRob3V0IHBhc3NpbmcgYSB2YWx1ZSBmb3IgaW50ZXJydXB0LlxuXHQgKiBAcHJvcGVydHkgZGVmYXVsdEludGVycnVwdEJlaGF2aW9yXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IFNvdW5kLklOVEVSUlVQVF9OT05FLCBvciBcIm5vbmVcIlxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMFxuXHQgKi9cblx0cy5kZWZhdWx0SW50ZXJydXB0QmVoYXZpb3IgPSBzLklOVEVSUlVQVF9OT05FOyAgLy8gT0pSIGRvZXMgcy5JTlRFUlJVUFRfQU5ZIG1ha2UgbW9yZSBzZW5zZSBhcyBkZWZhdWx0PyAgTmVlZHMgZ2FtZSBkZXYgdGVzdGluZyB0byBzZWUgd2hpY2ggY2FzZSBtYWtlcyBtb3JlIHNlbnNlLlxuXG5cdC8qKlxuXHQgKiBBbiBhcnJheSBvZiBleHRlbnNpb25zIHRvIGF0dGVtcHQgdG8gdXNlIHdoZW4gbG9hZGluZyBzb3VuZCwgaWYgdGhlIGRlZmF1bHQgaXMgdW5zdXBwb3J0ZWQgYnkgdGhlIGFjdGl2ZSBwbHVnaW4uXG5cdCAqIFRoZXNlIGFyZSBhcHBsaWVkIGluIG9yZGVyLCBzbyBpZiB5b3UgdHJ5IHRvIExvYWQgVGh1bmRlci5vZ2cgaW4gYSBicm93c2VyIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCBvZ2csIGFuZCB5b3VyXG5cdCAqIGV4dGVuc2lvbnMgYXJyYXkgaXMgW1wibXAzXCIsIFwibTRhXCIsIFwid2F2XCJdIGl0IHdpbGwgY2hlY2sgbXAzIHN1cHBvcnQsIHRoZW4gbTRhLCB0aGVuIHdhdi4gVGhlIGF1ZGlvIGZpbGVzIG5lZWRcblx0ICogdG8gZXhpc3QgaW4gdGhlIHNhbWUgbG9jYXRpb24sIGFzIG9ubHkgdGhlIGV4dGVuc2lvbiBpcyBhbHRlcmVkLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgcmVnYXJkbGVzcyBvZiB3aGljaCBmaWxlIGlzIGxvYWRlZCwgeW91IGNhbiBjYWxsIHt7I2Nyb3NzTGluayBcIlNvdW5kL2NyZWF0ZUluc3RhbmNlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGFuZCB7eyNjcm9zc0xpbmsgXCJTb3VuZC9wbGF5XCJ9fXt7L2Nyb3NzTGlua319IHVzaW5nIHRoZSBzYW1lIGlkIG9yIGZ1bGwgc291cmNlIHBhdGggcGFzc2VkIGZvciBsb2FkaW5nLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqXHR2YXIgc291bmRzID0gW1xuXHQgKlx0XHR7c3JjOlwibXlQYXRoL215U291bmQub2dnXCIsIGlkOlwiZXhhbXBsZVwifSxcblx0ICpcdF07XG5cdCAqXHRjcmVhdGVqcy5Tb3VuZC5hbHRlcm5hdGVFeHRlbnNpb25zID0gW1wibXAzXCJdOyAvLyBub3cgaWYgb2dnIGlzIG5vdCBzdXBwb3J0ZWQsIFNvdW5kSlMgd2lsbCB0cnkgYXNzZXQwLm1wM1xuXHQgKlx0Y3JlYXRlanMuU291bmQub24oXCJmaWxlbG9hZFwiLCBoYW5kbGVMb2FkKTsgLy8gY2FsbCBoYW5kbGVMb2FkIHdoZW4gZWFjaCBzb3VuZCBsb2Fkc1xuXHQgKlx0Y3JlYXRlanMuU291bmQucmVnaXN0ZXJTb3VuZHMoc291bmRzLCBhc3NldFBhdGgpO1xuXHQgKlx0Ly8gLi4uXG5cdCAqXHRjcmVhdGVqcy5Tb3VuZC5wbGF5KFwibXlQYXRoL215U291bmQub2dnXCIpOyAvLyB3b3JrcyByZWdhcmRsZXNzIG9mIHdoYXQgZXh0ZW5zaW9uIGlzIHN1cHBvcnRlZC4gIE5vdGUgY2FsbGluZyB3aXRoIElEIGlzIGEgYmV0dGVyIGFwcHJvYWNoXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBhbHRlcm5hdGVFeHRlbnNpb25zXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQHNpbmNlIDAuNS4yXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuYWx0ZXJuYXRlRXh0ZW5zaW9ucyA9IFtdO1xuXG5cdC8qKlxuXHQgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBwbHVnaW4uIElmIHRoaXMgaXMgbnVsbCwgdGhlbiBubyBwbHVnaW4gY291bGQgYmUgaW5pdGlhbGl6ZWQuIElmIG5vIHBsdWdpbiB3YXMgc3BlY2lmaWVkLFxuXHQgKiBTb3VuZCBhdHRlbXB0cyB0byBhcHBseSB0aGUgZGVmYXVsdCBwbHVnaW5zOiB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fSwgZm9sbG93ZWQgYnlcblx0ICoge3sjY3Jvc3NMaW5rIFwiSFRNTEF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAcHJvcGVydHkgYWN0aXZlUGx1Z2luXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gICAgcy5hY3RpdmVQbHVnaW4gPSBudWxsO1xuXG5cbi8vIGNsYXNzIGdldHRlciAvIHNldHRlciBwcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBTZXQgdGhlIG1hc3RlciB2b2x1bWUgb2YgU291bmQuIFRoZSBtYXN0ZXIgdm9sdW1lIGlzIG11bHRpcGxpZWQgYWdhaW5zdCBlYWNoIHNvdW5kJ3MgaW5kaXZpZHVhbCB2b2x1bWUuICBGb3Jcblx0ICogZXhhbXBsZSwgaWYgbWFzdGVyIHZvbHVtZSBpcyAwLjUgYW5kIGEgc291bmQncyB2b2x1bWUgaXMgMC41LCB0aGUgcmVzdWx0aW5nIHZvbHVtZSBpcyAwLjI1LiBUbyBzZXQgaW5kaXZpZHVhbFxuXHQgKiBzb3VuZCB2b2x1bWUsIHVzZSBBYnN0cmFjdFNvdW5kSW5zdGFuY2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3ZvbHVtZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICBjcmVhdGVqcy5Tb3VuZC52b2x1bWUgPSAwLjU7XG5cdCAqXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSB2b2x1bWVcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQGRlZmF1bHQgMVxuXHQgKiBAc2luY2UgMC42LjFcblx0ICovXG5cdHMuX21hc3RlclZvbHVtZSA9IDE7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLCBcInZvbHVtZVwiLCB7XG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7cmV0dXJuIHRoaXMuX21hc3RlclZvbHVtZTt9LFxuXHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGlmIChOdW1iZXIodmFsdWUpID09IG51bGwpIHtyZXR1cm4gZmFsc2U7fVxuXHRcdFx0XHR2YWx1ZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHZhbHVlKSk7XG5cdFx0XHRcdHMuX21hc3RlclZvbHVtZSA9IHZhbHVlO1xuXHRcdFx0XHRpZiAoIXRoaXMuYWN0aXZlUGx1Z2luIHx8ICF0aGlzLmFjdGl2ZVBsdWdpbi5zZXRWb2x1bWUgfHwgIXRoaXMuYWN0aXZlUGx1Z2luLnNldFZvbHVtZSh2YWx1ZSkpIHtcblx0XHRcdFx0XHR2YXIgaW5zdGFuY2VzID0gdGhpcy5faW5zdGFuY2VzO1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gaW5zdGFuY2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0aW5zdGFuY2VzW2ldLnNldE1hc3RlclZvbHVtZSh2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBNdXRlL1VubXV0ZSBhbGwgYXVkaW8uIE5vdGUgdGhhdCBtdXRlZCBhdWRpbyBzdGlsbCBwbGF5cyBhdCAwIHZvbHVtZS4gVGhpcyBnbG9iYWwgbXV0ZSB2YWx1ZSBpcyBtYWludGFpbmVkXG5cdCAqIHNlcGFyYXRlbHkgYW5kIHdoZW4gc2V0IHdpbGwgb3ZlcnJpZGUsIGJ1dCBub3QgY2hhbmdlIHRoZSBtdXRlIHByb3BlcnR5IG9mIGluZGl2aWR1YWwgaW5zdGFuY2VzLiBUbyBtdXRlIGFuIGluZGl2aWR1YWxcblx0ICogaW5zdGFuY2UsIHVzZSBBYnN0cmFjdFNvdW5kSW5zdGFuY2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL211dGVkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgIGNyZWF0ZWpzLlNvdW5kLm11dGVkID0gdHJ1ZTtcblx0ICpcblx0ICpcblx0ICogQHByb3BlcnR5IG11dGVkXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAZGVmYXVsdCBmYWxzZVxuXHQgKiBAc2luY2UgMC42LjFcblx0ICovXG5cdHMuX21hc3Rlck11dGUgPSBmYWxzZTtcblx0Ly8gT0pSIHJlZmVyZW5jZXMgdG8gdGhlIG1ldGhvZHMgd2VyZSBub3Qgd29ya2luZywgc28gdGhlIGNvZGUgaGFkIHRvIGJlIGR1cGxpY2F0ZWQgaGVyZVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkocywgXCJtdXRlZFwiLCB7XG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7cmV0dXJuIHRoaXMuX21hc3Rlck11dGU7fSxcblx0XHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRpZiAodmFsdWUgPT0gbnVsbCkge3JldHVybiBmYWxzZTt9XG5cblx0XHRcdFx0dGhpcy5fbWFzdGVyTXV0ZSA9IHZhbHVlO1xuXHRcdFx0XHRpZiAoIXRoaXMuYWN0aXZlUGx1Z2luIHx8ICF0aGlzLmFjdGl2ZVBsdWdpbi5zZXRNdXRlIHx8ICF0aGlzLmFjdGl2ZVBsdWdpbi5zZXRNdXRlKHZhbHVlKSkge1xuXHRcdFx0XHRcdHZhciBpbnN0YW5jZXMgPSB0aGlzLl9pbnN0YW5jZXM7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBpbnN0YW5jZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpbnN0YW5jZXNbaV0uc2V0TWFzdGVyTXV0ZSh2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogR2V0IHRoZSBhY3RpdmUgcGx1Z2lucyBjYXBhYmlsaXRpZXMsIHdoaWNoIGhlbHAgZGV0ZXJtaW5lIGlmIGEgcGx1Z2luIGNhbiBiZSB1c2VkIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LFxuXHQgKiBvciBpZiB0aGUgcGx1Z2luIHN1cHBvcnRzIGEgc3BlY2lmaWMgZmVhdHVyZS4gQ2FwYWJpbGl0aWVzIGluY2x1ZGU6XG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT48Yj5wYW5uaW5nOjwvYj4gSWYgdGhlIHBsdWdpbiBjYW4gcGFuIGF1ZGlvIGZyb20gbGVmdCB0byByaWdodDwvbGk+XG5cdCAqICAgICA8bGk+PGI+dm9sdW1lOzwvYj4gSWYgdGhlIHBsdWdpbiBjYW4gY29udHJvbCBhdWRpbyB2b2x1bWUuPC9saT5cblx0ICogICAgIDxsaT48Yj50cmFja3M6PC9iPiBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXVkaW8gdHJhY2tzIHRoYXQgY2FuIGJlIHBsYXllZCBiYWNrIGF0IGEgdGltZS4gVGhpcyB3aWxsIGJlIC0xXG5cdCAqICAgICBpZiB0aGVyZSBpcyBubyBrbm93biBsaW1pdC48L2xpPlxuXHQgKiA8YnIgLz5BbiBlbnRyeSBmb3IgZWFjaCBmaWxlIHR5cGUgaW4ge3sjY3Jvc3NMaW5rIFwiU291bmQvU1VQUE9SVEVEX0VYVEVOU0lPTlM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06XG5cdCAqICAgICA8bGk+PGI+bXAzOjwvYj4gSWYgTVAzIGF1ZGlvIGlzIHN1cHBvcnRlZC48L2xpPlxuXHQgKiAgICAgPGxpPjxiPm9nZzo8L2I+IElmIE9HRyBhdWRpbyBpcyBzdXBwb3J0ZWQuPC9saT5cblx0ICogICAgIDxsaT48Yj53YXY6PC9iPiBJZiBXQVYgYXVkaW8gaXMgc3VwcG9ydGVkLjwvbGk+XG5cdCAqICAgICA8bGk+PGI+bXBlZzo8L2I+IElmIE1QRUcgYXVkaW8gaXMgc3VwcG9ydGVkLjwvbGk+XG5cdCAqICAgICA8bGk+PGI+bTRhOjwvYj4gSWYgTTRBIGF1ZGlvIGlzIHN1cHBvcnRlZC48L2xpPlxuXHQgKiAgICAgPGxpPjxiPm1wNDo8L2I+IElmIE1QNCBhdWRpbyBpcyBzdXBwb3J0ZWQuPC9saT5cblx0ICogICAgIDxsaT48Yj5haWZmOjwvYj4gSWYgYWlmZiBhdWRpbyBpcyBzdXBwb3J0ZWQuPC9saT5cblx0ICogICAgIDxsaT48Yj53bWE6PC9iPiBJZiB3bWEgYXVkaW8gaXMgc3VwcG9ydGVkLjwvbGk+XG5cdCAqICAgICA8bGk+PGI+bWlkOjwvYj4gSWYgbWlkIGF1ZGlvIGlzIHN1cHBvcnRlZC48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiBZb3UgY2FuIGdldCBhIHNwZWNpZmljIGNhcGFiaWxpdHkgb2YgdGhlIGFjdGl2ZSBwbHVnaW4gdXNpbmcgc3RhbmRhcmQgb2JqZWN0IG5vdGF0aW9uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgbXAzID0gY3JlYXRlanMuU291bmQuY2FwYWJpbGl0aWVzLm1wMztcblx0ICpcblx0ICogTm90ZSB0aGlzIHByb3BlcnR5IGlzIHJlYWQgb25seS5cblx0ICpcblx0ICogQHByb3BlcnR5IGNhcGFiaWxpdGllc1xuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKiBAc3RhdGljXG5cdCAqIEByZWFkT25seVxuXHQgKiBAc2luY2UgMC42LjFcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLCBcImNhcGFiaWxpdGllc1wiLCB7XG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0aWYgKHMuYWN0aXZlUGx1Z2luID09IG51bGwpIHtyZXR1cm4gbnVsbDt9XG5cdFx0XHRcdFx0cmV0dXJuIHMuYWN0aXZlUGx1Z2luLl9jYXBhYmlsaXRpZXM7XG5cdFx0XHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGZhbHNlO31cblx0fSk7XG5cblxuLy8gQ2xhc3MgUHJpdmF0ZSBwcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBwbHVnaW5zIGhhdmUgYmVlbiByZWdpc3RlcmVkLiBJZiBmYWxzZSwgdGhlIGZpcnN0IGNhbGwgdG8gcGxheSgpIHdpbGwgaW5zdGFudGlhdGUgdGhlIGRlZmF1bHRcblx0ICogcGx1Z2lucyAoe3sjY3Jvc3NMaW5rIFwiV2ViQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0sIGZvbGxvd2VkIGJ5IHt7I2Nyb3NzTGluayBcIkhUTUxBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fSkuXG5cdCAqIElmIHBsdWdpbnMgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQsIGJ1dCBub25lIGFyZSBhcHBsaWNhYmxlLCB0aGVuIHNvdW5kIHBsYXliYWNrIHdpbGwgZmFpbC5cblx0ICogQHByb3BlcnR5IF9wbHVnaW5zUmVnaXN0ZXJlZFxuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzLl9wbHVnaW5zUmVnaXN0ZXJlZCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBVc2VkIGludGVybmFsbHkgdG8gYXNzaWduIHVuaXF1ZSBJRHMgdG8gZWFjaCBBYnN0cmFjdFNvdW5kSW5zdGFuY2UuXG5cdCAqIEBwcm9wZXJ0eSBfbGFzdElEXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cy5fbGFzdElEID0gMDtcblxuXHQvKipcblx0ICogQW4gYXJyYXkgY29udGFpbmluZyBhbGwgY3VycmVudGx5IHBsYXlpbmcgaW5zdGFuY2VzLiBUaGlzIGFsbG93cyBTb3VuZCB0byBjb250cm9sIHRoZSB2b2x1bWUsIG11dGUsIGFuZCBwbGF5YmFjayBvZlxuXHQgKiBhbGwgaW5zdGFuY2VzIHdoZW4gdXNpbmcgc3RhdGljIEFQSXMgbGlrZSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9zdG9wXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJTb3VuZC9zZXRWb2x1bWVcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFdoZW4gYW4gaW5zdGFuY2UgaGFzIGZpbmlzaGVkIHBsYXliYWNrLCBpdCBnZXRzIHJlbW92ZWQgdmlhIHRoZSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9maW5pc2hlZFBsYXlpbmdcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLiBJZiB0aGUgdXNlciByZXBsYXlzIGFuIGluc3RhbmNlLCBpdCBnZXRzIGFkZGVkIGJhY2sgaW4gdmlhIHRoZSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9fYmVnaW5QbGF5aW5nXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZC5cblx0ICogQHByb3BlcnR5IF9pbnN0YW5jZXNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuX2luc3RhbmNlcyA9IFtdO1xuXG5cdC8qKlxuXHQgKiBBbiBvYmplY3QgaGFzaCBzdG9yaW5nIG9iamVjdHMgd2l0aCBzb3VuZCBzb3VyY2VzLCBzdGFydFRpbWUsIGFuZCBkdXJhdGlvbiB2aWEgdGhlcmUgY29ycmVzcG9uZGluZyBJRC5cblx0ICogQHByb3BlcnR5IF9pZEhhc2hcblx0ICogQHR5cGUge09iamVjdH1cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLl9pZEhhc2ggPSB7fTtcblxuXHQvKipcblx0ICogQW4gb2JqZWN0IGhhc2ggdGhhdCBzdG9yZXMgcHJlbG9hZGluZyBzb3VuZCBzb3VyY2VzIHZpYSB0aGUgcGFyc2VkIHNvdXJjZSB0aGF0IGlzIHBhc3NlZCB0byB0aGUgcGx1Z2luLiAgQ29udGFpbnMgdGhlXG5cdCAqIHNvdXJjZSwgaWQsIGFuZCBkYXRhIHRoYXQgd2FzIHBhc3NlZCBpbiBieSB0aGUgdXNlci4gIFBhcnNlZCBzb3VyY2VzIGNhbiBjb250YWluIG11bHRpcGxlIGluc3RhbmNlcyBvZiBzb3VyY2UsIGlkLFxuXHQgKiBhbmQgZGF0YS5cblx0ICogQHByb3BlcnR5IF9wcmVsb2FkSGFzaFxuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuX3ByZWxvYWRIYXNoID0ge307XG5cblx0LyoqXG5cdCAqIEFuIG9iamVjdCBoYXNoIHN0b3Jpbmcge3sjY3Jvc3NMaW5rIFwiUGxheVByb3BzQ29uZmlnXCJ9fXt7L2Nyb3NzTGlua319IHZpYSB0aGUgcGFyc2VkIHNvdXJjZSB0aGF0IGlzIHBhc3NlZCBhcyBkZWZhdWx0UGxheVByb3BzIGluXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNvdW5kL3JlZ2lzdGVyU291bmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlNvdW5kL3JlZ2lzdGVyU291bmRzXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAcHJvcGVydHkgX2RlZmF1bHRQbGF5UHJvcHNIYXNoXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjFcblx0ICovXG5cdHMuX2RlZmF1bHRQbGF5UHJvcHNIYXNoID0ge307XG5cblxuLy8gRXZlbnREaXNwYXRjaGVyIG1ldGhvZHM6XG5cdHMuYWRkRXZlbnRMaXN0ZW5lciA9IG51bGw7XG5cdHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IG51bGw7XG5cdHMucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMgPSBudWxsO1xuXHRzLmRpc3BhdGNoRXZlbnQgPSBudWxsO1xuXHRzLmhhc0V2ZW50TGlzdGVuZXIgPSBudWxsO1xuXHRzLl9saXN0ZW5lcnMgPSBudWxsO1xuXG5cdGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplKHMpOyAvLyBpbmplY3QgRXZlbnREaXNwYXRjaGVyIG1ldGhvZHMuXG5cblxuLy8gRXZlbnRzXG5cdC8qKlxuXHQgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gYSBmaWxlIGZpbmlzaGVzIGxvYWRpbmcgaW50ZXJuYWxseS4gVGhpcyBldmVudCBpcyBmaXJlZCBmb3IgZWFjaCBsb2FkZWQgc291bmQsXG5cdCAqIHNvIGFueSBoYW5kbGVyIG1ldGhvZHMgc2hvdWxkIGxvb2sgdXAgdGhlIDxjb2RlPmV2ZW50LnNyYzwvY29kZT4gdG8gaGFuZGxlIGEgcGFydGljdWxhciBzb3VuZC5cblx0ICogQGV2ZW50IGZpbGVsb2FkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291cmNlIG9mIHRoZSBzb3VuZCB0aGF0IHdhcyBsb2FkZWQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbaWRdIFRoZSBpZCBwYXNzZWQgaW4gd2hlbiB0aGUgc291bmQgd2FzIHJlZ2lzdGVyZWQuIElmIG9uZSB3YXMgbm90IHByb3ZpZGVkLCBpdCB3aWxsIGJlIG51bGwuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gW2RhdGFdIEFueSBhZGRpdGlvbmFsIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBpdGVtLiBJZiBub3QgcHJvdmlkZWQsIGl0IHdpbGwgYmUgdW5kZWZpbmVkLlxuXHQgKiBAc2luY2UgMC40LjFcblx0ICovXG5cblx0LyoqXG5cdCAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIGZpbGUgZmFpbHMgbG9hZGluZyBpbnRlcm5hbGx5LiBUaGlzIGV2ZW50IGlzIGZpcmVkIGZvciBlYWNoIGxvYWRlZCBzb3VuZCxcblx0ICogc28gYW55IGhhbmRsZXIgbWV0aG9kcyBzaG91bGQgbG9vayB1cCB0aGUgPGNvZGU+ZXZlbnQuc3JjPC9jb2RlPiB0byBoYW5kbGUgYSBwYXJ0aWN1bGFyIHNvdW5kLlxuXHQgKiBAZXZlbnQgZmlsZWVycm9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291cmNlIG9mIHRoZSBzb3VuZCB0aGF0IHdhcyBsb2FkZWQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbaWRdIFRoZSBpZCBwYXNzZWQgaW4gd2hlbiB0aGUgc291bmQgd2FzIHJlZ2lzdGVyZWQuIElmIG9uZSB3YXMgbm90IHByb3ZpZGVkLCBpdCB3aWxsIGJlIG51bGwuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gW2RhdGFdIEFueSBhZGRpdGlvbmFsIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBpdGVtLiBJZiBub3QgcHJvdmlkZWQsIGl0IHdpbGwgYmUgdW5kZWZpbmVkLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblxuLy8gQ2xhc3MgUHVibGljIE1ldGhvZHNcblx0LyoqXG5cdCAqIEdldCB0aGUgcHJlbG9hZCBydWxlcyB0byBhbGxvdyBTb3VuZCB0byBiZSB1c2VkIGFzIGEgcGx1Z2luIGJ5IDxhIGhyZWY9XCJodHRwOi8vcHJlbG9hZGpzLmNvbVwiIHRhcmdldD1cIl9ibGFua1wiPlByZWxvYWRKUzwvYT4uXG5cdCAqIEFueSBsb2FkIGNhbGxzIHRoYXQgaGF2ZSB0aGUgbWF0Y2hpbmcgdHlwZSBvciBleHRlbnNpb24gd2lsbCBmaXJlIHRoZSBjYWxsYmFjayBtZXRob2QsIGFuZCB1c2UgdGhlIHJlc3VsdGluZ1xuXHQgKiBvYmplY3QsIHdoaWNoIGlzIHBvdGVudGlhbGx5IG1vZGlmaWVkIGJ5IFNvdW5kLiBUaGlzIGhlbHBzIHdoZW4gZGV0ZXJtaW5pbmcgdGhlIGNvcnJlY3QgcGF0aCwgYXMgd2VsbCBhc1xuXHQgKiByZWdpc3RlcmluZyB0aGUgYXVkaW8gaW5zdGFuY2Uocykgd2l0aCBTb3VuZC4gVGhpcyBtZXRob2Qgc2hvdWxkIG5vdCBiZSBjYWxsZWQsIGV4Y2VwdCBieSBQcmVsb2FkSlMuXG5cdCAqIEBtZXRob2QgZ2V0UHJlbG9hZEhhbmRsZXJzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmc6XG5cdCAqIDx1bD48bGk+Y2FsbGJhY2s6IEEgcHJlbG9hZCBjYWxsYmFjayB0aGF0IGlzIGZpcmVkIHdoZW4gYSBmaWxlIGlzIGFkZGVkIHRvIFByZWxvYWRKUywgd2hpY2ggcHJvdmlkZXNcblx0ICogICAgICBTb3VuZCBhIG1lY2hhbmlzbSB0byBtb2RpZnkgdGhlIGxvYWQgcGFyYW1ldGVycywgc2VsZWN0IHRoZSBjb3JyZWN0IGZpbGUgZm9ybWF0LCByZWdpc3RlciB0aGUgc291bmQsIGV0Yy48L2xpPlxuXHQgKiAgICAgIDxsaT50eXBlczogQSBsaXN0IG9mIGZpbGUgdHlwZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGJ5IFNvdW5kIChjdXJyZW50bHkgc3VwcG9ydHMgXCJzb3VuZFwiKS48L2xpPlxuXHQgKiAgICAgIDxsaT5leHRlbnNpb25zOiBBIGxpc3Qgb2YgZmlsZSBleHRlbnNpb25zIHRoYXQgYXJlIHN1cHBvcnRlZCBieSBTb3VuZCAoc2VlIHt7I2Nyb3NzTGluayBcIlNvdW5kL1NVUFBPUlRFRF9FWFRFTlNJT05TOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319KS48L2xpPjwvdWw+XG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cy5nZXRQcmVsb2FkSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGNhbGxiYWNrOmNyZWF0ZWpzLnByb3h5KHMuaW5pdExvYWQsIHMpLFxuXHRcdFx0dHlwZXM6W1wic291bmRcIl0sXG5cdFx0XHRleHRlbnNpb25zOnMuU1VQUE9SVEVEX0VYVEVOU0lPTlNcblx0XHR9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2VkIHRvIGRpc3BhdGNoIGZpbGVsb2FkIGV2ZW50cyBmcm9tIGludGVybmFsIGxvYWRpbmcuXG5cdCAqIEBtZXRob2QgX2hhbmRsZUxvYWRDb21wbGV0ZVxuXHQgKiBAcGFyYW0gZXZlbnQgQSBsb2FkZXIgZXZlbnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuX2hhbmRsZUxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHNyYyA9IGV2ZW50LnRhcmdldC5nZXRJdGVtKCkuc3JjO1xuXHRcdGlmICghcy5fcHJlbG9hZEhhc2hbc3JjXSkge3JldHVybjt9XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHMuX3ByZWxvYWRIYXNoW3NyY10ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHMuX3ByZWxvYWRIYXNoW3NyY11baV07XG5cdFx0XHRzLl9wcmVsb2FkSGFzaFtzcmNdW2ldID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCFzLmhhc0V2ZW50TGlzdGVuZXIoXCJmaWxlbG9hZFwiKSkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJmaWxlbG9hZFwiKTtcblx0XHRcdGV2ZW50LnNyYyA9IGl0ZW0uc3JjO1xuXHRcdFx0ZXZlbnQuaWQgPSBpdGVtLmlkO1xuXHRcdFx0ZXZlbnQuZGF0YSA9IGl0ZW0uZGF0YTtcblx0XHRcdGV2ZW50LnNwcml0ZSA9IGl0ZW0uc3ByaXRlO1xuXG5cdFx0XHRzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVXNlZCB0byBkaXNwYXRjaCBlcnJvciBldmVudHMgZnJvbSBpbnRlcm5hbCBwcmVsb2FkaW5nLlxuXHQgKiBAcGFyYW0gZXZlbnRcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5faGFuZGxlTG9hZEVycm9yID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgc3JjID0gZXZlbnQudGFyZ2V0LmdldEl0ZW0oKS5zcmM7XG5cdFx0aWYgKCFzLl9wcmVsb2FkSGFzaFtzcmNdKSB7cmV0dXJuO31cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gcy5fcHJlbG9hZEhhc2hbc3JjXS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gcy5fcHJlbG9hZEhhc2hbc3JjXVtpXTtcblx0XHRcdHMuX3ByZWxvYWRIYXNoW3NyY11baV0gPSBmYWxzZTtcblxuXHRcdFx0aWYgKCFzLmhhc0V2ZW50TGlzdGVuZXIoXCJmaWxlZXJyb3JcIikpIHsgY29udGludWU7IH1cblxuXHRcdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiZmlsZWVycm9yXCIpO1xuXHRcdFx0ZXZlbnQuc3JjID0gaXRlbS5zcmM7XG5cdFx0XHRldmVudC5pZCA9IGl0ZW0uaWQ7XG5cdFx0XHRldmVudC5kYXRhID0gaXRlbS5kYXRhO1xuXHRcdFx0ZXZlbnQuc3ByaXRlID0gaXRlbS5zcHJpdGU7XG5cblx0XHRcdHMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2VkIGJ5IHt7I2Nyb3NzTGluayBcIlNvdW5kL3JlZ2lzdGVyUGx1Z2luc1wifX17ey9jcm9zc0xpbmt9fSB0byByZWdpc3RlciBhIFNvdW5kIHBsdWdpbi5cblx0ICpcblx0ICogQG1ldGhvZCBfcmVnaXN0ZXJQbHVnaW5cblx0ICogQHBhcmFtIHtPYmplY3R9IHBsdWdpbiBUaGUgcGx1Z2luIGNsYXNzIHRvIGluc3RhbGwuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHBsdWdpbiB3YXMgc3VjY2Vzc2Z1bGx5IGluaXRpYWxpemVkLlxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzLl9yZWdpc3RlclBsdWdpbiA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcblx0XHQvLyBOb3RlOiBFYWNoIHBsdWdpbiBpcyBwYXNzZWQgaW4gYXMgYSBjbGFzcyByZWZlcmVuY2UsIGJ1dCB3ZSBzdG9yZSB0aGUgYWN0aXZlUGx1Z2luIGFzIGFuIGluc3RhbmNlXG5cdFx0aWYgKHBsdWdpbi5pc1N1cHBvcnRlZCgpKSB7XG5cdFx0XHRzLmFjdGl2ZVBsdWdpbiA9IG5ldyBwbHVnaW4oKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVyIGEgbGlzdCBvZiBTb3VuZCBwbHVnaW5zLCBpbiBvcmRlciBvZiBwcmVjZWRlbmNlLiBUbyByZWdpc3RlciBhIHNpbmdsZSBwbHVnaW4sIHBhc3MgYSBzaW5nbGUgZWxlbWVudCBpbiB0aGUgYXJyYXkuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5GbGFzaEF1ZGlvUGx1Z2luLnN3ZlBhdGggPSBcIi4uL3NyYy9zb3VuZGpzL2ZsYXNoYXVkaW8vXCI7XG5cdCAqICAgICAgY3JlYXRlanMuU291bmQucmVnaXN0ZXJQbHVnaW5zKFtjcmVhdGVqcy5XZWJBdWRpb1BsdWdpbiwgY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLCBjcmVhdGVqcy5GbGFzaEF1ZGlvUGx1Z2luXSk7XG5cdCAqXG5cdCAqIEBtZXRob2QgcmVnaXN0ZXJQbHVnaW5zXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHBsdWdpbnMgQW4gYXJyYXkgb2YgcGx1Z2lucyBjbGFzc2VzIHRvIGluc3RhbGwuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgYSBwbHVnaW4gd2FzIHN1Y2Nlc3NmdWxseSBpbml0aWFsaXplZC5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5yZWdpc3RlclBsdWdpbnMgPSBmdW5jdGlvbiAocGx1Z2lucykge1xuXHRcdHMuX3BsdWdpbnNSZWdpc3RlcmVkID0gdHJ1ZTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBsdWdpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAocy5fcmVnaXN0ZXJQbHVnaW4ocGx1Z2luc1tpXSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCBwbHVnaW5zLiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCB3aGVuIGFueSBhdWRpbyBpcyBwbGF5ZWQgb3IgcmVnaXN0ZXJlZCBiZWZvcmVcblx0ICogdGhlIHVzZXIgaGFzIG1hbnVhbGx5IHJlZ2lzdGVyZWQgcGx1Z2lucywgYW5kIGVuYWJsZXMgU291bmQgdG8gd29yayB3aXRob3V0IG1hbnVhbCBwbHVnaW4gc2V0dXAuIEN1cnJlbnRseSwgdGhlXG5cdCAqIGRlZmF1bHQgcGx1Z2lucyBhcmUge3sjY3Jvc3NMaW5rIFwiV2ViQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0gZm9sbG93ZWQgYnkge3sjY3Jvc3NMaW5rIFwiSFRNTEF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqIFx0aWYgKCFjcmVhdGVqcy5pbml0aWFsaXplRGVmYXVsdFBsdWdpbnMoKSkgeyByZXR1cm47IH1cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplRGVmYXVsdFBsdWdpbnNcblx0ICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgYSBwbHVnaW4gd2FzIGluaXRpYWxpemVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqIEBzaW5jZSAwLjQuMFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmluaXRpYWxpemVEZWZhdWx0UGx1Z2lucyA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAocy5hY3RpdmVQbHVnaW4gIT0gbnVsbCkge3JldHVybiB0cnVlO31cblx0XHRpZiAocy5fcGx1Z2luc1JlZ2lzdGVyZWQpIHtyZXR1cm4gZmFsc2U7fVxuXHRcdGlmIChzLnJlZ2lzdGVyUGx1Z2lucyhbY3JlYXRlanMuV2ViQXVkaW9QbHVnaW4sIGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbl0pKSB7cmV0dXJuIHRydWU7fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiBTb3VuZCBoYXMgYmVlbiBpbml0aWFsaXplZCwgYW5kIGEgcGx1Z2luIGhhcyBiZWVuIGFjdGl2YXRlZC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBUaGlzIGV4YW1wbGUgc2V0cyB1cCBhIEZsYXNoIGZhbGxiYWNrLCBidXQgb25seSBpZiB0aGVyZSBpcyBubyBwbHVnaW4gc3BlY2lmaWVkIHlldC5cblx0ICpcblx0ICogXHRpZiAoIWNyZWF0ZWpzLlNvdW5kLmlzUmVhZHkoKSkge1xuXHQgKlx0XHRjcmVhdGVqcy5GbGFzaEF1ZGlvUGx1Z2luLnN3ZlBhdGggPSBcIi4uL3NyYy9zb3VuZGpzL2ZsYXNoYXVkaW8vXCI7XG5cdCAqIFx0XHRjcmVhdGVqcy5Tb3VuZC5yZWdpc3RlclBsdWdpbnMoW2NyZWF0ZWpzLldlYkF1ZGlvUGx1Z2luLCBjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4sIGNyZWF0ZWpzLkZsYXNoQXVkaW9QbHVnaW5dKTtcblx0ICpcdH1cblx0ICpcblx0ICogQG1ldGhvZCBpc1JlYWR5XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIFNvdW5kIGhhcyBpbml0aWFsaXplZCBhIHBsdWdpbi5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5pc1JlYWR5ID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAocy5hY3RpdmVQbHVnaW4gIT0gbnVsbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERlcHJlY2F0ZWQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiU291bmQvY2FwYWJpbGl0aWVzOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqXG5cdCAqIEBtZXRob2QgZ2V0Q2FwYWJpbGl0aWVzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNhcGFiaWxpdGllcyBvZiB0aGUgYWN0aXZlIHBsdWdpbi5cblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0cy5nZXRDYXBhYmlsaXRpZXMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHMuYWN0aXZlUGx1Z2luID09IG51bGwpIHtyZXR1cm4gbnVsbDt9XG5cdFx0cmV0dXJuIHMuYWN0aXZlUGx1Z2luLl9jYXBhYmlsaXRpZXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIERlcHJlY2F0ZWQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiU291bmQvY2FwYWJpbGl0aWVzOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqXG5cdCAqIEBtZXRob2QgZ2V0Q2FwYWJpbGl0eVxuXHQgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBjYXBhYmlsaXR5IHRvIHJldHJpZXZlXG5cdCAqIEByZXR1cm4ge051bWJlcnxCb29sZWFufSBUaGUgdmFsdWUgb2YgdGhlIGNhcGFiaWxpdHkuXG5cdCAqIEBzdGF0aWNcblx0ICogQHNlZSBnZXRDYXBhYmlsaXRpZXNcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdHMuZ2V0Q2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRpZiAocy5hY3RpdmVQbHVnaW4gPT0gbnVsbCkge3JldHVybiBudWxsO31cblx0XHRyZXR1cm4gcy5hY3RpdmVQbHVnaW4uX2NhcGFiaWxpdGllc1trZXldO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQcm9jZXNzIG1hbmlmZXN0IGl0ZW1zIGZyb20gPGEgaHJlZj1cImh0dHA6Ly9wcmVsb2FkanMuY29tXCIgdGFyZ2V0PVwiX2JsYW5rXCI+UHJlbG9hZEpTPC9hPi4gVGhpcyBtZXRob2QgaXMgaW50ZW5kZWRcblx0ICogZm9yIHVzYWdlIGJ5IGEgcGx1Z2luLCBhbmQgbm90IGZvciBkaXJlY3QgaW50ZXJhY3Rpb24uXG5cdCAqIEBtZXRob2QgaW5pdExvYWRcblx0ICogQHBhcmFtIHtPYmplY3R9IHNyYyBUaGUgb2JqZWN0IHRvIGxvYWQuXG5cdCAqIEByZXR1cm4ge09iamVjdHxBYnN0cmFjdExvYWRlcn0gQW4gaW5zdGFuY2Ugb2YgQWJzdHJhY3RMb2FkZXIuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5pbml0TG9hZCA9IGZ1bmN0aW9uIChsb2FkSXRlbSkge1xuXHRcdHJldHVybiBzLl9yZWdpc3RlclNvdW5kKGxvYWRJdGVtKTtcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgbWV0aG9kIGZvciBsb2FkaW5nIHNvdW5kcy4gIFRoaXMgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZGlyZWN0bHkuXG5cdCAqXG5cdCAqIEBtZXRob2QgX3JlZ2lzdGVyU291bmRcblx0ICogQHBhcmFtIHtPYmplY3R9IHNyYyBUaGUgb2JqZWN0IHRvIGxvYWQsIGNvbnRhaW5pbmcgc3JjIHByb3BlcnR5IGFuZCBvcHRpb25hbGx5IGNvbnRhaW5pbmcgaWQgYW5kIGRhdGEuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIG1vZGlmaWVkIHZhbHVlcyB0aGF0IHdlcmUgcGFzc2VkIGluLCB3aGljaCBkZWZpbmVzIHRoZSBzb3VuZC5cblx0ICogUmV0dXJucyBmYWxzZSBpZiB0aGUgc291cmNlIGNhbm5vdCBiZSBwYXJzZWQgb3Igbm8gcGx1Z2lucyBjYW4gYmUgaW5pdGlhbGl6ZWQuXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc291cmNlIGlzIGFscmVhZHkgbG9hZGVkLlxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHRzLl9yZWdpc3RlclNvdW5kID0gZnVuY3Rpb24gKGxvYWRJdGVtKSB7XG5cdFx0aWYgKCFzLmluaXRpYWxpemVEZWZhdWx0UGx1Z2lucygpKSB7cmV0dXJuIGZhbHNlO31cblxuXHRcdHZhciBkZXRhaWxzO1xuXHRcdGlmIChsb2FkSXRlbS5zcmMgaW5zdGFuY2VvZiBPYmplY3QpIHtcblx0XHRcdGRldGFpbHMgPSBzLl9wYXJzZVNyYyhsb2FkSXRlbS5zcmMpO1xuXHRcdFx0ZGV0YWlscy5zcmMgPSBsb2FkSXRlbS5wYXRoICsgZGV0YWlscy5zcmM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRldGFpbHMgPSBzLl9wYXJzZVBhdGgobG9hZEl0ZW0uc3JjKTtcblx0XHR9XG5cdFx0aWYgKGRldGFpbHMgPT0gbnVsbCkge3JldHVybiBmYWxzZTt9XG5cdFx0bG9hZEl0ZW0uc3JjID0gZGV0YWlscy5zcmM7XG5cdFx0bG9hZEl0ZW0udHlwZSA9IFwic291bmRcIjtcblxuXHRcdHZhciBkYXRhID0gbG9hZEl0ZW0uZGF0YTtcblx0XHR2YXIgbnVtQ2hhbm5lbHMgPSBudWxsO1xuXHRcdGlmIChkYXRhICE9IG51bGwpIHtcblx0XHRcdGlmICghaXNOYU4oZGF0YS5jaGFubmVscykpIHtcblx0XHRcdFx0bnVtQ2hhbm5lbHMgPSBwYXJzZUludChkYXRhLmNoYW5uZWxzKTtcblx0XHRcdH0gZWxzZSBpZiAoIWlzTmFOKGRhdGEpKSB7XG5cdFx0XHRcdG51bUNoYW5uZWxzID0gcGFyc2VJbnQoZGF0YSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKGRhdGEuYXVkaW9TcHJpdGUpIHtcblx0XHRcdFx0dmFyIHNwO1xuXHRcdFx0XHRmb3IodmFyIGkgPSBkYXRhLmF1ZGlvU3ByaXRlLmxlbmd0aDsgaS0tOyApIHtcblx0XHRcdFx0XHRzcCA9IGRhdGEuYXVkaW9TcHJpdGVbaV07XG5cdFx0XHRcdFx0cy5faWRIYXNoW3NwLmlkXSA9IHtzcmM6IGxvYWRJdGVtLnNyYywgc3RhcnRUaW1lOiBwYXJzZUludChzcC5zdGFydFRpbWUpLCBkdXJhdGlvbjogcGFyc2VJbnQoc3AuZHVyYXRpb24pfTtcblxuXHRcdFx0XHRcdGlmIChzcC5kZWZhdWx0UGxheVByb3BzKSB7XG5cdFx0XHRcdFx0XHRzLl9kZWZhdWx0UGxheVByb3BzSGFzaFtzcC5pZF0gPSBjcmVhdGVqcy5QbGF5UHJvcHNDb25maWcuY3JlYXRlKHNwLmRlZmF1bHRQbGF5UHJvcHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobG9hZEl0ZW0uaWQgIT0gbnVsbCkge3MuX2lkSGFzaFtsb2FkSXRlbS5pZF0gPSB7c3JjOiBsb2FkSXRlbS5zcmN9fTtcblx0XHR2YXIgbG9hZGVyID0gcy5hY3RpdmVQbHVnaW4ucmVnaXN0ZXIobG9hZEl0ZW0pO1xuXG5cdFx0U291bmRDaGFubmVsLmNyZWF0ZShsb2FkSXRlbS5zcmMsIG51bUNoYW5uZWxzKTtcblxuXHRcdC8vIHJldHVybiB0aGUgbnVtYmVyIG9mIGluc3RhbmNlcyB0byB0aGUgdXNlci4gIFRoaXMgd2lsbCBhbHNvIGJlIHJldHVybmVkIGluIHRoZSBsb2FkIGV2ZW50LlxuXHRcdGlmIChkYXRhID09IG51bGwgfHwgIWlzTmFOKGRhdGEpKSB7XG5cdFx0XHRsb2FkSXRlbS5kYXRhID0gbnVtQ2hhbm5lbHMgfHwgU291bmRDaGFubmVsLm1heFBlckNoYW5uZWwoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bG9hZEl0ZW0uZGF0YS5jaGFubmVscyA9IG51bUNoYW5uZWxzIHx8IFNvdW5kQ2hhbm5lbC5tYXhQZXJDaGFubmVsKCk7XG5cdFx0fVxuXG5cdFx0aWYgKGxvYWRlci50eXBlKSB7bG9hZEl0ZW0udHlwZSA9IGxvYWRlci50eXBlO31cblxuXHRcdGlmIChsb2FkSXRlbS5kZWZhdWx0UGxheVByb3BzKSB7XG5cdFx0XHRzLl9kZWZhdWx0UGxheVByb3BzSGFzaFtsb2FkSXRlbS5zcmNdID0gY3JlYXRlanMuUGxheVByb3BzQ29uZmlnLmNyZWF0ZShsb2FkSXRlbS5kZWZhdWx0UGxheVByb3BzKTtcblx0XHR9XG5cdFx0cmV0dXJuIGxvYWRlcjtcblx0fTtcblxuXHQvKipcblx0ICogUmVnaXN0ZXIgYW4gYXVkaW8gZmlsZSBmb3IgbG9hZGluZyBhbmQgZnV0dXJlIHBsYXliYWNrIGluIFNvdW5kLiBUaGlzIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIHdoZW4gdXNpbmdcblx0ICogPGEgaHJlZj1cImh0dHA6Ly9wcmVsb2FkanMuY29tXCIgdGFyZ2V0PVwiX2JsYW5rXCI+UHJlbG9hZEpTPC9hPi4gIEl0IGlzIHJlY29tbWVuZGVkIHRvIHJlZ2lzdGVyIGFsbCBzb3VuZHMgdGhhdFxuXHQgKiBuZWVkIHRvIGJlIHBsYXllZCBiYWNrIGluIG9yZGVyIHRvIHByb3Blcmx5IHByZXBhcmUgYW5kIHByZWxvYWQgdGhlbS4gU291bmQgZG9lcyBpbnRlcm5hbCBwcmVsb2FkaW5nIHdoZW4gcmVxdWlyZWQuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5hbHRlcm5hdGVFeHRlbnNpb25zID0gW1wibXAzXCJdO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLm9uKFwiZmlsZWxvYWRcIiwgaGFuZGxlTG9hZCk7IC8vIGFkZCBhbiBldmVudCBsaXN0ZW5lciBmb3Igd2hlbiBsb2FkIGlzIGNvbXBsZXRlZFxuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLnJlZ2lzdGVyU291bmQoXCJteUF1ZGlvUGF0aC9teVNvdW5kLm9nZ1wiLCBcIm15SURcIiwgMyk7XG5cdCAqICAgICAgY3JlYXRlanMuU291bmQucmVnaXN0ZXJTb3VuZCh7b2dnOlwicGF0aDEvbXlTb3VuZC5vZ2dcIiwgbXAzOlwicGF0aDIvbXlTb3VuZE5vRXh0ZW5zaW9uXCJ9LCBcIm15SURcIiwgMyk7XG5cdCAqXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVnaXN0ZXJTb3VuZFxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE9iamVjdH0gc3JjIFRoZSBzb3VyY2Ugb3IgYW4gT2JqZWN0IHdpdGggYSBcInNyY1wiIHByb3BlcnR5IG9yIGFuIE9iamVjdCB3aXRoIG11bHRpcGxlIGV4dGVuc2lvbiBsYWJlbGVkIHNyYyBwcm9wZXJ0aWVzLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2lkXSBBbiBpZCBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgdG8gcGxheSB0aGUgc291bmQgbGF0ZXIuICBOb3RlIGlkIGlzIHJlcXVpcmVkIGZvciB3aGVuIHNyYyBpcyBtdWx0aXBsZSBleHRlbnNpb24gbGFiZWxlZCBzcmMgcHJvcGVydGllcy5cblx0ICogQHBhcmFtIHtOdW1iZXIgfCBPYmplY3R9IFtkYXRhXSBEYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgaXRlbS4gU291bmQgdXNlcyB0aGUgZGF0YSBwYXJhbWV0ZXIgYXMgdGhlIG51bWJlciBvZlxuXHQgKiBjaGFubmVscyBmb3IgYW4gYXVkaW8gaW5zdGFuY2UsIGhvd2V2ZXIgYSBcImNoYW5uZWxzXCIgcHJvcGVydHkgY2FuIGJlIGFwcGVuZGVkIHRvIHRoZSBkYXRhIG9iamVjdCBpZiBpdCBpcyB1c2VkXG5cdCAqIGZvciBvdGhlciBpbmZvcm1hdGlvbi4gVGhlIGF1ZGlvIGNoYW5uZWxzIHdpbGwgc2V0IGEgZGVmYXVsdCBiYXNlZCBvbiBwbHVnaW4gaWYgbm8gdmFsdWUgaXMgZm91bmQuXG5cdCAqIFNvdW5kIGFsc28gdXNlcyB0aGUgZGF0YSBwcm9wZXJ0eSB0byBob2xkIGFuIHt7I2Nyb3NzTGluayBcIkF1ZGlvU3ByaXRlXCJ9fXt7L2Nyb3NzTGlua319IGFycmF5IG9mIG9iamVjdHMgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQge2lkLCBzdGFydFRpbWUsIGR1cmF0aW9ufS48YnIvPlxuXHQgKiAgIGlkIHVzZWQgdG8gcGxheSB0aGUgc291bmQgbGF0ZXIsIGluIHRoZSBzYW1lIG1hbm5lciBhcyBhIHNvdW5kIHNyYyB3aXRoIGFuIGlkLjxici8+XG5cdCAqICAgc3RhcnRUaW1lIGlzIHRoZSBpbml0aWFsIG9mZnNldCB0byBzdGFydCBwbGF5YmFjayBhbmQgbG9vcCBmcm9tLCBpbiBtaWxsaXNlY29uZHMuPGJyLz5cblx0ICogICBkdXJhdGlvbiBpcyB0aGUgYW1vdW50IG9mIHRpbWUgdG8gcGxheSB0aGUgY2xpcCBmb3IsIGluIG1pbGxpc2Vjb25kcy48YnIvPlxuXHQgKiBUaGlzIGFsbG93cyBTb3VuZCB0byBzdXBwb3J0IGF1ZGlvIHNwcml0ZXMgdGhhdCBhcmUgcGxheWVkIGJhY2sgYnkgaWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlUGF0aCBTZXQgYSBwYXRoIHRoYXQgd2lsbCBiZSBwcmVwZW5kZWQgdG8gc3JjIGZvciBsb2FkaW5nLlxuXHQgKiBAcGFyYW0ge09iamVjdCB8IFBsYXlQcm9wc0NvbmZpZ30gZGVmYXVsdFBsYXlQcm9wcyBPcHRpb25hbCBQbGF5YmFjayBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBzZXQgYXMgdGhlIGRlZmF1bHRzIG9uIGFueSBuZXcgQWJzdHJhY3RTb3VuZEluc3RhbmNlLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiUGxheVByb3BzQ29uZmlnXCJ9fXt7L2Nyb3NzTGlua319IGZvciBvcHRpb25zLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHRoZSBtb2RpZmllZCB2YWx1ZXMgdGhhdCB3ZXJlIHBhc3NlZCBpbiwgd2hpY2ggZGVmaW5lcyB0aGUgc291bmQuXG5cdCAqIFJldHVybnMgZmFsc2UgaWYgdGhlIHNvdXJjZSBjYW5ub3QgYmUgcGFyc2VkIG9yIG5vIHBsdWdpbnMgY2FuIGJlIGluaXRpYWxpemVkLlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNvdXJjZSBpcyBhbHJlYWR5IGxvYWRlZC5cblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC40LjBcblx0ICovXG5cdHMucmVnaXN0ZXJTb3VuZCA9IGZ1bmN0aW9uIChzcmMsIGlkLCBkYXRhLCBiYXNlUGF0aCwgZGVmYXVsdFBsYXlQcm9wcykge1xuXHRcdHZhciBsb2FkSXRlbSA9IHtzcmM6IHNyYywgaWQ6IGlkLCBkYXRhOmRhdGEsIGRlZmF1bHRQbGF5UHJvcHM6ZGVmYXVsdFBsYXlQcm9wc307XG5cdFx0aWYgKHNyYyBpbnN0YW5jZW9mIE9iamVjdCAmJiBzcmMuc3JjKSB7XG5cdFx0XHRiYXNlUGF0aCA9IGlkO1xuXHRcdFx0bG9hZEl0ZW0gPSBzcmM7XG5cdFx0fVxuXHRcdGxvYWRJdGVtID0gY3JlYXRlanMuTG9hZEl0ZW0uY3JlYXRlKGxvYWRJdGVtKTtcblx0XHRsb2FkSXRlbS5wYXRoID0gYmFzZVBhdGg7XG5cblx0XHRpZiAoYmFzZVBhdGggIT0gbnVsbCAmJiAhKGxvYWRJdGVtLnNyYyBpbnN0YW5jZW9mIE9iamVjdCkpIHtsb2FkSXRlbS5zcmMgPSBiYXNlUGF0aCArIHNyYzt9XG5cblx0XHR2YXIgbG9hZGVyID0gcy5fcmVnaXN0ZXJTb3VuZChsb2FkSXRlbSk7XG5cdFx0aWYoIWxvYWRlcikge3JldHVybiBmYWxzZTt9XG5cblx0XHRpZiAoIXMuX3ByZWxvYWRIYXNoW2xvYWRJdGVtLnNyY10pIHsgcy5fcHJlbG9hZEhhc2hbbG9hZEl0ZW0uc3JjXSA9IFtdO31cblx0XHRzLl9wcmVsb2FkSGFzaFtsb2FkSXRlbS5zcmNdLnB1c2gobG9hZEl0ZW0pO1xuXHRcdGlmIChzLl9wcmVsb2FkSGFzaFtsb2FkSXRlbS5zcmNdLmxlbmd0aCA9PSAxKSB7XG5cdFx0XHQvLyBPSlIgbm90ZSB0aGlzIHdpbGwgZGlzYWxsb3cgcmVsb2FkaW5nIGEgc291bmQgaWYgbG9hZGluZyBmYWlscyBvciB0aGUgc291cmNlIGNoYW5nZXNcblx0XHRcdGxvYWRlci5vbihcImNvbXBsZXRlXCIsIGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZUxvYWRDb21wbGV0ZSwgdGhpcykpO1xuXHRcdFx0bG9hZGVyLm9uKFwiZXJyb3JcIiwgY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlTG9hZEVycm9yLCB0aGlzKSk7XG5cdFx0XHRzLmFjdGl2ZVBsdWdpbi5wcmVsb2FkKGxvYWRlcik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChzLl9wcmVsb2FkSGFzaFtsb2FkSXRlbS5zcmNdWzBdID09IHRydWUpIHtyZXR1cm4gdHJ1ZTt9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxvYWRJdGVtO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZWdpc3RlciBhbiBhcnJheSBvZiBhdWRpbyBmaWxlcyBmb3IgbG9hZGluZyBhbmQgZnV0dXJlIHBsYXliYWNrIGluIFNvdW5kLiBJdCBpcyByZWNvbW1lbmRlZCB0byByZWdpc3RlciBhbGxcblx0ICogc291bmRzIHRoYXQgbmVlZCB0byBiZSBwbGF5ZWQgYmFjayBpbiBvcmRlciB0byBwcm9wZXJseSBwcmVwYXJlIGFuZCBwcmVsb2FkIHRoZW0uIFNvdW5kIGRvZXMgaW50ZXJuYWwgcHJlbG9hZGluZ1xuXHQgKiB3aGVuIHJlcXVpcmVkLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqIFx0XHR2YXIgYXNzZXRQYXRoID0gXCIuL215QXVkaW9QYXRoL1wiO1xuXHQgKiAgICAgIHZhciBzb3VuZHMgPSBbXG5cdCAqICAgICAgICAgIHtzcmM6XCJhc3NldDAub2dnXCIsIGlkOlwiZXhhbXBsZVwifSxcblx0ICogICAgICAgICAge3NyYzpcImFzc2V0MS5vZ2dcIiwgaWQ6XCIxXCIsIGRhdGE6Nn0sXG5cdCAqICAgICAgICAgIHtzcmM6XCJhc3NldDIubXAzXCIsIGlkOlwid29ya3NcIn1cblx0ICogICAgICAgICAge3NyYzp7bXAzOlwicGF0aDEvYXNzZXQzLm1wM1wiLCBvZ2c6XCJwYXRoMi9hc3NldDNOb0V4dGVuc2lvbn0sIGlkOlwiYmV0dGVyXCJ9XG5cdCAqICAgICAgXTtcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5hbHRlcm5hdGVFeHRlbnNpb25zID0gW1wibXAzXCJdO1x0Ly8gaWYgdGhlIHBhc3NlZCBleHRlbnNpb24gaXMgbm90IHN1cHBvcnRlZCwgdHJ5IHRoaXMgZXh0ZW5zaW9uXG5cdCAqICAgICAgY3JlYXRlanMuU291bmQub24oXCJmaWxlbG9hZFwiLCBoYW5kbGVMb2FkKTsgLy8gY2FsbCBoYW5kbGVMb2FkIHdoZW4gZWFjaCBzb3VuZCBsb2Fkc1xuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLnJlZ2lzdGVyU291bmRzKHNvdW5kcywgYXNzZXRQYXRoKTtcblx0ICpcblx0ICogQG1ldGhvZCByZWdpc3RlclNvdW5kc1xuXHQgKiBAcGFyYW0ge0FycmF5fSBzb3VuZHMgQW4gYXJyYXkgb2Ygb2JqZWN0cyB0byBsb2FkLiBPYmplY3RzIGFyZSBleHBlY3RlZCB0byBiZSBpbiB0aGUgZm9ybWF0IG5lZWRlZCBmb3Jcblx0ICoge3sjY3Jvc3NMaW5rIFwiU291bmQvcmVnaXN0ZXJTb3VuZFwifX17ey9jcm9zc0xpbmt9fTogPGNvZGU+e3NyYzpzcmNVUkksIGlkOklELCBkYXRhOkRhdGF9PC9jb2RlPlxuXHQgKiB3aXRoIFwiaWRcIiBhbmQgXCJkYXRhXCIgYmVpbmcgb3B0aW9uYWwuXG5cdCAqIFlvdSBjYW4gYWxzbyBwYXNzIGFuIG9iamVjdCB3aXRoIHBhdGggYW5kIG1hbmlmZXN0IHByb3BlcnRpZXMsIHdoZXJlIHBhdGggaXMgYSBiYXNlUGF0aCBhbmQgbWFuaWZlc3QgaXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB0byBsb2FkLlxuXHQgKiBOb3RlIGlkIGlzIHJlcXVpcmVkIGlmIHNyYyBpcyBhbiBvYmplY3Qgd2l0aCBleHRlbnNpb24gbGFiZWxlZCBzcmMgcHJvcGVydGllcy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGJhc2VQYXRoIFNldCBhIHBhdGggdGhhdCB3aWxsIGJlIHByZXBlbmRlZCB0byBlYWNoIHNyYyB3aGVuIGxvYWRpbmcuICBXaGVuIGNyZWF0aW5nLCBwbGF5aW5nLCBvciByZW1vdmluZ1xuXHQgKiBhdWRpbyB0aGF0IHdhcyBsb2FkZWQgd2l0aCBhIGJhc2VQYXRoIGJ5IHNyYywgdGhlIGJhc2VQYXRoIG11c3QgYmUgaW5jbHVkZWQuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHRoZSBtb2RpZmllZCB2YWx1ZXMgdGhhdCB3ZXJlIHBhc3NlZCBpbiwgd2hpY2ggZGVmaW5lcyBlYWNoIHNvdW5kLlxuXHQgKiBMaWtlIHJlZ2lzdGVyU291bmQsIGl0IHdpbGwgcmV0dXJuIGZhbHNlIGZvciBhbnkgdmFsdWVzIHdoZW4gdGhlIHNvdXJjZSBjYW5ub3QgYmUgcGFyc2VkIG9yIGlmIG5vIHBsdWdpbnMgY2FuIGJlIGluaXRpYWxpemVkLlxuXHQgKiBBbHNvLCBpdCB3aWxsIHJldHVybiB0cnVlIGZvciBhbnkgdmFsdWVzIHdoZW4gdGhlIHNvdXJjZSBpcyBhbHJlYWR5IGxvYWRlZC5cblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMucmVnaXN0ZXJTb3VuZHMgPSBmdW5jdGlvbiAoc291bmRzLCBiYXNlUGF0aCkge1xuXHRcdHZhciByZXR1cm5WYWx1ZXMgPSBbXTtcblx0XHRpZiAoc291bmRzLnBhdGgpIHtcblx0XHRcdGlmICghYmFzZVBhdGgpIHtcblx0XHRcdFx0YmFzZVBhdGggPSBzb3VuZHMucGF0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJhc2VQYXRoID0gYmFzZVBhdGggKyBzb3VuZHMucGF0aDtcblx0XHRcdH1cblx0XHRcdHNvdW5kcyA9IHNvdW5kcy5tYW5pZmVzdDtcblx0XHRcdC8vIFRPRE8gZG9jdW1lbnQgdGhpcyBmZWF0dXJlXG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc291bmRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0cmV0dXJuVmFsdWVzW2ldID0gY3JlYXRlanMuU291bmQucmVnaXN0ZXJTb3VuZChzb3VuZHNbaV0uc3JjLCBzb3VuZHNbaV0uaWQsIHNvdW5kc1tpXS5kYXRhLCBiYXNlUGF0aCwgc291bmRzW2ldLmRlZmF1bHRQbGF5UHJvcHMpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0dXJuVmFsdWVzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYSBzb3VuZCB0aGF0IGhhcyBiZWVuIHJlZ2lzdGVyZWQgd2l0aCB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZWdpc3RlclNvdW5kXCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNvdW5kL3JlZ2lzdGVyU291bmRzXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiA8YnIgLz5Ob3RlIHRoaXMgd2lsbCBzdG9wIHBsYXliYWNrIG9uIGFjdGl2ZSBpbnN0YW5jZXMgcGxheWluZyB0aGlzIHNvdW5kIGJlZm9yZSBkZWxldGluZyB0aGVtLlxuXHQgKiA8YnIgLz5Ob3RlIGlmIHlvdSBwYXNzZWQgaW4gYSBiYXNlUGF0aCwgeW91IG5lZWQgdG8gcGFzcyBpdCBvciBwcmVwZW5kIGl0IHRvIHRoZSBzcmMgaGVyZS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLnJlbW92ZVNvdW5kKFwibXlJRFwiKTtcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5yZW1vdmVTb3VuZChcIm15QXVkaW9CYXNlUGF0aC9teVNvdW5kLm9nZ1wiKTtcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5yZW1vdmVTb3VuZChcIm15UGF0aC9teU90aGVyU291bmQubXAzXCIsIFwibXlCYXNlUGF0aC9cIik7XG5cdCAqICAgICAgY3JlYXRlanMuU291bmQucmVtb3ZlU291bmQoe21wMzpcIm11c2ljTm9FeHRlbnNpb25cIiwgb2dnOlwibXVzaWMub2dnXCJ9LCBcIm15QmFzZVBhdGgvXCIpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHJlbW92ZVNvdW5kXG5cdCAqIEBwYXJhbSB7U3RyaW5nIHwgT2JqZWN0fSBzcmMgVGhlIHNyYyBvciBJRCBvZiB0aGUgYXVkaW8sIG9yIGFuIE9iamVjdCB3aXRoIGEgXCJzcmNcIiBwcm9wZXJ0eSwgb3IgYW4gT2JqZWN0IHdpdGggbXVsdGlwbGUgZXh0ZW5zaW9uIGxhYmVsZWQgc3JjIHByb3BlcnRpZXMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlUGF0aCBTZXQgYSBwYXRoIHRoYXQgd2lsbCBiZSBwcmVwZW5kZWQgdG8gZWFjaCBzcmMgd2hlbiByZW1vdmluZy5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBzb3VuZCBpcyBzdWNjZXNzZnVsbHkgcmVtb3ZlZC5cblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC40LjFcblx0ICovXG5cdHMucmVtb3ZlU291bmQgPSBmdW5jdGlvbihzcmMsIGJhc2VQYXRoKSB7XG5cdFx0aWYgKHMuYWN0aXZlUGx1Z2luID09IG51bGwpIHtyZXR1cm4gZmFsc2U7fVxuXG5cdFx0aWYgKHNyYyBpbnN0YW5jZW9mIE9iamVjdCAmJiBzcmMuc3JjKSB7c3JjID0gc3JjLnNyYzt9XG5cblx0XHR2YXIgZGV0YWlscztcblx0XHRpZiAoc3JjIGluc3RhbmNlb2YgT2JqZWN0KSB7XG5cdFx0XHRkZXRhaWxzID0gcy5fcGFyc2VTcmMoc3JjKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3JjID0gcy5fZ2V0U3JjQnlJZChzcmMpLnNyYztcblx0XHRcdGRldGFpbHMgPSBzLl9wYXJzZVBhdGgoc3JjKTtcblx0XHR9XG5cdFx0aWYgKGRldGFpbHMgPT0gbnVsbCkge3JldHVybiBmYWxzZTt9XG5cdFx0c3JjID0gZGV0YWlscy5zcmM7XG5cdFx0aWYgKGJhc2VQYXRoICE9IG51bGwpIHtzcmMgPSBiYXNlUGF0aCArIHNyYzt9XG5cblx0XHRmb3IodmFyIHByb3AgaW4gcy5faWRIYXNoKXtcblx0XHRcdGlmKHMuX2lkSGFzaFtwcm9wXS5zcmMgPT0gc3JjKSB7XG5cdFx0XHRcdGRlbGV0ZShzLl9pZEhhc2hbcHJvcF0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGNsZWFyIGZyb20gU291bmRDaGFubmVsLCB3aGljaCBhbHNvIHN0b3BzIGFuZCBkZWxldGVzIGFsbCBpbnN0YW5jZXNcblx0XHRTb3VuZENoYW5uZWwucmVtb3ZlU3JjKHNyYyk7XG5cblx0XHRkZWxldGUocy5fcHJlbG9hZEhhc2hbc3JjXSk7XG5cblx0XHRzLmFjdGl2ZVBsdWdpbi5yZW1vdmVTb3VuZChzcmMpO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbiBhcnJheSBvZiBhdWRpbyBmaWxlcyB0aGF0IGhhdmUgYmVlbiByZWdpc3RlcmVkIHdpdGgge3sjY3Jvc3NMaW5rIFwiU291bmQvcmVnaXN0ZXJTb3VuZFwifX17ey9jcm9zc0xpbmt9fSBvclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZWdpc3RlclNvdW5kc1wifX17ey9jcm9zc0xpbmt9fS5cblx0ICogPGJyIC8+Tm90ZSB0aGlzIHdpbGwgc3RvcCBwbGF5YmFjayBvbiBhY3RpdmUgaW5zdGFuY2VzIHBsYXlpbmcgdGhpcyBhdWRpbyBiZWZvcmUgZGVsZXRpbmcgdGhlbS5cblx0ICogPGJyIC8+Tm90ZSBpZiB5b3UgcGFzc2VkIGluIGEgYmFzZVBhdGgsIHlvdSBuZWVkIHRvIHBhc3MgaXQgb3IgcHJlcGVuZCBpdCB0byB0aGUgc3JjIGhlcmUuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogXHRcdGFzc2V0UGF0aCA9IFwiLi9teVBhdGgvXCI7XG5cdCAqICAgICAgdmFyIHNvdW5kcyA9IFtcblx0ICogICAgICAgICAge3NyYzpcImFzc2V0MC5vZ2dcIiwgaWQ6XCJleGFtcGxlXCJ9LFxuXHQgKiAgICAgICAgICB7c3JjOlwiYXNzZXQxLm9nZ1wiLCBpZDpcIjFcIiwgZGF0YTo2fSxcblx0ICogICAgICAgICAge3NyYzpcImFzc2V0Mi5tcDNcIiwgaWQ6XCJ3b3Jrc1wifVxuXHQgKiAgICAgIF07XG5cdCAqICAgICAgY3JlYXRlanMuU291bmQucmVtb3ZlU291bmRzKHNvdW5kcywgYXNzZXRQYXRoKTtcblx0ICpcblx0ICogQG1ldGhvZCByZW1vdmVTb3VuZHNcblx0ICogQHBhcmFtIHtBcnJheX0gc291bmRzIEFuIGFycmF5IG9mIG9iamVjdHMgdG8gcmVtb3ZlLiBPYmplY3RzIGFyZSBleHBlY3RlZCB0byBiZSBpbiB0aGUgZm9ybWF0IG5lZWRlZCBmb3Jcblx0ICoge3sjY3Jvc3NMaW5rIFwiU291bmQvcmVtb3ZlU291bmRcIn19e3svY3Jvc3NMaW5rfX06IDxjb2RlPntzcmNPcklEOnNyY1VSSW9ySUR9PC9jb2RlPi5cblx0ICogWW91IGNhbiBhbHNvIHBhc3MgYW4gb2JqZWN0IHdpdGggcGF0aCBhbmQgbWFuaWZlc3QgcHJvcGVydGllcywgd2hlcmUgcGF0aCBpcyBhIGJhc2VQYXRoIGFuZCBtYW5pZmVzdCBpcyBhbiBhcnJheSBvZiBvYmplY3RzIHRvIHJlbW92ZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGJhc2VQYXRoIFNldCBhIHBhdGggdGhhdCB3aWxsIGJlIHByZXBlbmRlZCB0byBlYWNoIHNyYyB3aGVuIHJlbW92aW5nLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEFuIGFycmF5IG9mIEJvb2xlYW4gdmFsdWVzIHJlcHJlc2VudGluZyBpZiB0aGUgc291bmRzIHdpdGggdGhlIHNhbWUgYXJyYXkgaW5kZXggd2VyZVxuXHQgKiBzdWNjZXNzZnVsbHkgcmVtb3ZlZC5cblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC40LjFcblx0ICovXG5cdHMucmVtb3ZlU291bmRzID0gZnVuY3Rpb24gKHNvdW5kcywgYmFzZVBhdGgpIHtcblx0XHR2YXIgcmV0dXJuVmFsdWVzID0gW107XG5cdFx0aWYgKHNvdW5kcy5wYXRoKSB7XG5cdFx0XHRpZiAoIWJhc2VQYXRoKSB7XG5cdFx0XHRcdGJhc2VQYXRoID0gc291bmRzLnBhdGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRiYXNlUGF0aCA9IGJhc2VQYXRoICsgc291bmRzLnBhdGg7XG5cdFx0XHR9XG5cdFx0XHRzb3VuZHMgPSBzb3VuZHMubWFuaWZlc3Q7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc291bmRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0cmV0dXJuVmFsdWVzW2ldID0gY3JlYXRlanMuU291bmQucmVtb3ZlU291bmQoc291bmRzW2ldLnNyYywgYmFzZVBhdGgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0dXJuVmFsdWVzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYWxsIHNvdW5kcyB0aGF0IGhhdmUgYmVlbiByZWdpc3RlcmVkIHdpdGgge3sjY3Jvc3NMaW5rIFwiU291bmQvcmVnaXN0ZXJTb3VuZFwifX17ey9jcm9zc0xpbmt9fSBvclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTb3VuZC9yZWdpc3RlclNvdW5kc1wifX17ey9jcm9zc0xpbmt9fS5cblx0ICogPGJyIC8+Tm90ZSB0aGlzIHdpbGwgc3RvcCBwbGF5YmFjayBvbiBhbGwgYWN0aXZlIHNvdW5kIGluc3RhbmNlcyBiZWZvcmUgZGVsZXRpbmcgdGhlbS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgY3JlYXRlanMuU291bmQucmVtb3ZlQWxsU291bmRzKCk7XG5cdCAqXG5cdCAqIEBtZXRob2QgcmVtb3ZlQWxsU291bmRzXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNC4xXG5cdCAqL1xuXHRzLnJlbW92ZUFsbFNvdW5kcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHMuX2lkSGFzaCA9IHt9O1xuXHRcdHMuX3ByZWxvYWRIYXNoID0ge307XG5cdFx0U291bmRDaGFubmVsLnJlbW92ZUFsbCgpO1xuXHRcdGlmIChzLmFjdGl2ZVBsdWdpbikge3MuYWN0aXZlUGx1Z2luLnJlbW92ZUFsbFNvdW5kcygpO31cblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgYSBzb3VyY2UgaGFzIGJlZW4gbG9hZGVkIGJ5IGludGVybmFsIHByZWxvYWRlcnMuIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSB0aGF0IHNvdW5kcyB0aGF0IGFyZVxuXHQgKiBub3QgY29tcGxldGVkIHByZWxvYWRpbmcgd2lsbCBub3Qga2ljayBvZmYgYSBuZXcgaW50ZXJuYWwgcHJlbG9hZCBpZiB0aGV5IGFyZSBwbGF5ZWQuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgIHZhciBteVNvdW5kID0gXCJhc3NldFBhdGgvYXNzZXQwLm9nZ1wiO1xuXHQgKiAgICAgaWYoY3JlYXRlanMuU291bmQubG9hZENvbXBsZXRlKG15U291bmQpIHtcblx0ICogICAgICAgICBjcmVhdGVqcy5Tb3VuZC5wbGF5KG15U291bmQpO1xuXHQgKiAgICAgfVxuXHQgKlxuXHQgKiBAbWV0aG9kIGxvYWRDb21wbGV0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzcmMgb3IgaWQgdGhhdCBpcyBiZWluZyBsb2FkZWQuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBzcmMgaXMgYWxyZWFkeSBsb2FkZWQuXG5cdCAqIEBzaW5jZSAwLjQuMFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uIChzcmMpIHtcblx0XHRpZiAoIXMuaXNSZWFkeSgpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHZhciBkZXRhaWxzID0gcy5fcGFyc2VQYXRoKHNyYyk7XG5cdFx0aWYgKGRldGFpbHMpIHtcblx0XHRcdHNyYyA9IHMuX2dldFNyY0J5SWQoZGV0YWlscy5zcmMpLnNyYztcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3JjID0gcy5fZ2V0U3JjQnlJZChzcmMpLnNyYztcblx0XHR9XG5cdFx0aWYocy5fcHJlbG9hZEhhc2hbc3JjXSA9PSB1bmRlZmluZWQpIHtyZXR1cm4gZmFsc2U7fVxuXHRcdHJldHVybiAocy5fcHJlbG9hZEhhc2hbc3JjXVswXSA9PSB0cnVlKTsgIC8vIHNyYyBvbmx5IGxvYWRzIG9uY2UsIHNvIGlmIGl0J3MgdHJ1ZSBmb3IgdGhlIGZpcnN0IGl0J3MgdHJ1ZSBmb3IgYWxsXG5cdH07XG5cblx0LyoqXG5cdCAqIFBhcnNlIHRoZSBwYXRoIG9mIGEgc291bmQuIEFsdGVybmF0ZSBleHRlbnNpb25zIHdpbGwgYmUgYXR0ZW1wdGVkIGluIG9yZGVyIGlmIHRoZVxuXHQgKiBjdXJyZW50IGV4dGVuc2lvbiBpcyBub3Qgc3VwcG9ydGVkXG5cdCAqIEBtZXRob2QgX3BhcnNlUGF0aFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIHBhdGggdG8gYW4gYXVkaW8gc291cmNlLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEEgZm9ybWF0dGVkIG9iamVjdCB0aGF0IGNhbiBiZSByZWdpc3RlcmVkIHdpdGggdGhlIHt7I2Nyb3NzTGluayBcIlNvdW5kL2FjdGl2ZVBsdWdpbjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBhbmQgcmV0dXJuZWQgdG8gYSBwcmVsb2FkZXIgbGlrZSA8YSBocmVmPVwiaHR0cDovL3ByZWxvYWRqcy5jb21cIiB0YXJnZXQ9XCJfYmxhbmtcIj5QcmVsb2FkSlM8L2E+LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuX3BhcnNlUGF0aCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGlmICh0eXBlb2YodmFsdWUpICE9IFwic3RyaW5nXCIpIHt2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7fVxuXG5cdFx0dmFyIG1hdGNoID0gdmFsdWUubWF0Y2gocy5GSUxFX1BBVFRFUk4pO1xuXHRcdGlmIChtYXRjaCA9PSBudWxsKSB7cmV0dXJuIGZhbHNlO31cblxuXHRcdHZhciBuYW1lID0gbWF0Y2hbNF07XG5cdFx0dmFyIGV4dCA9IG1hdGNoWzVdO1xuXHRcdHZhciBjID0gcy5jYXBhYmlsaXRpZXM7XG5cdFx0dmFyIGkgPSAwO1xuXHRcdHdoaWxlICghY1tleHRdKSB7XG5cdFx0XHRleHQgPSBzLmFsdGVybmF0ZUV4dGVuc2lvbnNbaSsrXTtcblx0XHRcdGlmIChpID4gcy5hbHRlcm5hdGVFeHRlbnNpb25zLmxlbmd0aCkgeyByZXR1cm4gbnVsbDt9XHQvLyBubyBleHRlbnNpb25zIGFyZSBzdXBwb3J0ZWRcblx0XHR9XG5cdFx0dmFsdWUgPSB2YWx1ZS5yZXBsYWNlKFwiLlwiK21hdGNoWzVdLCBcIi5cIitleHQpO1xuXG5cdFx0dmFyIHJldCA9IHtuYW1lOm5hbWUsIHNyYzp2YWx1ZSwgZXh0ZW5zaW9uOmV4dH07XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcblxuXHQvKipcblx0ICogUGFyc2UgdGhlIHBhdGggb2YgYSBzb3VuZCBiYXNlZCBvbiBwcm9wZXJ0aWVzIG9mIHNyYyBtYXRjaGluZyB3aXRoIHN1cHBvcnRlZCBleHRlbnNpb25zLlxuXHQgKiBSZXR1cm5zIGZhbHNlIGlmIG5vbmUgb2YgdGhlIHByb3BlcnRpZXMgYXJlIHN1cHBvcnRlZFxuXHQgKiBAbWV0aG9kIF9wYXJzZVNyY1xuXHQgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVGhlIHBhdGhzIHRvIGFuIGF1ZGlvIHNvdXJjZSwgaW5kZXhlZCBieSBleHRlbnNpb24gdHlwZS5cblx0ICogQHJldHVybiB7T2JqZWN0fSBBIGZvcm1hdHRlZCBvYmplY3QgdGhhdCBjYW4gYmUgcmVnaXN0ZXJlZCB3aXRoIHRoZSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9hY3RpdmVQbHVnaW46cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogYW5kIHJldHVybmVkIHRvIGEgcHJlbG9hZGVyIGxpa2UgPGEgaHJlZj1cImh0dHA6Ly9wcmVsb2FkanMuY29tXCIgdGFyZ2V0PVwiX2JsYW5rXCI+UHJlbG9hZEpTPC9hPi5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLl9wYXJzZVNyYyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHZhciByZXQgPSB7bmFtZTp1bmRlZmluZWQsIHNyYzp1bmRlZmluZWQsIGV4dGVuc2lvbjp1bmRlZmluZWR9O1xuXHRcdHZhciBjID0gcy5jYXBhYmlsaXRpZXM7XG5cblx0XHRmb3IgKHZhciBwcm9wIGluIHZhbHVlKSB7XG5cdFx0ICBpZih2YWx1ZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBjW3Byb3BdKSB7XG5cdFx0XHRcdHJldC5zcmMgPSB2YWx1ZVtwcm9wXTtcblx0XHRcdFx0cmV0LmV4dGVuc2lvbiA9IHByb3A7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdCAgfVxuXHRcdH1cblx0XHRpZiAoIXJldC5zcmMpIHtyZXR1cm4gZmFsc2U7fVx0Ly8gbm8gbWF0Y2hlc1xuXG5cdFx0dmFyIGkgPSByZXQuc3JjLmxhc3RJbmRleE9mKFwiL1wiKTtcblx0XHRpZiAoaSAhPSAtMSkge1xuXHRcdFx0cmV0Lm5hbWUgPSByZXQuc3JjLnNsaWNlKGkrMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldC5uYW1lID0gcmV0LnNyYztcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLVxuXHQgU3RhdGljIEFQSS5cblx0IC0tLS0tLS0tLS0tLS0tLSAqL1xuXHQvKipcblx0ICogUGxheSBhIHNvdW5kIGFuZCBnZXQgYSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2VcIn19e3svY3Jvc3NMaW5rfX0gdG8gY29udHJvbC4gSWYgdGhlIHNvdW5kIGZhaWxzIHRvIHBsYXksIGFcblx0ICogQWJzdHJhY3RTb3VuZEluc3RhbmNlIHdpbGwgc3RpbGwgYmUgcmV0dXJuZWQsIGFuZCBoYXZlIGEgcGxheVN0YXRlIG9mIHt7I2Nyb3NzTGluayBcIlNvdW5kL1BMQVlfRkFJTEVEOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBOb3RlIHRoYXQgZXZlbiBvbiBzb3VuZHMgd2l0aCBmYWlsZWQgcGxheWJhY2ssIHlvdSBtYXkgc3RpbGwgYmUgYWJsZSB0byBjYWxsIEFic3RyYWN0U291bmRJbnN0YW5jZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvcGxheVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogc2luY2UgdGhlIGZhaWx1cmUgY291bGQgYmUgZHVlIHRvIGxhY2sgb2YgYXZhaWxhYmxlIGNoYW5uZWxzLiBJZiB0aGUgc3JjIGRvZXMgbm90IGhhdmUgYSBzdXBwb3J0ZWQgZXh0ZW5zaW9uIG9yXG5cdCAqIGlmIHRoZXJlIGlzIG5vIGF2YWlsYWJsZSBwbHVnaW4sIGEgZGVmYXVsdCBBYnN0cmFjdFNvdW5kSW5zdGFuY2Ugd2lsbCBiZSByZXR1cm5lZCB3aGljaCB3aWxsIG5vdCBwbGF5IGFueSBhdWRpbywgYnV0IHdpbGwgbm90IGdlbmVyYXRlIGVycm9ycy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLm9uKFwiZmlsZWxvYWRcIiwgaGFuZGxlTG9hZCk7XG5cdCAqICAgICAgY3JlYXRlanMuU291bmQucmVnaXN0ZXJTb3VuZChcIm15QXVkaW9QYXRoL215U291bmQubXAzXCIsIFwibXlJRFwiLCAzKTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVMb2FkKGV2ZW50KSB7XG5cdCAqICAgICAgXHRjcmVhdGVqcy5Tb3VuZC5wbGF5KFwibXlJRFwiKTtcblx0ICogICAgICBcdC8vIHN0b3JlIG9mZiBBYnN0cmFjdFNvdW5kSW5zdGFuY2UgZm9yIGNvbnRyb2xsaW5nXG5cdCAqICAgICAgXHR2YXIgbXlJbnN0YW5jZSA9IGNyZWF0ZWpzLlNvdW5kLnBsYXkoXCJteUlEXCIsIHtpbnRlcnJ1cHQ6IGNyZWF0ZWpzLlNvdW5kLklOVEVSUlVQVF9BTlksIGxvb3A6LTF9KTtcblx0ICogICAgICB9XG5cdCAqXG5cdCAqIE5PVEUgdG8gY3JlYXRlIGFuIGF1ZGlvIHNwcml0ZSB0aGF0IGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQsIGJvdGggc3RhcnRUaW1lIGFuZCBkdXJhdGlvbiBuZWVkIHRvIGJlIHNldC5cblx0ICogVGhpcyBpcyBvbmx5IHdoZW4gY3JlYXRpbmcgYSBuZXcgYXVkaW8gc3ByaXRlLCBub3Qgd2hlbiBwbGF5aW5nIHVzaW5nIHRoZSBpZCBvZiBhbiBhbHJlYWR5IHJlZ2lzdGVyZWQgYXVkaW8gc3ByaXRlLlxuXHQgKlxuXHQgKiA8Yj5QYXJhbWV0ZXJzIERlcHJlY2F0ZWQ8L2I+PGJyIC8+XG5cdCAqIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG1ldGhvZCBhcmUgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBhIHNpbmdsZSBwYXJhbWV0ZXIgdGhhdCBpcyBhbiBPYmplY3Qgb3Ige3sjY3Jvc3NMaW5rIFwiUGxheVByb3BzQ29uZmlnXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiBAbWV0aG9kIHBsYXlcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc3JjIG9yIElEIG9mIHRoZSBhdWRpby5cblx0ICogQHBhcmFtIHtTdHJpbmcgfCBPYmplY3R9IFtpbnRlcnJ1cHQ9XCJub25lXCJ8b3B0aW9uc10gPGI+VGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSByZW5hbWVkIHBsYXlQcm9wcyBpbiB0aGUgbmV4dCByZWxlYXNlLjwvYj48YnIgLz5cblx0ICogVGhpcyBwYXJhbWV0ZXIgY2FuIGJlIGFuIGluc3RhbmNlIG9mIHt7I2Nyb3NzTGluayBcIlBsYXlQcm9wc0NvbmZpZ1wifX17ey9jcm9zc0xpbmt9fSBvciBhbiBPYmplY3QgdGhhdCBjb250YWlucyBhbnkgb3IgYWxsIG9wdGlvbmFsIHByb3BlcnRpZXMgYnkgbmFtZSxcblx0ICogaW5jbHVkaW5nOiBpbnRlcnJ1cHQsIGRlbGF5LCBvZmZzZXQsIGxvb3AsIHZvbHVtZSwgcGFuLCBzdGFydFRpbWUsIGFuZCBkdXJhdGlvbiAoc2VlIHRoZSBhYm92ZSBjb2RlIHNhbXBsZSkuXG5cdCAqIDxiciAvPjxzdHJvbmc+T1I8L3N0cm9uZz48YnIgLz5cblx0ICogPGI+RGVwcmVjYXRlZDwvYj4gSG93IHRvIGludGVycnVwdCBhbnkgY3VycmVudGx5IHBsYXlpbmcgaW5zdGFuY2VzIG9mIGF1ZGlvIHdpdGggdGhlIHNhbWUgc291cmNlLFxuXHQgKiBpZiB0aGUgbWF4aW11bSBudW1iZXIgb2YgaW5zdGFuY2VzIG9mIHRoZSBzb3VuZCBhcmUgYWxyZWFkeSBwbGF5aW5nLiBWYWx1ZXMgYXJlIGRlZmluZWQgYXMgPGNvZGU+SU5URVJSVVBUX1RZUEU8L2NvZGU+XG5cdCAqIGNvbnN0YW50cyBvbiB0aGUgU291bmQgY2xhc3MsIHdpdGggdGhlIGRlZmF1bHQgZGVmaW5lZCBieSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9kZWZhdWx0SW50ZXJydXB0QmVoYXZpb3I6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsYXk9MF0gPGI+RGVwcmVjYXRlZDwvYj4gVGhlIGFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IHRoZSBzdGFydCBvZiBhdWRpbyBwbGF5YmFjaywgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29mZnNldD0wXSA8Yj5EZXByZWNhdGVkPC9iPiBUaGUgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBhdWRpbyB0byBiZWdpbiBwbGF5YmFjaywgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2xvb3A9MF0gPGI+RGVwcmVjYXRlZDwvYj4gSG93IG1hbnkgdGltZXMgdGhlIGF1ZGlvIGxvb3BzIHdoZW4gaXQgcmVhY2hlcyB0aGUgZW5kIG9mIHBsYXliYWNrLiBUaGUgZGVmYXVsdCBpcyAwIChub1xuXHQgKiBsb29wcyksIGFuZCAtMSBjYW4gYmUgdXNlZCBmb3IgaW5maW5pdGUgcGxheWJhY2suXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdm9sdW1lPTFdIDxiPkRlcHJlY2F0ZWQ8L2I+IFRoZSB2b2x1bWUgb2YgdGhlIHNvdW5kLCBiZXR3ZWVuIDAgYW5kIDEuIE5vdGUgdGhhdCB0aGUgbWFzdGVyIHZvbHVtZSBpcyBhcHBsaWVkXG5cdCAqIGFnYWluc3QgdGhlIGluZGl2aWR1YWwgdm9sdW1lLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3Bhbj0wXSA8Yj5EZXByZWNhdGVkPC9iPiBUaGUgbGVmdC1yaWdodCBwYW4gb2YgdGhlIHNvdW5kIChpZiBzdXBwb3J0ZWQpLCBiZXR3ZWVuIC0xIChsZWZ0KSBhbmQgMSAocmlnaHQpLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0VGltZT1udWxsXSA8Yj5EZXByZWNhdGVkPC9iPiBUbyBjcmVhdGUgYW4gYXVkaW8gc3ByaXRlICh3aXRoIGR1cmF0aW9uKSwgdGhlIGluaXRpYWwgb2Zmc2V0IHRvIHN0YXJ0IHBsYXliYWNrIGFuZCBsb29wIGZyb20sIGluIG1pbGxpc2Vjb25kcy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtkdXJhdGlvbj1udWxsXSA8Yj5EZXByZWNhdGVkPC9iPiBUbyBjcmVhdGUgYW4gYXVkaW8gc3ByaXRlICh3aXRoIHN0YXJ0VGltZSksIHRoZSBhbW91bnQgb2YgdGltZSB0byBwbGF5IHRoZSBjbGlwIGZvciwgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKiBAcmV0dXJuIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IEEge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlXCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgY2FuIGJlIGNvbnRyb2xsZWQgYWZ0ZXIgaXQgaXMgY3JlYXRlZC5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5wbGF5ID0gZnVuY3Rpb24gKHNyYywgaW50ZXJydXB0LCBkZWxheSwgb2Zmc2V0LCBsb29wLCB2b2x1bWUsIHBhbiwgc3RhcnRUaW1lLCBkdXJhdGlvbikge1xuXHRcdHZhciBwbGF5UHJvcHM7XG5cdFx0aWYgKGludGVycnVwdCBpbnN0YW5jZW9mIE9iamVjdCB8fCBpbnRlcnJ1cHQgaW5zdGFuY2VvZiBjcmVhdGVqcy5QbGF5UHJvcHNDb25maWcpIHtcblx0XHRcdHBsYXlQcm9wcyA9IGNyZWF0ZWpzLlBsYXlQcm9wc0NvbmZpZy5jcmVhdGUoaW50ZXJydXB0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGxheVByb3BzID0gY3JlYXRlanMuUGxheVByb3BzQ29uZmlnLmNyZWF0ZSh7aW50ZXJydXB0OmludGVycnVwdCwgZGVsYXk6ZGVsYXksIG9mZnNldDpvZmZzZXQsIGxvb3A6bG9vcCwgdm9sdW1lOnZvbHVtZSwgcGFuOnBhbiwgc3RhcnRUaW1lOnN0YXJ0VGltZSwgZHVyYXRpb246ZHVyYXRpb259KTtcblx0XHR9XG5cdFx0dmFyIGluc3RhbmNlID0gcy5jcmVhdGVJbnN0YW5jZShzcmMsIHBsYXlQcm9wcy5zdGFydFRpbWUsIHBsYXlQcm9wcy5kdXJhdGlvbik7XG5cdFx0dmFyIG9rID0gcy5fcGxheUluc3RhbmNlKGluc3RhbmNlLCBwbGF5UHJvcHMpO1xuXHRcdGlmICghb2spIHtpbnN0YW5jZS5fcGxheUZhaWxlZCgpO31cblx0XHRyZXR1cm4gaW5zdGFuY2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2VcIn19e3svY3Jvc3NMaW5rfX0gdXNpbmcgdGhlIHBhc3NlZCBpbiBzcmMuIElmIHRoZSBzcmMgZG9lcyBub3QgaGF2ZSBhXG5cdCAqIHN1cHBvcnRlZCBleHRlbnNpb24gb3IgaWYgdGhlcmUgaXMgbm8gYXZhaWxhYmxlIHBsdWdpbiwgYSBkZWZhdWx0IEFic3RyYWN0U291bmRJbnN0YW5jZSB3aWxsIGJlIHJldHVybmVkIHRoYXQgY2FuIGJlXG5cdCAqIGNhbGxlZCBzYWZlbHkgYnV0IGRvZXMgbm90aGluZy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBteUluc3RhbmNlID0gbnVsbDtcblx0ICogICAgICBjcmVhdGVqcy5Tb3VuZC5vbihcImZpbGVsb2FkXCIsIGhhbmRsZUxvYWQpO1xuXHQgKiAgICAgIGNyZWF0ZWpzLlNvdW5kLnJlZ2lzdGVyU291bmQoXCJteUF1ZGlvUGF0aC9teVNvdW5kLm1wM1wiLCBcIm15SURcIiwgMyk7XG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlTG9hZChldmVudCkge1xuXHQgKiAgICAgIFx0bXlJbnN0YW5jZSA9IGNyZWF0ZWpzLlNvdW5kLmNyZWF0ZUluc3RhbmNlKFwibXlJRFwiKTtcblx0ICogICAgICBcdC8vIGFsdGVybmF0ZWx5IHdlIGNvdWxkIGNhbGwgdGhlIGZvbGxvd2luZ1xuXHQgKiAgICAgIFx0bXlJbnN0YW5jZSA9IGNyZWF0ZWpzLlNvdW5kLmNyZWF0ZUluc3RhbmNlKFwibXlBdWRpb1BhdGgvbXlTb3VuZC5tcDNcIik7XG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBOT1RFIHRvIGNyZWF0ZSBhbiBhdWRpbyBzcHJpdGUgdGhhdCBoYXMgbm90IGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLCBib3RoIHN0YXJ0VGltZSBhbmQgZHVyYXRpb24gbmVlZCB0byBiZSBzZXQuXG5cdCAqIFRoaXMgaXMgb25seSB3aGVuIGNyZWF0aW5nIGEgbmV3IGF1ZGlvIHNwcml0ZSwgbm90IHdoZW4gcGxheWluZyB1c2luZyB0aGUgaWQgb2YgYW4gYWxyZWFkeSByZWdpc3RlcmVkIGF1ZGlvIHNwcml0ZS5cblx0ICpcblx0ICogQG1ldGhvZCBjcmVhdGVJbnN0YW5jZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzcmMgb3IgSUQgb2YgdGhlIGF1ZGlvLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0VGltZT1udWxsXSBUbyBjcmVhdGUgYW4gYXVkaW8gc3ByaXRlICh3aXRoIGR1cmF0aW9uKSwgdGhlIGluaXRpYWwgb2Zmc2V0IHRvIHN0YXJ0IHBsYXliYWNrIGFuZCBsb29wIGZyb20sIGluIG1pbGxpc2Vjb25kcy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtkdXJhdGlvbj1udWxsXSBUbyBjcmVhdGUgYW4gYXVkaW8gc3ByaXRlICh3aXRoIHN0YXJ0VGltZSksIHRoZSBhbW91bnQgb2YgdGltZSB0byBwbGF5IHRoZSBjbGlwIGZvciwgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKiBAcmV0dXJuIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IEEge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlXCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgY2FuIGJlIGNvbnRyb2xsZWQgYWZ0ZXIgaXQgaXMgY3JlYXRlZC5cblx0ICogVW5zdXBwb3J0ZWQgZXh0ZW5zaW9ucyB3aWxsIHJldHVybiB0aGUgZGVmYXVsdCBBYnN0cmFjdFNvdW5kSW5zdGFuY2UuXG5cdCAqIEBzaW5jZSAwLjQuMFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNyZWF0ZUluc3RhbmNlID0gZnVuY3Rpb24gKHNyYywgc3RhcnRUaW1lLCBkdXJhdGlvbikge1xuXHRcdGlmICghcy5pbml0aWFsaXplRGVmYXVsdFBsdWdpbnMoKSkge3JldHVybiBuZXcgY3JlYXRlanMuRGVmYXVsdFNvdW5kSW5zdGFuY2Uoc3JjLCBzdGFydFRpbWUsIGR1cmF0aW9uKTt9XG5cblx0XHR2YXIgZGVmYXVsdFBsYXlQcm9wcyA9IHMuX2RlZmF1bHRQbGF5UHJvcHNIYXNoW3NyY107XHQvLyBmb3IgYXVkaW8gc3ByaXRlcywgd2hpY2ggY3JlYXRlIGFuZCBzdG9yZSBkZWZhdWx0cyBieSBpZFxuXHRcdHNyYyA9IHMuX2dldFNyY0J5SWQoc3JjKTtcblxuXHRcdHZhciBkZXRhaWxzID0gcy5fcGFyc2VQYXRoKHNyYy5zcmMpO1xuXG5cdFx0dmFyIGluc3RhbmNlID0gbnVsbDtcblx0XHRpZiAoZGV0YWlscyAhPSBudWxsICYmIGRldGFpbHMuc3JjICE9IG51bGwpIHtcblx0XHRcdFNvdW5kQ2hhbm5lbC5jcmVhdGUoZGV0YWlscy5zcmMpO1xuXHRcdFx0aWYgKHN0YXJ0VGltZSA9PSBudWxsKSB7c3RhcnRUaW1lID0gc3JjLnN0YXJ0VGltZTt9XG5cdFx0XHRpbnN0YW5jZSA9IHMuYWN0aXZlUGx1Z2luLmNyZWF0ZShkZXRhaWxzLnNyYywgc3RhcnRUaW1lLCBkdXJhdGlvbiB8fCBzcmMuZHVyYXRpb24pO1xuXG5cdFx0XHRkZWZhdWx0UGxheVByb3BzID0gZGVmYXVsdFBsYXlQcm9wcyB8fCBzLl9kZWZhdWx0UGxheVByb3BzSGFzaFtkZXRhaWxzLnNyY107XG5cdFx0XHRpZihkZWZhdWx0UGxheVByb3BzKSB7XG5cdFx0XHRcdGluc3RhbmNlLmFwcGx5UGxheVByb3BzKGRlZmF1bHRQbGF5UHJvcHMpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbnN0YW5jZSA9IG5ldyBjcmVhdGVqcy5EZWZhdWx0U291bmRJbnN0YW5jZShzcmMsIHN0YXJ0VGltZSwgZHVyYXRpb24pO1xuXHRcdH1cblxuXHRcdGluc3RhbmNlLnVuaXF1ZUlkID0gcy5fbGFzdElEKys7XG5cblx0XHRyZXR1cm4gaW5zdGFuY2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3AgYWxsIGF1ZGlvIChnbG9iYWwgc3RvcCkuIFN0b3BwZWQgYXVkaW8gaXMgcmVzZXQsIGFuZCBub3QgcGF1c2VkLiBUbyBwbGF5IGF1ZGlvIHRoYXQgaGFzIGJlZW4gc3RvcHBlZCxcblx0ICogY2FsbCBBYnN0cmFjdFNvdW5kSW5zdGFuY2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3BsYXlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgIGNyZWF0ZWpzLlNvdW5kLnN0b3AoKTtcblx0ICpcblx0ICogQG1ldGhvZCBzdG9wXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuc3RvcCA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaW5zdGFuY2VzID0gdGhpcy5faW5zdGFuY2VzO1xuXHRcdGZvciAodmFyIGkgPSBpbnN0YW5jZXMubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0aW5zdGFuY2VzW2ldLnN0b3AoKTsgIC8vIE5PVEUgc3RvcCByZW1vdmVzIGluc3RhbmNlIGZyb20gdGhpcy5faW5zdGFuY2VzXG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXByZWNhdGVkLCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIlNvdW5kL3ZvbHVtZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHNldFZvbHVtZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVGhlIG1hc3RlciB2b2x1bWUgdmFsdWUuIFRoZSBhY2NlcHRhYmxlIHJhbmdlIGlzIDAtMS5cblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0cy5zZXRWb2x1bWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRpZiAoTnVtYmVyKHZhbHVlKSA9PSBudWxsKSB7cmV0dXJuIGZhbHNlO31cblx0XHR2YWx1ZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHZhbHVlKSk7XG5cdFx0cy5fbWFzdGVyVm9sdW1lID0gdmFsdWU7XG5cdFx0aWYgKCF0aGlzLmFjdGl2ZVBsdWdpbiB8fCAhdGhpcy5hY3RpdmVQbHVnaW4uc2V0Vm9sdW1lIHx8ICF0aGlzLmFjdGl2ZVBsdWdpbi5zZXRWb2x1bWUodmFsdWUpKSB7XG5cdFx0XHR2YXIgaW5zdGFuY2VzID0gdGhpcy5faW5zdGFuY2VzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBpbnN0YW5jZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGluc3RhbmNlc1tpXS5zZXRNYXN0ZXJWb2x1bWUodmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJTb3VuZC92b2x1bWU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICpcblx0ICogQG1ldGhvZCBnZXRWb2x1bWVcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgbWFzdGVyIHZvbHVtZSwgaW4gYSByYW5nZSBvZiAwLTEuXG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdHMuZ2V0Vm9sdW1lID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXN0ZXJWb2x1bWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIERlcHJlY2F0ZWQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiU291bmQvbXV0ZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICpcblx0ICogQG1ldGhvZCBzZXRNdXRlXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgV2hldGhlciB0aGUgYXVkaW8gc2hvdWxkIGJlIG11dGVkIG9yIG5vdC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIG11dGUgd2FzIHNldC5cblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC40LjBcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdHMuc2V0TXV0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PSBudWxsKSB7cmV0dXJuIGZhbHNlO31cblxuXHRcdHRoaXMuX21hc3Rlck11dGUgPSB2YWx1ZTtcblx0XHRpZiAoIXRoaXMuYWN0aXZlUGx1Z2luIHx8ICF0aGlzLmFjdGl2ZVBsdWdpbi5zZXRNdXRlIHx8ICF0aGlzLmFjdGl2ZVBsdWdpbi5zZXRNdXRlKHZhbHVlKSkge1xuXHRcdFx0dmFyIGluc3RhbmNlcyA9IHRoaXMuX2luc3RhbmNlcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gaW5zdGFuY2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpbnN0YW5jZXNbaV0uc2V0TWFzdGVyTXV0ZSh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXByZWNhdGVkLCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIlNvdW5kL211dGVkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqXG5cdCAqIEBtZXRob2QgZ2V0TXV0ZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUaGUgbXV0ZSB2YWx1ZSBvZiBTb3VuZC5cblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC40LjBcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdHMuZ2V0TXV0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFzdGVyTXV0ZTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0IHRoZSBkZWZhdWx0IHBsYXliYWNrIHByb3BlcnRpZXMgZm9yIGFsbCBuZXcgU291bmRJbnN0YW5jZXMgb2YgdGhlIHBhc3NlZCBpbiBzcmMgb3IgSUQuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJQbGF5UHJvcHNDb25maWdcIn19e3svY3Jvc3NMaW5rfX0gZm9yIGF2YWlsYWJsZSBwcm9wZXJ0aWVzLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHNldERlZmF1bHRQbGF5UHJvcHNcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc3JjIG9yIElEIHVzZWQgdG8gcmVnaXN0ZXIgdGhlIGF1ZGlvLlxuXHQgKiBAcGFyYW0ge09iamVjdCB8IFBsYXlQcm9wc0NvbmZpZ30gcGxheVByb3BzIFRoZSBwbGF5YmFjayBwcm9wZXJ0aWVzIHlvdSB3b3VsZCBsaWtlIHRvIHNldC5cblx0ICogQHNpbmNlIDAuNi4xXG5cdCAqL1xuXHRzLnNldERlZmF1bHRQbGF5UHJvcHMgPSBmdW5jdGlvbihzcmMsIHBsYXlQcm9wcykge1xuXHRcdHNyYyA9IHMuX2dldFNyY0J5SWQoc3JjKTtcblx0XHRzLl9kZWZhdWx0UGxheVByb3BzSGFzaFtzLl9wYXJzZVBhdGgoc3JjLnNyYykuc3JjXSA9IGNyZWF0ZWpzLlBsYXlQcm9wc0NvbmZpZy5jcmVhdGUocGxheVByb3BzKTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IHRoZSBkZWZhdWx0IHBsYXliYWNrIHByb3BlcnRpZXMgZm9yIHRoZSBwYXNzZWQgaW4gc3JjIG9yIElELiAgVGhlc2UgcHJvcGVydGllcyBhcmUgYXBwbGllZCB0byBhbGxcblx0ICogbmV3IFNvdW5kSW5zdGFuY2VzLiAgUmV0dXJucyBudWxsIGlmIGRlZmF1bHQgZG9lcyBub3QgZXhpc3QuXG5cdCAqXG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFBsYXlQcm9wc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzcmMgb3IgSUQgdXNlZCB0byByZWdpc3RlciB0aGUgYXVkaW8uXG5cdCAqIEByZXR1cm5zIHtQbGF5UHJvcHNDb25maWd9IHJldHVybnMgYW4gZXhpc3RpbmcgUGxheVByb3BzQ29uZmlnIG9yIG51bGwgaWYgb25lIGRvZXMgbm90IGV4aXN0XG5cdCAqIEBzaW5jZSAwLjYuMVxuXHQgKi9cblx0cy5nZXREZWZhdWx0UGxheVByb3BzID0gZnVuY3Rpb24oc3JjKSB7XG5cdFx0c3JjID0gcy5fZ2V0U3JjQnlJZChzcmMpO1xuXHRcdHJldHVybiBzLl9kZWZhdWx0UGxheVByb3BzSGFzaFtzLl9wYXJzZVBhdGgoc3JjLnNyYykuc3JjXTtcblx0fTtcblxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLVxuXHQgSW50ZXJuYWwgbWV0aG9kc1xuXHQgLS0tLS0tLS0tLS0tLS0tICovXG5cdC8qKlxuXHQgKiBQbGF5IGFuIGluc3RhbmNlLiBUaGlzIGlzIGNhbGxlZCBieSB0aGUgc3RhdGljIEFQSSwgYXMgd2VsbCBhcyBmcm9tIHBsdWdpbnMuIFRoaXMgYWxsb3dzIHRoZSBjb3JlIGNsYXNzIHRvXG5cdCAqIGNvbnRyb2wgZGVsYXlzLlxuXHQgKiBAbWV0aG9kIF9wbGF5SW5zdGFuY2Vcblx0ICogQHBhcmFtIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IGluc3RhbmNlIFRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2VcIn19e3svY3Jvc3NMaW5rfX0gdG8gc3RhcnQgcGxheWluZy5cblx0ICogQHBhcmFtIHtQbGF5UHJvcHNDb25maWd9IHBsYXlQcm9wcyBBIFBsYXlQcm9wc0NvbmZpZyBvYmplY3QuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBzb3VuZCBjYW4gc3RhcnQgcGxheWluZy4gU291bmRzIHRoYXQgZmFpbCBpbW1lZGlhdGVseSB3aWxsIHJldHVybiBmYWxzZS4gU291bmRzIHRoYXRcblx0ICogaGF2ZSBhIGRlbGF5IHdpbGwgcmV0dXJuIHRydWUsIGJ1dCBtYXkgc3RpbGwgZmFpbCB0byBwbGF5LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuX3BsYXlJbnN0YW5jZSA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgcGxheVByb3BzKSB7XG5cdFx0dmFyIGRlZmF1bHRQbGF5UHJvcHMgPSBzLl9kZWZhdWx0UGxheVByb3BzSGFzaFtpbnN0YW5jZS5zcmNdIHx8IHt9O1xuXHRcdGlmIChwbGF5UHJvcHMuaW50ZXJydXB0ID09IG51bGwpIHtwbGF5UHJvcHMuaW50ZXJydXB0ID0gZGVmYXVsdFBsYXlQcm9wcy5pbnRlcnJ1cHQgfHwgcy5kZWZhdWx0SW50ZXJydXB0QmVoYXZpb3J9O1xuXHRcdGlmIChwbGF5UHJvcHMuZGVsYXkgPT0gbnVsbCkge3BsYXlQcm9wcy5kZWxheSA9IGRlZmF1bHRQbGF5UHJvcHMuZGVsYXkgfHwgMDt9XG5cdFx0aWYgKHBsYXlQcm9wcy5vZmZzZXQgPT0gbnVsbCkge3BsYXlQcm9wcy5vZmZzZXQgPSBpbnN0YW5jZS5nZXRQb3NpdGlvbigpO31cblx0XHRpZiAocGxheVByb3BzLmxvb3AgPT0gbnVsbCkge3BsYXlQcm9wcy5sb29wID0gaW5zdGFuY2UubG9vcDt9XG5cdFx0aWYgKHBsYXlQcm9wcy52b2x1bWUgPT0gbnVsbCkge3BsYXlQcm9wcy52b2x1bWUgPSBpbnN0YW5jZS52b2x1bWU7fVxuXHRcdGlmIChwbGF5UHJvcHMucGFuID09IG51bGwpIHtwbGF5UHJvcHMucGFuID0gaW5zdGFuY2UucGFuO31cblxuXHRcdGlmIChwbGF5UHJvcHMuZGVsYXkgPT0gMCkge1xuXHRcdFx0dmFyIG9rID0gcy5fYmVnaW5QbGF5aW5nKGluc3RhbmNlLCBwbGF5UHJvcHMpO1xuXHRcdFx0aWYgKCFvaykge3JldHVybiBmYWxzZTt9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vTm90ZSB0aGF0IHdlIGNhbid0IHBhc3MgYXJndW1lbnRzIHRvIHByb3h5IE9SIHNldFRpbWVvdXQgKElFIG9ubHkpLCBzbyBqdXN0IHdyYXAgdGhlIGZ1bmN0aW9uIGNhbGwuXG5cdFx0XHQvLyBPSlIgV2ViQXVkaW8gbWF5IHdhbnQgdG8gaGFuZGxlIHRoaXMgZGlmZmVyZW50bHksIHNvIGl0IG1pZ2h0IG1ha2Ugc2Vuc2UgdG8gbW92ZSB0aGlzIGZ1bmN0aW9uYWxpdHkgaW50byB0aGUgcGx1Z2lucyBpbiB0aGUgZnV0dXJlXG5cdFx0XHR2YXIgZGVsYXlUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cy5fYmVnaW5QbGF5aW5nKGluc3RhbmNlLCBwbGF5UHJvcHMpO1xuXHRcdFx0fSwgcGxheVByb3BzLmRlbGF5KTtcblx0XHRcdGluc3RhbmNlLmRlbGF5VGltZW91dElkID0gZGVsYXlUaW1lb3V0SWQ7XG5cdFx0fVxuXG5cdFx0dGhpcy5faW5zdGFuY2VzLnB1c2goaW5zdGFuY2UpO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2luIHBsYXliYWNrLiBUaGlzIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBvciBhZnRlciBkZWxheSBieSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9wbGF5SW5zdGFuY2VcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgX2JlZ2luUGxheWluZ1xuXHQgKiBAcGFyYW0ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gaW5zdGFuY2UgQSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2VcIn19e3svY3Jvc3NMaW5rfX0gdG8gYmVnaW4gcGxheWJhY2suXG5cdCAqIEBwYXJhbSB7UGxheVByb3BzQ29uZmlnfSBwbGF5UHJvcHMgQSBQbGF5UHJvcHNDb25maWcgb2JqZWN0LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgc291bmQgY2FuIHN0YXJ0IHBsYXlpbmcuIElmIHRoZXJlIGFyZSBubyBhdmFpbGFibGUgY2hhbm5lbHMsIG9yIHRoZSBpbnN0YW5jZSBmYWlscyB0b1xuXHQgKiBzdGFydCwgdGhpcyB3aWxsIHJldHVybiBmYWxzZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLl9iZWdpblBsYXlpbmcgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIHBsYXlQcm9wcykge1xuXHRcdGlmICghU291bmRDaGFubmVsLmFkZChpbnN0YW5jZSwgcGxheVByb3BzLmludGVycnVwdCkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0dmFyIHJlc3VsdCA9IGluc3RhbmNlLl9iZWdpblBsYXlpbmcocGxheVByb3BzKTtcblx0XHRpZiAoIXJlc3VsdCkge1xuXHRcdFx0dmFyIGluZGV4ID0gY3JlYXRlanMuaW5kZXhPZih0aGlzLl9pbnN0YW5jZXMsIGluc3RhbmNlKTtcblx0XHRcdGlmIChpbmRleCA+IC0xKSB7dGhpcy5faW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IHRoZSBzb3VyY2Ugb2YgYSBzb3VuZCB2aWEgdGhlIElEIHBhc3NlZCBpbiB3aXRoIGEgcmVnaXN0ZXIgY2FsbC4gSWYgbm8gSUQgaXMgZm91bmQgdGhlIHZhbHVlIGlzIHJldHVybmVkXG5cdCAqIGluc3RlYWQuXG5cdCAqIEBtZXRob2QgX2dldFNyY0J5SWRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSBJRCB0aGUgc291bmQgd2FzIHJlZ2lzdGVyZWQgd2l0aC5cblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgc291cmNlIG9mIHRoZSBzb3VuZCBpZiBpdCBoYXMgYmVlbiByZWdpc3RlcmVkIHdpdGggdGhpcyBJRCBvciB0aGUgdmFsdWUgdGhhdCB3YXMgcGFzc2VkIGluLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuX2dldFNyY0J5SWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRyZXR1cm4gcy5faWRIYXNoW3ZhbHVlXSB8fCB7c3JjOiB2YWx1ZX07XG5cdH07XG5cblx0LyoqXG5cdCAqIEEgc291bmQgaGFzIGNvbXBsZXRlZCBwbGF5YmFjaywgYmVlbiBpbnRlcnJ1cHRlZCwgZmFpbGVkLCBvciBiZWVuIHN0b3BwZWQuIFRoaXMgbWV0aG9kIHJlbW92ZXMgdGhlIGluc3RhbmNlIGZyb21cblx0ICogU291bmQgbWFuYWdlbWVudC4gSXQgd2lsbCBiZSBhZGRlZCBhZ2FpbiwgaWYgdGhlIHNvdW5kIHJlLXBsYXlzLiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgaXMgY2FsbGVkIGZyb20gdGhlXG5cdCAqIGluc3RhbmNlcyB0aGVtc2VsdmVzLlxuXHQgKiBAbWV0aG9kIF9wbGF5RmluaXNoZWRcblx0ICogQHBhcmFtIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IGluc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IGZpbmlzaGVkIHBsYXliYWNrLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuX3BsYXlGaW5pc2hlZCA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuXHRcdFNvdW5kQ2hhbm5lbC5yZW1vdmUoaW5zdGFuY2UpO1xuXHRcdHZhciBpbmRleCA9IGNyZWF0ZWpzLmluZGV4T2YodGhpcy5faW5zdGFuY2VzLCBpbnN0YW5jZSk7XG5cdFx0aWYgKGluZGV4ID4gLTEpIHt0aGlzLl9pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTt9XHQvLyBPSlIgdGhpcyB3aWxsIGFsd2F5cyBiZSA+IC0xLCB0aGVyZSBpcyBubyB3YXkgZm9yIGFuIGluc3RhbmNlIHRvIGV4aXN0IHdpdGhvdXQgYmVpbmcgYWRkZWQgdG8gdGhpcy5faW5zdGFuY2VzXG5cdH07XG5cblx0Y3JlYXRlanMuU291bmQgPSBTb3VuZDtcblxuXHQvKipcblx0ICogQW4gaW50ZXJuYWwgY2xhc3MgdGhhdCBtYW5hZ2VzIHRoZSBudW1iZXIgb2YgYWN0aXZlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZXMgZm9yXG5cdCAqIGVhY2ggc291bmQgdHlwZS4gVGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGludGVybmFsbHkgYnkgdGhlIHt7I2Nyb3NzTGluayBcIlNvdW5kXCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzLlxuXHQgKlxuXHQgKiBUaGUgbnVtYmVyIG9mIHNvdW5kcyBpcyBhcnRpZmljaWFsbHkgbGltaXRlZCBieSBTb3VuZCBpbiBvcmRlciB0byBwcmV2ZW50IG92ZXItc2F0dXJhdGlvbiBvZiBhXG5cdCAqIHNpbmdsZSBzb3VuZCwgYXMgd2VsbCBhcyB0byBzdGF5IHdpdGhpbiBoYXJkd2FyZSBsaW1pdGF0aW9ucywgYWx0aG91Z2ggdGhlIGxhdHRlciBtYXkgZGlzYXBwZWFyIHdpdGggYmV0dGVyXG5cdCAqIGJyb3dzZXIgc3VwcG9ydC5cblx0ICpcblx0ICogV2hlbiBhIHNvdW5kIGlzIHBsYXllZCwgdGhpcyBjbGFzcyBlbnN1cmVzIHRoYXQgdGhlcmUgaXMgYW4gYXZhaWxhYmxlIGluc3RhbmNlLCBvciBpbnRlcnJ1cHRzIGFuIGFwcHJvcHJpYXRlXG5cdCAqIHNvdW5kIHRoYXQgaXMgYWxyZWFkeSBwbGF5aW5nLlxuXHQgKiAjY2xhc3MgU291bmRDaGFubmVsXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBvZiB0aGUgaW5zdGFuY2VzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4PTFdIFRoZSBudW1iZXIgb2YgaW5zdGFuY2VzIGFsbG93ZWRcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGZ1bmN0aW9uIFNvdW5kQ2hhbm5lbChzcmMsIG1heCkge1xuXHRcdHRoaXMuaW5pdChzcmMsIG1heCk7XG5cdH1cblxuXHQvKiAtLS0tLS0tLS0tLS1cblx0IFN0YXRpYyBBUElcblx0IC0tLS0tLS0tLS0tLSAqL1xuXHQvKipcblx0ICogQSBoYXNoIG9mIGNoYW5uZWwgaW5zdGFuY2VzIGluZGV4ZWQgYnkgc291cmNlLlxuXHQgKiAjcHJvcGVydHkgY2hhbm5lbHNcblx0ICogQHR5cGUge09iamVjdH1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0U291bmRDaGFubmVsLmNoYW5uZWxzID0ge307XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIHNvdW5kIGNoYW5uZWwuIE5vdGUgdGhhdCBpZiB0aGUgc291bmQgY2hhbm5lbCBhbHJlYWR5IGV4aXN0cywgdGhpcyB3aWxsIGZhaWwuXG5cdCAqICNtZXRob2QgY3JlYXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBmb3IgdGhlIGNoYW5uZWxcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1heCBUaGUgbWF4aW11bSBhbW91bnQgdGhpcyBjaGFubmVsIGhvbGRzLiBUaGUgZGVmYXVsdCBpcyB7eyNjcm9zc0xpbmsgXCJTb3VuZENoYW5uZWwubWF4RGVmYXVsdFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIGNoYW5uZWxzIHdlcmUgY3JlYXRlZC5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0U291bmRDaGFubmVsLmNyZWF0ZSA9IGZ1bmN0aW9uIChzcmMsIG1heCkge1xuXHRcdHZhciBjaGFubmVsID0gU291bmRDaGFubmVsLmdldChzcmMpO1xuXHRcdGlmIChjaGFubmVsID09IG51bGwpIHtcblx0XHRcdFNvdW5kQ2hhbm5lbC5jaGFubmVsc1tzcmNdID0gbmV3IFNvdW5kQ2hhbm5lbChzcmMsIG1heCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXHQvKipcblx0ICogRGVsZXRlIGEgc291bmQgY2hhbm5lbCwgc3RvcCBhbmQgZGVsZXRlIGFsbCByZWxhdGVkIGluc3RhbmNlcy4gTm90ZSB0aGF0IGlmIHRoZSBzb3VuZCBjaGFubmVsIGRvZXMgbm90IGV4aXN0LCB0aGlzIHdpbGwgZmFpbC5cblx0ICogI21ldGhvZCByZW1vdmVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291cmNlIGZvciB0aGUgY2hhbm5lbFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgY2hhbm5lbHMgd2VyZSBkZWxldGVkLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRTb3VuZENoYW5uZWwucmVtb3ZlU3JjID0gZnVuY3Rpb24gKHNyYykge1xuXHRcdHZhciBjaGFubmVsID0gU291bmRDaGFubmVsLmdldChzcmMpO1xuXHRcdGlmIChjaGFubmVsID09IG51bGwpIHtyZXR1cm4gZmFsc2U7fVxuXHRcdGNoYW5uZWwuX3JlbW92ZUFsbCgpO1x0Ly8gdGhpcyBzdG9wcyBhbmQgcmVtb3ZlcyBhbGwgYWN0aXZlIGluc3RhbmNlc1xuXHRcdGRlbGV0ZShTb3VuZENoYW5uZWwuY2hhbm5lbHNbc3JjXSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdC8qKlxuXHQgKiBEZWxldGUgYWxsIHNvdW5kIGNoYW5uZWxzLCBzdG9wIGFuZCBkZWxldGUgYWxsIHJlbGF0ZWQgaW5zdGFuY2VzLlxuXHQgKiAjbWV0aG9kIHJlbW92ZUFsbFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRTb3VuZENoYW5uZWwucmVtb3ZlQWxsID0gZnVuY3Rpb24gKCkge1xuXHRcdGZvcih2YXIgY2hhbm5lbCBpbiBTb3VuZENoYW5uZWwuY2hhbm5lbHMpIHtcblx0XHRcdFNvdW5kQ2hhbm5lbC5jaGFubmVsc1tjaGFubmVsXS5fcmVtb3ZlQWxsKCk7XHQvLyB0aGlzIHN0b3BzIGFuZCByZW1vdmVzIGFsbCBhY3RpdmUgaW5zdGFuY2VzXG5cdFx0fVxuXHRcdFNvdW5kQ2hhbm5lbC5jaGFubmVscyA9IHt9O1xuXHR9O1xuXHQvKipcblx0ICogQWRkIGFuIGluc3RhbmNlIHRvIGEgc291bmQgY2hhbm5lbC5cblx0ICogI21ldGhvZCBhZGRcblx0ICogQHBhcmFtIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IGluc3RhbmNlIFRoZSBpbnN0YW5jZSB0byBhZGQgdG8gdGhlIGNoYW5uZWxcblx0ICogQHBhcmFtIHtTdHJpbmd9IGludGVycnVwdCBUaGUgaW50ZXJydXB0IHZhbHVlIHRvIHVzZS4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiU291bmQvcGxheVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscyBvbiBpbnRlcnJ1cHQgbW9kZXMuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRoZSBzdWNjZXNzIG9mIHRoZSBtZXRob2QgY2FsbC4gSWYgdGhlIGNoYW5uZWwgaXMgZnVsbCwgaXQgd2lsbCByZXR1cm4gZmFsc2UuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFNvdW5kQ2hhbm5lbC5hZGQgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGludGVycnVwdCkge1xuXHRcdHZhciBjaGFubmVsID0gU291bmRDaGFubmVsLmdldChpbnN0YW5jZS5zcmMpO1xuXHRcdGlmIChjaGFubmVsID09IG51bGwpIHtyZXR1cm4gZmFsc2U7fVxuXHRcdHJldHVybiBjaGFubmVsLl9hZGQoaW5zdGFuY2UsIGludGVycnVwdCk7XG5cdH07XG5cdC8qKlxuXHQgKiBSZW1vdmUgYW4gaW5zdGFuY2UgZnJvbSB0aGUgY2hhbm5lbC5cblx0ICogI21ldGhvZCByZW1vdmVcblx0ICogQHBhcmFtIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IGluc3RhbmNlIFRoZSBpbnN0YW5jZSB0byByZW1vdmUgZnJvbSB0aGUgY2hhbm5lbFxuXHQgKiBAcmV0dXJuIFRoZSBzdWNjZXNzIG9mIHRoZSBtZXRob2QgY2FsbC4gSWYgdGhlcmUgaXMgbm8gY2hhbm5lbCwgaXQgd2lsbCByZXR1cm4gZmFsc2UuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFNvdW5kQ2hhbm5lbC5yZW1vdmUgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcblx0XHR2YXIgY2hhbm5lbCA9IFNvdW5kQ2hhbm5lbC5nZXQoaW5zdGFuY2Uuc3JjKTtcblx0XHRpZiAoY2hhbm5lbCA9PSBudWxsKSB7cmV0dXJuIGZhbHNlO31cblx0XHRjaGFubmVsLl9yZW1vdmUoaW5zdGFuY2UpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHQvKipcblx0ICogR2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiBzb3VuZHMgeW91IGNhbiBoYXZlIGluIGEgY2hhbm5lbC5cblx0ICogI21ldGhvZCBtYXhQZXJDaGFubmVsXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNvdW5kcyB5b3UgY2FuIGhhdmUgaW4gYSBjaGFubmVsLlxuXHQgKi9cblx0U291bmRDaGFubmVsLm1heFBlckNoYW5uZWwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHAubWF4RGVmYXVsdDtcblx0fTtcblx0LyoqXG5cdCAqIEdldCBhIGNoYW5uZWwgaW5zdGFuY2UgYnkgaXRzIHNyYy5cblx0ICogI21ldGhvZCBnZXRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc3JjIHRvIHVzZSB0byBsb29rIHVwIHRoZSBjaGFubmVsXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFNvdW5kQ2hhbm5lbC5nZXQgPSBmdW5jdGlvbiAoc3JjKSB7XG5cdFx0cmV0dXJuIFNvdW5kQ2hhbm5lbC5jaGFubmVsc1tzcmNdO1xuXHR9O1xuXG5cdHZhciBwID0gU291bmRDaGFubmVsLnByb3RvdHlwZTtcblx0cC5jb25zdHJ1Y3RvciA9IFNvdW5kQ2hhbm5lbDtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblxuXHQvKipcblx0ICogVGhlIHNvdXJjZSBvZiB0aGUgY2hhbm5lbC5cblx0ICogI3Byb3BlcnR5IHNyY1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKi9cblx0cC5zcmMgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgaW5zdGFuY2VzIGluIHRoaXMgY2hhbm5lbC4gIC0xIGluZGljYXRlcyBubyBsaW1pdFxuXHQgKiAjcHJvcGVydHkgbWF4XG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqL1xuXHRwLm1heCA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFRoZSBkZWZhdWx0IHZhbHVlIHRvIHNldCBmb3IgbWF4LCBpZiBpdCBpc24ndCBwYXNzZWQgaW4uICBBbHNvIHVzZWQgaWYgLTEgaXMgcGFzc2VkLlxuXHQgKiAjcHJvcGVydHkgbWF4RGVmYXVsdFxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAxMDBcblx0ICogQHNpbmNlIDAuNC4wXG5cdCAqL1xuXHRwLm1heERlZmF1bHQgPSAxMDA7XG5cblx0LyoqXG5cdCAqIFRoZSBjdXJyZW50IG51bWJlciBvZiBhY3RpdmUgaW5zdGFuY2VzLlxuXHQgKiAjcHJvcGVydHkgbGVuZ3RoXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqL1xuXHRwLmxlbmd0aCA9IDA7XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIGNoYW5uZWwuXG5cdCAqICNtZXRob2QgaW5pdFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VyY2Ugb2YgdGhlIGNoYW5uZWxcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1heCBUaGUgbWF4aW11bSBudW1iZXIgb2YgaW5zdGFuY2VzIGluIHRoZSBjaGFubmVsXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuaW5pdCA9IGZ1bmN0aW9uIChzcmMsIG1heCkge1xuXHRcdHRoaXMuc3JjID0gc3JjO1xuXHRcdHRoaXMubWF4ID0gbWF4IHx8IHRoaXMubWF4RGVmYXVsdDtcblx0XHRpZiAodGhpcy5tYXggPT0gLTEpIHt0aGlzLm1heCA9IHRoaXMubWF4RGVmYXVsdDt9XG5cdFx0dGhpcy5faW5zdGFuY2VzID0gW107XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCBhbiBpbnN0YW5jZSBieSBpbmRleC5cblx0ICogI21ldGhvZCBnZXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCB0byByZXR1cm4uXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gVGhlIEFic3RyYWN0U291bmRJbnN0YW5jZSBhdCBhIHNwZWNpZmljIGluc3RhbmNlLlxuXHQgKi9cblx0cC5fZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0cmV0dXJuIHRoaXMuX2luc3RhbmNlc1tpbmRleF07XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZCBhIG5ldyBpbnN0YW5jZSB0byB0aGUgY2hhbm5lbC5cblx0ICogI21ldGhvZCBhZGRcblx0ICogQHBhcmFtIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IGluc3RhbmNlIFRoZSBpbnN0YW5jZSB0byBhZGQuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRoZSBzdWNjZXNzIG9mIHRoZSBtZXRob2QgY2FsbC4gSWYgdGhlIGNoYW5uZWwgaXMgZnVsbCwgaXQgd2lsbCByZXR1cm4gZmFsc2UuXG5cdCAqL1xuXHRwLl9hZGQgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGludGVycnVwdCkge1xuXHRcdGlmICghdGhpcy5fZ2V0U2xvdChpbnRlcnJ1cHQsIGluc3RhbmNlKSkge3JldHVybiBmYWxzZTt9XG5cdFx0dGhpcy5faW5zdGFuY2VzLnB1c2goaW5zdGFuY2UpO1xuXHRcdHRoaXMubGVuZ3RoKys7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbiBpbnN0YW5jZSBmcm9tIHRoZSBjaGFubmVsLCBlaXRoZXIgd2hlbiBpdCBoYXMgZmluaXNoZWQgcGxheWluZywgb3IgaXQgaGFzIGJlZW4gaW50ZXJydXB0ZWQuXG5cdCAqICNtZXRob2QgcmVtb3ZlXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBpbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gcmVtb3ZlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRoZSBzdWNjZXNzIG9mIHRoZSByZW1vdmUgY2FsbC4gSWYgdGhlIGluc3RhbmNlIGlzIG5vdCBmb3VuZCBpbiB0aGlzIGNoYW5uZWwsIGl0IHdpbGxcblx0ICogcmV0dXJuIGZhbHNlLlxuXHQgKi9cblx0cC5fcmVtb3ZlID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG5cdFx0dmFyIGluZGV4ID0gY3JlYXRlanMuaW5kZXhPZih0aGlzLl9pbnN0YW5jZXMsIGluc3RhbmNlKTtcblx0XHRpZiAoaW5kZXggPT0gLTEpIHtyZXR1cm4gZmFsc2U7fVxuXHRcdHRoaXMuX2luc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdHRoaXMubGVuZ3RoLS07XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3AgcGxheWJhY2sgYW5kIHJlbW92ZSBhbGwgaW5zdGFuY2VzIGZyb20gdGhlIGNoYW5uZWwuICBVc3VhbGx5IGluIHJlc3BvbnNlIHRvIGEgZGVsZXRlIGNhbGwuXG5cdCAqICNtZXRob2QgcmVtb3ZlQWxsXG5cdCAqL1xuXHRwLl9yZW1vdmVBbGwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gTm90ZSB0aGF0IHN0b3AoKSByZW1vdmVzIHRoZSBpdGVtIGZyb20gdGhlIGxpc3Rcblx0XHRmb3IgKHZhciBpPXRoaXMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuXHRcdFx0dGhpcy5faW5zdGFuY2VzW2ldLnN0b3AoKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCBhbiBhdmFpbGFibGUgc2xvdCBkZXBlbmRpbmcgb24gaW50ZXJydXB0IHZhbHVlIGFuZCBpZiBzbG90cyBhcmUgYXZhaWxhYmxlLlxuXHQgKiAjbWV0aG9kIGdldFNsb3Rcblx0ICogQHBhcmFtIHtTdHJpbmd9IGludGVycnVwdCBUaGUgaW50ZXJydXB0IHZhbHVlIHRvIHVzZS5cblx0ICogQHBhcmFtIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IGluc3RhbmNlIFRoZSBzb3VuZCBpbnN0YW5jZSB0aGF0IHdpbGwgZ28gaW4gdGhlIGNoYW5uZWwgaWYgc3VjY2Vzc2Z1bC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gRGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBhbiBhdmFpbGFibGUgc2xvdC4gRGVwZW5kaW5nIG9uIHRoZSBpbnRlcnJ1cHQgbW9kZSwgaWYgdGhlcmUgYXJlIG5vIHNsb3RzLFxuXHQgKiBhbiBleGlzdGluZyBBYnN0cmFjdFNvdW5kSW5zdGFuY2UgbWF5IGJlIGludGVycnVwdGVkLiBJZiB0aGVyZSBhcmUgbm8gc2xvdHMsIHRoaXMgbWV0aG9kIHJldHVybnMgZmFsc2UuXG5cdCAqL1xuXHRwLl9nZXRTbG90ID0gZnVuY3Rpb24gKGludGVycnVwdCwgaW5zdGFuY2UpIHtcblx0XHR2YXIgdGFyZ2V0LCByZXBsYWNlbWVudDtcblxuXHRcdGlmIChpbnRlcnJ1cHQgIT0gU291bmQuSU5URVJSVVBUX05PTkUpIHtcblx0XHRcdC8vIEZpcnN0IHJlcGxhY2VtZW50IGNhbmRpZGF0ZVxuXHRcdFx0cmVwbGFjZW1lbnQgPSB0aGlzLl9nZXQoMCk7XG5cdFx0XHRpZiAocmVwbGFjZW1lbnQgPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubWF4OyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR0YXJnZXQgPSB0aGlzLl9nZXQoaSk7XG5cblx0XHRcdC8vIEF2YWlsYWJsZSBTcGFjZVxuXHRcdFx0aWYgKHRhcmdldCA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBdWRpbyBpcyBjb21wbGV0ZSBvciBub3QgcGxheWluZ1xuXHRcdFx0aWYgKHRhcmdldC5wbGF5U3RhdGUgPT0gU291bmQuUExBWV9GSU5JU0hFRCB8fFxuXHRcdFx0XHR0YXJnZXQucGxheVN0YXRlID09IFNvdW5kLlBMQVlfSU5URVJSVVBURUQgfHxcblx0XHRcdFx0dGFyZ2V0LnBsYXlTdGF0ZSA9PSBTb3VuZC5QTEFZX0ZBSUxFRCkge1xuXHRcdFx0XHRyZXBsYWNlbWVudCA9IHRhcmdldDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpbnRlcnJ1cHQgPT0gU291bmQuSU5URVJSVVBUX05PTkUpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEF1ZGlvIGlzIGEgYmV0dGVyIGNhbmRpZGF0ZSB0aGFuIHRoZSBjdXJyZW50IHRhcmdldCwgYWNjb3JkaW5nIHRvIHBsYXloZWFkXG5cdFx0XHRpZiAoKGludGVycnVwdCA9PSBTb3VuZC5JTlRFUlJVUFRfRUFSTFkgJiYgdGFyZ2V0LmdldFBvc2l0aW9uKCkgPCByZXBsYWNlbWVudC5nZXRQb3NpdGlvbigpKSB8fFxuXHRcdFx0XHQoaW50ZXJydXB0ID09IFNvdW5kLklOVEVSUlVQVF9MQVRFICYmIHRhcmdldC5nZXRQb3NpdGlvbigpID4gcmVwbGFjZW1lbnQuZ2V0UG9zaXRpb24oKSkpIHtcblx0XHRcdFx0XHRyZXBsYWNlbWVudCA9IHRhcmdldDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAocmVwbGFjZW1lbnQgIT0gbnVsbCkge1xuXHRcdFx0cmVwbGFjZW1lbnQuX2ludGVycnVwdCgpO1xuXHRcdFx0dGhpcy5fcmVtb3ZlKHJlcGxhY2VtZW50KTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbU291bmQgU291bmRDaGFubmVsXVwiO1xuXHR9O1xuXHQvLyBkbyBub3QgYWRkIFNvdW5kQ2hhbm5lbCB0byBuYW1lc3BhY2VcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEFic3RyYWN0U291bmRJbnN0YW5jZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuLyoqXG4gKiBBIEFic3RyYWN0U291bmRJbnN0YW5jZSBpcyBjcmVhdGVkIHdoZW4gYW55IGNhbGxzIHRvIHRoZSBTb3VuZCBBUEkgbWV0aG9kIHt7I2Nyb3NzTGluayBcIlNvdW5kL3BsYXlcIn19e3svY3Jvc3NMaW5rfX0gb3JcbiAqIHt7I2Nyb3NzTGluayBcIlNvdW5kL2NyZWF0ZUluc3RhbmNlXCJ9fXt7L2Nyb3NzTGlua319IGFyZSBtYWRlLiBUaGUgQWJzdHJhY3RTb3VuZEluc3RhbmNlIGlzIHJldHVybmVkIGJ5IHRoZSBhY3RpdmUgcGx1Z2luXG4gKiBmb3IgY29udHJvbCBieSB0aGUgdXNlci5cbiAqXG4gKiA8aDQ+RXhhbXBsZTwvaDQ+XG4gKlxuICogICAgICB2YXIgbXlJbnN0YW5jZSA9IGNyZWF0ZWpzLlNvdW5kLnBsYXkoXCJteUFzc2V0UGF0aC9teVNyY0ZpbGUubXAzXCIpO1xuICpcbiAqIEEgbnVtYmVyIG9mIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBwcm92aWRlIGEgcXVpY2sgd2F5IHRvIGRldGVybWluZSBob3cgYSBzb3VuZCBpcyBwbGF5ZWQuIFBsZWFzZSBzZWUgdGhlIFNvdW5kXG4gKiBBUEkgbWV0aG9kIHt7I2Nyb3NzTGluayBcIlNvdW5kL3BsYXlcIn19e3svY3Jvc3NMaW5rfX0gZm9yIGEgbGlzdCBvZiBhcmd1bWVudHMuXG4gKlxuICogT25jZSBhIEFic3RyYWN0U291bmRJbnN0YW5jZSBpcyBjcmVhdGVkLCBhIHJlZmVyZW5jZSBjYW4gYmUgc3RvcmVkIHRoYXQgY2FuIGJlIHVzZWQgdG8gY29udHJvbCB0aGUgYXVkaW8gZGlyZWN0bHkgdGhyb3VnaFxuICogdGhlIEFic3RyYWN0U291bmRJbnN0YW5jZS4gSWYgdGhlIHJlZmVyZW5jZSBpcyBub3Qgc3RvcmVkLCB0aGUgQWJzdHJhY3RTb3VuZEluc3RhbmNlIHdpbGwgcGxheSBvdXQgaXRzIGF1ZGlvIChhbmQgYW55IGxvb3BzKSwgYW5kXG4gKiBpcyB0aGVuIGRlLXJlZmVyZW5jZWQgZnJvbSB0aGUge3sjY3Jvc3NMaW5rIFwiU291bmRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3Mgc28gdGhhdCBpdCBjYW4gYmUgY2xlYW5lZCB1cC4gSWYgYXVkaW9cbiAqIHBsYXliYWNrIGhhcyBjb21wbGV0ZWQsIGEgc2ltcGxlIGNhbGwgdG8gdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9wbGF5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlIG1ldGhvZFxuICogd2lsbCByZWJ1aWxkIHRoZSByZWZlcmVuY2VzIHRoZSBTb3VuZCBjbGFzcyBuZWVkIHRvIGNvbnRyb2wgaXQuXG4gKlxuICogICAgICB2YXIgbXlJbnN0YW5jZSA9IGNyZWF0ZWpzLlNvdW5kLnBsYXkoXCJteUFzc2V0UGF0aC9teVNyY0ZpbGUubXAzXCIsIHtsb29wOjJ9KTtcbiAqICAgICAgbXlJbnN0YW5jZS5vbihcImxvb3BcIiwgaGFuZGxlTG9vcCk7XG4gKiAgICAgIGZ1bmN0aW9uIGhhbmRsZUxvb3AoZXZlbnQpIHtcbiAqICAgICAgICAgIG15SW5zdGFuY2Uudm9sdW1lID0gbXlJbnN0YW5jZS52b2x1bWUgKiAwLjU7XG4gKiAgICAgIH1cbiAqXG4gKiBFdmVudHMgYXJlIGRpc3BhdGNoZWQgZnJvbSB0aGUgaW5zdGFuY2UgdG8gbm90aWZ5IHdoZW4gdGhlIHNvdW5kIGhhcyBjb21wbGV0ZWQsIGxvb3BlZCwgb3Igd2hlbiBwbGF5YmFjayBmYWlsc1xuICpcbiAqICAgICAgdmFyIG15SW5zdGFuY2UgPSBjcmVhdGVqcy5Tb3VuZC5wbGF5KFwibXlBc3NldFBhdGgvbXlTcmNGaWxlLm1wM1wiKTtcbiAqICAgICAgbXlJbnN0YW5jZS5vbihcImNvbXBsZXRlXCIsIGhhbmRsZUNvbXBsZXRlKTtcbiAqICAgICAgbXlJbnN0YW5jZS5vbihcImxvb3BcIiwgaGFuZGxlTG9vcCk7XG4gKiAgICAgIG15SW5zdGFuY2Uub24oXCJmYWlsZWRcIiwgaGFuZGxlRmFpbGVkKTtcbiAqXG4gKlxuICogQGNsYXNzIEFic3RyYWN0U291bmRJbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgcGF0aCB0byBhbmQgZmlsZSBuYW1lIG9mIHRoZSBzb3VuZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFRpbWUgQXVkaW8gc3ByaXRlIHByb3BlcnR5IHVzZWQgdG8gYXBwbHkgYW4gb2Zmc2V0LCBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gQXVkaW8gc3ByaXRlIHByb3BlcnR5IHVzZWQgdG8gc2V0IHRoZSB0aW1lIHRoZSBjbGlwIHBsYXlzIGZvciwgaW4gbWlsbGlzZWNvbmRzLlxuICogQHBhcmFtIHtPYmplY3R9IHBsYXliYWNrUmVzb3VyY2UgQW55IHJlc291cmNlIG5lZWRlZCBieSBwbHVnaW4gdG8gc3VwcG9ydCBhdWRpbyBwbGF5YmFjay5cbiAqIEBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlclxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gQ29uc3RydWN0b3I6XG5cdHZhciBBYnN0cmFjdFNvdW5kSW5zdGFuY2UgPSBmdW5jdGlvbiAoc3JjLCBzdGFydFRpbWUsIGR1cmF0aW9uLCBwbGF5YmFja1Jlc291cmNlKSB7XG5cdFx0dGhpcy5FdmVudERpc3BhdGNoZXJfY29uc3RydWN0b3IoKTtcblxuXG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSBzb3VyY2Ugb2YgdGhlIHNvdW5kLlxuXHRcdCAqIEBwcm9wZXJ0eSBzcmNcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnNyYyA9IHNyYztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIGluc3RhbmNlLiBUaGlzIGlzIHNldCBieSB7eyNjcm9zc0xpbmsgXCJTb3VuZFwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgdW5pcXVlSWRcblx0XHQgKiBAdHlwZSB7U3RyaW5nfSB8IE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IC0xXG5cdFx0ICovXG5cdFx0dGhpcy51bmlxdWVJZCA9IC0xO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHBsYXkgc3RhdGUgb2YgdGhlIHNvdW5kLiBQbGF5IHN0YXRlcyBhcmUgZGVmaW5lZCBhcyBjb25zdGFudHMgb24ge3sjY3Jvc3NMaW5rIFwiU291bmRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IHBsYXlTdGF0ZVxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMucGxheVN0YXRlID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEEgVGltZW91dCBjcmVhdGVkIGJ5IHt7I2Nyb3NzTGluayBcIlNvdW5kXCJ9fXt7L2Nyb3NzTGlua319IHdoZW4gdGhpcyBBYnN0cmFjdFNvdW5kSW5zdGFuY2UgaXMgcGxheWVkIHdpdGggYSBkZWxheS5cblx0XHQgKiBUaGlzIGFsbG93cyBBYnN0cmFjdFNvdW5kSW5zdGFuY2UgdG8gcmVtb3ZlIHRoZSBkZWxheSBpZiBzdG9wLCBwYXVzZSwgb3IgY2xlYW51cCBhcmUgY2FsbGVkIGJlZm9yZSBwbGF5YmFjayBiZWdpbnMuXG5cdFx0ICogQHByb3BlcnR5IGRlbGF5VGltZW91dElkXG5cdFx0ICogQHR5cGUge3RpbWVvdXRWYXJpYWJsZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBzaW5jZSAwLjQuMFxuXHRcdCAqL1xuXHRcdHRoaXMuZGVsYXlUaW1lb3V0SWQgPSBudWxsO1xuXHRcdC8vIFRPRE8gY29uc2lkZXIgbW92aW5nIGRlbGF5IGludG8gQWJzdHJhY3RTb3VuZEluc3RhbmNlIHNvIGl0IGNhbiBiZSBoYW5kbGVkIGJ5IHBsdWdpbnNcblxuXG5cdC8vIHByaXZhdGUgcHJvcGVydGllc1xuXHQvLyBHZXR0ZXIgLyBTZXR0ZXIgUHJvcGVydGllc1xuXHRcdC8vIE9KUiBUT0RPIGZpbmQgb3JpZ2luYWwgcmVhc29uIHRoYXQgd2UgZGlkbid0IHVzZSBkZWZpbmVkIGZ1bmN0aW9ucy4gIEkgdGhpbmsgaXQgd2FzIHBlcmZvcm1hbmNlIHJlbGF0ZWRcblx0XHQvKipcblx0XHQgKiBUaGUgdm9sdW1lIG9mIHRoZSBzb3VuZCwgYmV0d2VlbiAwIGFuZCAxLlxuXHRcdCAqXG5cdFx0ICogVGhlIGFjdHVhbCBvdXRwdXQgdm9sdW1lIG9mIGEgc291bmQgY2FuIGJlIGNhbGN1bGF0ZWQgdXNpbmc6XG5cdFx0ICogPGNvZGU+bXlJbnN0YW5jZS52b2x1bWUgKiBjcmVhdGVqcy5Tb3VuZC5nZXRWb2x1bWUoKTs8L2NvZGU+XG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgdm9sdW1lXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0dGhpcy5fdm9sdW1lID0gIDE7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidm9sdW1lXCIsIHtcblx0XHRcdGdldDogdGhpcy5nZXRWb2x1bWUsXG5cdFx0XHRzZXQ6IHRoaXMuc2V0Vm9sdW1lXG5cdFx0fSk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcGFuIG9mIHRoZSBzb3VuZCwgYmV0d2VlbiAtMSAobGVmdCkgYW5kIDEgKHJpZ2h0KS4gTm90ZSB0aGF0IHBhbiBpcyBub3Qgc3VwcG9ydGVkIGJ5IEhUTUwgQXVkaW8uXG5cdFx0ICpcblx0XHQgKiA8YnIgLz5Ob3RlIGluIFdlYkF1ZGlvUGx1Z2luIHRoaXMgb25seSBnaXZlcyB1cyB0aGUgXCJ4XCIgdmFsdWUgb2Ygd2hhdCBpcyBhY3R1YWxseSAzRCBhdWRpby5cblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBwYW5cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLl9wYW4gPSAgMDtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYW5cIiwge1xuXHRcdFx0Z2V0OiB0aGlzLmdldFBhbixcblx0XHRcdHNldDogdGhpcy5zZXRQYW5cblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIEF1ZGlvIHNwcml0ZSBwcm9wZXJ0eSB1c2VkIHRvIGRldGVybWluZSB0aGUgc3RhcnRpbmcgb2Zmc2V0LlxuXHRcdCAqIEBwcm9wZXJ0eSBzdGFydFRpbWVcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAc2luY2UgMC42LjFcblx0XHQgKi9cblx0XHR0aGlzLl9zdGFydFRpbWUgPSBNYXRoLm1heCgwLCBzdGFydFRpbWUgfHwgMCk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhcnRUaW1lXCIsIHtcblx0XHRcdGdldDogdGhpcy5nZXRTdGFydFRpbWUsXG5cdFx0XHRzZXQ6IHRoaXMuc2V0U3RhcnRUaW1lXG5cdFx0fSk7XG5cblx0XHQvKipcblx0XHQgKiBTZXRzIG9yIGdldHMgdGhlIGxlbmd0aCBvZiB0aGUgYXVkaW8gY2xpcCwgdmFsdWUgaXMgaW4gbWlsbGlzZWNvbmRzLlxuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IGR1cmF0aW9uXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHNpbmNlIDAuNi4wXG5cdFx0ICovXG5cdFx0dGhpcy5fZHVyYXRpb24gPSBNYXRoLm1heCgwLCBkdXJhdGlvbiB8fCAwKTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkdXJhdGlvblwiLCB7XG5cdFx0XHRnZXQ6IHRoaXMuZ2V0RHVyYXRpb24sXG5cdFx0XHRzZXQ6IHRoaXMuc2V0RHVyYXRpb25cblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIE9iamVjdCB0aGF0IGhvbGRzIHBsdWdpbiBzcGVjaWZpYyByZXNvdXJjZSBuZWVkIGZvciBhdWRpbyBwbGF5YmFjay5cblx0XHQgKiBUaGlzIGlzIHNldCBpbnRlcm5hbGx5IGJ5IHRoZSBwbHVnaW4uICBGb3IgZXhhbXBsZSwgV2ViQXVkaW9QbHVnaW4gd2lsbCBzZXQgYW4gYXJyYXkgYnVmZmVyLFxuXHRcdCAqIEhUTUxBdWRpb1BsdWdpbiB3aWxsIHNldCBhIHRhZywgRmxhc2hBdWRpb1BsdWdpbiB3aWxsIHNldCBhIGZsYXNoIHJlZmVyZW5jZS5cblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBwbGF5YmFja1Jlc291cmNlXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZSA9IG51bGw7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGxheWJhY2tSZXNvdXJjZVwiLCB7XG5cdFx0XHRnZXQ6IHRoaXMuZ2V0UGxheWJhY2tSZXNvdXJjZSxcblx0XHRcdHNldDogdGhpcy5zZXRQbGF5YmFja1Jlc291cmNlXG5cdFx0fSk7XG5cdFx0aWYocGxheWJhY2tSZXNvdXJjZSAhPT0gZmFsc2UgJiYgcGxheWJhY2tSZXNvdXJjZSAhPT0gdHJ1ZSkgeyB0aGlzLnNldFBsYXliYWNrUmVzb3VyY2UocGxheWJhY2tSZXNvdXJjZSk7IH1cblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgcGxheWhlYWQgaW4gbWlsbGlzZWNvbmRzLiBUaGlzIGNhbiBiZSBzZXQgd2hpbGUgYSBzb3VuZCBpcyBwbGF5aW5nLCBwYXVzZWQsIG9yIHN0b3BwZWQuXG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgcG9zaXRpb25cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAc2luY2UgMC42LjBcblx0XHQgKi9cblx0XHR0aGlzLl9wb3NpdGlvbiA9IDA7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicG9zaXRpb25cIiwge1xuXHRcdFx0Z2V0OiB0aGlzLmdldFBvc2l0aW9uLFxuXHRcdFx0c2V0OiB0aGlzLnNldFBvc2l0aW9uXG5cdFx0fSk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIHBsYXkgbG9vcHMgcmVtYWluaW5nLiBOZWdhdGl2ZSB2YWx1ZXMgd2lsbCBsb29wIGluZmluaXRlbHkuXG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgbG9vcFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKiBAc2luY2UgMC42LjBcblx0XHQgKi9cblx0XHR0aGlzLl9sb29wID0gMDtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsb29wXCIsIHtcblx0XHRcdGdldDogdGhpcy5nZXRMb29wLFxuXHRcdFx0c2V0OiB0aGlzLnNldExvb3Bcblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIE11dGVzIG9yIHVubXV0ZXMgdGhlIGN1cnJlbnQgYXVkaW8gaW5zdGFuY2UuXG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgbXV0ZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEBzaW5jZSAwLjYuMFxuXHRcdCAqL1xuXHRcdHRoaXMuX211dGVkID0gZmFsc2U7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibXV0ZWRcIiwge1xuXHRcdFx0Z2V0OiB0aGlzLmdldE11dGVkLFxuXHRcdFx0c2V0OiB0aGlzLnNldE11dGVkXG5cdFx0fSk7XG5cblx0XHQvKipcblx0XHQgKiBQYXVzZXMgb3IgcmVzdW1lcyB0aGUgY3VycmVudCBhdWRpbyBpbnN0YW5jZS5cblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBwYXVzZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHR0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYXVzZWRcIiwge1xuXHRcdFx0Z2V0OiB0aGlzLmdldFBhdXNlZCxcblx0XHRcdHNldDogdGhpcy5zZXRQYXVzZWRcblx0XHR9KTtcblxuXG5cdC8vIEV2ZW50c1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBldmVudCB0aGF0IGlzIGZpcmVkIHdoZW4gcGxheWJhY2sgaGFzIHN0YXJ0ZWQgc3VjY2Vzc2Z1bGx5LlxuXHRcdCAqIEBldmVudCBzdWNjZWVkZWRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0XHQgKiBAc2luY2UgMC40LjBcblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBldmVudCB0aGF0IGlzIGZpcmVkIHdoZW4gcGxheWJhY2sgaXMgaW50ZXJydXB0ZWQuIFRoaXMgaGFwcGVucyB3aGVuIGFub3RoZXIgc291bmQgd2l0aCB0aGUgc2FtZVxuXHRcdCAqIHNyYyBwcm9wZXJ0eSBpcyBwbGF5ZWQgdXNpbmcgYW4gaW50ZXJydXB0IHZhbHVlIHRoYXQgY2F1c2VzIHRoaXMgaW5zdGFuY2UgdG8gc3RvcCBwbGF5aW5nLlxuXHRcdCAqIEBldmVudCBpbnRlcnJ1cHRlZFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHRcdCAqIEBzaW5jZSAwLjQuMFxuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGV2ZW50IHRoYXQgaXMgZmlyZWQgd2hlbiBwbGF5YmFjayBoYXMgZmFpbGVkLiBUaGlzIGhhcHBlbnMgd2hlbiB0aGVyZSBhcmUgdG9vIG1hbnkgY2hhbm5lbHMgd2l0aCB0aGUgc2FtZVxuXHRcdCAqIHNyYyBwcm9wZXJ0eSBhbHJlYWR5IHBsYXlpbmcgKGFuZCB0aGUgaW50ZXJydXB0IHZhbHVlIGRvZXNuJ3QgY2F1c2UgYW4gaW50ZXJydXB0IG9mIGFub3RoZXIgaW5zdGFuY2UpLCBvclxuXHRcdCAqIHRoZSBzb3VuZCBjb3VsZCBub3QgYmUgcGxheWVkLCBwZXJoYXBzIGR1ZSB0byBhIDQwNCBlcnJvci5cblx0XHQgKiBAZXZlbnQgZmFpbGVkXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdFx0ICogQHNpbmNlIDAuNC4wXG5cdFx0ICovXG5cblx0XHQvKipcblx0XHQgKiBUaGUgZXZlbnQgdGhhdCBpcyBmaXJlZCB3aGVuIGEgc291bmQgaGFzIGNvbXBsZXRlZCBwbGF5aW5nIGJ1dCBoYXMgbG9vcHMgcmVtYWluaW5nLlxuXHRcdCAqIEBldmVudCBsb29wXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdFx0ICogQHNpbmNlIDAuNC4wXG5cdFx0ICovXG5cblx0XHQvKipcblx0XHQgKiBUaGUgZXZlbnQgdGhhdCBpcyBmaXJlZCB3aGVuIHBsYXliYWNrIGNvbXBsZXRlcy4gVGhpcyBtZWFucyB0aGF0IHRoZSBzb3VuZCBoYXMgZmluaXNoZWQgcGxheWluZyBpbiBpdHNcblx0XHQgKiBlbnRpcmV0eSwgaW5jbHVkaW5nIGl0cyBsb29wIGl0ZXJhdGlvbnMuXG5cdFx0ICogQGV2ZW50IGNvbXBsZXRlXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdFx0ICogQHNpbmNlIDAuNC4wXG5cdFx0ICovXG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQWJzdHJhY3RTb3VuZEluc3RhbmNlLCBjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cbi8vIFB1YmxpYyBNZXRob2RzOlxuXHQvKipcblx0ICogUGxheSBhbiBpbnN0YW5jZS4gVGhpcyBtZXRob2QgaXMgaW50ZW5kZWQgdG8gYmUgY2FsbGVkIG9uIFNvdW5kSW5zdGFuY2VzIHRoYXQgYWxyZWFkeSBleGlzdCAoY3JlYXRlZFxuXHQgKiB3aXRoIHRoZSBTb3VuZCBBUEkge3sjY3Jvc3NMaW5rIFwiU291bmQvY3JlYXRlSW5zdGFuY2VcIn19e3svY3Jvc3NMaW5rfX0gb3Ige3sjY3Jvc3NMaW5rIFwiU291bmQvcGxheVwifX17ey9jcm9zc0xpbmt9fSkuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgbXlJbnN0YW5jZSA9IGNyZWF0ZWpzLlNvdW5kLmNyZWF0ZUluc3RhbmNlKG15U3JjKTtcblx0ICogICAgICBteUluc3RhbmNlLnBsYXkoe2ludGVycnVwdDpjcmVhdGVqcy5Tb3VuZC5JTlRFUlJVUFRfQU5ZLCBsb29wOjIsIHBhbjowLjV9KTtcblx0ICpcblx0ICogTm90ZSB0aGF0IGlmIHRoaXMgc291bmQgaXMgYWxyZWFkeSBwbGF5aW5nLCB0aGlzIGNhbGwgd2lsbCBzdGlsbCBzZXQgdGhlIHBhc3NlZCBpbiBwYXJhbWV0ZXJzLlxuXG5cdCAqIDxiPlBhcmFtZXRlcnMgRGVwcmVjYXRlZDwvYj48YnIgLz5cblx0ICogVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgbWV0aG9kIGFyZSBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGEgc2luZ2xlIHBhcmFtZXRlciB0aGF0IGlzIGFuIE9iamVjdCBvciB7eyNjcm9zc0xpbmsgXCJQbGF5UHJvcHNDb25maWdcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIEBtZXRob2QgcGxheVxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE9iamVjdH0gW2ludGVycnVwdD1cIm5vbmVcInxvcHRpb25zXSA8Yj5UaGlzIHBhcmFtZXRlciB3aWxsIGJlIHJlbmFtZWQgcGxheVByb3BzIGluIHRoZSBuZXh0IHJlbGVhc2UuPC9iPjxiciAvPlxuXHQgKiBUaGlzIHBhcmFtZXRlciBjYW4gYmUgYW4gaW5zdGFuY2Ugb2Yge3sjY3Jvc3NMaW5rIFwiUGxheVByb3BzQ29uZmlnXCJ9fXt7L2Nyb3NzTGlua319IG9yIGFuIE9iamVjdCB0aGF0IGNvbnRhaW5zIGFueSBvciBhbGwgb3B0aW9uYWwgcHJvcGVydGllcyBieSBuYW1lLFxuXHQgKiBpbmNsdWRpbmc6IGludGVycnVwdCwgZGVsYXksIG9mZnNldCwgbG9vcCwgdm9sdW1lLCBwYW4sIHN0YXJ0VGltZSwgYW5kIGR1cmF0aW9uIChzZWUgdGhlIGFib3ZlIGNvZGUgc2FtcGxlKS5cblx0ICogPGJyIC8+PHN0cm9uZz5PUjwvc3Ryb25nPjxiciAvPlxuXHQgKiA8Yj5EZXByZWNhdGVkPC9iPiBIb3cgdG8gaW50ZXJydXB0IGFueSBjdXJyZW50bHkgcGxheWluZyBpbnN0YW5jZXMgb2YgYXVkaW8gd2l0aCB0aGUgc2FtZSBzb3VyY2UsXG5cdCAqIGlmIHRoZSBtYXhpbXVtIG51bWJlciBvZiBpbnN0YW5jZXMgb2YgdGhlIHNvdW5kIGFyZSBhbHJlYWR5IHBsYXlpbmcuIFZhbHVlcyBhcmUgZGVmaW5lZCBhcyA8Y29kZT5JTlRFUlJVUFRfVFlQRTwvY29kZT5cblx0ICogY29uc3RhbnRzIG9uIHRoZSBTb3VuZCBjbGFzcywgd2l0aCB0aGUgZGVmYXVsdCBkZWZpbmVkIGJ5IHt7I2Nyb3NzTGluayBcIlNvdW5kL2RlZmF1bHRJbnRlcnJ1cHRCZWhhdmlvcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtkZWxheT0wXSA8Yj5EZXByZWNhdGVkPC9iPiBUaGUgYW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgdGhlIHN0YXJ0IG9mIGF1ZGlvIHBsYXliYWNrLCBpbiBtaWxsaXNlY29uZHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0PTBdIDxiPkRlcHJlY2F0ZWQ8L2I+IFRoZSBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGF1ZGlvIHRvIGJlZ2luIHBsYXliYWNrLCBpbiBtaWxsaXNlY29uZHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbbG9vcD0wXSA8Yj5EZXByZWNhdGVkPC9iPiBIb3cgbWFueSB0aW1lcyB0aGUgYXVkaW8gbG9vcHMgd2hlbiBpdCByZWFjaGVzIHRoZSBlbmQgb2YgcGxheWJhY2suIFRoZSBkZWZhdWx0IGlzIDAgKG5vXG5cdCAqIGxvb3BzKSwgYW5kIC0xIGNhbiBiZSB1c2VkIGZvciBpbmZpbml0ZSBwbGF5YmFjay5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt2b2x1bWU9MV0gPGI+RGVwcmVjYXRlZDwvYj4gVGhlIHZvbHVtZSBvZiB0aGUgc291bmQsIGJldHdlZW4gMCBhbmQgMS4gTm90ZSB0aGF0IHRoZSBtYXN0ZXIgdm9sdW1lIGlzIGFwcGxpZWRcblx0ICogYWdhaW5zdCB0aGUgaW5kaXZpZHVhbCB2b2x1bWUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcGFuPTBdIDxiPkRlcHJlY2F0ZWQ8L2I+IFRoZSBsZWZ0LXJpZ2h0IHBhbiBvZiB0aGUgc291bmQgKGlmIHN1cHBvcnRlZCksIGJldHdlZW4gLTEgKGxlZnQpIGFuZCAxIChyaWdodCkuXG5cdCAqIE5vdGUgdGhhdCBwYW4gaXMgbm90IHN1cHBvcnRlZCBmb3IgSFRNTCBBdWRpby5cblx0ICogQHJldHVybiB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBBIHJlZmVyZW5jZSB0byBpdHNlbGYsIGludGVuZGVkIGZvciBjaGFpbmluZyBjYWxscy5cblx0ICovXG5cdHAucGxheSA9IGZ1bmN0aW9uIChpbnRlcnJ1cHQsIGRlbGF5LCBvZmZzZXQsIGxvb3AsIHZvbHVtZSwgcGFuKSB7XG5cdFx0dmFyIHBsYXlQcm9wcztcblx0XHRpZiAoaW50ZXJydXB0IGluc3RhbmNlb2YgT2JqZWN0IHx8IGludGVycnVwdCBpbnN0YW5jZW9mIGNyZWF0ZWpzLlBsYXlQcm9wc0NvbmZpZykge1xuXHRcdFx0cGxheVByb3BzID0gY3JlYXRlanMuUGxheVByb3BzQ29uZmlnLmNyZWF0ZShpbnRlcnJ1cHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwbGF5UHJvcHMgPSBjcmVhdGVqcy5QbGF5UHJvcHNDb25maWcuY3JlYXRlKHtpbnRlcnJ1cHQ6aW50ZXJydXB0LCBkZWxheTpkZWxheSwgb2Zmc2V0Om9mZnNldCwgbG9vcDpsb29wLCB2b2x1bWU6dm9sdW1lLCBwYW46cGFufSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMucGxheVN0YXRlID09IGNyZWF0ZWpzLlNvdW5kLlBMQVlfU1VDQ0VFREVEKSB7XG5cdFx0XHR0aGlzLmFwcGx5UGxheVByb3BzKHBsYXlQcm9wcyk7XG5cdFx0XHRpZiAodGhpcy5fcGF1c2VkKSB7XHR0aGlzLnNldFBhdXNlZChmYWxzZSk7IH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5fY2xlYW5VcCgpO1xuXHRcdGNyZWF0ZWpzLlNvdW5kLl9wbGF5SW5zdGFuY2UodGhpcywgcGxheVByb3BzKTtcdC8vIG1ha2UgdGhpcyBhbiBldmVudCBkaXNwYXRjaD8/XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3AgcGxheWJhY2sgb2YgdGhlIGluc3RhbmNlLiBTdG9wcGVkIHNvdW5kcyB3aWxsIHJlc2V0IHRoZWlyIHBvc2l0aW9uIHRvIDAsIGFuZCBjYWxscyB0byB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvcmVzdW1lXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdpbGwgZmFpbC4gVG8gc3RhcnQgcGxheWJhY2sgYWdhaW4sIGNhbGwge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3BsYXlcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICpcbiAgICAgKiBJZiB5b3UgZG9uJ3Qgd2FudCB0byBsb3NlIHlvdXIgcG9zaXRpb24gdXNlIHlvdXJTb3VuZEluc3RhbmNlLnBhdXNlZCA9IHRydWUgaW5zdGVhZC4ge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3BhdXNlZFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgbXlJbnN0YW5jZS5zdG9wKCk7XG5cdCAqXG5cdCAqIEBtZXRob2Qgc3RvcFxuXHQgKiBAcmV0dXJuIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IEEgcmVmZXJlbmNlIHRvIGl0c2VsZiwgaW50ZW5kZWQgZm9yIGNoYWluaW5nIGNhbGxzLlxuXHQgKi9cblx0cC5zdG9wID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3Bvc2l0aW9uID0gMDtcblx0XHR0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9oYW5kbGVTdG9wKCk7XG5cdFx0dGhpcy5fY2xlYW5VcCgpO1xuXHRcdHRoaXMucGxheVN0YXRlID0gY3JlYXRlanMuU291bmQuUExBWV9GSU5JU0hFRDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlIGFsbCBleHRlcm5hbCByZWZlcmVuY2VzIGFuZCByZXNvdXJjZXMgZnJvbSBBYnN0cmFjdFNvdW5kSW5zdGFuY2UuICBOb3RlIHRoaXMgaXMgaXJyZXZlcnNpYmxlIGFuZCBBYnN0cmFjdFNvdW5kSW5zdGFuY2Ugd2lsbCBubyBsb25nZXIgd29ya1xuXHQgKiBAbWV0aG9kIGRlc3Ryb3lcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9jbGVhblVwKCk7XG5cdFx0dGhpcy5zcmMgPSBudWxsO1xuXHRcdHRoaXMucGxheWJhY2tSZXNvdXJjZSA9IG51bGw7XG5cblx0XHR0aGlzLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRha2VzIGFuIFBsYXlQcm9wc0NvbmZpZyBvciBPYmplY3Qgd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFuZCBzZXRzIHRoZW0gb24gdGhpcyBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBhcHBseVBsYXlQcm9wc1xuXHQgKiBAcGFyYW0ge1BsYXlQcm9wc0NvbmZpZyB8IE9iamVjdH0gcGxheVByb3BzIEEgUGxheVByb3BzQ29uZmlnIG9yIG9iamVjdCBjb250YWluaW5nIHRoZSBzYW1lIHByb3BlcnRpZXMuXG5cdCAqIEBzaW5jZSAwLjYuMVxuXHQgKiBAcmV0dXJuIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IEEgcmVmZXJlbmNlIHRvIGl0c2VsZiwgaW50ZW5kZWQgZm9yIGNoYWluaW5nIGNhbGxzLlxuXHQgKi9cblx0cC5hcHBseVBsYXlQcm9wcyA9IGZ1bmN0aW9uKHBsYXlQcm9wcykge1xuXHRcdGlmIChwbGF5UHJvcHMub2Zmc2V0ICE9IG51bGwpIHsgdGhpcy5zZXRQb3NpdGlvbihwbGF5UHJvcHMub2Zmc2V0KSB9XG5cdFx0aWYgKHBsYXlQcm9wcy5sb29wICE9IG51bGwpIHsgdGhpcy5zZXRMb29wKHBsYXlQcm9wcy5sb29wKTsgfVxuXHRcdGlmIChwbGF5UHJvcHMudm9sdW1lICE9IG51bGwpIHsgdGhpcy5zZXRWb2x1bWUocGxheVByb3BzLnZvbHVtZSk7IH1cblx0XHRpZiAocGxheVByb3BzLnBhbiAhPSBudWxsKSB7IHRoaXMuc2V0UGFuKHBsYXlQcm9wcy5wYW4pOyB9XG5cdFx0aWYgKHBsYXlQcm9wcy5zdGFydFRpbWUgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5zZXRTdGFydFRpbWUocGxheVByb3BzLnN0YXJ0VGltZSk7XG5cdFx0XHR0aGlzLnNldER1cmF0aW9uKHBsYXlQcm9wcy5kdXJhdGlvbik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFwiW0Fic3RyYWN0U291bmRJbnN0YW5jZV1cIjtcblx0fTtcblxuLy8gZ2V0L3NldCBtZXRob2RzIHRoYXQgYWxsb3cgc3VwcG9ydCBmb3IgSUU4XG5cdC8qKlxuXHQgKiBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9wYXVzZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZGlyZWN0bHkgYXMgYSBwcm9wZXJ0eSxcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBnZXRQYXVzZWRcblx0ICogQHJldHVybnMge2Jvb2xlYW59IElmIHRoZSBpbnN0YW5jZSBpcyBjdXJyZW50bHkgcGF1c2VkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5nZXRQYXVzZWQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF1c2VkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9wYXVzZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZGlyZWN0bHkgYXMgYSBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIHNldFBhdXNlZFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKiBAcmV0dXJuIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IEEgcmVmZXJlbmNlIHRvIGl0c2VsZiwgaW50ZW5kZWQgZm9yIGNoYWluaW5nIGNhbGxzLlxuXHQgKi9cblx0cC5zZXRQYXVzZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRpZiAoKHZhbHVlICE9PSB0cnVlICYmIHZhbHVlICE9PSBmYWxzZSkgfHwgdGhpcy5fcGF1c2VkID09IHZhbHVlKSB7cmV0dXJuO31cblx0XHRpZiAodmFsdWUgPT0gdHJ1ZSAmJiB0aGlzLnBsYXlTdGF0ZSAhPSBjcmVhdGVqcy5Tb3VuZC5QTEFZX1NVQ0NFRURFRCkge3JldHVybjt9XG5cdFx0dGhpcy5fcGF1c2VkID0gdmFsdWU7XG5cdFx0aWYodmFsdWUpIHtcblx0XHRcdHRoaXMuX3BhdXNlKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3Jlc3VtZSgpO1xuXHRcdH1cblx0XHRjbGVhclRpbWVvdXQodGhpcy5kZWxheVRpbWVvdXRJZCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3ZvbHVtZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBkaXJlY3RseSBhcyBhIHByb3BlcnR5XG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqIEBtZXRob2Qgc2V0Vm9sdW1lXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgdm9sdW1lIHRvIHNldCwgYmV0d2VlbiAwIGFuZCAxLlxuXHQgKiBAcmV0dXJuIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IEEgcmVmZXJlbmNlIHRvIGl0c2VsZiwgaW50ZW5kZWQgZm9yIGNoYWluaW5nIGNhbGxzLlxuXHQgKi9cblx0cC5zZXRWb2x1bWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT0gdGhpcy5fdm9sdW1lKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fdm9sdW1lID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdmFsdWUpKTtcblx0XHRpZiAoIXRoaXMuX211dGVkKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVWb2x1bWUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3ZvbHVtZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBkaXJlY3RseSBhcyBhIHByb3BlcnR5XG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqIEBtZXRob2QgZ2V0Vm9sdW1lXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGN1cnJlbnQgdm9sdW1lIG9mIHRoZSBzb3VuZCBpbnN0YW5jZS5cblx0ICovXG5cdHAuZ2V0Vm9sdW1lID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl92b2x1bWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL211dGVkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBzZXRNdXRlZFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIElmIHRoZSBzb3VuZCBzaG91bGQgYmUgbXV0ZWQuXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gQSByZWZlcmVuY2UgdG8gaXRzZWxmLCBpbnRlbmRlZCBmb3IgY2hhaW5pbmcgY2FsbHMuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5zZXRNdXRlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSAhPT0gdHJ1ZSAmJiB2YWx1ZSAhPT0gZmFsc2UpIHtyZXR1cm47fVxuXHRcdHRoaXMuX211dGVkID0gdmFsdWU7XG5cdFx0dGhpcy5fdXBkYXRlVm9sdW1lKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL211dGVkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBnZXRNdXRlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgc291bmQgaXMgbXV0ZWQuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5nZXRNdXRlZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbXV0ZWQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3Bhbjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBkaXJlY3RseSBhcyBhIHByb3BlcnR5XG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqIEBtZXRob2Qgc2V0UGFuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgcGFuIHZhbHVlLCBiZXR3ZWVuIC0xIChsZWZ0KSBhbmQgMSAocmlnaHQpLlxuXHQgKiBAcmV0dXJuIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IFJldHVybnMgcmVmZXJlbmNlIHRvIGl0c2VsZiBmb3IgY2hhaW5pbmcgY2FsbHNcblx0ICovXG5cdHAuc2V0UGFuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYodmFsdWUgPT0gdGhpcy5fcGFuKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fcGFuID0gTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIHZhbHVlKSk7XG5cdFx0dGhpcy5fdXBkYXRlUGFuKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIERFUFJFQ0FURUQsIHBsZWFzZSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlL3Bhbjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBkaXJlY3RseSBhcyBhIHByb3BlcnR5XG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqIEBtZXRob2QgZ2V0UGFuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIHZhbHVlIG9mIHRoZSBwYW4sIGJldHdlZW4gLTEgKGxlZnQpIGFuZCAxIChyaWdodCkuXG5cdCAqL1xuXHRwLmdldFBhbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFuO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9wb3NpdGlvbjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBkaXJlY3RseSBhcyBhIHByb3BlcnR5XG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqIEBtZXRob2QgZ2V0UG9zaXRpb25cblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgcG9zaXRpb24gb2YgdGhlIHBsYXloZWFkIGluIHRoZSBzb3VuZCwgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKi9cblx0cC5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX3BhdXNlZCAmJiB0aGlzLnBsYXlTdGF0ZSA9PSBjcmVhdGVqcy5Tb3VuZC5QTEFZX1NVQ0NFRURFRCkge1xuXHRcdFx0dGhpcy5fcG9zaXRpb24gPSB0aGlzLl9jYWxjdWxhdGVDdXJyZW50UG9zaXRpb24oKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3Bvc2l0aW9uO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9wb3NpdGlvbjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBkaXJlY3RseSBhcyBhIHByb3BlcnR5XG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqIEBtZXRob2Qgc2V0UG9zaXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSBwb3NpdGlvbiB0byBwbGFjZSB0aGUgcGxheWhlYWQsIGluIG1pbGxpc2Vjb25kcy5cblx0ICogQHJldHVybiB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBSZXR1cm5zIHJlZmVyZW5jZSB0byBpdHNlbGYgZm9yIGNoYWluaW5nIGNhbGxzXG5cdCAqL1xuXHRwLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dGhpcy5fcG9zaXRpb24gPSBNYXRoLm1heCgwLCB2YWx1ZSk7XG5cdFx0aWYgKHRoaXMucGxheVN0YXRlID09IGNyZWF0ZWpzLlNvdW5kLlBMQVlfU1VDQ0VFREVEKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2Uvc3RhcnRUaW1lOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBnZXRTdGFydFRpbWVcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgc3RhcnRUaW1lIG9mIHRoZSBzb3VuZCBpbnN0YW5jZSBpbiBtaWxsaXNlY29uZHMuXG5cdCAqL1xuXHRwLmdldFN0YXJ0VGltZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3RhcnRUaW1lO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9zdGFydFRpbWU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZGlyZWN0bHkgYXMgYSBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIHNldFN0YXJ0VGltZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG5ldyBzdGFydFRpbWUgdGltZSBpbiBtaWxsaSBzZWNvbmRzLlxuXHQgKiBAcmV0dXJuIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IFJldHVybnMgcmVmZXJlbmNlIHRvIGl0c2VsZiBmb3IgY2hhaW5pbmcgY2FsbHNcblx0ICovXG5cdHAuc2V0U3RhcnRUaW1lID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09IHRoaXMuX3N0YXJ0VGltZSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IE1hdGgubWF4KDAsIHZhbHVlIHx8IDApO1xuXHRcdHRoaXMuX3VwZGF0ZVN0YXJ0VGltZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9kdXJhdGlvbjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBkaXJlY3RseSBhcyBhIHByb3BlcnR5XG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqIEBtZXRob2QgZ2V0RHVyYXRpb25cblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgZHVyYXRpb24gb2YgdGhlIHNvdW5kIGluc3RhbmNlIGluIG1pbGxpc2Vjb25kcy5cblx0ICovXG5cdHAuZ2V0RHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9kdXJhdGlvbjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBkaXJlY3RseSBhcyBhIHByb3BlcnR5XG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqIEBtZXRob2Qgc2V0RHVyYXRpb25cblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBuZXcgZHVyYXRpb24gdGltZSBpbiBtaWxsaSBzZWNvbmRzLlxuXHQgKiBAcmV0dXJuIHtBYnN0cmFjdFNvdW5kSW5zdGFuY2V9IFJldHVybnMgcmVmZXJlbmNlIHRvIGl0c2VsZiBmb3IgY2hhaW5pbmcgY2FsbHNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLnNldER1cmF0aW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09IHRoaXMuX2R1cmF0aW9uKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fZHVyYXRpb24gPSBNYXRoLm1heCgwLCB2YWx1ZSB8fCAwKTtcblx0XHR0aGlzLl91cGRhdGVEdXJhdGlvbigpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9wbGF5YmFja1Jlc291cmNlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBzZXRQbGF5YmFja1xuXHQgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVGhlIG5ldyBwbGF5YmFjayByZXNvdXJjZS5cblx0ICogQHJldHVybiB7QWJzdHJhY3RTb3VuZEluc3RhbmNlfSBSZXR1cm5zIHJlZmVyZW5jZSB0byBpdHNlbGYgZm9yIGNoYWluaW5nIGNhbGxzXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKiovXG5cdHAuc2V0UGxheWJhY2tSZXNvdXJjZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UgPSB2YWx1ZTtcblx0XHRpZiAodGhpcy5fZHVyYXRpb24gPT0gMCkgeyB0aGlzLl9zZXREdXJhdGlvbkZyb21Tb3VyY2UoKTsgfVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZS9wbGF5YmFja1Jlc291cmNlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGRpcmVjdGx5IGFzIGEgcHJvcGVydHlcblx0ICpcblx0ICogQGRlcHJlY2F0ZWRcblx0ICogQG1ldGhvZCBzZXRQbGF5YmFja1xuXHQgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVGhlIG5ldyBwbGF5YmFjayByZXNvdXJjZS5cblx0ICogQHJldHVybiB7T2JqZWN0fSBwbGF5YmFjayByZXNvdXJjZSB1c2VkIGZvciBwbGF5aW5nIGF1ZGlvXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKiovXG5cdHAuZ2V0UGxheWJhY2tSZXNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGxheWJhY2tSZXNvdXJjZTtcblx0fTtcblxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvbG9vcDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBkaXJlY3RseSBhcyBhIHByb3BlcnR5XG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqIEBtZXRob2QgZ2V0TG9vcFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKiovXG5cdHAuZ2V0TG9vcCA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbG9vcDtcblx0fTtcblxuXHQvKipcblx0ICogREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2UvbG9vcDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBkaXJlY3RseSBhcyBhIHByb3BlcnR5LFxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBAbWV0aG9kIHNldExvb3Bcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gbG9vcCBhZnRlciBwbGF5LlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuc2V0TG9vcCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGlmKHRoaXMuX3BsYXliYWNrUmVzb3VyY2UgIT0gbnVsbCkge1xuXHRcdFx0Ly8gcmVtb3ZlIGxvb3Bpbmdcblx0XHRcdGlmICh0aGlzLl9sb29wICE9IDAgJiYgdmFsdWUgPT0gMCkge1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVMb29waW5nKHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdC8vIGFkZCBsb29waW5nXG5cdFx0XHRlbHNlIGlmICh0aGlzLl9sb29wID09IDAgJiYgdmFsdWUgIT0gMCkge1xuXHRcdFx0XHR0aGlzLl9hZGRMb29waW5nKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fbG9vcCA9IHZhbHVlO1xuXHR9O1xuXG5cbi8vIFByaXZhdGUgTWV0aG9kczpcblx0LyoqXG5cdCAqIEEgaGVscGVyIG1ldGhvZCB0aGF0IGRpc3BhdGNoZXMgYWxsIGV2ZW50cyBmb3IgQWJzdHJhY3RTb3VuZEluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIF9zZW5kRXZlbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGVcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2VuZEV2ZW50ID0gZnVuY3Rpb24gKHR5cGUpIHtcblx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQodHlwZSk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogQ2xlYW4gdXAgdGhlIGluc3RhbmNlLiBSZW1vdmUgcmVmZXJlbmNlcyBhbmQgY2xlYW4gdXAgYW55IGFkZGl0aW9uYWwgcHJvcGVydGllcyBzdWNoIGFzIHRpbWVycy5cblx0ICogQG1ldGhvZCBfY2xlYW5VcFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9jbGVhblVwID0gZnVuY3Rpb24gKCkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLmRlbGF5VGltZW91dElkKTsgLy8gY2xlYXIgdGltZW91dCB0aGF0IHBsYXlzIGRlbGF5ZWQgc291bmRcblx0XHR0aGlzLl9oYW5kbGVDbGVhblVwKCk7XG5cdFx0dGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cblx0XHRjcmVhdGVqcy5Tb3VuZC5fcGxheUZpbmlzaGVkKHRoaXMpO1x0Ly8gVE9ETyBjaGFuZ2UgdG8gYW4gZXZlbnRcblx0fTtcblxuXHQvKipcblx0ICogVGhlIHNvdW5kIGhhcyBiZWVuIGludGVycnVwdGVkLlxuXHQgKiBAbWV0aG9kIF9pbnRlcnJ1cHRcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5faW50ZXJydXB0ID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NsZWFuVXAoKTtcblx0XHR0aGlzLnBsYXlTdGF0ZSA9IGNyZWF0ZWpzLlNvdW5kLlBMQVlfSU5URVJSVVBURUQ7XG5cdFx0dGhpcy5fc2VuZEV2ZW50KFwiaW50ZXJydXB0ZWRcIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCBieSB0aGUgU291bmQgY2xhc3Mgd2hlbiB0aGUgYXVkaW8gaXMgcmVhZHkgdG8gcGxheSAoZGVsYXkgaGFzIGNvbXBsZXRlZCkuIFN0YXJ0cyBzb3VuZCBwbGF5aW5nIGlmIHRoZVxuXHQgKiBzcmMgaXMgbG9hZGVkLCBvdGhlcndpc2UgcGxheWJhY2sgd2lsbCBmYWlsLlxuXHQgKiBAbWV0aG9kIF9iZWdpblBsYXlpbmdcblx0ICogQHBhcmFtIHtQbGF5UHJvcHNDb25maWd9IHBsYXlQcm9wcyBBIFBsYXlQcm9wc0NvbmZpZyBvYmplY3QuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHBsYXliYWNrIHN1Y2NlZWRlZC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0Ly8gT0pSIEZsYXNoQXVkaW9Tb3VuZEluc3RhbmNlIG92ZXJ3cml0ZXNcblx0cC5fYmVnaW5QbGF5aW5nID0gZnVuY3Rpb24gKHBsYXlQcm9wcykge1xuXHRcdHRoaXMuc2V0UG9zaXRpb24ocGxheVByb3BzLm9mZnNldCk7XG5cdFx0dGhpcy5zZXRMb29wKHBsYXlQcm9wcy5sb29wKTtcblx0XHR0aGlzLnNldFZvbHVtZShwbGF5UHJvcHMudm9sdW1lKTtcblx0XHR0aGlzLnNldFBhbihwbGF5UHJvcHMucGFuKTtcblx0XHRpZiAocGxheVByb3BzLnN0YXJ0VGltZSAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLnNldFN0YXJ0VGltZShwbGF5UHJvcHMuc3RhcnRUaW1lKTtcblx0XHRcdHRoaXMuc2V0RHVyYXRpb24ocGxheVByb3BzLmR1cmF0aW9uKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fcGxheWJhY2tSZXNvdXJjZSAhPSBudWxsICYmIHRoaXMuX3Bvc2l0aW9uIDwgdGhpcy5fZHVyYXRpb24pIHtcblx0XHRcdHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5faGFuZGxlU291bmRSZWFkeSgpO1xuXHRcdFx0dGhpcy5wbGF5U3RhdGUgPSBjcmVhdGVqcy5Tb3VuZC5QTEFZX1NVQ0NFRURFRDtcblx0XHRcdHRoaXMuX3NlbmRFdmVudChcInN1Y2NlZWRlZFwiKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9wbGF5RmFpbGVkKCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBQbGF5IGhhcyBmYWlsZWQsIHdoaWNoIGNhbiBoYXBwZW4gZm9yIGEgdmFyaWV0eSBvZiByZWFzb25zLlxuXHQgKiBDbGVhbnMgdXAgaW5zdGFuY2UgYW5kIGRpc3BhdGNoZXMgZmFpbGVkIGV2ZW50XG5cdCAqIEBtZXRob2QgX3BsYXlGYWlsZWRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX3BsYXlGYWlsZWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY2xlYW5VcCgpO1xuXHRcdHRoaXMucGxheVN0YXRlID0gY3JlYXRlanMuU291bmQuUExBWV9GQUlMRUQ7XG5cdFx0dGhpcy5fc2VuZEV2ZW50KFwiZmFpbGVkXCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBdWRpbyBoYXMgZmluaXNoZWQgcGxheWluZy4gTWFudWFsbHkgbG9vcCBpdCBpZiByZXF1aXJlZC5cblx0ICogQG1ldGhvZCBfaGFuZGxlU291bmRDb21wbGV0ZVxuXHQgKiBAcGFyYW0gZXZlbnRcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5faGFuZGxlU291bmRDb21wbGV0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMuX3Bvc2l0aW9uID0gMDsgIC8vIGhhdmUgdG8gc2V0IHRoaXMgYXMgaXQgY2FuIGJlIHNldCBieSBwYXVzZSBkdXJpbmcgcGxheWJhY2tcblxuXHRcdGlmICh0aGlzLl9sb29wICE9IDApIHtcblx0XHRcdHRoaXMuX2xvb3AtLTsgIC8vIE5PVEUgdGhpcyBpbnRyb2R1Y2VzIGEgdGhlb3JldGljYWwgbGltaXQgb24gbG9vcHMgPSBmbG9hdCBtYXggc2l6ZSB4IDIgLSAxXG5cdFx0XHR0aGlzLl9oYW5kbGVMb29wKCk7XG5cdFx0XHR0aGlzLl9zZW5kRXZlbnQoXCJsb29wXCIpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NsZWFuVXAoKTtcblx0XHR0aGlzLnBsYXlTdGF0ZSA9IGNyZWF0ZWpzLlNvdW5kLlBMQVlfRklOSVNIRUQ7XG5cdFx0dGhpcy5fc2VuZEV2ZW50KFwiY29tcGxldGVcIik7XG5cdH07XG5cbi8vIFBsdWdpbiBzcGVjaWZpYyBjb2RlXG5cdC8qKlxuXHQgKiBIYW5kbGVzIHN0YXJ0aW5nIHBsYXliYWNrIHdoZW4gdGhlIHNvdW5kIGlzIHJlYWR5IGZvciBwbGF5aW5nLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVTb3VuZFJlYWR5XG5cdCAqIEBwcm90ZWN0ZWRcbiBcdCAqL1xuXHRwLl9oYW5kbGVTb3VuZFJlYWR5ID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vIHBsdWdpbiBzcGVjaWZpYyBjb2RlXG5cdH07XG5cblx0LyoqXG5cdCAqIEludGVybmFsIGZ1bmN0aW9uIHVzZWQgdG8gdXBkYXRlIHRoZSB2b2x1bWUgYmFzZWQgb24gdGhlIGluc3RhbmNlIHZvbHVtZSwgbWFzdGVyIHZvbHVtZSwgaW5zdGFuY2UgbXV0ZSB2YWx1ZSxcblx0ICogYW5kIG1hc3RlciBtdXRlIHZhbHVlLlxuXHQgKiBAbWV0aG9kIF91cGRhdGVWb2x1bWVcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fdXBkYXRlVm9sdW1lID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vIHBsdWdpbiBzcGVjaWZpYyBjb2RlXG5cdH07XG5cblx0LyoqXG5cdCAqIEludGVybmFsIGZ1bmN0aW9uIHVzZWQgdG8gdXBkYXRlIHRoZSBwYW5cblx0ICogQG1ldGhvZCBfdXBkYXRlUGFuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl91cGRhdGVQYW4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcGx1Z2luIHNwZWNpZmljIGNvZGVcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgZnVuY3Rpb24gdXNlZCB0byB1cGRhdGUgdGhlIHN0YXJ0VGltZSBvZiB0aGUgYXVkaW8uXG5cdCAqIEBtZXRob2QgX3VwZGF0ZVN0YXJ0VGltZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMVxuXHQgKi9cblx0cC5fdXBkYXRlU3RhcnRUaW1lID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vIHBsdWdpbiBzcGVjaWZpYyBjb2RlXG5cdH07XG5cblx0LyoqXG5cdCAqIEludGVybmFsIGZ1bmN0aW9uIHVzZWQgdG8gdXBkYXRlIHRoZSBkdXJhdGlvbiBvZiB0aGUgYXVkaW8uXG5cdCAqIEBtZXRob2QgX3VwZGF0ZUR1cmF0aW9uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl91cGRhdGVEdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwbHVnaW4gc3BlY2lmaWMgY29kZVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBmdW5jdGlvbiB1c2VkIHRvIGdldCB0aGUgZHVyYXRpb24gb2YgdGhlIGF1ZGlvIGZyb20gdGhlIHNvdXJjZSB3ZSdsbCBiZSBwbGF5aW5nLlxuXHQgKiBAbWV0aG9kIF91cGRhdGVEdXJhdGlvblxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5fc2V0RHVyYXRpb25Gcm9tU291cmNlID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vIHBsdWdpbiBzcGVjaWZpYyBjb2RlXG5cdH07XG5cblx0LyoqXG5cdCAqIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgY2FsY3VsYXRlcyB0aGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgcGxheWhlYWQgYW5kIHNldHMgdGhpcy5fcG9zaXRpb24gdG8gdGhhdCB2YWx1ZVxuXHQgKiBAbWV0aG9kIF9jYWxjdWxhdGVDdXJyZW50UG9zaXRpb25cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuX2NhbGN1bGF0ZUN1cnJlbnRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwbHVnaW4gc3BlY2lmaWMgY29kZSB0aGF0IHNldHMgdGhpcy5wb3NpdGlvblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBmdW5jdGlvbiB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIHBsYXloZWFkLlxuXHQgKiBAbWV0aG9kIF91cGRhdGVQb3NpdGlvblxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5fdXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcGx1Z2luIHNwZWNpZmljIGNvZGVcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgZnVuY3Rpb24gY2FsbGVkIHdoZW4gbG9vcGluZyBpcyByZW1vdmVkIGR1cmluZyBwbGF5YmFjay5cblx0ICogQG1ldGhvZCBfcmVtb3ZlTG9vcGluZ1xuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG51bWJlciBvZiB0aW1lcyB0byBsb29wIGFmdGVyIHBsYXkuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl9yZW1vdmVMb29waW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0Ly8gcGx1Z2luIHNwZWNpZmljIGNvZGVcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgZnVuY3Rpb24gY2FsbGVkIHdoZW4gbG9vcGluZyBpcyBhZGRlZCBkdXJpbmcgcGxheWJhY2suXG5cdCAqIEBtZXRob2QgX2FkZExvb3Bpbmdcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gbG9vcCBhZnRlciBwbGF5LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5fYWRkTG9vcGluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdC8vIHBsdWdpbiBzcGVjaWZpYyBjb2RlXG5cdH07XG5cblx0LyoqXG5cdCAqIEludGVybmFsIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIHBhdXNpbmcgcGxheWJhY2tcblx0ICogQG1ldGhvZCBfcGF1c2Vcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuX3BhdXNlID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vIHBsdWdpbiBzcGVjaWZpYyBjb2RlXG5cdH07XG5cblx0LyoqXG5cdCAqIEludGVybmFsIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIHJlc3VtaW5nIHBsYXliYWNrXG5cdCAqIEBtZXRob2QgX3Jlc3VtZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5fcmVzdW1lID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vIHBsdWdpbiBzcGVjaWZpYyBjb2RlXG5cdH07XG5cblx0LyoqXG5cdCAqIEludGVybmFsIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIHN0b3BwaW5nIHBsYXliYWNrXG5cdCAqIEBtZXRob2QgX2hhbmRsZVN0b3Bcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuX2hhbmRsZVN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHQvLyBwbHVnaW4gc3BlY2lmaWMgY29kZVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBmdW5jdGlvbiBjYWxsZWQgd2hlbiBBYnN0cmFjdFNvdW5kSW5zdGFuY2UgaXMgYmVpbmcgY2xlYW5lZCB1cFxuXHQgKiBAbWV0aG9kIF9oYW5kbGVDbGVhblVwXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl9oYW5kbGVDbGVhblVwID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gcGx1Z2luIHNwZWNpZmljIGNvZGVcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgZnVuY3Rpb24gY2FsbGVkIHdoZW4gQWJzdHJhY3RTb3VuZEluc3RhbmNlIGhhcyBwbGF5ZWQgdG8gZW5kIGFuZCBpcyBsb29waW5nXG5cdCAqIEBtZXRob2QgX2hhbmRsZUxvb3Bcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuX2hhbmRsZUxvb3AgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcGx1Z2luIHNwZWNpZmljIGNvZGVcblx0fTtcblxuXHRjcmVhdGVqcy5BYnN0cmFjdFNvdW5kSW5zdGFuY2UgPSBjcmVhdGVqcy5wcm9tb3RlKEFic3RyYWN0U291bmRJbnN0YW5jZSwgXCJFdmVudERpc3BhdGNoZXJcIik7XG5cdGNyZWF0ZWpzLkRlZmF1bHRTb3VuZEluc3RhbmNlID0gY3JlYXRlanMuQWJzdHJhY3RTb3VuZEluc3RhbmNlO1x0Ly8gdXNlZCB3aGVuIG5vIHBsdWdpbiBpcyBzdXBwb3J0ZWRcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBBYnN0cmFjdFBsdWdpbi5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG4gXHQvKipcblx0ICogQSBkZWZhdWx0IHBsdWdpbiBjbGFzcyB1c2VkIGFzIGEgYmFzZSBmb3IgYWxsIG90aGVyIHBsdWdpbnMuXG5cdCAqIEBjbGFzcyBBYnN0cmFjdFBsdWdpblxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cdHZhciBBYnN0cmFjdFBsdWdpbiA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjYXBhYmlsaXRpZXMgb2YgdGhlIHBsdWdpbi5cblx0XHQgKiBtZXRob2QgYW5kIGlzIHVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJvcGVydHkgX2NhcGFiaWxpdGllc1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAc3RhdGljXG5cdFx0ICovXG5cdFx0dGhpcy5fY2FwYWJpbGl0aWVzID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIE9iamVjdCBoYXNoIGluZGV4ZWQgYnkgdGhlIHNvdXJjZSBVUkkgb2YgYWxsIGNyZWF0ZWQgbG9hZGVycywgdXNlZCB0byBwcm9wZXJseSBkZXN0cm95IHRoZW0gaWYgc291cmNlcyBhcmUgcmVtb3ZlZC5cblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkZXJzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBPYmplY3QgaGFzaCBpbmRleGVkIGJ5IHRoZSBzb3VyY2UgVVJJIG9mIGVhY2ggZmlsZSB0byBpbmRpY2F0ZSBpZiBhbiBhdWRpbyBzb3VyY2UgaGFzIGJlZ3VuIGxvYWRpbmcsXG5cdFx0ICogaXMgY3VycmVudGx5IGxvYWRpbmcsIG9yIGhhcyBjb21wbGV0ZWQgbG9hZGluZy4gIENhbiBiZSB1c2VkIHRvIHN0b3JlIG5vbiBib29sZWFuIGRhdGEgYWZ0ZXIgbG9hZGluZ1xuXHRcdCAqIGlzIGNvbXBsZXRlIChmb3IgZXhhbXBsZSBhcnJheUJ1ZmZlcnMgZm9yIHdlYiBhdWRpbykuXG5cdFx0ICogQHByb3BlcnR5IF9hdWRpb1NvdXJjZXNcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9hdWRpb1NvdXJjZXMgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIE9iamVjdCBoYXNoIGluZGV4ZWQgYnkgdGhlIHNvdXJjZSBVUkkgb2YgYWxsIGNyZWF0ZWQgU291bmRJbnN0YW5jZXMsIHVwZGF0ZXMgdGhlIHBsYXliYWNrUmVzb3VyY2UgaWYgaXQgbG9hZHMgYWZ0ZXIgdGhleSBhcmUgY3JlYXRlZCxcblx0XHQgKiBhbmQgcHJvcGVybHkgZGVzdHJveSB0aGVtIGlmIHNvdXJjZXMgYXJlIHJlbW92ZWRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9zb3VuZEluc3RhbmNlcyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGludGVybmFsIG1hc3RlciB2b2x1bWUgdmFsdWUgb2YgdGhlIHBsdWdpbi5cblx0XHQgKiBAcHJvcGVydHkgX3ZvbHVtZVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl92b2x1bWUgPSAxO1xuXG5cdFx0LyoqXG5cdFx0ICogQSByZWZlcmVuY2UgdG8gYSBsb2FkZXIgY2xhc3MgdXNlZCBieSBhIHBsdWdpbiB0aGF0IG11c3QgYmUgc2V0LlxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRlckNsYXNzO1xuXG5cdFx0LyoqXG5cdFx0ICogQSByZWZlcmVuY2UgdG8gYW4gQWJzdHJhY3RTb3VuZEluc3RhbmNlIGNsYXNzIHVzZWQgYnkgYSBwbHVnaW4gdGhhdCBtdXN0IGJlIHNldC5cblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcm90ZWN0ZWQ7XG5cdFx0ICovXG5cdFx0dGhpcy5fc291bmRJbnN0YW5jZUNsYXNzO1xuXHR9O1xuXHR2YXIgcCA9IEFic3RyYWN0UGx1Z2luLnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblxuLy8gU3RhdGljIFByb3BlcnRpZXM6XG4vLyBOT1RFIFRIRVNFIFBST1BFUlRJRVMgTkVFRCBUTyBCRSBBRERFRCBUTyBFQUNIIFBMVUdJTlxuXHQvKipcblx0ICogVGhlIGNhcGFiaWxpdGllcyBvZiB0aGUgcGx1Z2luLiBUaGlzIGlzIGdlbmVyYXRlZCB2aWEgdGhlIF9nZW5lcmF0ZUNhcGFiaWxpdGllcyBtZXRob2QgYW5kIGlzIHVzZWQgaW50ZXJuYWxseS5cblx0ICogQHByb3BlcnR5IF9jYXBhYmlsaXRpZXNcblx0ICogQHR5cGUge09iamVjdH1cblx0ICogQGRlZmF1bHQgbnVsbFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdEFic3RyYWN0UGx1Z2luLl9jYXBhYmlsaXRpZXMgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgdGhlIHBsdWdpbiBjYW4gYmUgdXNlZCBpbiB0aGUgY3VycmVudCBicm93c2VyL09TLlxuXHQgKiBAbWV0aG9kIGlzU3VwcG9ydGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBwbHVnaW4gY2FuIGJlIGluaXRpYWxpemVkLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRBYnN0cmFjdFBsdWdpbi5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFByZS1yZWdpc3RlciBhIHNvdW5kIGZvciBwcmVsb2FkaW5nIGFuZCBzZXR1cC4gVGhpcyBpcyBjYWxsZWQgYnkge3sjY3Jvc3NMaW5rIFwiU291bmRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIE5vdGUgYWxsIHBsdWdpbnMgcHJvdmlkZSBhIDxjb2RlPkxvYWRlcjwvY29kZT4gaW5zdGFuY2UsIHdoaWNoIDxhIGhyZWY9XCJodHRwOi8vcHJlbG9hZGpzLmNvbVwiIHRhcmdldD1cIl9ibGFua1wiPlByZWxvYWRKUzwvYT5cblx0ICogY2FuIHVzZSB0byBhc3Npc3Qgd2l0aCBwcmVsb2FkaW5nLlxuXHQgKiBAbWV0aG9kIHJlZ2lzdGVyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBsb2FkSXRlbSBBbiBPYmplY3QgY29udGFpbmluZyB0aGUgc291cmNlIG9mIHRoZSBhdWRpb1xuXHQgKiBOb3RlIHRoYXQgbm90IGV2ZXJ5IHBsdWdpbiB3aWxsIG1hbmFnZSB0aGlzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEEgcmVzdWx0IG9iamVjdCwgY29udGFpbmluZyBhIFwidGFnXCIgZm9yIHByZWxvYWRpbmcgcHVycG9zZXMuXG5cdCAqL1xuXHRwLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGxvYWRJdGVtKSB7XG5cdFx0dmFyIGxvYWRlciA9IHRoaXMuX2xvYWRlcnNbbG9hZEl0ZW0uc3JjXTtcblx0XHRpZihsb2FkZXIgJiYgIWxvYWRlci5jYW5jZWxlZCkge3JldHVybiB0aGlzLl9sb2FkZXJzW2xvYWRJdGVtLnNyY107fVx0Ly8gYWxyZWFkeSBsb2FkaW5nL2xvYWRlZCB0aGlzLCBzbyBkb24ndCBsb2FkIHR3aWNlXG5cdFx0Ly8gT0pSIHBvdGVudGlhbCBpc3N1ZSB0aGF0IHdlIHdvbid0IGJlIGZpcmluZyBsb2FkZWQgZXZlbnQsIG1pZ2h0IG5lZWQgdG8gdHJpZ2dlciBpZiB0aGlzIGlzIGFscmVhZHkgbG9hZGVkP1xuXHRcdHRoaXMuX2F1ZGlvU291cmNlc1tsb2FkSXRlbS5zcmNdID0gdHJ1ZTtcblx0XHR0aGlzLl9zb3VuZEluc3RhbmNlc1tsb2FkSXRlbS5zcmNdID0gW107XG5cdFx0bG9hZGVyID0gbmV3IHRoaXMuX2xvYWRlckNsYXNzKGxvYWRJdGVtKTtcblx0XHRsb2FkZXIub24oXCJjb21wbGV0ZVwiLCB0aGlzLl9oYW5kbGVQcmVsb2FkQ29tcGxldGUsIHRoaXMpO1xuXHRcdHRoaXMuX2xvYWRlcnNbbG9hZEl0ZW0uc3JjXSA9IGxvYWRlcjtcblx0XHRyZXR1cm4gbG9hZGVyO1xuXHR9O1xuXG5cdC8vIG5vdGUgc291bmQgY2FsbHMgcmVnaXN0ZXIgYmVmb3JlIGNhbGxpbmcgcHJlbG9hZFxuXHQvKipcblx0ICogSW50ZXJuYWxseSBwcmVsb2FkIGEgc291bmQuXG5cdCAqIEBtZXRob2QgcHJlbG9hZFxuXHQgKiBAcGFyYW0ge0xvYWRlcn0gbG9hZGVyIFRoZSBzb3VuZCBVUkkgdG8gbG9hZC5cblx0ICovXG5cdHAucHJlbG9hZCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHRsb2FkZXIub24oXCJlcnJvclwiLCB0aGlzLl9oYW5kbGVQcmVsb2FkRXJyb3IsIHRoaXMpO1xuXHRcdGxvYWRlci5sb2FkKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBwcmVsb2FkaW5nIGhhcyBzdGFydGVkIGZvciBhIHNwZWNpZmljIHNvdXJjZS4gSWYgdGhlIHNvdXJjZSBpcyBmb3VuZCwgd2UgY2FuIGFzc3VtZSBpdCBpcyBsb2FkaW5nLFxuXHQgKiBvciBoYXMgYWxyZWFkeSBmaW5pc2hlZCBsb2FkaW5nLlxuXHQgKiBAbWV0aG9kIGlzUHJlbG9hZFN0YXJ0ZWRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291bmQgVVJJIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0cC5pc1ByZWxvYWRTdGFydGVkID0gZnVuY3Rpb24gKHNyYykge1xuXHRcdHJldHVybiAodGhpcy5fYXVkaW9Tb3VyY2VzW3NyY10gIT0gbnVsbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBwcmVsb2FkaW5nIGhhcyBmaW5pc2hlZCBmb3IgYSBzcGVjaWZpYyBzb3VyY2UuXG5cdCAqIEBtZXRob2QgaXNQcmVsb2FkQ29tcGxldGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291bmQgVVJJIHRvIGxvYWQuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRwLmlzUHJlbG9hZENvbXBsZXRlID0gZnVuY3Rpb24gKHNyYykge1xuXHRcdHJldHVybiAoISh0aGlzLl9hdWRpb1NvdXJjZXNbc3JjXSA9PSBudWxsIHx8IHRoaXMuX2F1ZGlvU291cmNlc1tzcmNdID09IHRydWUpKTtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlIGEgc291bmQgYWRkZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiV2ViQXVkaW9QbHVnaW4vcmVnaXN0ZXJcIn19e3svY3Jvc3NMaW5rfX0uIE5vdGUgdGhpcyBkb2VzIG5vdCBjYW5jZWwgYSBwcmVsb2FkLlxuXHQgKiBAbWV0aG9kIHJlbW92ZVNvdW5kXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdW5kIFVSSSB0byB1bmxvYWQuXG5cdCAqL1xuXHRwLnJlbW92ZVNvdW5kID0gZnVuY3Rpb24gKHNyYykge1xuXHRcdGlmICghdGhpcy5fc291bmRJbnN0YW5jZXNbc3JjXSkgeyByZXR1cm47IH1cblx0XHRmb3IgKHZhciBpID0gdGhpcy5fc291bmRJbnN0YW5jZXNbc3JjXS5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHRoaXMuX3NvdW5kSW5zdGFuY2VzW3NyY11baV07XG5cdFx0XHRpdGVtLmRlc3Ryb3koKTtcblx0XHR9XG5cdFx0ZGVsZXRlKHRoaXMuX3NvdW5kSW5zdGFuY2VzW3NyY10pO1xuXHRcdGRlbGV0ZSh0aGlzLl9hdWRpb1NvdXJjZXNbc3JjXSk7XG5cdFx0aWYodGhpcy5fbG9hZGVyc1tzcmNdKSB7IHRoaXMuX2xvYWRlcnNbc3JjXS5kZXN0cm95KCk7IH1cblx0XHRkZWxldGUodGhpcy5fbG9hZGVyc1tzcmNdKTtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlIGFsbCBzb3VuZHMgYWRkZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiV2ViQXVkaW9QbHVnaW4vcmVnaXN0ZXJcIn19e3svY3Jvc3NMaW5rfX0uIE5vdGUgdGhpcyBkb2VzIG5vdCBjYW5jZWwgYSBwcmVsb2FkLlxuXHQgKiBAbWV0aG9kIHJlbW92ZUFsbFNvdW5kc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VuZCBVUkkgdG8gdW5sb2FkLlxuXHQgKi9cblx0cC5yZW1vdmVBbGxTb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yKHZhciBrZXkgaW4gdGhpcy5fYXVkaW9Tb3VyY2VzKSB7XG5cdFx0XHR0aGlzLnJlbW92ZVNvdW5kKGtleSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBzb3VuZCBpbnN0YW5jZS4gSWYgdGhlIHNvdW5kIGhhcyBub3QgYmVlbiBwcmVsb2FkZWQsIGl0IGlzIGludGVybmFsbHkgcHJlbG9hZGVkIGhlcmUuXG5cdCAqIEBtZXRob2QgY3JlYXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdW5kIHNvdXJjZSB0byB1c2UuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFRpbWUgQXVkaW8gc3ByaXRlIHByb3BlcnR5IHVzZWQgdG8gYXBwbHkgYW4gb2Zmc2V0LCBpbiBtaWxsaXNlY29uZHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBBdWRpbyBzcHJpdGUgcHJvcGVydHkgdXNlZCB0byBzZXQgdGhlIHRpbWUgdGhlIGNsaXAgcGxheXMgZm9yLCBpbiBtaWxsaXNlY29uZHMuXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0U291bmRJbnN0YW5jZX0gQSBzb3VuZCBpbnN0YW5jZSBmb3IgcGxheWJhY2sgYW5kIGNvbnRyb2wuXG5cdCAqL1xuXHRwLmNyZWF0ZSA9IGZ1bmN0aW9uIChzcmMsIHN0YXJ0VGltZSwgZHVyYXRpb24pIHtcblx0XHRpZiAoIXRoaXMuaXNQcmVsb2FkU3RhcnRlZChzcmMpKSB7XG5cdFx0XHR0aGlzLnByZWxvYWQodGhpcy5yZWdpc3RlcihzcmMpKTtcblx0XHR9XG5cdFx0dmFyIHNpID0gbmV3IHRoaXMuX3NvdW5kSW5zdGFuY2VDbGFzcyhzcmMsIHN0YXJ0VGltZSwgZHVyYXRpb24sIHRoaXMuX2F1ZGlvU291cmNlc1tzcmNdKTtcblx0XHR0aGlzLl9zb3VuZEluc3RhbmNlc1tzcmNdLnB1c2goc2kpO1xuXHRcdHJldHVybiBzaTtcblx0fTtcblxuXHQvLyBpZiBhIHBsdWdpbiBkb2VzIG5vdCBzdXBwb3J0IHZvbHVtZSBhbmQgbXV0ZSwgaXQgc2hvdWxkIHNldCB0aGVzZSB0byBudWxsXG5cdC8qKlxuXHQgKiBTZXQgdGhlIG1hc3RlciB2b2x1bWUgb2YgdGhlIHBsdWdpbiwgd2hpY2ggYWZmZWN0cyBhbGwgU291bmRJbnN0YW5jZXMuXG5cdCAqIEBtZXRob2Qgc2V0Vm9sdW1lXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgdm9sdW1lIHRvIHNldCwgYmV0d2VlbiAwIGFuZCAxLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgcGx1Z2luIHByb2Nlc3NlcyB0aGUgc2V0Vm9sdW1lIGNhbGwgKHRydWUpLiBUaGUgU291bmQgY2xhc3Mgd2lsbCBhZmZlY3QgYWxsIHRoZVxuXHQgKiBpbnN0YW5jZXMgbWFudWFsbHkgb3RoZXJ3aXNlLlxuXHQgKi9cblx0cC5zZXRWb2x1bWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR0aGlzLl92b2x1bWUgPSB2YWx1ZTtcblx0XHR0aGlzLl91cGRhdGVWb2x1bWUoKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IHRoZSBtYXN0ZXIgdm9sdW1lIG9mIHRoZSBwbHVnaW4sIHdoaWNoIGFmZmVjdHMgYWxsIFNvdW5kSW5zdGFuY2VzLlxuXHQgKiBAbWV0aG9kIGdldFZvbHVtZVxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSB2b2x1bWUgbGV2ZWwsIGJldHdlZW4gMCBhbmQgMS5cblx0ICovXG5cdHAuZ2V0Vm9sdW1lID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl92b2x1bWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIE11dGUgYWxsIHNvdW5kcyB2aWEgdGhlIHBsdWdpbi5cblx0ICogQG1ldGhvZCBzZXRNdXRlXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgSWYgYWxsIHNvdW5kIHNob3VsZCBiZSBtdXRlZCBvciBub3QuIE5vdGUgdGhhdCBwbHVnaW4tbGV2ZWwgbXV0aW5nIGp1c3QgbG9va3MgdXBcblx0ICogdGhlIG11dGUgdmFsdWUgb2YgU291bmQge3sjY3Jvc3NMaW5rIFwiU291bmQvZ2V0TXV0ZVwifX17ey9jcm9zc0xpbmt9fSwgc28gdGhpcyBwcm9wZXJ0eSBpcyBub3QgdXNlZCBoZXJlLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgbXV0ZSBjYWxsIHN1Y2NlZWRzLlxuXHQgKi9cblx0cC5zZXRNdXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dGhpcy5fdXBkYXRlVm9sdW1lKCk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0Ly8gcGx1Z2lucyBzaG91bGQgb3ZlcndyaXRlIHRoaXMgbWV0aG9kXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFwiW0Fic3RyYWN0UGx1Z2luXVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEhhbmRsZXMgaW50ZXJuYWwgcHJlbG9hZCBjb21wbGV0aW9uLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVQcmVsb2FkQ29tcGxldGVcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5faGFuZGxlUHJlbG9hZENvbXBsZXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIHNyYyA9IGV2ZW50LnRhcmdldC5nZXRJdGVtKCkuc3JjO1xuXHRcdHRoaXMuX2F1ZGlvU291cmNlc1tzcmNdID0gZXZlbnQucmVzdWx0O1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc291bmRJbnN0YW5jZXNbc3JjXS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gdGhpcy5fc291bmRJbnN0YW5jZXNbc3JjXVtpXTtcblx0XHRcdGl0ZW0uc2V0UGxheWJhY2tSZXNvdXJjZSh0aGlzLl9hdWRpb1NvdXJjZXNbc3JjXSk7XG5cdFx0XHQvLyBUb0RvIGNvbnNpZGVyIGFkZGluZyBwbGF5IGNhbGwgaGVyZSBpZiBwbGF5c3RhdGUgPT0gcGxheWZhaWxlZFxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlcyBpbnRlcm5hbCBwcmVsb2FkIGVycm9zXG5cdCAqIEBtZXRob2QgX2hhbmRsZVByZWxvYWRFcnJvclxuXHQgKiBAcGFyYW0gZXZlbnRcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5faGFuZGxlUHJlbG9hZEVycm9yID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHQvL2RlbGV0ZSh0aGlzLl9hdWRpb1NvdXJjZXNbc3JjXSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgZ2FpbiB2YWx1ZSBmb3IgbWFzdGVyIGF1ZGlvLiBTaG91bGQgbm90IGJlIGNhbGxlZCBleHRlcm5hbGx5LlxuXHQgKiBAbWV0aG9kIF91cGRhdGVWb2x1bWVcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fdXBkYXRlVm9sdW1lID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vIFBsdWdpbiBTcGVjaWZpYyBjb2RlXG5cdH07XG5cblx0Y3JlYXRlanMuQWJzdHJhY3RQbHVnaW4gPSBBYnN0cmFjdFBsdWdpbjtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBXZWJBdWRpb0xvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIExvYWRlciBwcm92aWRlcyBhIG1lY2hhbmlzbSB0byBwcmVsb2FkIFdlYiBBdWRpbyBjb250ZW50IHZpYSBQcmVsb2FkSlMgb3IgaW50ZXJuYWxseS4gSW5zdGFuY2VzIGFyZSByZXR1cm5lZCB0b1xuXHQgKiB0aGUgcHJlbG9hZGVyLCBhbmQgdGhlIGxvYWQgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHRoZSBhc3NldCBuZWVkcyB0byBiZSByZXF1ZXN0ZWQuXG5cdCAqXG5cdCAqIEBjbGFzcyBXZWJBdWRpb0xvYWRlclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbG9hZEl0ZW0gVGhlIGl0ZW0gdG8gYmUgbG9hZGVkXG5cdCAqIEBleHRlbmRzIFhIUlJlcXVlc3Rcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0ZnVuY3Rpb24gTG9hZGVyKGxvYWRJdGVtKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgdHJ1ZSwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU09VTkQpO1xuXG5cdH07XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cblx0LyoqXG5cdCAqIHdlYiBhdWRpbyBjb250ZXh0IHJlcXVpcmVkIGZvciBkZWNvZGluZyBhdWRpb1xuXHQgKiBAcHJvcGVydHkgY29udGV4dFxuXHQgKiBAdHlwZSB7QXVkaW9Db250ZXh0fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRMb2FkZXIuY29udGV4dCA9IG51bGw7XG5cblxuLy8gcHVibGljIG1ldGhvZHNcblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbV2ViQXVkaW9Mb2FkZXJdXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzXG5cdHAuX2NyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLlhIUlJlcXVlc3QodGhpcy5faXRlbSwgZmFsc2UpO1xuXHRcdHRoaXMuX3JlcXVlc3Quc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIik7XG5cdH07XG5cblx0cC5fc2VuZENvbXBsZXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0Ly8gT0pSIHdlIGxlYXZlIHRoaXMgd3JhcHBlZCBpbiBMb2FkZXIgYmVjYXVzZSB3ZSBuZWVkIHRvIHJlZmVyZW5jZSBzcmMgYW5kIHRoZSBoYW5kbGVyIG9ubHkgcmVjZWl2ZXMgYSBzaW5nbGUgYXJndW1lbnQsIHRoZSBkZWNvZGVkQXVkaW9cblx0XHRMb2FkZXIuY29udGV4dC5kZWNvZGVBdWRpb0RhdGEodGhpcy5fcmF3UmVzdWx0LFxuXHQgICAgICAgICBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVBdWRpb0RlY29kZWQsIHRoaXMpLFxuXHQgICAgICAgICBjcmVhdGVqcy5wcm94eSh0aGlzLl9zZW5kRXJyb3IsIHRoaXMpKTtcblx0fTtcblxuXG5cdC8qKlxuXHQqIFRoZSBhdWRpbyBoYXMgYmVlbiBkZWNvZGVkLlxuXHQqIEBtZXRob2QgaGFuZGxlQXVkaW9EZWNvZGVkXG5cdCogQHBhcmFtIGRlY29kZWRcblx0KiBAcHJvdGVjdGVkXG5cdCovXG5cdHAuX2hhbmRsZUF1ZGlvRGVjb2RlZCA9IGZ1bmN0aW9uIChkZWNvZGVkQXVkaW8pIHtcblx0XHR0aGlzLl9yZXN1bHQgPSBkZWNvZGVkQXVkaW87XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9fc2VuZENvbXBsZXRlKCk7XG5cdH07XG5cblx0Y3JlYXRlanMuV2ViQXVkaW9Mb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBXZWJBdWRpb1NvdW5kSW5zdGFuY2UuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbi8qKlxuICogV2ViQXVkaW9Tb3VuZEluc3RhbmNlIGV4dGVuZHMgdGhlIGJhc2UgYXBpIG9mIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0U291bmRJbnN0YW5jZVwifX17ey9jcm9zc0xpbmt9fSBhbmQgaXMgdXNlZCBieVxuICoge3sjY3Jvc3NMaW5rIFwiV2ViQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0uXG4gKlxuICogV2ViQXVkaW9Tb3VuZEluc3RhbmNlIGV4cG9zZXMgYXVkaW9Ob2RlcyBmb3IgYWR2YW5jZWQgdXNlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgcGF0aCB0byBhbmQgZmlsZSBuYW1lIG9mIHRoZSBzb3VuZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFRpbWUgQXVkaW8gc3ByaXRlIHByb3BlcnR5IHVzZWQgdG8gYXBwbHkgYW4gb2Zmc2V0LCBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gQXVkaW8gc3ByaXRlIHByb3BlcnR5IHVzZWQgdG8gc2V0IHRoZSB0aW1lIHRoZSBjbGlwIHBsYXlzIGZvciwgaW4gbWlsbGlzZWNvbmRzLlxuICogQHBhcmFtIHtPYmplY3R9IHBsYXliYWNrUmVzb3VyY2UgQW55IHJlc291cmNlIG5lZWRlZCBieSBwbHVnaW4gdG8gc3VwcG9ydCBhdWRpbyBwbGF5YmFjay5cbiAqIEBjbGFzcyBXZWJBdWRpb1NvdW5kSW5zdGFuY2VcbiAqIEBleHRlbmRzIEFic3RyYWN0U291bmRJbnN0YW5jZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGZ1bmN0aW9uIFdlYkF1ZGlvU291bmRJbnN0YW5jZShzcmMsIHN0YXJ0VGltZSwgZHVyYXRpb24sIHBsYXliYWNrUmVzb3VyY2UpIHtcblx0XHR0aGlzLkFic3RyYWN0U291bmRJbnN0YW5jZV9jb25zdHJ1Y3RvcihzcmMsIHN0YXJ0VGltZSwgZHVyYXRpb24sIHBsYXliYWNrUmVzb3VyY2UpO1xuXG5cbi8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogTk9URSB0aGlzIGlzIG9ubHkgaW50ZW5kZWQgZm9yIHVzZSBieSBhZHZhbmNlZCB1c2Vycy5cblx0XHQgKiA8YnIgLz5HYWluTm9kZSBmb3IgY29udHJvbGxpbmcgPGNvZGU+V2ViQXVkaW9Tb3VuZEluc3RhbmNlPC9jb2RlPiB2b2x1bWUuIENvbm5lY3RlZCB0byB0aGUge3sjY3Jvc3NMaW5rIFwiV2ViQXVkaW9Tb3VuZEluc3RhbmNlL2Rlc3RpbmF0aW9uTm9kZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgZ2Fpbk5vZGVcblx0XHQgKiBAdHlwZSB7QXVkaW9HYWluTm9kZX1cblx0XHQgKiBAc2luY2UgMC40LjBcblx0XHQgKlxuXHRcdCAqL1xuXHRcdHRoaXMuZ2Fpbk5vZGUgPSBzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuXG5cdFx0LyoqXG5cdFx0ICogTk9URSB0aGlzIGlzIG9ubHkgaW50ZW5kZWQgZm9yIHVzZSBieSBhZHZhbmNlZCB1c2Vycy5cblx0XHQgKiA8YnIgLz5BIHBhbk5vZGUgYWxsb3dpbmcgbGVmdCBhbmQgcmlnaHQgYXVkaW8gY2hhbm5lbCBwYW5uaW5nIG9ubHkuIENvbm5lY3RlZCB0byBXZWJBdWRpb1NvdW5kSW5zdGFuY2Uge3sjY3Jvc3NMaW5rIFwiV2ViQXVkaW9Tb3VuZEluc3RhbmNlL2dhaW5Ob2RlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBwYW5Ob2RlXG5cdFx0ICogQHR5cGUge0F1ZGlvUGFubmVyTm9kZX1cblx0XHQgKiBAc2luY2UgMC40LjBcblx0XHQgKi9cblx0XHR0aGlzLnBhbk5vZGUgPSBzLmNvbnRleHQuY3JlYXRlUGFubmVyKCk7XG5cdFx0dGhpcy5wYW5Ob2RlLnBhbm5pbmdNb2RlbCA9IHMuX3Bhbm5pbmdNb2RlbDtcblx0XHR0aGlzLnBhbk5vZGUuY29ubmVjdCh0aGlzLmdhaW5Ob2RlKTtcblx0XHR0aGlzLl91cGRhdGVQYW4oKTtcblxuXHRcdC8qKlxuXHRcdCAqIE5PVEUgdGhpcyBpcyBvbmx5IGludGVuZGVkIGZvciB1c2UgYnkgYWR2YW5jZWQgdXNlcnMuXG5cdFx0ICogPGJyIC8+c291cmNlTm9kZSBpcyB0aGUgYXVkaW8gc291cmNlLiBDb25uZWN0ZWQgdG8gV2ViQXVkaW9Tb3VuZEluc3RhbmNlIHt7I2Nyb3NzTGluayBcIldlYkF1ZGlvU291bmRJbnN0YW5jZS9wYW5Ob2RlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBzb3VyY2VOb2RlXG5cdFx0ICogQHR5cGUge0F1ZGlvTm9kZX1cblx0XHQgKiBAc2luY2UgMC40LjBcblx0XHQgKlxuXHRcdCAqL1xuXHRcdHRoaXMuc291cmNlTm9kZSA9IG51bGw7XG5cblxuLy8gcHJpdmF0ZSBwcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogVGltZW91dCB0aGF0IGlzIGNyZWF0ZWQgaW50ZXJuYWxseSB0byBoYW5kbGUgc291bmQgcGxheWluZyB0byBjb21wbGV0aW9uLlxuXHRcdCAqIFN0b3JlZCBzbyB3ZSBjYW4gcmVtb3ZlIGl0IHdoZW4gc3RvcCwgcGF1c2UsIG9yIGNsZWFudXAgYXJlIGNhbGxlZFxuXHRcdCAqIEBwcm9wZXJ0eSBfc291bmRDb21wbGV0ZVRpbWVvdXRcblx0XHQgKiBAdHlwZSB7dGltZW91dFZhcmlhYmxlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHNpbmNlIDAuNC4wXG5cdFx0ICovXG5cdFx0dGhpcy5fc291bmRDb21wbGV0ZVRpbWVvdXQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogTk9URSB0aGlzIGlzIG9ubHkgaW50ZW5kZWQgZm9yIHVzZSBieSB2ZXJ5IGFkdmFuY2VkIHVzZXJzLlxuXHRcdCAqIF9zb3VyY2VOb2RlTmV4dCBpcyB0aGUgYXVkaW8gc291cmNlIGZvciB0aGUgbmV4dCBsb29wLCBpbnNlcnRlZCBpbiBhIGxvb2sgYWhlYWQgYXBwcm9hY2ggdG8gYWxsb3cgZm9yIHNtb290aFxuXHRcdCAqIGxvb3BpbmcuIENvbm5lY3RlZCB0byB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1NvdW5kSW5zdGFuY2UvZ2Fpbk5vZGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IF9zb3VyY2VOb2RlTmV4dFxuXHRcdCAqIEB0eXBlIHtBdWRpb05vZGV9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAc2luY2UgMC40LjFcblx0XHQgKlxuXHRcdCAqL1xuXHRcdHRoaXMuX3NvdXJjZU5vZGVOZXh0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRpbWUgYXVkaW8gc3RhcnRlZCBwbGF5YmFjaywgaW4gc2Vjb25kcy4gVXNlZCB0byBoYW5kbGUgc2V0IHBvc2l0aW9uLCBnZXQgcG9zaXRpb24sIGFuZCByZXN1bWluZyBmcm9tIHBhdXNlZC5cblx0XHQgKiBAcHJvcGVydHkgX3BsYXliYWNrU3RhcnRUaW1lXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBzaW5jZSAwLjQuMFxuXHRcdCAqL1xuXHRcdHRoaXMuX3BsYXliYWNrU3RhcnRUaW1lID0gMDtcblxuXHRcdC8vIFByb3hpZXMsIG1ha2UgcmVtb3ZpbmcgbGlzdGVuZXJzIGVhc2llci5cblx0XHR0aGlzLl9lbmRlZEhhbmRsZXIgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVTb3VuZENvbXBsZXRlLCB0aGlzKTtcblx0fTtcblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoV2ViQXVkaW9Tb3VuZEluc3RhbmNlLCBjcmVhdGVqcy5BYnN0cmFjdFNvdW5kSW5zdGFuY2UpO1xuXHR2YXIgcyA9IFdlYkF1ZGlvU291bmRJbnN0YW5jZTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXG5cdC8qKlxuXHQgKiBOb3RlIHRoaXMgaXMgb25seSBpbnRlbmRlZCBmb3IgdXNlIGJ5IGFkdmFuY2VkIHVzZXJzLlxuXHQgKiA8YnIgLz5BdWRpbyBjb250ZXh0IHVzZWQgdG8gY3JlYXRlIG5vZGVzLiAgVGhpcyBpcyBhbmQgbmVlZHMgdG8gYmUgdGhlIHNhbWUgY29udGV4dCB1c2VkIGJ5IHt7I2Nyb3NzTGluayBcIldlYkF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319LlxuICBcdCAqIEBwcm9wZXJ0eSBjb250ZXh0XG5cdCAqIEB0eXBlIHtBdWRpb0NvbnRleHR9XG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLmNvbnRleHQgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBOb3RlIHRoaXMgaXMgb25seSBpbnRlbmRlZCBmb3IgdXNlIGJ5IGFkdmFuY2VkIHVzZXJzLlxuXHQgKiA8YnIgLz5UaGUgc2NyYXRjaCBidWZmZXIgdGhhdCB3aWxsIGJlIGFzc2lnbmVkIHRvIHRoZSBidWZmZXIgcHJvcGVydHkgb2YgYSBzb3VyY2Ugbm9kZSBvbiBjbG9zZS4gIFxuXHQgKiBUaGlzIGlzIGFuZCBzaG91bGQgYmUgdGhlIHNhbWUgc2NyYXRjaCBidWZmZXIgcmVmZXJlbmNlZCBieSB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fS5cbiAgXHQgKiBAcHJvcGVydHkgX3NjcmF0Y2hCdWZmZXJcblx0ICogQHR5cGUge0F1ZGlvQnVmZmVyU291cmNlTm9kZX1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5fc2NyYXRjaEJ1ZmZlciA9IG51bGw7XG5cblx0LyoqXG5cdCAqIE5vdGUgdGhpcyBpcyBvbmx5IGludGVuZGVkIGZvciB1c2UgYnkgYWR2YW5jZWQgdXNlcnMuXG5cdCAqIDxiciAvPiBBdWRpbyBub2RlIGZyb20gV2ViQXVkaW9QbHVnaW4gdGhhdCBzZXF1ZW5jZXMgdG8gPGNvZGU+Y29udGV4dC5kZXN0aW5hdGlvbjwvY29kZT5cblx0ICogQHByb3BlcnR5IGRlc3RpbmF0aW9uTm9kZVxuXHQgKiBAdHlwZSB7QXVkaW9Ob2RlfVxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5kZXN0aW5hdGlvbk5vZGUgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBWYWx1ZSB0byBzZXQgcGFubmluZyBtb2RlbCB0byBlcXVhbCBwb3dlciBmb3IgV2ViQXVkaW9Tb3VuZEluc3RhbmNlLiAgQ2FuIGJlIFwiZXF1YWxwb3dlclwiIG9yIDAgZGVwZW5kaW5nIG9uIGJyb3dzZXIgaW1wbGVtZW50YXRpb24uXG5cdCAqIEBwcm9wZXJ0eSBfcGFubmluZ01vZGVsXG5cdCAqIEB0eXBlIHtOdW1iZXIgLyBTdHJpbmd9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuX3Bhbm5pbmdNb2RlbCA9IFwiZXF1YWxwb3dlclwiO1xuXG5cbi8vIFB1YmxpYyBtZXRob2RzXG5cdHAuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuQWJzdHJhY3RTb3VuZEluc3RhbmNlX2Rlc3Ryb3koKTtcblxuXHRcdHRoaXMucGFuTm9kZS5kaXNjb25uZWN0KDApO1xuXHRcdHRoaXMucGFuTm9kZSA9IG51bGw7XG5cdFx0dGhpcy5nYWluTm9kZS5kaXNjb25uZWN0KDApO1xuXHRcdHRoaXMuZ2Fpbk5vZGUgPSBudWxsO1xuXHR9O1xuXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFwiW1dlYkF1ZGlvU291bmRJbnN0YW5jZV1cIjtcblx0fTtcblxuXG4vLyBQcml2YXRlIE1ldGhvZHNcblx0cC5fdXBkYXRlUGFuID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5wYW5Ob2RlLnNldFBvc2l0aW9uKHRoaXMuX3BhbiwgMCwgLTAuNSk7XG5cdFx0Ly8geiBuZWVkIHRvIGJlIC0wLjUgb3RoZXJ3aXNlIHRoZSBzb3VuZCBvbmx5IHBsYXlzIGluIGxlZnQsIHJpZ2h0LCBvciBjZW50ZXJcblx0fTtcblxuXHRwLl9yZW1vdmVMb29waW5nID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzLl9zb3VyY2VOb2RlTmV4dCA9IHRoaXMuX2NsZWFuVXBBdWRpb05vZGUodGhpcy5fc291cmNlTm9kZU5leHQpO1xuXHR9O1xuXG5cdHAuX2FkZExvb3BpbmcgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh0aGlzLnBsYXlTdGF0ZSAhPSBjcmVhdGVqcy5Tb3VuZC5QTEFZX1NVQ0NFRURFRCkgeyByZXR1cm47IH1cblx0XHR0aGlzLl9zb3VyY2VOb2RlTmV4dCA9IHRoaXMuX2NyZWF0ZUFuZFBsYXlBdWRpb05vZGUodGhpcy5fcGxheWJhY2tTdGFydFRpbWUsIDApO1xuXHR9O1xuXG5cdHAuX3NldER1cmF0aW9uRnJvbVNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9kdXJhdGlvbiA9IHRoaXMucGxheWJhY2tSZXNvdXJjZS5kdXJhdGlvbiAqIDEwMDA7XG5cdH07XG5cblx0cC5faGFuZGxlQ2xlYW5VcCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5zb3VyY2VOb2RlICYmIHRoaXMucGxheVN0YXRlID09IGNyZWF0ZWpzLlNvdW5kLlBMQVlfU1VDQ0VFREVEKSB7XG5cdFx0XHR0aGlzLnNvdXJjZU5vZGUgPSB0aGlzLl9jbGVhblVwQXVkaW9Ob2RlKHRoaXMuc291cmNlTm9kZSk7XG5cdFx0XHR0aGlzLl9zb3VyY2VOb2RlTmV4dCA9IHRoaXMuX2NsZWFuVXBBdWRpb05vZGUodGhpcy5fc291cmNlTm9kZU5leHQpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmdhaW5Ob2RlLm51bWJlck9mT3V0cHV0cyAhPSAwKSB7dGhpcy5nYWluTm9kZS5kaXNjb25uZWN0KDApO31cblx0XHQvLyBPSlIgdGhlcmUgYXBwZWFycyB0byBiZSBhIGJ1ZyB0aGF0IHRoaXMgZG9lc24ndCBhbHdheXMgd29yayBpbiB3ZWJraXQgKENocm9tZSBhbmQgU2FmYXJpKS4gQWNjb3JkaW5nIHRvIHRoZSBkb2N1bWVudGF0aW9uLCB0aGlzIHNob3VsZCB3b3JrLlxuXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NvdW5kQ29tcGxldGVUaW1lb3V0KTtcblxuXHRcdHRoaXMuX3BsYXliYWNrU3RhcnRUaW1lID0gMDtcdC8vIFRoaXMgaXMgdXNlZCBieSBnZXRQb3NpdGlvblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUdXJuIG9mZiBhbmQgZGlzY29ubmVjdCBhbiBhdWRpb05vZGUsIHRoZW4gc2V0IHJlZmVyZW5jZSB0byBudWxsIHRvIHJlbGVhc2UgaXQgZm9yIGdhcmJhZ2UgY29sbGVjdGlvblxuXHQgKiBAbWV0aG9kIF9jbGVhblVwQXVkaW9Ob2RlXG5cdCAqIEBwYXJhbSBhdWRpb05vZGVcblx0ICogQHJldHVybiB7YXVkaW9Ob2RlfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKi9cblx0cC5fY2xlYW5VcEF1ZGlvTm9kZSA9IGZ1bmN0aW9uKGF1ZGlvTm9kZSkge1xuXHRcdGlmKGF1ZGlvTm9kZSkge1xuXHRcdFx0YXVkaW9Ob2RlLnN0b3AoMCk7XG5cdFx0XHRhdWRpb05vZGUuZGlzY29ubmVjdCgwKTtcblx0XHRcdC8vIG5lY2Vzc2FyeSB0byBwcmV2ZW50IGxlYWsgb24gaU9TIFNhZmFyaSA3LTkuIHdpbGwgdGhyb3cgaW4gYWxtb3N0IGFsbCBvdGhlclxuXHRcdFx0Ly8gYnJvd3NlciBpbXBsZW1lbnRhdGlvbnMuXG5cdFx0XHR0cnkgeyBhdWRpb05vZGUuYnVmZmVyID0gcy5fc2NyYXRjaEJ1ZmZlcjsgfSBjYXRjaChlKSB7fVxuXHRcdFx0YXVkaW9Ob2RlID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIGF1ZGlvTm9kZTtcblx0fTtcblxuXHRwLl9oYW5kbGVTb3VuZFJlYWR5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dGhpcy5nYWluTm9kZS5jb25uZWN0KHMuZGVzdGluYXRpb25Ob2RlKTsgIC8vIHRoaXMgbGluZSBjYW4gY2F1c2UgYSBtZW1vcnkgbGVhay4gIE5vZGVzIG5lZWQgdG8gYmUgZGlzY29ubmVjdGVkIGZyb20gdGhlIGF1ZGlvRGVzdGluYXRpb24gb3IgYW55IHNlcXVlbmNlIHRoYXQgbGVhZHMgdG8gaXQuXG5cblx0XHR2YXIgZHVyID0gdGhpcy5fZHVyYXRpb24gKiAwLjAwMTtcblx0XHR2YXIgcG9zID0gdGhpcy5fcG9zaXRpb24gKiAwLjAwMTtcblx0XHRpZiAocG9zID4gZHVyKSB7cG9zID0gZHVyO31cblx0XHR0aGlzLnNvdXJjZU5vZGUgPSB0aGlzLl9jcmVhdGVBbmRQbGF5QXVkaW9Ob2RlKChzLmNvbnRleHQuY3VycmVudFRpbWUgLSBkdXIpLCBwb3MpO1xuXHRcdHRoaXMuX3BsYXliYWNrU3RhcnRUaW1lID0gdGhpcy5zb3VyY2VOb2RlLnN0YXJ0VGltZSAtIHBvcztcblxuXHRcdHRoaXMuX3NvdW5kQ29tcGxldGVUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLl9lbmRlZEhhbmRsZXIsIChkdXIgLSBwb3MpICogMTAwMCk7XG5cblx0XHRpZih0aGlzLl9sb29wICE9IDApIHtcblx0XHRcdHRoaXMuX3NvdXJjZU5vZGVOZXh0ID0gdGhpcy5fY3JlYXRlQW5kUGxheUF1ZGlvTm9kZSh0aGlzLl9wbGF5YmFja1N0YXJ0VGltZSwgMCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGF1ZGlvIG5vZGUgdXNpbmcgdGhlIGN1cnJlbnQgc3JjIGFuZCBjb250ZXh0LCBjb25uZWN0cyBpdCB0byB0aGUgZ2FpbiBub2RlLCBhbmQgc3RhcnRzIHBsYXliYWNrLlxuXHQgKiBAbWV0aG9kIF9jcmVhdGVBbmRQbGF5QXVkaW9Ob2RlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFRpbWUgVGhlIHRpbWUgdG8gYWRkIHRoaXMgdG8gdGhlIHdlYiBhdWRpbyBjb250ZXh0LCBpbiBzZWNvbmRzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IFRoZSBhbW91bnQgb2YgdGltZSBpbnRvIHRoZSBzcmMgYXVkaW8gdG8gc3RhcnQgcGxheWJhY2ssIGluIHNlY29uZHMuXG5cdCAqIEByZXR1cm4ge2F1ZGlvTm9kZX1cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC40LjFcblx0ICovXG5cdHAuX2NyZWF0ZUFuZFBsYXlBdWRpb05vZGUgPSBmdW5jdGlvbihzdGFydFRpbWUsIG9mZnNldCkge1xuXHRcdHZhciBhdWRpb05vZGUgPSBzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cdFx0YXVkaW9Ob2RlLmJ1ZmZlciA9IHRoaXMucGxheWJhY2tSZXNvdXJjZTtcblx0XHRhdWRpb05vZGUuY29ubmVjdCh0aGlzLnBhbk5vZGUpO1xuXHRcdHZhciBkdXIgPSB0aGlzLl9kdXJhdGlvbiAqIDAuMDAxO1xuXHRcdGF1ZGlvTm9kZS5zdGFydFRpbWUgPSBzdGFydFRpbWUgKyBkdXI7XG5cdFx0YXVkaW9Ob2RlLnN0YXJ0KGF1ZGlvTm9kZS5zdGFydFRpbWUsIG9mZnNldCsodGhpcy5fc3RhcnRUaW1lKjAuMDAxKSwgZHVyIC0gb2Zmc2V0KTtcblx0XHRyZXR1cm4gYXVkaW9Ob2RlO1xuXHR9O1xuXG5cdHAuX3BhdXNlID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3Bvc2l0aW9uID0gKHMuY29udGV4dC5jdXJyZW50VGltZSAtIHRoaXMuX3BsYXliYWNrU3RhcnRUaW1lKSAqIDEwMDA7ICAvLyAqIDEwMDAgdG8gZ2l2ZSBtaWxsaXNlY29uZHMsIGxldHMgdXMgcmVzdGFydCBhdCBzYW1lIHBvaW50XG5cdFx0dGhpcy5zb3VyY2VOb2RlID0gdGhpcy5fY2xlYW5VcEF1ZGlvTm9kZSh0aGlzLnNvdXJjZU5vZGUpO1xuXHRcdHRoaXMuX3NvdXJjZU5vZGVOZXh0ID0gdGhpcy5fY2xlYW5VcEF1ZGlvTm9kZSh0aGlzLl9zb3VyY2VOb2RlTmV4dCk7XG5cblx0XHRpZiAodGhpcy5nYWluTm9kZS5udW1iZXJPZk91dHB1dHMgIT0gMCkge3RoaXMuZ2Fpbk5vZGUuZGlzY29ubmVjdCgwKTt9XG5cblx0XHRjbGVhclRpbWVvdXQodGhpcy5fc291bmRDb21wbGV0ZVRpbWVvdXQpO1xuXHR9O1xuXG5cdHAuX3Jlc3VtZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9oYW5kbGVTb3VuZFJlYWR5KCk7XG5cdH07XG5cblx0Lypcblx0cC5faGFuZGxlU3RvcCA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB3ZWIgYXVkaW8gZG9lcyBub3QgbmVlZCB0byBkbyBhbnl0aGluZyBleHRyYVxuXHR9O1xuXHQqL1xuXG5cdHAuX3VwZGF0ZVZvbHVtZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbmV3Vm9sdW1lID0gdGhpcy5fbXV0ZWQgPyAwIDogdGhpcy5fdm9sdW1lO1xuXHQgIFx0aWYgKG5ld1ZvbHVtZSAhPSB0aGlzLmdhaW5Ob2RlLmdhaW4udmFsdWUpIHtcblx0XHQgIHRoaXMuZ2Fpbk5vZGUuZ2Fpbi52YWx1ZSA9IG5ld1ZvbHVtZTtcbiAgXHRcdH1cblx0fTtcblxuXHRwLl9jYWxjdWxhdGVDdXJyZW50UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICgocy5jb250ZXh0LmN1cnJlbnRUaW1lIC0gdGhpcy5fcGxheWJhY2tTdGFydFRpbWUpICogMTAwMCk7IC8vIHBvcyBpbiBzZWNvbmRzICogMTAwMCB0byBnaXZlIG1pbGxpc2Vjb25kc1xuXHR9O1xuXG5cdHAuX3VwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuc291cmNlTm9kZSA9IHRoaXMuX2NsZWFuVXBBdWRpb05vZGUodGhpcy5zb3VyY2VOb2RlKTtcblx0XHR0aGlzLl9zb3VyY2VOb2RlTmV4dCA9IHRoaXMuX2NsZWFuVXBBdWRpb05vZGUodGhpcy5fc291cmNlTm9kZU5leHQpO1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9zb3VuZENvbXBsZXRlVGltZW91dCk7XG5cblx0XHRpZiAoIXRoaXMuX3BhdXNlZCkge3RoaXMuX2hhbmRsZVNvdW5kUmVhZHkoKTt9XG5cdH07XG5cblx0Ly8gT0pSIHdlIGFyZSB1c2luZyBhIGxvb2sgYWhlYWQgYXBwcm9hY2ggdG8gZW5zdXJlIHNtb290aCBsb29waW5nLlxuXHQvLyBXZSBhZGQgX3NvdXJjZU5vZGVOZXh0IHRvIHRoZSBhdWRpbyBjb250ZXh0IHNvIHRoYXQgaXQgc3RhcnRzIHBsYXlpbmcgZXZlbiBpZiB0aGlzIGNhbGxiYWNrIGlzIGRlbGF5ZWQuXG5cdC8vIFRoaXMgdGVjaG5pcXVlIGlzIGRlc2NyaWJlZCBoZXJlOiAgaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvYXVkaW8vc2NoZWR1bGluZy9cblx0Ly8gTk9URSB0aGUgY29zdCBvZiB0aGlzIGlzIHRoYXQgb3VyIGF1ZGlvIGxvb3AgbWF5IG5vdCBhbHdheXMgbWF0Y2ggdGhlIGxvb3AgZXZlbnQgdGltaW5nIHByZWNpc2VseS5cblx0cC5faGFuZGxlTG9vcCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jbGVhblVwQXVkaW9Ob2RlKHRoaXMuc291cmNlTm9kZSk7XG5cdFx0dGhpcy5zb3VyY2VOb2RlID0gdGhpcy5fc291cmNlTm9kZU5leHQ7XG5cdFx0dGhpcy5fcGxheWJhY2tTdGFydFRpbWUgPSB0aGlzLnNvdXJjZU5vZGUuc3RhcnRUaW1lO1xuXHRcdHRoaXMuX3NvdXJjZU5vZGVOZXh0ID0gdGhpcy5fY3JlYXRlQW5kUGxheUF1ZGlvTm9kZSh0aGlzLl9wbGF5YmFja1N0YXJ0VGltZSwgMCk7XG5cdFx0dGhpcy5fc291bmRDb21wbGV0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuX2VuZGVkSGFuZGxlciwgdGhpcy5fZHVyYXRpb24pO1xuXHR9O1xuXG5cdHAuX3VwZGF0ZUR1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmKHRoaXMucGxheVN0YXRlID09IGNyZWF0ZWpzLlNvdW5kLlBMQVlfU1VDQ0VFREVEKSB7XG5cdFx0XHR0aGlzLl9wYXVzZSgpO1xuXHRcdFx0dGhpcy5fcmVzdW1lKCk7XG5cdFx0fVxuXHR9O1xuXG5cdGNyZWF0ZWpzLldlYkF1ZGlvU291bmRJbnN0YW5jZSA9IGNyZWF0ZWpzLnByb21vdGUoV2ViQXVkaW9Tb3VuZEluc3RhbmNlLCBcIkFic3RyYWN0U291bmRJbnN0YW5jZVwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBXZWJBdWRpb1BsdWdpbi5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogUGxheSBzb3VuZHMgdXNpbmcgV2ViIEF1ZGlvIGluIHRoZSBicm93c2VyLiBUaGUgV2ViQXVkaW9QbHVnaW4gaXMgY3VycmVudGx5IHRoZSBkZWZhdWx0IHBsdWdpbiwgYW5kIHdpbGwgYmUgdXNlZFxuXHQgKiBhbnl3aGVyZSB0aGF0IGl0IGlzIHN1cHBvcnRlZC4gVG8gY2hhbmdlIHBsdWdpbiBwcmlvcml0eSwgY2hlY2sgb3V0IHRoZSBTb3VuZCBBUElcblx0ICoge3sjY3Jvc3NMaW5rIFwiU291bmQvcmVnaXN0ZXJQbHVnaW5zXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cblxuXHQgKiA8aDQ+S25vd24gQnJvd3NlciBhbmQgT1MgaXNzdWVzIGZvciBXZWIgQXVkaW88L2g0PlxuXHQgKiA8Yj5GaXJlZm94IDI1PC9iPlxuXHQgKiA8bGk+XG5cdCAqICAgICBtcDMgYXVkaW8gZmlsZXMgZG8gbm90IGxvYWQgcHJvcGVybHkgb24gYWxsIHdpbmRvd3MgbWFjaGluZXMsIHJlcG9ydGVkIDxhIGhyZWY9XCJodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD05Mjk5NjlcIiB0YXJnZXQ9XCJfYmxhbmtcIj5oZXJlPC9hPi5cblx0ICogICAgIDxiciAvPkZvciB0aGlzIHJlYXNvbiBpdCBpcyByZWNvbW1lbmRlZCB0byBwYXNzIGFub3RoZXIgRmlyZUZveC1zdXBwb3J0ZWQgdHlwZSAoaS5lLiBvZ2cpIGFzIHRoZSBkZWZhdWx0XG5cdCAqICAgICBleHRlbnNpb24sIHVudGlsIHRoaXMgYnVnIGlzIHJlc29sdmVkXG5cdCAqIDwvbGk+XG5cdCAqXG5cdCAqIDxiPldlYmtpdCAoQ2hyb21lIGFuZCBTYWZhcmkpPC9iPlxuXHQgKiA8bGk+XG5cdCAqICAgICBBdWRpb05vZGUuZGlzY29ubmVjdCBkb2VzIG5vdCBhbHdheXMgc2VlbSB0byB3b3JrLiAgVGhpcyBjYW4gY2F1c2UgdGhlIGZpbGUgc2l6ZSB0byBncm93IG92ZXIgdGltZSBpZiB5b3Vcblx0ICogXHQgICBhcmUgcGxheWluZyBhIGxvdCBvZiBhdWRpbyBmaWxlcy5cblx0ICogPC9saT5cblx0ICpcblx0ICogPGI+aU9TIDYgbGltaXRhdGlvbnM8L2I+XG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT5cblx0ICogICAgICAgICBTb3VuZCBpcyBpbml0aWFsbHkgbXV0ZWQgYW5kIHdpbGwgb25seSB1bm11dGUgdGhyb3VnaCBwbGF5IGJlaW5nIGNhbGxlZCBpbnNpZGUgYSB1c2VyIGluaXRpYXRlZCBldmVudFxuXHQgKiAgICAgICAgICh0b3VjaC9jbGljaykuIFBsZWFzZSByZWFkIHRoZSBtb2JpbGUgcGxheWJhY2sgbm90ZXMgaW4gdGhlIHRoZSB7eyNjcm9zc0xpbmsgXCJTb3VuZFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiAgICAgICAgIGNsYXNzIGZvciBhIGZ1bGwgb3ZlcnZpZXcgb2YgdGhlIGxpbWl0YXRpb25zLCBhbmQgaG93IHRvIGdldCBhcm91bmQgdGhlbS5cblx0ICogICAgIDwvbGk+XG5cdCAqXHQgICA8bGk+XG5cdCAqXHQgICAgICAgQSBidWcgZXhpc3RzIHRoYXQgd2lsbCBkaXN0b3J0IHVuLWNhY2hlZCBhdWRpbyB3aGVuIGEgdmlkZW8gZWxlbWVudCBpcyBwcmVzZW50IGluIHRoZSBET00uIFlvdSBjYW4gYXZvaWRcblx0ICpcdCAgICAgICB0aGlzIGJ1ZyBieSBlbnN1cmluZyB0aGUgYXVkaW8gYW5kIHZpZGVvIGF1ZGlvIHNoYXJlIHRoZSBzYW1lIHNhbXBsZSByYXRlLlxuXHQgKlx0ICAgPC9saT5cblx0ICogPC91bD5cblx0ICogQGNsYXNzIFdlYkF1ZGlvUGx1Z2luXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0UGx1Z2luXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAc2luY2UgMC40LjBcblx0ICovXG5cdGZ1bmN0aW9uIFdlYkF1ZGlvUGx1Z2luKCkge1xuXHRcdHRoaXMuQWJzdHJhY3RQbHVnaW5fY29uc3RydWN0b3IoKTtcblxuXG4vLyBQcml2YXRlIFByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBWYWx1ZSB0byBzZXQgcGFubmluZyBtb2RlbCB0byBlcXVhbCBwb3dlciBmb3IgV2ViQXVkaW9Tb3VuZEluc3RhbmNlLiAgQ2FuIGJlIFwiZXF1YWxwb3dlclwiIG9yIDAgZGVwZW5kaW5nIG9uIGJyb3dzZXIgaW1wbGVtZW50YXRpb24uXG5cdFx0ICogQHByb3BlcnR5IF9wYW5uaW5nTW9kZWxcblx0XHQgKiBAdHlwZSB7TnVtYmVyIC8gU3RyaW5nfVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9wYW5uaW5nTW9kZWwgPSBzLl9wYW5uaW5nTW9kZWw7O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHdlYiBhdWRpbyBjb250ZXh0LCB3aGljaCBXZWJBdWRpbyB1c2VzIHRvIHBsYXkgYXVkaW8uIEFsbCBub2RlcyB0aGF0IGludGVyYWN0IHdpdGggdGhlIFdlYkF1ZGlvUGx1Z2luXG5cdFx0ICogbmVlZCB0byBiZSBjcmVhdGVkIHdpdGhpbiB0aGlzIGNvbnRleHQuXG5cdFx0ICogQHByb3BlcnR5IGNvbnRleHRcblx0XHQgKiBAdHlwZSB7QXVkaW9Db250ZXh0fVxuXHRcdCAqL1xuXHRcdHRoaXMuY29udGV4dCA9IHMuY29udGV4dDtcblxuXHRcdC8qKlxuXHRcdCAqIEEgRHluYW1pY3NDb21wcmVzc29yTm9kZSwgd2hpY2ggaXMgdXNlZCB0byBpbXByb3ZlIHNvdW5kIHF1YWxpdHkgYW5kIHByZXZlbnQgYXVkaW8gZGlzdG9ydGlvbi5cblx0XHQgKiBJdCBpcyBjb25uZWN0ZWQgdG8gPGNvZGU+Y29udGV4dC5kZXN0aW5hdGlvbjwvY29kZT4uXG5cdFx0ICpcblx0XHQgKiBDYW4gYmUgYWNjZXNzZWQgYnkgYWR2YW5jZWQgdXNlcnMgdGhyb3VnaCBjcmVhdGVqcy5Tb3VuZC5hY3RpdmVQbHVnaW4uZHluYW1pY3NDb21wcmVzc29yTm9kZS5cblx0XHQgKiBAcHJvcGVydHkgZHluYW1pY3NDb21wcmVzc29yTm9kZVxuXHRcdCAqIEB0eXBlIHtBdWRpb05vZGV9XG5cdFx0ICovXG5cdFx0dGhpcy5keW5hbWljc0NvbXByZXNzb3JOb2RlID0gdGhpcy5jb250ZXh0LmNyZWF0ZUR5bmFtaWNzQ29tcHJlc3NvcigpO1xuXHRcdHRoaXMuZHluYW1pY3NDb21wcmVzc29yTm9kZS5jb25uZWN0KHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbik7XG5cblx0XHQvKipcblx0XHQgKiBBIEdhaW5Ob2RlIGZvciBjb250cm9sbGluZyBtYXN0ZXIgdm9sdW1lLiBJdCBpcyBjb25uZWN0ZWQgdG8ge3sjY3Jvc3NMaW5rIFwiV2ViQXVkaW9QbHVnaW4vZHluYW1pY3NDb21wcmVzc29yTm9kZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKlxuXHRcdCAqIENhbiBiZSBhY2Nlc3NlZCBieSBhZHZhbmNlZCB1c2VycyB0aHJvdWdoIGNyZWF0ZWpzLlNvdW5kLmFjdGl2ZVBsdWdpbi5nYWluTm9kZS5cblx0XHQgKiBAcHJvcGVydHkgZ2Fpbk5vZGVcblx0XHQgKiBAdHlwZSB7QXVkaW9HYWluTm9kZX1cblx0XHQgKi9cblx0XHR0aGlzLmdhaW5Ob2RlID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblx0XHR0aGlzLmdhaW5Ob2RlLmNvbm5lY3QodGhpcy5keW5hbWljc0NvbXByZXNzb3JOb2RlKTtcblx0XHRjcmVhdGVqcy5XZWJBdWRpb1NvdW5kSW5zdGFuY2UuZGVzdGluYXRpb25Ob2RlID0gdGhpcy5nYWluTm9kZTtcblxuXHRcdHRoaXMuX2NhcGFiaWxpdGllcyA9IHMuX2NhcGFiaWxpdGllcztcblxuXHRcdHRoaXMuX2xvYWRlckNsYXNzID0gY3JlYXRlanMuV2ViQXVkaW9Mb2FkZXI7XG5cdFx0dGhpcy5fc291bmRJbnN0YW5jZUNsYXNzID0gY3JlYXRlanMuV2ViQXVkaW9Tb3VuZEluc3RhbmNlO1xuXG5cdFx0dGhpcy5fYWRkUHJvcHNUb0NsYXNzZXMoKTtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChXZWJBdWRpb1BsdWdpbiwgY3JlYXRlanMuQWJzdHJhY3RQbHVnaW4pO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cbi8vIFN0YXRpYyBQcm9wZXJ0aWVzXG5cdHZhciBzID0gV2ViQXVkaW9QbHVnaW47XG5cdC8qKlxuXHQgKiBUaGUgY2FwYWJpbGl0aWVzIG9mIHRoZSBwbHVnaW4uIFRoaXMgaXMgZ2VuZXJhdGVkIHZpYSB0aGUge3sjY3Jvc3NMaW5rIFwiV2ViQXVkaW9QbHVnaW4vX2dlbmVyYXRlQ2FwYWJpbGl0aWVzOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QgYW5kIGlzIHVzZWQgaW50ZXJuYWxseS5cblx0ICogQHByb3BlcnR5IF9jYXBhYmlsaXRpZXNcblx0ICogQHR5cGUge09iamVjdH1cblx0ICogQGRlZmF1bHQgbnVsbFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuX2NhcGFiaWxpdGllcyA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFZhbHVlIHRvIHNldCBwYW5uaW5nIG1vZGVsIHRvIGVxdWFsIHBvd2VyIGZvciBXZWJBdWRpb1NvdW5kSW5zdGFuY2UuICBDYW4gYmUgXCJlcXVhbHBvd2VyXCIgb3IgMCBkZXBlbmRpbmcgb24gYnJvd3NlciBpbXBsZW1lbnRhdGlvbi5cblx0ICogQHByb3BlcnR5IF9wYW5uaW5nTW9kZWxcblx0ICogQHR5cGUge051bWJlciAvIFN0cmluZ31cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLl9wYW5uaW5nTW9kZWwgPSBcImVxdWFscG93ZXJcIjtcblxuXHQvKipcblx0ICogVGhlIHdlYiBhdWRpbyBjb250ZXh0LCB3aGljaCBXZWJBdWRpbyB1c2VzIHRvIHBsYXkgYXVkaW8uIEFsbCBub2RlcyB0aGF0IGludGVyYWN0IHdpdGggdGhlIFdlYkF1ZGlvUGx1Z2luXG5cdCAqIG5lZWQgdG8gYmUgY3JlYXRlZCB3aXRoaW4gdGhpcyBjb250ZXh0LlxuXHQgKlxuXHQgKiBBZHZhbmNlZCB1c2VycyBjYW4gc2V0IHRoaXMgdG8gYW4gZXhpc3RpbmcgY29udGV4dCwgYnV0IDxiPm11c3Q8L2I+IGRvIHNvIGJlZm9yZSB0aGV5IGNhbGxcblx0ICoge3sjY3Jvc3NMaW5rIFwiU291bmQvcmVnaXN0ZXJQbHVnaW5zXCJ9fXt7L2Nyb3NzTGlua319IG9yIHt7I2Nyb3NzTGluayBcIlNvdW5kL2luaXRpYWxpemVEZWZhdWx0UGx1Z2luc1wifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogQHByb3BlcnR5IGNvbnRleHRcblx0ICogQHR5cGUge0F1ZGlvQ29udGV4dH1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jb250ZXh0ID0gbnVsbDtcblxuXHQvKipcblx0ICogVGhlIHNjcmF0Y2ggYnVmZmVyIHRoYXQgd2lsbCBiZSBhc3NpZ25lZCB0byB0aGUgYnVmZmVyIHByb3BlcnR5IG9mIGEgc291cmNlIG5vZGUgb24gY2xvc2UuXG5cdCAqIFdvcmtzIGFyb3VuZCBhbiBpT1MgU2FmYXJpIGJ1ZzogaHR0cHM6Ly9naXRodWIuY29tL0NyZWF0ZUpTL1NvdW5kSlMvaXNzdWVzLzEwMlxuXHQgKlxuXHQgKiBBZHZhbmNlZCB1c2VycyBjYW4gc2V0IHRoaXMgdG8gYW4gZXhpc3Rpbmcgc291cmNlIG5vZGUsIGJ1dCA8Yj5tdXN0PC9iPiBkbyBzbyBiZWZvcmUgdGhleSBjYWxsXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNvdW5kL3JlZ2lzdGVyUGx1Z2luc1wifX17ey9jcm9zc0xpbmt9fSBvciB7eyNjcm9zc0xpbmsgXCJTb3VuZC9pbml0aWFsaXplRGVmYXVsdFBsdWdpbnNcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBfc2NyYXRjaEJ1ZmZlclxuXHQgKiBAdHlwZSB7QXVkaW9CdWZmZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0IHMuX3NjcmF0Y2hCdWZmZXIgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZWQgd2hldGhlciBhdWRpbyBvbiBpT1MgaGFzIGJlZW4gdW5sb2NrZWQsIHdoaWNoIHJlcXVpcmVzIGEgdG91Y2hlbmQvbW91c2Vkb3duIGV2ZW50IHRoYXQgcGxheXMgYW5cblx0ICogZW1wdHkgc291bmQuXG5cdCAqIEBwcm9wZXJ0eSBfdW5sb2NrZWRcblx0ICogQHR5cGUge2Jvb2xlYW59XG5cdCAqIEBzaW5jZSAwLjYuMlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cy5fdW5sb2NrZWQgPSBmYWxzZTtcblxuXG4vLyBTdGF0aWMgUHVibGljIE1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZSBpZiB0aGUgcGx1Z2luIGNhbiBiZSB1c2VkIGluIHRoZSBjdXJyZW50IGJyb3dzZXIvT1MuXG5cdCAqIEBtZXRob2QgaXNTdXBwb3J0ZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIHBsdWdpbiBjYW4gYmUgaW5pdGlhbGl6ZWQuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gY2hlY2sgaWYgdGhpcyBpcyBzb21lIGtpbmQgb2YgbW9iaWxlIGRldmljZSwgV2ViIEF1ZGlvIHdvcmtzIHdpdGggbG9jYWwgcHJvdG9jb2wgdW5kZXIgUGhvbmVHYXAgYW5kIGl0IGlzIHVubGlrZWx5IHNvbWVvbmUgaXMgdHJ5aW5nIHRvIHJ1biBhIGxvY2FsIGZpbGVcblx0XHR2YXIgaXNNb2JpbGVQaG9uZUdhcCA9IGNyZWF0ZWpzLkJyb3dzZXJEZXRlY3QuaXNJT1MgfHwgY3JlYXRlanMuQnJvd3NlckRldGVjdC5pc0FuZHJvaWQgfHwgY3JlYXRlanMuQnJvd3NlckRldGVjdC5pc0JsYWNrYmVycnk7XG5cdFx0Ly8gT0pSIGlzTW9iaWxlIG1heSBiZSByZWR1bmRhbnQgd2l0aCBfaXNGaWxlWEhSU3VwcG9ydGVkIGF2YWlsYWJsZS4gIENvbnNpZGVyIHJlbW92aW5nLlxuXHRcdGlmIChsb2NhdGlvbi5wcm90b2NvbCA9PSBcImZpbGU6XCIgJiYgIWlzTW9iaWxlUGhvbmVHYXAgJiYgIXRoaXMuX2lzRmlsZVhIUlN1cHBvcnRlZCgpKSB7IHJldHVybiBmYWxzZTsgfSAgLy8gV2ViIEF1ZGlvIHJlcXVpcmVzIFhIUiwgd2hpY2ggaXMgbm90IHVzdWFsbHkgYXZhaWxhYmxlIGxvY2FsbHlcblx0XHRzLl9nZW5lcmF0ZUNhcGFiaWxpdGllcygpO1xuXHRcdGlmIChzLmNvbnRleHQgPT0gbnVsbCkge3JldHVybiBmYWxzZTt9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBsYXlzIGFuIGVtcHR5IHNvdW5kIGluIHRoZSB3ZWIgYXVkaW8gY29udGV4dC4gIFRoaXMgaXMgdXNlZCB0byBlbmFibGUgd2ViIGF1ZGlvIG9uIGlPUyBkZXZpY2VzLCBhcyB0aGV5XG5cdCAqIHJlcXVpcmUgdGhlIGZpcnN0IHNvdW5kIHRvIGJlIHBsYXllZCBpbnNpZGUgb2YgYSB1c2VyIGluaXRpYXRlZCBldmVudCAodG91Y2gvY2xpY2spLiAgVGhpcyBpcyBjYWxsZWQgd2hlblxuXHQgKiB7eyNjcm9zc0xpbmsgXCJXZWJBdWRpb1BsdWdpblwifX17ey9jcm9zc0xpbmt9fSBpcyBpbml0aWFsaXplZCAoYnkgU291bmQge3sjY3Jvc3NMaW5rIFwiU291bmQvaW5pdGlhbGl6ZURlZmF1bHRQbHVnaW5zXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBleGFtcGxlKS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgZnVuY3Rpb24gaGFuZGxlVG91Y2goZXZlbnQpIHtcblx0ICogICAgICAgICBjcmVhdGVqcy5XZWJBdWRpb1BsdWdpbi5wbGF5RW1wdHlTb3VuZCgpO1xuXHQgKiAgICAgfVxuXHQgKlxuXHQgKiBAbWV0aG9kIHBsYXlFbXB0eVNvdW5kXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNC4xXG5cdCAqL1xuXHRzLnBsYXlFbXB0eVNvdW5kID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHMuY29udGV4dCA9PSBudWxsKSB7cmV0dXJuO31cblx0XHR2YXIgc291cmNlID0gcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuXHRcdHNvdXJjZS5idWZmZXIgPSBzLl9zY3JhdGNoQnVmZmVyO1xuXHRcdHNvdXJjZS5jb25uZWN0KHMuY29udGV4dC5kZXN0aW5hdGlvbik7XG5cdFx0c291cmNlLnN0YXJ0KDAsIDAsIDApO1xuXHR9O1xuXG5cbi8vIFN0YXRpYyBQcml2YXRlIE1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZSBpZiBYSFIgaXMgc3VwcG9ydGVkLCB3aGljaCBpcyBuZWNlc3NhcnkgZm9yIHdlYiBhdWRpby5cblx0ICogQG1ldGhvZCBfaXNGaWxlWEhSU3VwcG9ydGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIFhIUiBpcyBzdXBwb3J0ZWQuXG5cdCAqIEBzaW5jZSAwLjQuMlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuX2lzRmlsZVhIUlN1cHBvcnRlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIGl0J3MgbXVjaCBlYXNpZXIgdG8gZGV0ZWN0IHdoZW4gc29tZXRoaW5nIGdvZXMgd3JvbmcsIHNvIGxldCdzIHN0YXJ0IG9wdGltaXN0aWNhbGx5XG5cdFx0dmFyIHN1cHBvcnRlZCA9IHRydWU7XG5cblx0XHR2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0dHJ5IHtcblx0XHRcdHhoci5vcGVuKFwiR0VUXCIsIFwiV2ViQXVkaW9QbHVnaW5UZXN0LmZhaWxcIiwgZmFsc2UpOyAvLyBsb2FkaW5nIG5vbi1leGlzdGFudCBmaWxlIHRyaWdnZXJzIDQwNCBvbmx5IGlmIGl0IGNvdWxkIGxvYWQgKHN5bmNocm9ub3VzIGNhbGwpXG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdC8vIGNhdGNoIGVycm9ycyBpbiBjYXNlcyB3aGVyZSB0aGUgb25lcnJvciBpcyBwYXNzZWQgYnlcblx0XHRcdHN1cHBvcnRlZCA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIHN1cHBvcnRlZDtcblx0XHR9XG5cdFx0eGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHsgc3VwcG9ydGVkID0gZmFsc2U7IH07IC8vIGNhdXNlIGlycmVsZXZhbnRcblx0XHQvLyB3aXRoIHNlY3VyaXR5IHR1cm5lZCBvZmYsIHdlIGNhbiBnZXQgZW1wdHkgc3VjY2VzcyByZXN1bHRzLCB3aGljaCBpcyBhY3R1YWxseSBhIGZhaWxlZCByZWFkIChzdGF0dXMgY29kZSAwPylcblx0XHR4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7IHN1cHBvcnRlZCA9IHRoaXMuc3RhdHVzID09IDQwNCB8fCAodGhpcy5zdGF0dXMgPT0gMjAwIHx8ICh0aGlzLnN0YXR1cyA9PSAwICYmIHRoaXMucmVzcG9uc2UgIT0gXCJcIikpOyB9O1xuXHRcdHRyeSB7XG5cdFx0XHR4aHIuc2VuZCgpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHQvLyBjYXRjaCBlcnJvcnMgaW4gY2FzZXMgd2hlcmUgdGhlIG9uZXJyb3IgaXMgcGFzc2VkIGJ5XG5cdFx0XHRzdXBwb3J0ZWQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3VwcG9ydGVkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgdGhlIGNhcGFiaWxpdGllcyBvZiB0aGUgcGx1Z2luLiBVc2VkIGludGVybmFsbHkuIFBsZWFzZSBzZWUgdGhlIFNvdW5kIEFQSSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9nZXRDYXBhYmlsaXRpZXNcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kIGZvciBhbiBvdmVydmlldyBvZiBwbHVnaW4gY2FwYWJpbGl0aWVzLlxuXHQgKiBAbWV0aG9kIF9nZW5lcmF0ZUNhcGFiaWxpdGllc1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHMuX2dlbmVyYXRlQ2FwYWJpbGl0aWVzID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmIChzLl9jYXBhYmlsaXRpZXMgIT0gbnVsbCkge3JldHVybjt9XG5cdFx0Ly8gV2ViIEF1ZGlvIGNhbiBiZSBpbiBhbnkgZm9ybWF0cyBzdXBwb3J0ZWQgYnkgdGhlIGF1ZGlvIGVsZW1lbnQsIGZyb20gaHR0cDovL3d3dy53My5vcmcvVFIvd2ViYXVkaW8vI0F1ZGlvQ29udGV4dC1zZWN0aW9uXG5cdFx0dmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYXVkaW9cIik7XG5cdFx0aWYgKHQuY2FuUGxheVR5cGUgPT0gbnVsbCkge3JldHVybiBudWxsO31cblxuXHRcdGlmIChzLmNvbnRleHQgPT0gbnVsbCkge1xuXHRcdFx0aWYgKHdpbmRvdy5BdWRpb0NvbnRleHQpIHtcblx0XHRcdFx0cy5jb250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuXHRcdFx0fSBlbHNlIGlmICh3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KSB7XG5cdFx0XHRcdHMuY29udGV4dCA9IG5ldyB3ZWJraXRBdWRpb0NvbnRleHQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAocy5fc2NyYXRjaEJ1ZmZlciA9PSBudWxsKSB7XG5cdFx0XHRzLl9zY3JhdGNoQnVmZmVyID0gcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlcigxLCAxLCAyMjA1MCk7XG5cdFx0fVxuXG5cdFx0cy5fY29tcGF0aWJpbGl0eVNldFVwKCk7XG5cblx0XHQvLyBMaXN0ZW4gZm9yIGRvY3VtZW50IGxldmVsIGNsaWNrcyB0byB1bmxvY2sgV2ViQXVkaW8gb24gaU9TLiBTZWUgdGhlIF91bmxvY2sgbWV0aG9kLlxuXHRcdGlmIChcIm9udG91Y2hzdGFydFwiIGluIHdpbmRvdyAmJiBzLmNvbnRleHQuc3RhdGUgIT0gXCJydW5uaW5nXCIpIHtcblx0XHRcdHMuX3VubG9jaygpOyAvLyBXaGVuIHBsYXllZCBpbnNpZGUgb2YgYSB0b3VjaCBldmVudCwgdGhpcyB3aWxsIGVuYWJsZSBhdWRpbyBvbiBpT1MgaW1tZWRpYXRlbHkuXG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHMuX3VubG9jaywgdHJ1ZSk7XG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgcy5fdW5sb2NrLCB0cnVlKTtcblx0XHR9XG5cblxuXHRcdHMuX2NhcGFiaWxpdGllcyA9IHtcblx0XHRcdHBhbm5pbmc6dHJ1ZSxcblx0XHRcdHZvbHVtZTp0cnVlLFxuXHRcdFx0dHJhY2tzOi0xXG5cdFx0fTtcblxuXHRcdC8vIGRldGVybWluZSB3aGljaCBleHRlbnNpb25zIG91ciBicm93c2VyIHN1cHBvcnRzIGZvciB0aGlzIHBsdWdpbiBieSBpdGVyYXRpbmcgdGhyb3VnaCBTb3VuZC5TVVBQT1JURURfRVhURU5TSU9OU1xuXHRcdHZhciBzdXBwb3J0ZWRFeHRlbnNpb25zID0gY3JlYXRlanMuU291bmQuU1VQUE9SVEVEX0VYVEVOU0lPTlM7XG5cdFx0dmFyIGV4dGVuc2lvbk1hcCA9IGNyZWF0ZWpzLlNvdW5kLkVYVEVOU0lPTl9NQVA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzdXBwb3J0ZWRFeHRlbnNpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGV4dCA9IHN1cHBvcnRlZEV4dGVuc2lvbnNbaV07XG5cdFx0XHR2YXIgcGxheVR5cGUgPSBleHRlbnNpb25NYXBbZXh0XSB8fCBleHQ7XG5cdFx0XHRzLl9jYXBhYmlsaXRpZXNbZXh0XSA9ICh0LmNhblBsYXlUeXBlKFwiYXVkaW8vXCIgKyBleHQpICE9IFwibm9cIiAmJiB0LmNhblBsYXlUeXBlKFwiYXVkaW8vXCIgKyBleHQpICE9IFwiXCIpIHx8ICh0LmNhblBsYXlUeXBlKFwiYXVkaW8vXCIgKyBwbGF5VHlwZSkgIT0gXCJub1wiICYmIHQuY2FuUGxheVR5cGUoXCJhdWRpby9cIiArIHBsYXlUeXBlKSAhPSBcIlwiKTtcblx0XHR9ICAvLyBPSlIgYW5vdGhlciB3YXkgdG8gZG8gdGhpcyBtaWdodCBiZSBjYW5QbGF5VHlwZTpcIm00YVwiLCBjb2RleDogbXA0XG5cblx0XHQvLyAwPW5vIG91dHB1dCwgMT1tb25vLCAyPXN0ZXJlbywgND1zdXJyb3VuZCwgNj01LjEgc3Vycm91bmQuXG5cdFx0Ly8gU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3dlYmF1ZGlvLyNBdWRpb0NoYW5uZWxTcGxpdHRlciBmb3IgbW9yZSBkZXRhaWxzIG9uIGNoYW5uZWxzLlxuXHRcdGlmIChzLmNvbnRleHQuZGVzdGluYXRpb24ubnVtYmVyT2ZDaGFubmVscyA8IDIpIHtcblx0XHRcdHMuX2NhcGFiaWxpdGllcy5wYW5uaW5nID0gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXQgdXAgY29tcGF0aWJpbGl0eSBpZiBvbmx5IGRlcHJlY2F0ZWQgd2ViIGF1ZGlvIGNhbGxzIGFyZSBzdXBwb3J0ZWQuXG5cdCAqIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi93ZWJhdWRpby8jRGVwcmVjYXRpb25Ob3Rlc1xuXHQgKiBOZWVkZWQgc28gd2UgY2FuIHN1cHBvcnQgbmV3IGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBkZXByZWNhdGVkIGNhbGxzIChGaXJlZm94KSBhcyB3ZWxsIGFzIG9sZCBicm93c2VycyB0aGF0XG5cdCAqIGRvbid0IHN1cHBvcnQgbmV3IGNhbGxzLlxuXHQgKlxuXHQgKiBAbWV0aG9kIF9jb21wYXRpYmlsaXR5U2V0VXBcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjQuMlxuXHQgKi9cblx0cy5fY29tcGF0aWJpbGl0eVNldFVwID0gZnVuY3Rpb24oKSB7XG5cdFx0cy5fcGFubmluZ01vZGVsID0gXCJlcXVhbHBvd2VyXCI7XG5cdFx0Ly9hc3N1bWUgdGhhdCBpZiBvbmUgbmV3IGNhbGwgaXMgc3VwcG9ydGVkLCB0aGV5IGFsbCBhcmVcblx0XHRpZiAocy5jb250ZXh0LmNyZWF0ZUdhaW4pIHsgcmV0dXJuOyB9XG5cblx0XHQvLyBzaW1wbGUgbmFtZSBjaGFuZ2UsIGZ1bmN0aW9uYWxpdHkgdGhlIHNhbWVcblx0XHRzLmNvbnRleHQuY3JlYXRlR2FpbiA9IHMuY29udGV4dC5jcmVhdGVHYWluTm9kZTtcblxuXHRcdC8vIHNvdXJjZSBub2RlLCBhZGQgdG8gcHJvdG90eXBlXG5cdFx0dmFyIGF1ZGlvTm9kZSA9IHMuY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcblx0XHRhdWRpb05vZGUuX19wcm90b19fLnN0YXJ0ID0gYXVkaW9Ob2RlLl9fcHJvdG9fXy5ub3RlR3JhaW5PbjtcdC8vIG5vdGUgdGhhdCBub3RlR3JhaW5PbiByZXF1aXJlcyBhbGwgMyBwYXJhbWV0ZXJzXG5cdFx0YXVkaW9Ob2RlLl9fcHJvdG9fXy5zdG9wID0gYXVkaW9Ob2RlLl9fcHJvdG9fXy5ub3RlT2ZmO1xuXG5cdFx0Ly8gcGFubmluZ01vZGVsXG5cdFx0cy5fcGFubmluZ01vZGVsID0gMDtcblx0fTtcblxuXHQvKipcblx0ICogVHJ5IHRvIHVubG9jayBhdWRpbyBvbiBpT1MuIFRoaXMgaXMgdHJpZ2dlcmVkIGZyb20gZWl0aGVyIFdlYkF1ZGlvIHBsdWdpbiBzZXR1cCAod2hpY2ggd2lsbCB3b3JrIGlmIGluc2lkZSBvZlxuXHQgKiBhIGBtb3VzZWRvd25gIG9yIGB0b3VjaGVuZGAgZXZlbnQgc3RhY2spLCBvciB0aGUgZmlyc3QgZG9jdW1lbnQgdG91Y2hlbmQvbW91c2Vkb3duIGV2ZW50LiBJZiBpdCBmYWlscyAodG91Y2hlbmRcblx0ICogd2lsbCBmYWlsIGlmIHRoZSB1c2VyIHByZXNzZXMgZm9yIHRvbyBsb25nLCBpbmRpY2F0aW5nIGEgc2Nyb2xsIGV2ZW50IGluc3RlYWQgb2YgYSBjbGljayBldmVudC5cblx0ICpcblx0ICogTm90ZSB0aGF0IGVhcmxpZXIgdmVyc2lvbnMgb2YgaU9TIHN1cHBvcnRlZCBgdG91Y2hzdGFydGAgZm9yIHRoaXMsIGJ1dCBpT1M5IHJlbW92ZWQgdGhpcyBmdW5jdGlvbmFsaXR5LiBBZGRpbmdcblx0ICogYSBgdG91Y2hzdGFydGAgZXZlbnQgdG8gc3VwcG9ydCBvbGRlciBwbGF0Zm9ybXMgbWF5IHByZWNsdWRlIGEgYG1vdXNlZG93bmAgZXZlbiBmcm9tIGdldHRpbmcgZmlyZWQgb24gaU9TOSwgc28gd2Vcblx0ICogc3RpY2sgd2l0aCBgbW91c2Vkb3duYCBhbmQgYHRvdWNoZW5kYC5cblx0ICogQG1ldGhvZCBfdW5sb2NrXG5cdCAqIEBzaW5jZSAwLjYuMlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cy5fdW5sb2NrID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHMuX3VubG9ja2VkKSB7IHJldHVybjsgfVxuXHRcdHMucGxheUVtcHR5U291bmQoKTtcblx0XHRpZiAocy5jb250ZXh0LnN0YXRlID09IFwicnVubmluZ1wiKSB7XG5cdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHMuX3VubG9jaywgdHJ1ZSk7XG5cdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgcy5fdW5sb2NrLCB0cnVlKTtcblx0XHRcdHMuX3VubG9ja2VkID0gdHJ1ZTtcblx0XHR9XG5cdH07XG5cblxuLy8gUHVibGljIE1ldGhvZHNcblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbV2ViQXVkaW9QbHVnaW5dXCI7XG5cdH07XG5cblxuLy8gUHJpdmF0ZSBNZXRob2RzXG5cdC8qKlxuXHQgKiBTZXQgdXAgbmVlZGVkIHByb3BlcnRpZXMgb24gc3VwcG9ydGVkIGNsYXNzZXMgV2ViQXVkaW9Tb3VuZEluc3RhbmNlIGFuZCBXZWJBdWRpb0xvYWRlci5cblx0ICogQG1ldGhvZCBfYWRkUHJvcHNUb0NsYXNzZXNcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5fYWRkUHJvcHNUb0NsYXNzZXMgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgYyA9IHRoaXMuX3NvdW5kSW5zdGFuY2VDbGFzcztcblx0XHRjLmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cdFx0Yy5fc2NyYXRjaEJ1ZmZlciA9IHMuX3NjcmF0Y2hCdWZmZXI7XG5cdFx0Yy5kZXN0aW5hdGlvbk5vZGUgPSB0aGlzLmdhaW5Ob2RlO1xuXHRcdGMuX3Bhbm5pbmdNb2RlbCA9IHRoaXMuX3Bhbm5pbmdNb2RlbDtcblxuXHRcdHRoaXMuX2xvYWRlckNsYXNzLmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cdH07XG5cblxuXHQvKipcblx0ICogU2V0IHRoZSBnYWluIHZhbHVlIGZvciBtYXN0ZXIgYXVkaW8uIFNob3VsZCBub3QgYmUgY2FsbGVkIGV4dGVybmFsbHkuXG5cdCAqIEBtZXRob2QgX3VwZGF0ZVZvbHVtZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl91cGRhdGVWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG5ld1ZvbHVtZSA9IGNyZWF0ZWpzLlNvdW5kLl9tYXN0ZXJNdXRlID8gMCA6IHRoaXMuX3ZvbHVtZTtcblx0XHRpZiAobmV3Vm9sdW1lICE9IHRoaXMuZ2Fpbk5vZGUuZ2Fpbi52YWx1ZSkge1xuXHRcdFx0dGhpcy5nYWluTm9kZS5nYWluLnZhbHVlID0gbmV3Vm9sdW1lO1xuXHRcdH1cblx0fTtcblxuXHRjcmVhdGVqcy5XZWJBdWRpb1BsdWdpbiA9IGNyZWF0ZWpzLnByb21vdGUoV2ViQXVkaW9QbHVnaW4sIFwiQWJzdHJhY3RQbHVnaW5cIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gSFRNTEF1ZGlvVGFnUG9vbC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIEhUTUxBdWRpb1RhZ1Bvb2wgaXMgYW4gb2JqZWN0IHBvb2wgZm9yIEhUTUxBdWRpbyB0YWcgaW5zdGFuY2VzLlxuXHQgKiBAY2xhc3MgSFRNTEF1ZGlvVGFnUG9vbFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VyY2Ugb2YgdGhlIGNoYW5uZWwuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGZ1bmN0aW9uIEhUTUxBdWRpb1RhZ1Bvb2woKSB7XG5cdFx0XHR0aHJvdyBcIkhUTUxBdWRpb1RhZ1Bvb2wgY2Fubm90IGJlIGluc3RhbnRpYXRlZFwiO1xuXHR9XG5cblx0dmFyIHMgPSBIVE1MQXVkaW9UYWdQb29sO1xuXG4vLyBTdGF0aWMgUHJvcGVydGllc1xuXHQvKipcblx0ICogQSBoYXNoIGxvb2t1cCBvZiBlYWNoIGJhc2UgYXVkaW8gdGFnLCBpbmRleGVkIGJ5IHRoZSBhdWRpbyBzb3VyY2UuXG5cdCAqIEBwcm9wZXJ0eSBfdGFnc1xuXHQgKiBAdHlwZSB7e319XG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cy5fdGFncyA9IHt9O1xuXG5cdC8qKlxuXHQgKiBBbiBvYmplY3QgcG9vbCBmb3IgaHRtbCBhdWRpbyB0YWdzXG5cdCAqIEBwcm9wZXJ0eSBfdGFnUG9vbFxuXHQgKiBAdHlwZSB7VGFnUG9vbH1cblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzLl90YWdQb29sID0gbmV3IFRhZ1Bvb2woKTtcblxuXHQvKipcblx0ICogQSBoYXNoIGxvb2t1cCBvZiBpZiBhIGJhc2UgYXVkaW8gdGFnIGlzIGF2YWlsYWJsZSwgaW5kZXhlZCBieSB0aGUgYXVkaW8gc291cmNlXG5cdCAqIEBwcm9wZXJ0eSBfdGFnc1VzZWRcblx0ICogQHR5cGUge3t9fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuX3RhZ1VzZWQgPSB7fTtcblxuLy8gU3RhdGljIE1ldGhvZHNcblx0LyoqXG5cdCAgKiBHZXQgYW4gYXVkaW8gdGFnIHdpdGggdGhlIGdpdmVuIHNvdXJjZS5cblx0ICAqIEBtZXRob2QgZ2V0XG5cdCAgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VyY2UgZmlsZSB1c2VkIGJ5IHRoZSBhdWRpbyB0YWcuXG5cdCAgKiBAc3RhdGljXG5cdCAgKi9cblx0IHMuZ2V0ID0gZnVuY3Rpb24gKHNyYykge1xuXHRcdHZhciB0ID0gcy5fdGFnc1tzcmNdO1xuXHRcdGlmICh0ID09IG51bGwpIHtcblx0XHRcdC8vIGNyZWF0ZSBuZXcgYmFzZSB0YWdcblx0XHRcdHQgPSBzLl90YWdzW3NyY10gPSBzLl90YWdQb29sLmdldCgpO1xuXHRcdFx0dC5zcmMgPSBzcmM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGdldCBiYXNlIG9yIHBvb2xcblx0XHRcdGlmIChzLl90YWdVc2VkW3NyY10pIHtcblx0XHRcdFx0dCA9IHMuX3RhZ1Bvb2wuZ2V0KCk7XG5cdFx0XHRcdHQuc3JjID0gc3JjO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cy5fdGFnVXNlZFtzcmNdID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHQ7XG5cdCB9O1xuXG5cdCAvKipcblx0ICAqIFJldHVybiBhbiBhdWRpbyB0YWcgdG8gdGhlIHBvb2wuXG5cdCAgKiBAbWV0aG9kIHNldFxuXHQgICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291cmNlIGZpbGUgdXNlZCBieSB0aGUgYXVkaW8gdGFnLlxuXHQgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFnIEF1ZGlvIHRhZyB0byBzZXQuXG5cdCAgKiBAc3RhdGljXG5cdCAgKi9cblx0IHMuc2V0ID0gZnVuY3Rpb24gKHNyYywgdGFnKSB7XG5cdFx0IC8vIGNoZWNrIGlmIHRoaXMgaXMgYmFzZSwgaWYgeWVzIHNldCBib29sZWFuIGlmIG5vdCByZXR1cm4gdG8gcG9vbFxuXHRcdCBpZih0YWcgPT0gcy5fdGFnc1tzcmNdKSB7XG5cdFx0XHQgcy5fdGFnVXNlZFtzcmNdID0gZmFsc2U7XG5cdFx0IH0gZWxzZSB7XG5cdFx0XHQgcy5fdGFnUG9vbC5zZXQodGFnKTtcblx0XHQgfVxuXHQgfTtcblxuXHQvKipcblx0ICogRGVsZXRlIHN0b3JlZCB0YWcgcmVmZXJlbmNlIGFuZCByZXR1cm4gdGhlbSB0byBwb29sLiBOb3RlIHRoYXQgaWYgdGhlIHRhZyByZWZlcmVuY2UgZG9lcyBub3QgZXhpc3QsIHRoaXMgd2lsbCBmYWlsLlxuXHQgKiBAbWV0aG9kIHJlbW92ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VyY2UgZm9yIHRoZSB0YWdcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIFRhZ1Bvb2wgd2FzIGRlbGV0ZWQuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMucmVtb3ZlID0gZnVuY3Rpb24gKHNyYykge1xuXHRcdHZhciB0YWcgPSBzLl90YWdzW3NyY107XG5cdFx0aWYgKHRhZyA9PSBudWxsKSB7cmV0dXJuIGZhbHNlO31cblx0XHRzLl90YWdQb29sLnNldCh0YWcpO1xuXHRcdGRlbGV0ZShzLl90YWdzW3NyY10pO1xuXHRcdGRlbGV0ZShzLl90YWdVc2VkW3NyY10pO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBkdXJhdGlvbiBvZiB0aGUgc3JjIGF1ZGlvIGluIG1pbGxpc2Vjb25kc1xuXHQgKiBAbWV0aG9kIGdldER1cmF0aW9uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBmaWxlIHVzZWQgYnkgdGhlIGF1ZGlvIHRhZy5cblx0ICogQHJldHVybiB7TnVtYmVyfSBEdXJhdGlvbiBvZiBzcmMgaW4gbWlsbGlzZWNvbmRzXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuZ2V0RHVyYXRpb249IGZ1bmN0aW9uIChzcmMpIHtcblx0XHR2YXIgdCA9IHMuX3RhZ3Nbc3JjXTtcblx0XHRpZiAodCA9PSBudWxsIHx8ICF0LmR1cmF0aW9uKSB7cmV0dXJuIDA7fVx0Ly8gT0pSIGR1cmF0aW9uIGlzIE5hTiBpZiBsb2FkaW5nIGhhcyBub3QgY29tcGxldGVkXG5cdFx0cmV0dXJuIHQuZHVyYXRpb24gKiAxMDAwO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkhUTUxBdWRpb1RhZ1Bvb2wgPSBIVE1MQXVkaW9UYWdQb29sO1xuXG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQvKipcblx0ICogVGhlIFRhZ1Bvb2wgaXMgYW4gb2JqZWN0IHBvb2wgZm9yIEhUTUxBdWRpbyB0YWcgaW5zdGFuY2VzLlxuXHQgKiAjY2xhc3MgVGFnUG9vbFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VyY2Ugb2YgdGhlIGNoYW5uZWwuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGZ1bmN0aW9uIFRhZ1Bvb2woc3JjKSB7XG5cbi8vIFB1YmxpYyBQcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogQSBsaXN0IG9mIGFsbCBhdmFpbGFibGUgdGFncyBpbiB0aGUgcG9vbC5cblx0XHQgKiAjcHJvcGVydHkgdGFnc1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fdGFncyA9IFtdO1xuXHR9O1xuXG5cdHZhciBwID0gVGFnUG9vbC5wcm90b3R5cGU7XG5cdHAuY29uc3RydWN0b3IgPSBUYWdQb29sO1xuXG5cbi8vIFB1YmxpYyBNZXRob2RzXG5cdC8qKlxuXHQgKiBHZXQgYW4gSFRNTEF1ZGlvRWxlbWVudCBmb3IgaW1tZWRpYXRlIHBsYXliYWNrLiBUaGlzIHRha2VzIGl0IG91dCBvZiB0aGUgcG9vbC5cblx0ICogI21ldGhvZCBnZXRcblx0ICogQHJldHVybiB7SFRNTEF1ZGlvRWxlbWVudH0gQW4gSFRNTCBhdWRpbyB0YWcuXG5cdCAqL1xuXHRwLmdldCA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdGFnO1xuXHRcdGlmICh0aGlzLl90YWdzLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHR0YWcgPSB0aGlzLl9jcmVhdGVUYWcoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFnID0gdGhpcy5fdGFncy5wb3AoKTtcblx0XHR9XG5cdFx0aWYgKHRhZy5wYXJlbnROb2RlID09IG51bGwpIHtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRhZyk7fVxuXHRcdHJldHVybiB0YWc7XG5cdH07XG5cblx0LyoqXG5cdCAqIFB1dCBhbiBIVE1MQXVkaW9FbGVtZW50IGJhY2sgaW4gdGhlIHBvb2wgZm9yIHVzZS5cblx0ICogI21ldGhvZCBzZXRcblx0ICogQHBhcmFtIHtIVE1MQXVkaW9FbGVtZW50fSB0YWcgSFRNTCBhdWRpbyB0YWdcblx0ICovXG5cdHAuc2V0ID0gZnVuY3Rpb24gKHRhZykge1xuXHRcdC8vIE9KUiB0aGlzIGZpcnN0IHN0ZXAgc2VlbXMgdW5uZWNlc3Nhcnlcblx0XHR2YXIgaW5kZXggPSBjcmVhdGVqcy5pbmRleE9mKHRoaXMuX3RhZ3MsIHRhZyk7XG5cdFx0aWYgKGluZGV4ID09IC0xKSB7XG5cdFx0XHR0aGlzLl90YWdzLnNyYyA9IG51bGw7XG5cdFx0XHR0aGlzLl90YWdzLnB1c2godGFnKTtcblx0XHR9XG5cdH07XG5cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbVGFnUG9vbF1cIjtcblx0fTtcblxuXG4vLyBQcml2YXRlIE1ldGhvZHNcblx0LyoqXG5cdCAqIENyZWF0ZSBhbiBIVE1MIGF1ZGlvIHRhZy5cblx0ICogI21ldGhvZCBfY3JlYXRlVGFnXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHNvdXJjZSBmaWxlIHRvIHNldCBmb3IgdGhlIGF1ZGlvIHRhZy5cblx0ICogQHJldHVybiB7SFRNTEVsZW1lbnR9IFJldHVybnMgYW4gSFRNTCBhdWRpbyB0YWcuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2NyZWF0ZVRhZyA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImF1ZGlvXCIpO1xuXHRcdHRhZy5hdXRvcGxheSA9IGZhbHNlO1xuXHRcdHRhZy5wcmVsb2FkID0gXCJub25lXCI7XG5cdFx0Ly9MTTogRmlyZWZveCBmYWlscyB3aGVuIHRoaXMgdGhlIHByZWxvYWQ9XCJub25lXCIgZm9yIG90aGVyIHRhZ3MsIGJ1dCBpdCBuZWVkcyB0byBiZSBcIm5vbmVcIiB0byBlbnN1cmUgUHJlbG9hZEpTIHdvcmtzLlxuXHRcdHJldHVybiB0YWc7XG5cdH07XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBIVE1MQXVkaW9Tb3VuZEluc3RhbmNlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogSFRNTEF1ZGlvU291bmRJbnN0YW5jZSBleHRlbmRzIHRoZSBiYXNlIGFwaSBvZiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFNvdW5kSW5zdGFuY2VcIn19e3svY3Jvc3NMaW5rfX0gYW5kIGlzIHVzZWQgYnlcblx0ICoge3sjY3Jvc3NMaW5rIFwiSFRNTEF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBwYXRoIHRvIGFuZCBmaWxlIG5hbWUgb2YgdGhlIHNvdW5kLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRUaW1lIEF1ZGlvIHNwcml0ZSBwcm9wZXJ0eSB1c2VkIHRvIGFwcGx5IGFuIG9mZnNldCwgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gQXVkaW8gc3ByaXRlIHByb3BlcnR5IHVzZWQgdG8gc2V0IHRoZSB0aW1lIHRoZSBjbGlwIHBsYXlzIGZvciwgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGxheWJhY2tSZXNvdXJjZSBBbnkgcmVzb3VyY2UgbmVlZGVkIGJ5IHBsdWdpbiB0byBzdXBwb3J0IGF1ZGlvIHBsYXliYWNrLlxuXHQgKiBAY2xhc3MgSFRNTEF1ZGlvU291bmRJbnN0YW5jZVxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdFNvdW5kSW5zdGFuY2Vcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBIVE1MQXVkaW9Tb3VuZEluc3RhbmNlKHNyYywgc3RhcnRUaW1lLCBkdXJhdGlvbiwgcGxheWJhY2tSZXNvdXJjZSkge1xuXHRcdHRoaXMuQWJzdHJhY3RTb3VuZEluc3RhbmNlX2NvbnN0cnVjdG9yKHNyYywgc3RhcnRUaW1lLCBkdXJhdGlvbiwgcGxheWJhY2tSZXNvdXJjZSk7XG5cblxuLy8gUHJpdmF0ZSBQcm9wZXJ0aWVzXG5cdFx0dGhpcy5fYXVkaW9TcHJpdGVTdG9wVGltZSA9IG51bGw7XG5cdFx0dGhpcy5fZGVsYXlUaW1lb3V0SWQgPSBudWxsO1xuXG5cdFx0Ly8gUHJveGllcywgbWFrZSByZW1vdmluZyBsaXN0ZW5lcnMgZWFzaWVyLlxuXHRcdHRoaXMuX2VuZGVkSGFuZGxlciA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVNvdW5kQ29tcGxldGUsIHRoaXMpO1xuXHRcdHRoaXMuX3JlYWR5SGFuZGxlciA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVRhZ1JlYWR5LCB0aGlzKTtcblx0XHR0aGlzLl9zdGFsbGVkSGFuZGxlciA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX3BsYXlGYWlsZWQsIHRoaXMpO1xuXHRcdHRoaXMuX2F1ZGlvU3ByaXRlRW5kSGFuZGxlciA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZUF1ZGlvU3ByaXRlTG9vcCwgdGhpcyk7XG5cdFx0dGhpcy5fbG9vcEhhbmRsZXIgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVTb3VuZENvbXBsZXRlLCB0aGlzKTtcblxuXHRcdGlmIChkdXJhdGlvbikge1xuXHRcdFx0dGhpcy5fYXVkaW9TcHJpdGVTdG9wVGltZSA9IChzdGFydFRpbWUgKyBkdXJhdGlvbikgKiAwLjAwMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fZHVyYXRpb24gPSBjcmVhdGVqcy5IVE1MQXVkaW9UYWdQb29sLmdldER1cmF0aW9uKHRoaXMuc3JjKTtcblx0XHR9XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoSFRNTEF1ZGlvU291bmRJbnN0YW5jZSwgY3JlYXRlanMuQWJzdHJhY3RTb3VuZEluc3RhbmNlKTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXG4vLyBQdWJsaWMgTWV0aG9kc1xuXHQvKipcblx0ICogQ2FsbGVkIGJ5IHt7I2Nyb3NzTGluayBcIlNvdW5kXCJ9fXt7L2Nyb3NzTGlua319IHdoZW4gcGx1Z2luIGRvZXMgbm90IGhhbmRsZSBtYXN0ZXIgdm9sdW1lLlxuXHQgKiB1bmRvYydkIGJlY2F1c2UgaXQgaXMgbm90IG1lYW50IHRvIGJlIHVzZWQgb3V0c2lkZSBvZiBTb3VuZFxuXHQgKiAjbWV0aG9kIHNldE1hc3RlclZvbHVtZVxuXHQgKiBAcGFyYW0gdmFsdWVcblx0ICovXG5cdHAuc2V0TWFzdGVyVm9sdW1lID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dGhpcy5fdXBkYXRlVm9sdW1lKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCBieSB7eyNjcm9zc0xpbmsgXCJTb3VuZFwifX17ey9jcm9zc0xpbmt9fSB3aGVuIHBsdWdpbiBkb2VzIG5vdCBoYW5kbGUgbWFzdGVyIG11dGUuXG5cdCAqIHVuZG9jJ2QgYmVjYXVzZSBpdCBpcyBub3QgbWVhbnQgdG8gYmUgdXNlZCBvdXRzaWRlIG9mIFNvdW5kXG5cdCAqICNtZXRob2Qgc2V0TWFzdGVyTXV0ZVxuXHQgKiBAcGFyYW0gdmFsdWVcblx0ICovXG5cdHAuc2V0TWFzdGVyTXV0ZSA9IGZ1bmN0aW9uIChpc011dGVkKSB7XG5cdFx0dGhpcy5fdXBkYXRlVm9sdW1lKCk7XG5cdH07XG5cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbSFRNTEF1ZGlvU291bmRJbnN0YW5jZV1cIjtcblx0fTtcblxuLy9Qcml2YXRlIE1ldGhvZHNcblx0cC5fcmVtb3ZlTG9vcGluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmKHRoaXMuX3BsYXliYWNrUmVzb3VyY2UgPT0gbnVsbCkge3JldHVybjt9XG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5sb29wID0gZmFsc2U7XG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fU0VFS0VELCB0aGlzLl9sb29wSGFuZGxlciwgZmFsc2UpO1xuXHR9O1xuXG5cdHAuX2FkZExvb3BpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRpZih0aGlzLl9wbGF5YmFja1Jlc291cmNlID09IG51bGwgIHx8IHRoaXMuX2F1ZGlvU3ByaXRlU3RvcFRpbWUpIHtyZXR1cm47fVxuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX1NFRUtFRCwgdGhpcy5fbG9vcEhhbmRsZXIsIGZhbHNlKTtcblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLmxvb3AgPSB0cnVlO1xuXHR9O1xuXG5cdHAuX2hhbmRsZUNsZWFuVXAgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRhZyA9IHRoaXMuX3BsYXliYWNrUmVzb3VyY2U7XG5cdFx0aWYgKHRhZyAhPSBudWxsKSB7XG5cdFx0XHR0YWcucGF1c2UoKTtcblx0XHRcdHRhZy5sb29wID0gZmFsc2U7XG5cdFx0XHR0YWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX0VOREVELCB0aGlzLl9lbmRlZEhhbmRsZXIsIGZhbHNlKTtcblx0XHRcdHRhZy5yZW1vdmVFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fUkVBRFksIHRoaXMuX3JlYWR5SGFuZGxlciwgZmFsc2UpO1xuXHRcdFx0dGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19TVEFMTEVELCB0aGlzLl9zdGFsbGVkSGFuZGxlciwgZmFsc2UpO1xuXHRcdFx0dGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19TRUVLRUQsIHRoaXMuX2xvb3BIYW5kbGVyLCBmYWxzZSk7XG5cdFx0XHR0YWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX1RJTUVfVVBEQVRFLCB0aGlzLl9hdWRpb1Nwcml0ZUVuZEhhbmRsZXIsIGZhbHNlKTtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dGFnLmN1cnJlbnRUaW1lID0gdGhpcy5fc3RhcnRUaW1lO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0fSAvLyBSZXNldCBQb3NpdGlvblxuXHRcdFx0Y3JlYXRlanMuSFRNTEF1ZGlvVGFnUG9vbC5zZXQodGhpcy5zcmMsIHRhZyk7XG5cdFx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlID0gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0cC5fYmVnaW5QbGF5aW5nID0gZnVuY3Rpb24gKHBsYXlQcm9wcykge1xuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UgPSBjcmVhdGVqcy5IVE1MQXVkaW9UYWdQb29sLmdldCh0aGlzLnNyYyk7XG5cdFx0cmV0dXJuIHRoaXMuQWJzdHJhY3RTb3VuZEluc3RhbmNlX19iZWdpblBsYXlpbmcocGxheVByb3BzKTtcblx0fTtcblxuXHRwLl9oYW5kbGVTb3VuZFJlYWR5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMuX3BsYXliYWNrUmVzb3VyY2UucmVhZHlTdGF0ZSAhPT0gNCkge1xuXHRcdFx0dmFyIHRhZyA9IHRoaXMuX3BsYXliYWNrUmVzb3VyY2U7XG5cdFx0XHR0YWcuYWRkRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX1JFQURZLCB0aGlzLl9yZWFkeUhhbmRsZXIsIGZhbHNlKTtcblx0XHRcdHRhZy5hZGRFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fU1RBTExFRCwgdGhpcy5fc3RhbGxlZEhhbmRsZXIsIGZhbHNlKTtcblx0XHRcdHRhZy5wcmVsb2FkID0gXCJhdXRvXCI7IC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciBGaXJlZm94LCBhcyBpdCB3b24ndCBldmVyIFwibG9hZFwiIHVudGlsIHRoaXMgaXMgc2V0LlxuXHRcdFx0dGFnLmxvYWQoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVWb2x1bWUoKTtcblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLmN1cnJlbnRUaW1lID0gKHRoaXMuX3N0YXJ0VGltZSArIHRoaXMuX3Bvc2l0aW9uKSAqIDAuMDAxO1xuXHRcdGlmICh0aGlzLl9hdWRpb1Nwcml0ZVN0b3BUaW1lKSB7XG5cdFx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9USU1FX1VQREFURSwgdGhpcy5fYXVkaW9TcHJpdGVFbmRIYW5kbGVyLCBmYWxzZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX0VOREVELCB0aGlzLl9lbmRlZEhhbmRsZXIsIGZhbHNlKTtcblx0XHRcdGlmKHRoaXMuX2xvb3AgIT0gMCkge1xuXHRcdFx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19TRUVLRUQsIHRoaXMuX2xvb3BIYW5kbGVyLCBmYWxzZSk7XG5cdFx0XHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UubG9vcCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5wbGF5KCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZWQgdG8gaGFuZGxlIHdoZW4gYSB0YWcgaXMgbm90IHJlYWR5IGZvciBpbW1lZGlhdGUgcGxheWJhY2sgd2hlbiBpdCBpcyByZXR1cm5lZCBmcm9tIHRoZSBIVE1MQXVkaW9UYWdQb29sLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVUYWdSZWFkeVxuXHQgKiBAcGFyYW0gZXZlbnRcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5faGFuZGxlVGFnUmVhZHkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19SRUFEWSwgdGhpcy5fcmVhZHlIYW5kbGVyLCBmYWxzZSk7XG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fU1RBTExFRCwgdGhpcy5fc3RhbGxlZEhhbmRsZXIsIGZhbHNlKTtcblxuXHRcdHRoaXMuX2hhbmRsZVNvdW5kUmVhZHkoKTtcblx0fTtcblxuXHRwLl9wYXVzZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLnBhdXNlKCk7XG5cdH07XG5cblx0cC5fcmVzdW1lID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UucGxheSgpO1xuXHR9O1xuXG5cdHAuX3VwZGF0ZVZvbHVtZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcGxheWJhY2tSZXNvdXJjZSAhPSBudWxsKSB7XG5cdFx0XHR2YXIgbmV3Vm9sdW1lID0gKHRoaXMuX211dGVkIHx8IGNyZWF0ZWpzLlNvdW5kLl9tYXN0ZXJNdXRlKSA/IDAgOiB0aGlzLl92b2x1bWUgKiBjcmVhdGVqcy5Tb3VuZC5fbWFzdGVyVm9sdW1lO1xuXHRcdFx0aWYgKG5ld1ZvbHVtZSAhPSB0aGlzLl9wbGF5YmFja1Jlc291cmNlLnZvbHVtZSkge3RoaXMuX3BsYXliYWNrUmVzb3VyY2Uudm9sdW1lID0gbmV3Vm9sdW1lO31cblx0XHR9XG5cdH07XG5cblx0cC5fY2FsY3VsYXRlQ3VycmVudFBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICh0aGlzLl9wbGF5YmFja1Jlc291cmNlLmN1cnJlbnRUaW1lICogMTAwMCkgLSB0aGlzLl9zdGFydFRpbWU7XG5cdH07XG5cblx0cC5fdXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19TRUVLRUQsIHRoaXMuX2xvb3BIYW5kbGVyLCBmYWxzZSk7XG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5hZGRFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fU0VFS0VELCB0aGlzLl9oYW5kbGVTZXRQb3NpdGlvblNlZWssIGZhbHNlKTtcblx0XHR0cnkge1xuXHRcdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5jdXJyZW50VGltZSA9ICh0aGlzLl9wb3NpdGlvbiArIHRoaXMuX3N0YXJ0VGltZSkgKiAwLjAwMTtcblx0XHR9IGNhdGNoIChlcnJvcikgeyAvLyBPdXQgb2YgcmFuZ2Vcblx0XHRcdHRoaXMuX2hhbmRsZVNldFBvc2l0aW9uU2VlayhudWxsKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZWQgdG8gZW5hYmxlIHNldHRpbmcgcG9zaXRpb24sIGFzIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhhdCBzZWVrIHRvIGJlIGRvbmUgYmVmb3JlIHdlIGFkZCBiYWNrIG91ciBsb29wIGhhbmRsaW5nIHNlZWsgbGlzdGVuZXJcblx0ICogQG1ldGhvZCBfaGFuZGxlU2V0UG9zaXRpb25TZWVrXG5cdCAqIEBwYXJhbSBldmVudFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9oYW5kbGVTZXRQb3NpdGlvblNlZWsgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdGlmICh0aGlzLl9wbGF5YmFja1Jlc291cmNlID09IG51bGwpIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKGNyZWF0ZWpzLkhUTUxBdWRpb1BsdWdpbi5fQVVESU9fU0VFS0VELCB0aGlzLl9oYW5kbGVTZXRQb3NpdGlvblNlZWssIGZhbHNlKTtcblx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19TRUVLRUQsIHRoaXMuX2xvb3BIYW5kbGVyLCBmYWxzZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRpbWVyIHVzZWQgdG8gbG9vcCBhdWRpbyBzcHJpdGVzLlxuXHQgKiBOT1RFIGJlY2F1c2Ugb2YgdGhlIGluYWNjdXJhY2llcyBpbiB0aGUgdGltZXVwZGF0ZSBldmVudCAoMTUgLSAyNTBtcykgYW5kIGluIHNldHRpbmcgdGhlIHRhZyB0byB0aGUgZGVzaXJlZCB0aW1lZFxuXHQgKiAodXAgdG8gMzAwbXMpLCBpdCBpcyBzdHJvbmdseSByZWNvbW1lbmRlZCBub3QgdG8gbG9vcCBhdWRpbyBzcHJpdGVzIHdpdGggSFRNTCBBdWRpbyBpZiBzbW9vdGggbG9vcGluZyBpcyBkZXNpcmVkXG5cdCAqXG5cdCAqIEBtZXRob2QgX2hhbmRsZUF1ZGlvU3ByaXRlTG9vcFxuXHQgKiBAcGFyYW0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZUF1ZGlvU3ByaXRlTG9vcCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGlmKHRoaXMuX3BsYXliYWNrUmVzb3VyY2UuY3VycmVudFRpbWUgPD0gdGhpcy5fYXVkaW9TcHJpdGVTdG9wVGltZSkge3JldHVybjt9XG5cdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5wYXVzZSgpO1xuXHRcdGlmKHRoaXMuX2xvb3AgPT0gMCkge1xuXHRcdFx0dGhpcy5faGFuZGxlU291bmRDb21wbGV0ZShudWxsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcG9zaXRpb24gPSAwO1xuXHRcdFx0dGhpcy5fbG9vcC0tO1xuXHRcdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5jdXJyZW50VGltZSA9IHRoaXMuX3N0YXJ0VGltZSAqIDAuMDAxO1xuXHRcdFx0aWYoIXRoaXMuX3BhdXNlZCkge3RoaXMuX3BsYXliYWNrUmVzb3VyY2UucGxheSgpO31cblx0XHRcdHRoaXMuX3NlbmRFdmVudChcImxvb3BcIik7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIE5PVEUgd2l0aCB0aGlzIGFwcHJvYWNoIGF1ZGlvIHdpbGwgbG9vcCBhcyByZWxpYWJseSBhcyB0aGUgYnJvd3NlciBhbGxvd3Ncblx0Ly8gYnV0IHdlIGNvdWxkIGVuZCB1cCBzZW5kaW5nIHRoZSBsb29wIGV2ZW50IGFmdGVyIG5leHQgbG9vcCBwbGF5YmFjayBiZWdpbnNcblx0cC5faGFuZGxlTG9vcCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGlmKHRoaXMuX2xvb3AgPT0gMCkge1xuXHRcdFx0dGhpcy5fcGxheWJhY2tSZXNvdXJjZS5sb29wID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19TRUVLRUQsIHRoaXMuX2xvb3BIYW5kbGVyLCBmYWxzZSk7XG5cdFx0fVxuXHR9O1xuXG5cdHAuX3VwZGF0ZVN0YXJ0VGltZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9hdWRpb1Nwcml0ZVN0b3BUaW1lID0gKHRoaXMuX3N0YXJ0VGltZSArIHRoaXMuX2R1cmF0aW9uKSAqIDAuMDAxO1xuXG5cdFx0aWYodGhpcy5wbGF5U3RhdGUgPT0gY3JlYXRlanMuU291bmQuUExBWV9TVUNDRUVERUQpIHtcblx0XHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX0FVRElPX0VOREVELCB0aGlzLl9lbmRlZEhhbmRsZXIsIGZhbHNlKTtcblx0XHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihjcmVhdGVqcy5IVE1MQXVkaW9QbHVnaW4uX1RJTUVfVVBEQVRFLCB0aGlzLl9hdWRpb1Nwcml0ZUVuZEhhbmRsZXIsIGZhbHNlKTtcblx0XHR9XG5cdH07XG5cblx0cC5fdXBkYXRlRHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fYXVkaW9TcHJpdGVTdG9wVGltZSA9ICh0aGlzLl9zdGFydFRpbWUgKyB0aGlzLl9kdXJhdGlvbikgKiAwLjAwMTtcblxuXHRcdGlmKHRoaXMucGxheVN0YXRlID09IGNyZWF0ZWpzLlNvdW5kLlBMQVlfU1VDQ0VFREVEKSB7XG5cdFx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9BVURJT19FTkRFRCwgdGhpcy5fZW5kZWRIYW5kbGVyLCBmYWxzZSk7XG5cdFx0XHR0aGlzLl9wbGF5YmFja1Jlc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoY3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luLl9USU1FX1VQREFURSwgdGhpcy5fYXVkaW9TcHJpdGVFbmRIYW5kbGVyLCBmYWxzZSk7XG5cdFx0fVxuXHR9O1xuXG5cdHAuX3NldER1cmF0aW9uRnJvbVNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9kdXJhdGlvbiA9IGNyZWF0ZWpzLkhUTUxBdWRpb1RhZ1Bvb2wuZ2V0RHVyYXRpb24odGhpcy5zcmMpO1xuXHRcdHRoaXMuX3BsYXliYWNrUmVzb3VyY2UgPSBudWxsO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkhUTUxBdWRpb1NvdW5kSW5zdGFuY2UgPSBjcmVhdGVqcy5wcm9tb3RlKEhUTUxBdWRpb1NvdW5kSW5zdGFuY2UsIFwiQWJzdHJhY3RTb3VuZEluc3RhbmNlXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEhUTUxBdWRpb1BsdWdpbi5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogUGxheSBzb3VuZHMgdXNpbmcgSFRNTCAmbHQ7YXVkaW8mZ3Q7IHRhZ3MgaW4gdGhlIGJyb3dzZXIuIFRoaXMgcGx1Z2luIGlzIHRoZSBzZWNvbmQgcHJpb3JpdHkgcGx1Z2luIGluc3RhbGxlZFxuXHQgKiBieSBkZWZhdWx0LCBhZnRlciB0aGUge3sjY3Jvc3NMaW5rIFwiV2ViQXVkaW9QbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0uICBGb3Igb2xkZXIgYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBodG1sXG5cdCAqIGF1ZGlvLCBpbmNsdWRlIGFuZCBpbnN0YWxsIHRoZSB7eyNjcm9zc0xpbmsgXCJGbGFzaEF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiA8aDQ+S25vd24gQnJvd3NlciBhbmQgT1MgaXNzdWVzIGZvciBIVE1MIEF1ZGlvPC9oND5cblx0ICogPGI+QWxsIGJyb3dzZXJzPC9iPjxiciAvPlxuXHQgKiBUZXN0aW5nIGhhcyBzaG93biBpbiBhbGwgYnJvd3NlcnMgdGhlcmUgaXMgYSBsaW1pdCB0byBob3cgbWFueSBhdWRpbyB0YWcgaW5zdGFuY2VzIHlvdSBhcmUgYWxsb3dlZC4gIElmIHlvdSBleGNlZWRcblx0ICogdGhpcyBsaW1pdCwgeW91IGNhbiBleHBlY3QgdG8gc2VlIHVucHJlZGljdGFibGUgcmVzdWx0cy4gUGxlYXNlIHVzZSB7eyNjcm9zc0xpbmsgXCJTb3VuZC5NQVhfSU5TVEFOQ0VTXCJ9fXt7L2Nyb3NzTGlua319IGFzXG5cdCAqIGEgZ3VpZGUgdG8gaG93IG1hbnkgdG90YWwgYXVkaW8gdGFncyB5b3UgY2FuIHNhZmVseSB1c2UgaW4gYWxsIGJyb3dzZXJzLiAgVGhpcyBpc3N1ZSBpcyBwcmltYXJpbHkgbGltaXRlZCB0byBJRTkuXG5cdCAqXG4gICAgICogPGI+SUUgaHRtbCBsaW1pdGF0aW9uczwvYj48YnIgLz5cbiAgICAgKiA8dWw+PGxpPlRoZXJlIGlzIGEgZGVsYXkgaW4gYXBwbHlpbmcgdm9sdW1lIGNoYW5nZXMgdG8gdGFncyB0aGF0IG9jY3VycyBvbmNlIHBsYXliYWNrIGlzIHN0YXJ0ZWQuIFNvIGlmIHlvdSBoYXZlXG4gICAgICogbXV0ZWQgYWxsIHNvdW5kcywgdGhleSB3aWxsIGFsbCBwbGF5IGR1cmluZyB0aGlzIGRlbGF5IHVudGlsIHRoZSBtdXRlIGFwcGxpZXMgaW50ZXJuYWxseS4gVGhpcyBoYXBwZW5zIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgKiB3aGVuIG9yIGhvdyB5b3UgYXBwbHkgdGhlIHZvbHVtZSBjaGFuZ2UsIGFzIHRoZSB0YWcgc2VlbXMgdG8gbmVlZCB0byBwbGF5IHRvIGFwcGx5IGl0LjwvbGk+XG4gICAgICogPGxpPk1QMyBlbmNvZGluZyB3aWxsIG5vdCBhbHdheXMgd29yayBmb3IgYXVkaW8gdGFncyBpZiBpdCdzIG5vdCBkZWZhdWx0LiAgV2UndmUgZm91bmQgZGVmYXVsdCBlbmNvZGluZyB3aXRoXG4gICAgICogNjRrYnBzIHdvcmtzLjwvbGk+XG5cdCAqIDxsaT5PY2Nhc2lvbmFsbHkgdmVyeSBzaG9ydCBzYW1wbGVzIHdpbGwgZ2V0IGN1dCBvZmYuPC9saT5cblx0ICogPGxpPlRoZXJlIGlzIGEgbGltaXQgdG8gaG93IG1hbnkgYXVkaW8gdGFncyB5b3UgY2FuIGxvYWQgb3IgcGxheSBhdCBvbmNlLCB3aGljaCBhcHBlYXJzIHRvIGJlIGRldGVybWluZWQgYnlcblx0ICogaGFyZHdhcmUgYW5kIGJyb3dzZXIgc2V0dGluZ3MuICBTZWUge3sjY3Jvc3NMaW5rIFwiSFRNTEF1ZGlvUGx1Z2luLk1BWF9JTlNUQU5DRVNcIn19e3svY3Jvc3NMaW5rfX0gZm9yIGEgc2FmZSBlc3RpbWF0ZS5cblx0ICogTm90ZSB0aGF0IGF1ZGlvIHNwcml0ZXMgY2FuIGJlIHVzZWQgYXMgYSBzb2x1dGlvbiB0byB0aGlzIGlzc3VlLjwvbGk+PC91bD5cblx0ICpcblx0ICogPGI+U2FmYXJpIGxpbWl0YXRpb25zPC9iPjxiciAvPlxuXHQgKiA8dWw+PGxpPlNhZmFyaSByZXF1aXJlcyBRdWlja3RpbWUgdG8gYmUgaW5zdGFsbGVkIGZvciBhdWRpbyBwbGF5YmFjay48L2xpPjwvdWw+XG5cdCAqXG5cdCAqIDxiPmlPUyA2IGxpbWl0YXRpb25zPC9iPjxiciAvPlxuXHQgKiA8dWw+PGxpPmNhbiBvbmx5IGhhdmUgb25lICZsdDthdWRpbyZndDsgdGFnPC9saT5cblx0ICogXHRcdDxsaT5jYW4gbm90IHByZWxvYWQgb3IgYXV0b3BsYXkgdGhlIGF1ZGlvPC9saT5cblx0ICogXHRcdDxsaT5jYW4gbm90IGNhY2hlIHRoZSBhdWRpbzwvbGk+XG5cdCAqIFx0XHQ8bGk+Y2FuIG5vdCBwbGF5IHRoZSBhdWRpbyBleGNlcHQgaW5zaWRlIGEgdXNlciBpbml0aWF0ZWQgZXZlbnQuPC9saT5cblx0ICpcdFx0PGxpPk5vdGUgaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIHt7I2Nyb3NzTGluayBcIldlYkF1ZGlvUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319IGZvciBpT1MgKDYrKTwvbGk+XG5cdCAqIFx0XHQ8bGk+YXVkaW8gc3ByaXRlcyBjYW4gYmUgdXNlZCB0byBtaXRpZ2F0ZSBzb21lIG9mIHRoZXNlIGlzc3VlcyBhbmQgYXJlIHN0cm9uZ2x5IHJlY29tbWVuZGVkIG9uIGlPUzwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqIDxiPkFuZHJvaWQgTmF0aXZlIEJyb3dzZXIgbGltaXRhdGlvbnM8L2I+PGJyIC8+XG5cdCAqIDx1bD48bGk+V2UgaGF2ZSBubyBjb250cm9sIG92ZXIgYXVkaW8gdm9sdW1lLiBPbmx5IHRoZSB1c2VyIGNhbiBzZXQgdm9sdW1lIG9uIHRoZWlyIGRldmljZS48L2xpPlxuXHQgKiAgICAgIDxsaT5XZSBjYW4gb25seSBwbGF5IGF1ZGlvIGluc2lkZSBhIHVzZXIgZXZlbnQgKHRvdWNoL2NsaWNrKS4gIFRoaXMgY3VycmVudGx5IG1lYW5zIHlvdSBjYW5ub3QgbG9vcCBzb3VuZCBvciB1c2UgYSBkZWxheS48L2xpPjwvdWw+XG5cdCAqIDxiPiBBbmRyb2lkIENocm9tZSAyNi4wLjE0MTAuNTggc3BlY2lmaWMgbGltaXRhdGlvbnM8L2I+PGJyIC8+XG5cdCAqIDx1bD4gPGxpPkNhbiBvbmx5IHBsYXkgMSBzb3VuZCBhdCBhIHRpbWUuPC9saT5cblx0ICogICAgICA8bGk+U291bmQgaXMgbm90IGNhY2hlZC48L2xpPlxuXHQgKiAgICAgIDxsaT5Tb3VuZCBjYW4gb25seSBiZSBsb2FkZWQgaW4gYSB1c2VyIGluaXRpYXRlZCB0b3VjaC9jbGljayBldmVudC48L2xpPlxuXHQgKiAgICAgIDxsaT5UaGVyZSBpcyBhIGRlbGF5IGJlZm9yZSBhIHNvdW5kIGlzIHBsYXllZCwgcHJlc3VtYWJseSB3aGlsZSB0aGUgc3JjIGlzIGxvYWRlZC48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiU291bmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIGdlbmVyYWwgbm90ZXMgb24ga25vd24gaXNzdWVzLlxuXHQgKlxuXHQgKiBAY2xhc3MgSFRNTEF1ZGlvUGx1Z2luXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0UGx1Z2luXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gSFRNTEF1ZGlvUGx1Z2luKCkge1xuXHRcdHRoaXMuQWJzdHJhY3RQbHVnaW5fY29uc3RydWN0b3IoKTtcblxuXG5cdC8vIFB1YmxpYyBQcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBpcyBubyBsb25nZXIgbmVlZGVkIGFzIHdlIGFyZSBub3cgdXNpbmcgb2JqZWN0IHBvb2xpbmcgZm9yIHRhZ3MuXG5cdFx0ICpcblx0XHQgKiA8Yj5OT1RFIHRoaXMgcHJvcGVydHkgb25seSBleGlzdHMgYXMgYSBsaW1pdGF0aW9uIG9mIEhUTUwgYXVkaW8uPC9iPlxuXHRcdCAqIEBwcm9wZXJ0eSBkZWZhdWx0TnVtQ2hhbm5lbHNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDJcblx0XHQgKiBAc2luY2UgMC40LjBcblx0XHQgKiBAZGVwcmVjYXRlZFxuXHRcdCAqL1xuXHRcdHRoaXMuZGVmYXVsdE51bUNoYW5uZWxzID0gMjtcblxuXHRcdHRoaXMuX2NhcGFiaWxpdGllcyA9IHMuX2NhcGFiaWxpdGllcztcblxuXHRcdHRoaXMuX2xvYWRlckNsYXNzID0gY3JlYXRlanMuU291bmRMb2FkZXI7XG5cdFx0dGhpcy5fc291bmRJbnN0YW5jZUNsYXNzID0gY3JlYXRlanMuSFRNTEF1ZGlvU291bmRJbnN0YW5jZTtcblx0fVxuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEhUTUxBdWRpb1BsdWdpbiwgY3JlYXRlanMuQWJzdHJhY3RQbHVnaW4pO1xuXHR2YXIgcyA9IEhUTUxBdWRpb1BsdWdpbjtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXG4vLyBTdGF0aWMgUHJvcGVydGllc1xuXHQvKipcblx0ICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGluc3RhbmNlcyB0aGF0IGNhbiBiZSBsb2FkZWQgb3IgcGxheWVkLiBUaGlzIGlzIGEgYnJvd3NlciBsaW1pdGF0aW9uLCBwcmltYXJpbHkgbGltaXRlZCB0byBJRTkuXG5cdCAqIFRoZSBhY3R1YWwgbnVtYmVyIHZhcmllcyBmcm9tIGJyb3dzZXIgdG8gYnJvd3NlciAoYW5kIGlzIGxhcmdlbHkgaGFyZHdhcmUgZGVwZW5kYW50KSwgYnV0IHRoaXMgaXMgYSBzYWZlIGVzdGltYXRlLlxuXHQgKiBBdWRpbyBzcHJpdGVzIHdvcmsgYXJvdW5kIHRoaXMgbGltaXRhdGlvbi5cblx0ICogQHByb3BlcnR5IE1BWF9JTlNUQU5DRVNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQGRlZmF1bHQgMzBcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5NQVhfSU5TVEFOQ0VTID0gMzA7XG5cblx0LyoqXG5cdCAqIEV2ZW50IGNvbnN0YW50IGZvciB0aGUgXCJjYW5QbGF5VGhyb3VnaFwiIGV2ZW50IGZvciBjbGVhbmVyIGNvZGUuXG5cdCAqIEBwcm9wZXJ0eSBfQVVESU9fUkVBRFlcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgY2FucGxheXRocm91Z2hcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzLl9BVURJT19SRUFEWSA9IFwiY2FucGxheXRocm91Z2hcIjtcblxuXHQvKipcblx0ICogRXZlbnQgY29uc3RhbnQgZm9yIHRoZSBcImVuZGVkXCIgZXZlbnQgZm9yIGNsZWFuZXIgY29kZS5cblx0ICogQHByb3BlcnR5IF9BVURJT19FTkRFRFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBlbmRlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHMuX0FVRElPX0VOREVEID0gXCJlbmRlZFwiO1xuXG5cdC8qKlxuXHQgKiBFdmVudCBjb25zdGFudCBmb3IgdGhlIFwic2Vla2VkXCIgZXZlbnQgZm9yIGNsZWFuZXIgY29kZS4gIFdlIHV0aWxpemUgdGhpcyBldmVudCBmb3IgbWFpbnRhaW5pbmcgbG9vcCBldmVudHMuXG5cdCAqIEBwcm9wZXJ0eSBfQVVESU9fU0VFS0VEXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHNlZWtlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHMuX0FVRElPX1NFRUtFRCA9IFwic2Vla2VkXCI7XG5cblx0LyoqXG5cdCAqIEV2ZW50IGNvbnN0YW50IGZvciB0aGUgXCJzdGFsbGVkXCIgZXZlbnQgZm9yIGNsZWFuZXIgY29kZS5cblx0ICogQHByb3BlcnR5IF9BVURJT19TVEFMTEVEXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHN0YWxsZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzLl9BVURJT19TVEFMTEVEID0gXCJzdGFsbGVkXCI7XG5cblx0LyoqXG5cdCAqIEV2ZW50IGNvbnN0YW50IGZvciB0aGUgXCJ0aW1ldXBkYXRlXCIgZXZlbnQgZm9yIGNsZWFuZXIgY29kZS4gIFV0aWxpemVkIGZvciBsb29waW5nIGF1ZGlvIHNwcml0ZXMuXG5cdCAqIFRoaXMgZXZlbnQgY2FsbHNiYWNrIGV2ZXIgMTUgdG8gMjUwbXMgYW5kIGNhbiBiZSBkcm9wcGVkIGJ5IHRoZSBicm93c2VyIGZvciBwZXJmb3JtYW5jZS5cblx0ICogQHByb3BlcnR5IF9USU1FX1VQREFURVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCB0aW1ldXBkYXRlXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cy5fVElNRV9VUERBVEUgPSBcInRpbWV1cGRhdGVcIjtcblxuXHQvKipcblx0ICogVGhlIGNhcGFiaWxpdGllcyBvZiB0aGUgcGx1Z2luLiBUaGlzIGlzIGdlbmVyYXRlZCB2aWEgdGhlIHt7I2Nyb3NzTGluayBcIkhUTUxBdWRpb1BsdWdpbi9fZ2VuZXJhdGVDYXBhYmlsaXRpZXNcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLiBQbGVhc2Ugc2VlIHRoZSBTb3VuZCB7eyNjcm9zc0xpbmsgXCJTb3VuZC9nZXRDYXBhYmlsaXRpZXNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGZvciBhbiBvdmVydmlldyBvZiBhbGxcblx0ICogb2YgdGhlIGF2YWlsYWJsZSBwcm9wZXJ0aWVzLlxuXHQgKiBAcHJvcGVydHkgX2NhcGFiaWxpdGllc1xuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuX2NhcGFiaWxpdGllcyA9IG51bGw7XG5cblxuLy8gU3RhdGljIE1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZSBpZiB0aGUgcGx1Z2luIGNhbiBiZSB1c2VkIGluIHRoZSBjdXJyZW50IGJyb3dzZXIvT1MuIE5vdGUgdGhhdCBIVE1MIGF1ZGlvIGlzIGF2YWlsYWJsZSBpbiBtb3N0IG1vZGVyblxuXHQgKiBicm93c2VycywgYnV0IGlzIGRpc2FibGVkIGluIGlPUyBiZWNhdXNlIG9mIGl0cyBsaW1pdGF0aW9ucy5cblx0ICogQG1ldGhvZCBpc1N1cHBvcnRlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgcGx1Z2luIGNhbiBiZSBpbml0aWFsaXplZC5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRzLl9nZW5lcmF0ZUNhcGFiaWxpdGllcygpO1xuXHRcdHJldHVybiAocy5fY2FwYWJpbGl0aWVzICE9IG51bGwpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgdGhlIGNhcGFiaWxpdGllcyBvZiB0aGUgcGx1Z2luLiBVc2VkIGludGVybmFsbHkuIFBsZWFzZSBzZWUgdGhlIFNvdW5kIEFQSSB7eyNjcm9zc0xpbmsgXCJTb3VuZC9nZXRDYXBhYmlsaXRpZXNcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kIGZvciBhbiBvdmVydmlldyBvZiBwbHVnaW4gY2FwYWJpbGl0aWVzLlxuXHQgKiBAbWV0aG9kIF9nZW5lcmF0ZUNhcGFiaWxpdGllc1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHMuX2dlbmVyYXRlQ2FwYWJpbGl0aWVzID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmIChzLl9jYXBhYmlsaXRpZXMgIT0gbnVsbCkge3JldHVybjt9XG5cdFx0dmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYXVkaW9cIik7XG5cdFx0aWYgKHQuY2FuUGxheVR5cGUgPT0gbnVsbCkge3JldHVybiBudWxsO31cblxuXHRcdHMuX2NhcGFiaWxpdGllcyA9IHtcblx0XHRcdHBhbm5pbmc6ZmFsc2UsXG5cdFx0XHR2b2x1bWU6dHJ1ZSxcblx0XHRcdHRyYWNrczotMVxuXHRcdH07XG5cblx0XHQvLyBkZXRlcm1pbmUgd2hpY2ggZXh0ZW5zaW9ucyBvdXIgYnJvd3NlciBzdXBwb3J0cyBmb3IgdGhpcyBwbHVnaW4gYnkgaXRlcmF0aW5nIHRocm91Z2ggU291bmQuU1VQUE9SVEVEX0VYVEVOU0lPTlNcblx0XHR2YXIgc3VwcG9ydGVkRXh0ZW5zaW9ucyA9IGNyZWF0ZWpzLlNvdW5kLlNVUFBPUlRFRF9FWFRFTlNJT05TO1xuXHRcdHZhciBleHRlbnNpb25NYXAgPSBjcmVhdGVqcy5Tb3VuZC5FWFRFTlNJT05fTUFQO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc3VwcG9ydGVkRXh0ZW5zaW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBleHQgPSBzdXBwb3J0ZWRFeHRlbnNpb25zW2ldO1xuXHRcdFx0dmFyIHBsYXlUeXBlID0gZXh0ZW5zaW9uTWFwW2V4dF0gfHwgZXh0O1xuXHRcdFx0cy5fY2FwYWJpbGl0aWVzW2V4dF0gPSAodC5jYW5QbGF5VHlwZShcImF1ZGlvL1wiICsgZXh0KSAhPSBcIm5vXCIgJiYgdC5jYW5QbGF5VHlwZShcImF1ZGlvL1wiICsgZXh0KSAhPSBcIlwiKSB8fCAodC5jYW5QbGF5VHlwZShcImF1ZGlvL1wiICsgcGxheVR5cGUpICE9IFwibm9cIiAmJiB0LmNhblBsYXlUeXBlKFwiYXVkaW8vXCIgKyBwbGF5VHlwZSkgIT0gXCJcIik7XG5cdFx0fSAgLy8gT0pSIGFub3RoZXIgd2F5IHRvIGRvIHRoaXMgbWlnaHQgYmUgY2FuUGxheVR5cGU6XCJtNGFcIiwgY29kZXg6IG1wNFxuXHR9O1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzXG5cdHAucmVnaXN0ZXIgPSBmdW5jdGlvbiAobG9hZEl0ZW0pIHtcblx0XHR2YXIgdGFnID0gY3JlYXRlanMuSFRNTEF1ZGlvVGFnUG9vbC5nZXQobG9hZEl0ZW0uc3JjKTtcblx0XHR2YXIgbG9hZGVyID0gdGhpcy5BYnN0cmFjdFBsdWdpbl9yZWdpc3Rlcihsb2FkSXRlbSk7XG5cdFx0bG9hZGVyLnNldFRhZyh0YWcpO1xuXG5cdFx0cmV0dXJuIGxvYWRlcjtcblx0fTtcblxuXHRwLnJlbW92ZVNvdW5kID0gZnVuY3Rpb24gKHNyYykge1xuXHRcdHRoaXMuQWJzdHJhY3RQbHVnaW5fcmVtb3ZlU291bmQoc3JjKTtcblx0XHRjcmVhdGVqcy5IVE1MQXVkaW9UYWdQb29sLnJlbW92ZShzcmMpO1xuXHR9O1xuXG5cdHAuY3JlYXRlID0gZnVuY3Rpb24gKHNyYywgc3RhcnRUaW1lLCBkdXJhdGlvbikge1xuXHRcdHZhciBzaSA9IHRoaXMuQWJzdHJhY3RQbHVnaW5fY3JlYXRlKHNyYywgc3RhcnRUaW1lLCBkdXJhdGlvbik7XG5cdFx0c2kuc2V0UGxheWJhY2tSZXNvdXJjZShudWxsKTtcblx0XHRyZXR1cm4gc2k7XG5cdH07XG5cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbSFRNTEF1ZGlvUGx1Z2luXVwiO1xuXHR9O1xuXG5cdC8vIHBsdWdpbiBkb2VzIG5vdCBzdXBwb3J0IHRoZXNlXG5cdHAuc2V0Vm9sdW1lID0gcC5nZXRWb2x1bWUgPSBwLnNldE11dGUgPSBudWxsO1xuXG5cblx0Y3JlYXRlanMuSFRNTEF1ZGlvUGx1Z2luID0gY3JlYXRlanMucHJvbW90ZShIVE1MQXVkaW9QbHVnaW4sIFwiQWJzdHJhY3RQbHVnaW5cIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVHdlZW4uanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbi8vIFRPRE86IHBvc3NpYmx5IGFkZCBhIEVORCBhY3Rpb25zTW9kZSAob25seSBydW5zIGFjdGlvbnMgdGhhdCA9PSBwb3NpdGlvbik/XG4vLyBUT0RPOiBldmFsdWF0ZSBhIHdheSB0byBkZWNvdXBsZSBwYXVzZWQgZnJvbSB0aWNrIHJlZ2lzdHJhdGlvbi5cblxuXG5cblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBUd2VlbiBpbnN0YW5jZSB0d2VlbnMgcHJvcGVydGllcyBmb3IgYSBzaW5nbGUgdGFyZ2V0LiBJbnN0YW5jZSBtZXRob2RzIGNhbiBiZSBjaGFpbmVkIGZvciBlYXN5IGNvbnN0cnVjdGlvbiBhbmQgc2VxdWVuY2luZzpcblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHRhcmdldC5hbHBoYSA9IDE7XG5cdCAqXHQgICAgY3JlYXRlanMuVHdlZW4uZ2V0KHRhcmdldClcblx0ICpcdCAgICAgICAgIC53YWl0KDUwMClcblx0ICpcdCAgICAgICAgIC50byh7YWxwaGE6MCwgdmlzaWJsZTpmYWxzZX0sIDEwMDApXG5cdCAqXHQgICAgICAgICAuY2FsbChoYW5kbGVDb21wbGV0ZSk7XG5cdCAqXHQgICAgZnVuY3Rpb24gaGFuZGxlQ29tcGxldGUoKSB7XG5cdCAqXHQgICAgXHQvL1R3ZWVuIGNvbXBsZXRlXG5cdCAqXHQgICAgfVxuXHQgKlxuXHQgKiBNdWx0aXBsZSB0d2VlbnMgY2FuIHBvaW50IHRvIHRoZSBzYW1lIGluc3RhbmNlLCBob3dldmVyIGlmIHRoZXkgYWZmZWN0IHRoZSBzYW1lIHByb3BlcnRpZXMgdGhlcmUgY291bGQgYmUgdW5leHBlY3RlZFxuXHQgKiBiZWhhdmlvdXIuIFRvIHN0b3AgYWxsIHR3ZWVucyBvbiBhbiBvYmplY3QsIHVzZSB7eyNjcm9zc0xpbmsgXCJUd2Vlbi9yZW1vdmVUd2VlbnNcIn19e3svY3Jvc3NMaW5rfX0gb3IgcGFzcyBgb3ZlcnJpZGU6dHJ1ZWBcblx0ICogaW4gdGhlIHByb3BzIGFyZ3VtZW50LlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLlR3ZWVuLmdldCh0YXJnZXQsIHtvdmVycmlkZTp0cnVlfSkudG8oe3g6MTAwfSk7XG5cdCAqXG5cdCAqIFN1YnNjcmliZSB0byB0aGUge3sjY3Jvc3NMaW5rIFwiVHdlZW4vY2hhbmdlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IHRvIGdldCBub3RpZmllZCB3aGVuIGEgcHJvcGVydHkgb2YgdGhlXG5cdCAqIHRhcmdldCBpcyBjaGFuZ2VkLlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLlR3ZWVuLmdldCh0YXJnZXQsIHtvdmVycmlkZTp0cnVlfSkudG8oe3g6MTAwfSkuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVDaGFuZ2UpO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZUNoYW5nZShldmVudCkge1xuXHQgKiAgICAgICAgICAvLyBUaGUgdHdlZW4gY2hhbmdlZC5cblx0ICogICAgICB9XG5cdCAqXG5cdCAqIFNlZSB0aGUgVHdlZW4ge3sjY3Jvc3NMaW5rIFwiVHdlZW4vZ2V0XCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCBmb3IgYWRkaXRpb25hbCBwYXJhbSBkb2N1bWVudGF0aW9uLlxuXHQgKiBAY2xhc3MgVHdlZW5cblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCB0aGF0IHdpbGwgaGF2ZSBpdHMgcHJvcGVydGllcyB0d2VlbmVkLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzXSBUaGUgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIHRvIGFwcGx5IHRvIHRoaXMgdHdlZW4gaW5zdGFuY2UgKGV4LiBge2xvb3A6dHJ1ZSwgcGF1c2VkOnRydWV9YC5cblx0ICogQWxsIHByb3BlcnRpZXMgZGVmYXVsdCB0byBmYWxzZS4gU3VwcG9ydGVkIHByb3BzIGFyZTo8VUw+XG5cdCAqICAgIDxMST4gbG9vcDogc2V0cyB0aGUgbG9vcCBwcm9wZXJ0eSBvbiB0aGlzIHR3ZWVuLjwvTEk+XG5cdCAqICAgIDxMST4gdXNlVGlja3M6IHVzZXMgdGlja3MgZm9yIGFsbCBkdXJhdGlvbnMgaW5zdGVhZCBvZiBtaWxsaXNlY29uZHMuPC9MST5cblx0ICogICAgPExJPiBpZ25vcmVHbG9iYWxQYXVzZTogc2V0cyB0aGUge3sjY3Jvc3NMaW5rIFwiVHdlZW4vaWdub3JlR2xvYmFsUGF1c2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgb24gdGhpcyB0d2Vlbi48L0xJPlxuXHQgKiAgICA8TEk+IG92ZXJyaWRlOiBpZiB0cnVlLCBgVHdlZW4ucmVtb3ZlVHdlZW5zKHRhcmdldClgIHdpbGwgYmUgY2FsbGVkIHRvIHJlbW92ZSBhbnkgb3RoZXIgdHdlZW5zIHdpdGggdGhlIHNhbWUgdGFyZ2V0LlxuXHQgKiAgICA8TEk+IHBhdXNlZDogaW5kaWNhdGVzIHdoZXRoZXIgdG8gc3RhcnQgdGhlIHR3ZWVuIHBhdXNlZC48L0xJPlxuXHQgKiAgICA8TEk+IHBvc2l0aW9uOiBpbmRpY2F0ZXMgdGhlIGluaXRpYWwgcG9zaXRpb24gZm9yIHRoaXMgdHdlZW4uPC9MST5cblx0ICogICAgPExJPiBvbkNoYW5nZTogc3BlY2lmaWVzIGEgbGlzdGVuZXIgZm9yIHRoZSBcImNoYW5nZVwiIGV2ZW50LjwvTEk+XG5cdCAqIDwvVUw+XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcGx1Z2luRGF0YV0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgZGF0YSBmb3IgdXNlIGJ5IGluc3RhbGxlZCBwbHVnaW5zLiBTZWUgaW5kaXZpZHVhbFxuXHQgKiBwbHVnaW5zJyBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLlxuXHQgKiBAZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBUd2Vlbih0YXJnZXQsIHByb3BzLCBwbHVnaW5EYXRhKSB7XG5cblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQ2F1c2VzIHRoaXMgdHdlZW4gdG8gY29udGludWUgcGxheWluZyB3aGVuIGEgZ2xvYmFsIHBhdXNlIGlzIGFjdGl2ZS4gRm9yIGV4YW1wbGUsIGlmIFR3ZWVuSlMgaXMgdXNpbmcge3sjY3Jvc3NMaW5rIFwiVGlja2VyXCJ9fXt7L2Nyb3NzTGlua319LFxuXHRcdCAqIHRoZW4gc2V0dGluZyB0aGlzIHRvIHRydWUgKHRoZSBkZWZhdWx0KSB3aWxsIGNhdXNlIHRoaXMgdHdlZW4gdG8gYmUgcGF1c2VkIHdoZW4gPGNvZGU+VGlja2VyLnNldFBhdXNlZCh0cnVlKTwvY29kZT5cblx0XHQgKiBpcyBjYWxsZWQuIFNlZSB0aGUgVHdlZW4ge3sjY3Jvc3NMaW5rIFwiVHdlZW4vdGlja1wifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgZm9yIG1vcmUgaW5mby4gQ2FuIGJlIHNldCB2aWEgdGhlIHByb3BzXG5cdFx0ICogcGFyYW1ldGVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBpZ25vcmVHbG9iYWxQYXVzZVxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMuaWdub3JlR2xvYmFsUGF1c2UgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgdHJ1ZSwgdGhlIHR3ZWVuIHdpbGwgbG9vcCB3aGVuIGl0IHJlYWNoZXMgdGhlIGVuZC4gQ2FuIGJlIHNldCB2aWEgdGhlIHByb3BzIHBhcmFtLlxuXHRcdCAqIEBwcm9wZXJ0eSBsb29wXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmxvb3AgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogU3BlY2lmaWVzIHRoZSB0b3RhbCBkdXJhdGlvbiBvZiB0aGlzIHR3ZWVuIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgdXNlVGlja3MgaXMgdHJ1ZSkuXG5cdFx0ICogVGhpcyB2YWx1ZSBpcyBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgYXMgeW91IG1vZGlmeSB0aGUgdHdlZW4uIENoYW5naW5nIGl0IGRpcmVjdGx5IGNvdWxkIHJlc3VsdCBpbiB1bmV4cGVjdGVkXG5cdFx0ICogYmVoYXZpb3VyLlxuXHRcdCAqIEBwcm9wZXJ0eSBkdXJhdGlvblxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMuZHVyYXRpb24gPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBBbGxvd3MgeW91IHRvIHNwZWNpZnkgZGF0YSB0aGF0IHdpbGwgYmUgdXNlZCBieSBpbnN0YWxsZWQgcGx1Z2lucy4gRWFjaCBwbHVnaW4gdXNlcyB0aGlzIGRpZmZlcmVudGx5LCBidXQgaW4gZ2VuZXJhbFxuXHRcdCAqIHlvdSBzcGVjaWZ5IGRhdGEgYnkgc2V0dGluZyBpdCB0byBhIHByb3BlcnR5IG9mIHBsdWdpbkRhdGEgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBwbHVnaW4gY2xhc3MuXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKlx0bXlUd2Vlbi5wbHVnaW5EYXRhLlBsdWdpbkNsYXNzTmFtZSA9IGRhdGE7XG5cdFx0ICogPGJyLz5cblx0XHQgKiBBbHNvLCBtb3N0IHBsdWdpbnMgc3VwcG9ydCBhIHByb3BlcnR5IHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZW0uIFRoaXMgaXMgdHlwaWNhbGx5IHRoZSBwbHVnaW4gY2xhc3MgbmFtZSBmb2xsb3dlZCBieSBcIl9lbmFibGVkXCIuPGJyLz5cblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqXHRteVR3ZWVuLnBsdWdpbkRhdGEuUGx1Z2luQ2xhc3NOYW1lX2VuYWJsZWQgPSBmYWxzZTs8YnIvPlxuXHRcdCAqIDxici8+XG5cdFx0ICogU29tZSBwbHVnaW5zIGFsc28gc3RvcmUgaW5zdGFuY2UgZGF0YSBpbiB0aGlzIG9iamVjdCwgdXN1YWxseSBpbiBhIHByb3BlcnR5IG5hbWVkIF9QbHVnaW5DbGFzc05hbWUuXG5cdFx0ICogU2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciBpbmRpdmlkdWFsIHBsdWdpbnMgZm9yIG1vcmUgZGV0YWlscy5cblx0XHQgKiBAcHJvcGVydHkgcGx1Z2luRGF0YVxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5wbHVnaW5EYXRhID0gcGx1Z2luRGF0YSB8fCB7fTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHRhcmdldCBvZiB0aGlzIHR3ZWVuLiBUaGlzIGlzIHRoZSBvYmplY3Qgb24gd2hpY2ggdGhlIHR3ZWVuZWQgcHJvcGVydGllcyB3aWxsIGJlIGNoYW5nZWQuIENoYW5naW5nXG5cdFx0ICogdGhpcyBwcm9wZXJ0eSBhZnRlciB0aGUgdHdlZW4gaXMgY3JlYXRlZCB3aWxsIG5vdCBoYXZlIGFueSBlZmZlY3QuXG5cdFx0ICogQHByb3BlcnR5IHRhcmdldFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IG5vcm1hbGl6ZWQgcG9zaXRpb24gb2YgdGhlIHR3ZWVuLiBUaGlzIHdpbGwgYWx3YXlzIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCBkdXJhdGlvbi5cblx0XHQgKiBDaGFuZ2luZyB0aGlzIHByb3BlcnR5IGRpcmVjdGx5IHdpbGwgaGF2ZSBubyBlZmZlY3QuXG5cdFx0ICogQHByb3BlcnR5IHBvc2l0aW9uXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLnBvc2l0aW9uID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHRoZSB0d2VlbidzIGN1cnJlbnQgcG9zaXRpb24gaXMgd2l0aGluIGEgcGFzc2l2ZSB3YWl0LlxuXHRcdCAqIEBwcm9wZXJ0eSBwYXNzaXZlXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5wYXNzaXZlID0gZmFsc2U7XG5cdFxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3BhdXNlZFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2N1clF1ZXVlUHJvcHNcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9jdXJRdWV1ZVByb3BzID0ge307XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfaW5pdFF1ZXVlUHJvcHNcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9pbml0UXVldWVQcm9wcyA9IHt9O1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3N0ZXBzXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9zdGVwcyA9IFtdO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2FjdGlvbnNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX2FjdGlvbnMgPSBbXTtcblx0XG5cdFx0LyoqXG5cdFx0ICogUmF3IHBvc2l0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcHJldlBvc2l0aW9uXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3ByZXZQb3NpdGlvbiA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBwb3NpdGlvbiB3aXRoaW4gdGhlIGN1cnJlbnQgc3RlcC5cblx0XHQgKiBAcHJvcGVydHkgX3N0ZXBQb3NpdGlvblxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9zdGVwUG9zaXRpb24gPSAwOyAvLyB0aGlzIGlzIG5lZWRlZCBieSBNb3ZpZUNsaXAuXG5cdFxuXHRcdC8qKlxuXHRcdCAqIE5vcm1hbGl6ZWQgcG9zaXRpb24uXG5cdFx0ICogQHByb3BlcnR5IF9wcmV2UG9zXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAtMVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9wcmV2UG9zID0gLTE7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfdGFyZ2V0XG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3VzZVRpY2tzXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fdXNlVGlja3MgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9pbml0ZWRcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9pbml0ZWQgPSBmYWxzZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdHdlZW4gaXMgY3VycmVudGx5IHJlZ2lzdGVyZWQgd2l0aCBUd2Vlbi5cblx0XHQgKiBAcHJvcGVydHkgX3JlZ2lzdGVyZWRcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9yZWdpc3RlcmVkID0gZmFsc2U7XG5cblxuXHRcdGlmIChwcm9wcykge1xuXHRcdFx0dGhpcy5fdXNlVGlja3MgPSBwcm9wcy51c2VUaWNrcztcblx0XHRcdHRoaXMuaWdub3JlR2xvYmFsUGF1c2UgPSBwcm9wcy5pZ25vcmVHbG9iYWxQYXVzZTtcblx0XHRcdHRoaXMubG9vcCA9IHByb3BzLmxvb3A7XG5cdFx0XHRwcm9wcy5vbkNoYW5nZSAmJiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgcHJvcHMub25DaGFuZ2UpO1xuXHRcdFx0aWYgKHByb3BzLm92ZXJyaWRlKSB7IFR3ZWVuLnJlbW92ZVR3ZWVucyh0YXJnZXQpOyB9XG5cdFx0fVxuXHRcdGlmIChwcm9wcyYmcHJvcHMucGF1c2VkKSB7IHRoaXMuX3BhdXNlZD10cnVlOyB9XG5cdFx0ZWxzZSB7IGNyZWF0ZWpzLlR3ZWVuLl9yZWdpc3Rlcih0aGlzLHRydWUpOyB9XG5cdFx0aWYgKHByb3BzJiZwcm9wcy5wb3NpdGlvbiE9bnVsbCkgeyB0aGlzLnNldFBvc2l0aW9uKHByb3BzLnBvc2l0aW9uLCBUd2Vlbi5OT05FKTsgfVxuXG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoVHdlZW4sIGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlcik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cdFxuXG4vLyBzdGF0aWMgcHJvcGVydGllc1xuXHQvKipcblx0ICogQ29uc3RhbnQgZGVmaW5pbmcgdGhlIG5vbmUgYWN0aW9uc01vZGUgZm9yIHVzZSB3aXRoIHNldFBvc2l0aW9uLlxuXHQgKiBAcHJvcGVydHkgTk9ORVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICogQGRlZmF1bHQgMFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUd2Vlbi5OT05FID0gMDtcblxuXHQvKipcblx0ICogQ29uc3RhbnQgZGVmaW5pbmcgdGhlIGxvb3AgYWN0aW9uc01vZGUgZm9yIHVzZSB3aXRoIHNldFBvc2l0aW9uLlxuXHQgKiBAcHJvcGVydHkgTE9PUFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICogQGRlZmF1bHQgMVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUd2Vlbi5MT09QID0gMTtcblxuXHQvKipcblx0ICogQ29uc3RhbnQgZGVmaW5pbmcgdGhlIHJldmVyc2UgYWN0aW9uc01vZGUgZm9yIHVzZSB3aXRoIHNldFBvc2l0aW9uLlxuXHQgKiBAcHJvcGVydHkgUkVWRVJTRVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICogQGRlZmF1bHQgMlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUd2Vlbi5SRVZFUlNFID0gMjtcblxuXHQvKipcblx0ICogQ29uc3RhbnQgcmV0dXJuZWQgYnkgcGx1Z2lucyB0byB0ZWxsIHRoZSB0d2VlbiBub3QgdG8gdXNlIGRlZmF1bHQgYXNzaWdubWVudC5cblx0ICogQHByb3BlcnR5IElHTk9SRVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0VHdlZW4uSUdOT1JFID0ge307XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfbGlzdGVuZXJzXG5cdCAqIEB0eXBlIEFycmF5W1R3ZWVuXVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdFR3ZWVuLl90d2VlbnMgPSBbXTtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IF9wbHVnaW5zXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdFR3ZWVuLl9wbHVnaW5zID0ge307XG5cblxuLy8gc3RhdGljIG1ldGhvZHNcdFxuXHQvKipcblx0ICogUmV0dXJucyBhIG5ldyB0d2VlbiBpbnN0YW5jZS4gVGhpcyBpcyBmdW5jdGlvbmFsbHkgaWRlbnRpY2FsIHRvIHVzaW5nIFwibmV3IFR3ZWVuKC4uLilcIiwgYnV0IGxvb2tzIGNsZWFuZXJcblx0ICogd2l0aCB0aGUgY2hhaW5lZCBzeW50YXggb2YgVHdlZW5KUy5cblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKlx0XHR2YXIgdHdlZW4gPSBjcmVhdGVqcy5Ud2Vlbi5nZXQodGFyZ2V0KTtcblx0ICpcblx0ICogQG1ldGhvZCBnZXRcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCB0aGF0IHdpbGwgaGF2ZSBpdHMgcHJvcGVydGllcyB0d2VlbmVkLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzXSBUaGUgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIHRvIGFwcGx5IHRvIHRoaXMgdHdlZW4gaW5zdGFuY2UgKGV4LiBge2xvb3A6dHJ1ZSwgcGF1c2VkOnRydWV9YCkuXG5cdCAqIEFsbCBwcm9wZXJ0aWVzIGRlZmF1bHQgdG8gYGZhbHNlYC4gU3VwcG9ydGVkIHByb3BzIGFyZTpcblx0ICogPFVMPlxuXHQgKiAgICA8TEk+IGxvb3A6IHNldHMgdGhlIGxvb3AgcHJvcGVydHkgb24gdGhpcyB0d2Vlbi48L0xJPlxuXHQgKiAgICA8TEk+IHVzZVRpY2tzOiB1c2VzIHRpY2tzIGZvciBhbGwgZHVyYXRpb25zIGluc3RlYWQgb2YgbWlsbGlzZWNvbmRzLjwvTEk+XG5cdCAqICAgIDxMST4gaWdub3JlR2xvYmFsUGF1c2U6IHNldHMgdGhlIHt7I2Nyb3NzTGluayBcIlR3ZWVuL2lnbm9yZUdsb2JhbFBhdXNlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IG9uXG5cdCAqICAgIHRoaXMgdHdlZW4uPC9MST5cblx0ICogICAgPExJPiBvdmVycmlkZTogaWYgdHJ1ZSwgYGNyZWF0ZWpzLlR3ZWVuLnJlbW92ZVR3ZWVucyh0YXJnZXQpYCB3aWxsIGJlIGNhbGxlZCB0byByZW1vdmUgYW55IG90aGVyIHR3ZWVucyB3aXRoXG5cdCAqICAgIHRoZSBzYW1lIHRhcmdldC5cblx0ICogICAgPExJPiBwYXVzZWQ6IGluZGljYXRlcyB3aGV0aGVyIHRvIHN0YXJ0IHRoZSB0d2VlbiBwYXVzZWQuPC9MST5cblx0ICogICAgPExJPiBwb3NpdGlvbjogaW5kaWNhdGVzIHRoZSBpbml0aWFsIHBvc2l0aW9uIGZvciB0aGlzIHR3ZWVuLjwvTEk+XG5cdCAqICAgIDxMST4gb25DaGFuZ2U6IHNwZWNpZmllcyBhIGxpc3RlbmVyIGZvciB0aGUge3sjY3Jvc3NMaW5rIFwiVHdlZW4vY2hhbmdlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50LjwvTEk+XG5cdCAqIDwvVUw+XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcGx1Z2luRGF0YV0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgZGF0YSBmb3IgdXNlIGJ5IGluc3RhbGxlZCBwbHVnaW5zLiBTZWUgaW5kaXZpZHVhbCBwbHVnaW5zJ1xuXHQgKiBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvdmVycmlkZT1mYWxzZV0gSWYgdHJ1ZSwgYW55IHByZXZpb3VzIHR3ZWVucyBvbiB0aGUgc2FtZSB0YXJnZXQgd2lsbCBiZSByZW1vdmVkLiBUaGlzIGlzIHRoZVxuXHQgKiBzYW1lIGFzIGNhbGxpbmcgYFR3ZWVuLnJlbW92ZVR3ZWVucyh0YXJnZXQpYC5cblx0ICogQHJldHVybiB7VHdlZW59IEEgcmVmZXJlbmNlIHRvIHRoZSBjcmVhdGVkIHR3ZWVuLiBBZGRpdGlvbmFsIGNoYWluZWQgdHdlZW5zLCBtZXRob2QgY2FsbHMsIG9yIGNhbGxiYWNrcyBjYW4gYmVcblx0ICogYXBwbGllZCB0byB0aGUgcmV0dXJuZWQgdHdlZW4gaW5zdGFuY2UuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFR3ZWVuLmdldCA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvcHMsIHBsdWdpbkRhdGEsIG92ZXJyaWRlKSB7XG5cdFx0aWYgKG92ZXJyaWRlKSB7IFR3ZWVuLnJlbW92ZVR3ZWVucyh0YXJnZXQpOyB9XG5cdFx0cmV0dXJuIG5ldyBUd2Vlbih0YXJnZXQsIHByb3BzLCBwbHVnaW5EYXRhKTtcblx0fTtcblxuXHQvKipcblx0ICogQWR2YW5jZXMgYWxsIHR3ZWVucy4gVGhpcyB0eXBpY2FsbHkgdXNlcyB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyXCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzLCBidXQgeW91IGNhbiBjYWxsIGl0XG5cdCAqIG1hbnVhbGx5IGlmIHlvdSBwcmVmZXIgdG8gdXNlIHlvdXIgb3duIFwiaGVhcnRiZWF0XCIgaW1wbGVtZW50YXRpb24uXG5cdCAqIEBtZXRob2QgdGlja1xuXHQgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEgVGhlIGNoYW5nZSBpbiB0aW1lIGluIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCB0aWNrLiBSZXF1aXJlZCB1bmxlc3MgYWxsIHR3ZWVucyBoYXZlXG5cdCAqIGB1c2VUaWNrc2Agc2V0IHRvIHRydWUuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcGF1c2VkIEluZGljYXRlcyB3aGV0aGVyIGEgZ2xvYmFsIHBhdXNlIGlzIGluIGVmZmVjdC4gVHdlZW5zIHdpdGgge3sjY3Jvc3NMaW5rIFwiVHdlZW4vaWdub3JlR2xvYmFsUGF1c2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2lsbCBpZ25vcmUgdGhpcywgYnV0IGFsbCBvdGhlcnMgd2lsbCBwYXVzZSBpZiB0aGlzIGlzIGB0cnVlYC5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0VHdlZW4udGljayA9IGZ1bmN0aW9uKGRlbHRhLCBwYXVzZWQpIHtcblx0XHR2YXIgdHdlZW5zID0gVHdlZW4uX3R3ZWVucy5zbGljZSgpOyAvLyB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnMuXG5cdFx0Zm9yICh2YXIgaT10d2VlbnMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdHdlZW5zW2ldO1xuXHRcdFx0aWYgKChwYXVzZWQgJiYgIXR3ZWVuLmlnbm9yZUdsb2JhbFBhdXNlKSB8fCB0d2Vlbi5fcGF1c2VkKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHR0d2Vlbi50aWNrKHR3ZWVuLl91c2VUaWNrcz8xOmRlbHRhKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEhhbmRsZSBldmVudHMgdGhhdCByZXN1bHQgZnJvbSBUd2VlbiBiZWluZyB1c2VkIGFzIGFuIGV2ZW50IGhhbmRsZXIuIFRoaXMgaXMgaW5jbHVkZWQgdG8gYWxsb3cgVHdlZW4gdG8gaGFuZGxlXG5cdCAqIHt7I2Nyb3NzTGluayBcIlRpY2tlci90aWNrOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50cyBmcm9tIHRoZSBjcmVhdGVqcyB7eyNjcm9zc0xpbmsgXCJUaWNrZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIE5vIG90aGVyIGV2ZW50cyBhcmUgaGFuZGxlZCBpbiBUd2Vlbi5cblx0ICogQG1ldGhvZCBoYW5kbGVFdmVudFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgQW4gZXZlbnQgb2JqZWN0IHBhc3NlZCBpbiBieSB0aGUge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyXCJ9fXt7L2Nyb3NzTGlua319LiBXaWxsXG5cdCAqIHVzdWFsbHkgYmUgb2YgdHlwZSBcInRpY2tcIi5cblx0ICogQHByaXZhdGVcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC40LjJcblx0ICovXG5cdFR3ZWVuLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRpZiAoZXZlbnQudHlwZSA9PSBcInRpY2tcIikge1xuXHRcdFx0dGhpcy50aWNrKGV2ZW50LmRlbHRhLCBldmVudC5wYXVzZWQpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbGwgZXhpc3RpbmcgdHdlZW5zIGZvciBhIHRhcmdldC4gVGhpcyBpcyBjYWxsZWQgYXV0b21hdGljYWxseSBieSBuZXcgdHdlZW5zIGlmIHRoZSBgb3ZlcnJpZGVgXG5cdCAqIHByb3BlcnR5IGlzIGB0cnVlYC5cblx0ICogQG1ldGhvZCByZW1vdmVUd2VlbnNcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCB0byByZW1vdmUgZXhpc3RpbmcgdHdlZW5zIGZyb20uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFR3ZWVuLnJlbW92ZVR3ZWVucyA9IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdGlmICghdGFyZ2V0LnR3ZWVuanNfY291bnQpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIHR3ZWVucyA9IFR3ZWVuLl90d2VlbnM7XG5cdFx0Zm9yICh2YXIgaT10d2VlbnMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdHdlZW5zW2ldO1xuXHRcdFx0aWYgKHR3ZWVuLl90YXJnZXQgPT0gdGFyZ2V0KSB7XG5cdFx0XHRcdHR3ZWVuLl9wYXVzZWQgPSB0cnVlO1xuXHRcdFx0XHR0d2VlbnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0YXJnZXQudHdlZW5qc19jb3VudCA9IDA7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3AgYW5kIHJlbW92ZSBhbGwgZXhpc3RpbmcgdHdlZW5zLlxuXHQgKiBAbWV0aG9kIHJlbW92ZUFsbFR3ZWVuc1xuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKi9cblx0VHdlZW4ucmVtb3ZlQWxsVHdlZW5zID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHR3ZWVucyA9IFR3ZWVuLl90d2VlbnM7XG5cdFx0Zm9yICh2YXIgaT0gMCwgbD10d2VlbnMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0dmFyIHR3ZWVuID0gdHdlZW5zW2ldO1xuXHRcdFx0dHdlZW4uX3BhdXNlZCA9IHRydWU7XG5cdFx0XHR0d2Vlbi50YXJnZXQmJih0d2Vlbi50YXJnZXQudHdlZW5qc19jb3VudCA9IDApO1xuXHRcdH1cblx0XHR0d2VlbnMubGVuZ3RoID0gMDtcblx0fTtcblxuXHQvKipcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgYXJlIGFueSBhY3RpdmUgdHdlZW5zIChhbmQgaG93IG1hbnkpIG9uIHRoZSB0YXJnZXQgb2JqZWN0IChpZiBzcGVjaWZpZWQpIG9yIGluIGdlbmVyYWwuXG5cdCAqIEBtZXRob2QgaGFzQWN0aXZlVHdlZW5zXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbdGFyZ2V0XSBUaGUgdGFyZ2V0IHRvIGNoZWNrIGZvciBhY3RpdmUgdHdlZW5zLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgaW5kaWNhdGVcblx0ICogaWYgdGhlcmUgYXJlIGFueSBhY3RpdmUgdHdlZW5zIG9uIGFueSB0YXJnZXQuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZXJlIGFyZSBhY3RpdmUgdHdlZW5zLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUd2Vlbi5oYXNBY3RpdmVUd2VlbnMgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRpZiAodGFyZ2V0KSB7IHJldHVybiB0YXJnZXQudHdlZW5qc19jb3VudCAhPSBudWxsICYmICEhdGFyZ2V0LnR3ZWVuanNfY291bnQ7IH1cblx0XHRyZXR1cm4gVHdlZW4uX3R3ZWVucyAmJiAhIVR3ZWVuLl90d2VlbnMubGVuZ3RoO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnN0YWxscyBhIHBsdWdpbiwgd2hpY2ggY2FuIG1vZGlmeSBob3cgY2VydGFpbiBwcm9wZXJ0aWVzIGFyZSBoYW5kbGVkIHdoZW4gdHdlZW5lZC4gU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJDU1NQbHVnaW5cIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGFuIGV4YW1wbGUgb2YgaG93IHRvIHdyaXRlIFR3ZWVuSlMgcGx1Z2lucy5cblx0ICogQG1ldGhvZCBpbnN0YWxsUGx1Z2luXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtPYmplY3R9IHBsdWdpbiBUaGUgcGx1Z2luIGNsYXNzIHRvIGluc3RhbGxcblx0ICogQHBhcmFtIHtBcnJheX0gcHJvcGVydGllcyBBbiBhcnJheSBvZiBwcm9wZXJ0aWVzIHRoYXQgdGhlIHBsdWdpbiB3aWxsIGhhbmRsZS5cblx0ICovXG5cdFR3ZWVuLmluc3RhbGxQbHVnaW4gPSBmdW5jdGlvbihwbHVnaW4sIHByb3BlcnRpZXMpIHtcblx0XHR2YXIgcHJpb3JpdHkgPSBwbHVnaW4ucHJpb3JpdHk7XG5cdFx0aWYgKHByaW9yaXR5ID09IG51bGwpIHsgcGx1Z2luLnByaW9yaXR5ID0gcHJpb3JpdHkgPSAwOyB9XG5cdFx0Zm9yICh2YXIgaT0wLGw9cHJvcGVydGllcy5sZW5ndGgscD1Ud2Vlbi5fcGx1Z2lucztpPGw7aSsrKSB7XG5cdFx0XHR2YXIgbiA9IHByb3BlcnRpZXNbaV07XG5cdFx0XHRpZiAoIXBbbl0pIHsgcFtuXSA9IFtwbHVnaW5dOyB9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dmFyIGFyciA9IHBbbl07XG5cdFx0XHRcdGZvciAodmFyIGo9MCxqbD1hcnIubGVuZ3RoO2o8amw7aisrKSB7XG5cdFx0XHRcdFx0aWYgKHByaW9yaXR5IDwgYXJyW2pdLnByaW9yaXR5KSB7IGJyZWFrOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0cFtuXS5zcGxpY2UoaiwwLHBsdWdpbik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgb3IgdW5yZWdpc3RlcnMgYSB0d2VlbiB3aXRoIHRoZSB0aWNraW5nIHN5c3RlbS5cblx0ICogQG1ldGhvZCBfcmVnaXN0ZXJcblx0ICogQHBhcmFtIHtUd2Vlbn0gdHdlZW4gVGhlIHR3ZWVuIGluc3RhbmNlIHRvIHJlZ2lzdGVyIG9yIHVucmVnaXN0ZXIuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgSWYgYHRydWVgLCB0aGUgdHdlZW4gaXMgcmVnaXN0ZXJlZC4gSWYgYGZhbHNlYCB0aGUgdHdlZW4gaXMgdW5yZWdpc3RlcmVkLlxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdFR3ZWVuLl9yZWdpc3RlciA9IGZ1bmN0aW9uKHR3ZWVuLCB2YWx1ZSkge1xuXHRcdHZhciB0YXJnZXQgPSB0d2Vlbi5fdGFyZ2V0O1xuXHRcdHZhciB0d2VlbnMgPSBUd2Vlbi5fdHdlZW5zO1xuXHRcdGlmICh2YWx1ZSAmJiAhdHdlZW4uX3JlZ2lzdGVyZWQpIHtcblx0XHRcdC8vIFRPRE86IHRoaXMgYXBwcm9hY2ggbWlnaHQgZmFpbCBpZiBhIGRldiBpcyB1c2luZyBzZWFsZWQgb2JqZWN0cyBpbiBFUzVcblx0XHRcdGlmICh0YXJnZXQpIHsgdGFyZ2V0LnR3ZWVuanNfY291bnQgPSB0YXJnZXQudHdlZW5qc19jb3VudCA/IHRhcmdldC50d2VlbmpzX2NvdW50KzEgOiAxOyB9XG5cdFx0XHR0d2VlbnMucHVzaCh0d2Vlbik7XG5cdFx0XHRpZiAoIVR3ZWVuLl9pbml0ZWQgJiYgY3JlYXRlanMuVGlja2VyKSB7IGNyZWF0ZWpzLlRpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBUd2Vlbik7IFR3ZWVuLl9pbml0ZWQgPSB0cnVlOyB9XG5cdFx0fSBlbHNlIGlmICghdmFsdWUgJiYgdHdlZW4uX3JlZ2lzdGVyZWQpIHtcblx0XHRcdGlmICh0YXJnZXQpIHsgdGFyZ2V0LnR3ZWVuanNfY291bnQtLTsgfVxuXHRcdFx0dmFyIGkgPSB0d2VlbnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRpZiAodHdlZW5zW2ldID09IHR3ZWVuKSB7XG5cdFx0XHRcdFx0dHdlZW5zLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0d2Vlbi5fcmVnaXN0ZXJlZCA9IHZhbHVlO1xuXHR9O1xuXG5cbi8vIGV2ZW50czpcblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuZXZlciB0aGUgdHdlZW4ncyBwb3NpdGlvbiBjaGFuZ2VzLlxuXHQgKiBAZXZlbnQgY2hhbmdlXG5cdCAqIEBzaW5jZSAwLjQuMFxuXHQgKiovXG5cdFxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFF1ZXVlcyBhIHdhaXQgKGVzc2VudGlhbGx5IGFuIGVtcHR5IHR3ZWVuKS5cblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKlx0XHQvL1RoaXMgdHdlZW4gd2lsbCB3YWl0IDFzIGJlZm9yZSBhbHBoYSBpcyBmYWRlZCB0byAwLlxuXHQgKlx0XHRjcmVhdGVqcy5Ud2Vlbi5nZXQodGFyZ2V0KS53YWl0KDEwMDApLnRvKHthbHBoYTowfSwgMTAwMCk7XG5cdCAqXG5cdCAqIEBtZXRob2Qgd2FpdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gVGhlIGR1cmF0aW9uIG9mIHRoZSB3YWl0IGluIG1pbGxpc2Vjb25kcyAob3IgaW4gdGlja3MgaWYgYHVzZVRpY2tzYCBpcyB0cnVlKS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcGFzc2l2ZV0gVHdlZW4gcHJvcGVydGllcyB3aWxsIG5vdCBiZSB1cGRhdGVkIGR1cmluZyBhIHBhc3NpdmUgd2FpdC4gVGhpc1xuXHQgKiBpcyBtb3N0bHkgdXNlZnVsIGZvciB1c2Ugd2l0aCB7eyNjcm9zc0xpbmsgXCJUaW1lbGluZVwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZXMgdGhhdCBjb250YWluIG11bHRpcGxlIHR3ZWVuc1xuXHQgKiBhZmZlY3RpbmcgdGhlIHNhbWUgdGFyZ2V0IGF0IGRpZmZlcmVudCB0aW1lcy5cblx0ICogQHJldHVybiB7VHdlZW59IFRoaXMgdHdlZW4gaW5zdGFuY2UgKGZvciBjaGFpbmluZyBjYWxscykuXG5cdCAqKi9cblx0cC53YWl0ID0gZnVuY3Rpb24oZHVyYXRpb24sIHBhc3NpdmUpIHtcblx0XHRpZiAoZHVyYXRpb24gPT0gbnVsbCB8fCBkdXJhdGlvbiA8PSAwKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dmFyIG8gPSB0aGlzLl9jbG9uZVByb3BzKHRoaXMuX2N1clF1ZXVlUHJvcHMpO1xuXHRcdHJldHVybiB0aGlzLl9hZGRTdGVwKHtkOmR1cmF0aW9uLCBwMDpvLCBlOnRoaXMuX2xpbmVhckVhc2UsIHAxOm8sIHY6cGFzc2l2ZX0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBRdWV1ZXMgYSB0d2VlbiBmcm9tIHRoZSBjdXJyZW50IHZhbHVlcyB0byB0aGUgdGFyZ2V0IHByb3BlcnRpZXMuIFNldCBkdXJhdGlvbiB0byAwIHRvIGp1bXAgdG8gdGhlc2UgdmFsdWUuXG5cdCAqIE51bWVyaWMgcHJvcGVydGllcyB3aWxsIGJlIHR3ZWVuZWQgZnJvbSB0aGVpciBjdXJyZW50IHZhbHVlIGluIHRoZSB0d2VlbiB0byB0aGUgdGFyZ2V0IHZhbHVlLiBOb24tbnVtZXJpY1xuXHQgKiBwcm9wZXJ0aWVzIHdpbGwgYmUgc2V0IGF0IHRoZSBlbmQgb2YgdGhlIHNwZWNpZmllZCBkdXJhdGlvbi5cblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKlx0XHRjcmVhdGVqcy5Ud2Vlbi5nZXQodGFyZ2V0KS50byh7YWxwaGE6MH0sIDEwMDApO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHRvXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBBbiBvYmplY3Qgc3BlY2lmeWluZyBwcm9wZXJ0eSB0YXJnZXQgdmFsdWVzIGZvciB0aGlzIHR3ZWVuIChFeC4gYHt4OjMwMH1gIHdvdWxkIHR3ZWVuIHRoZSB4XG5cdCAqIHByb3BlcnR5IG9mIHRoZSB0YXJnZXQgdG8gMzAwKS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtkdXJhdGlvbj0wXSBUaGUgZHVyYXRpb24gb2YgdGhlIHdhaXQgaW4gbWlsbGlzZWNvbmRzIChvciBpbiB0aWNrcyBpZiBgdXNlVGlja3NgIGlzIHRydWUpLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZWFzZT1cImxpbmVhclwiXSBUaGUgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSBmb3IgdGhpcyB0d2Vlbi4gU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJFYXNlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGNsYXNzIGZvciBhIGxpc3Qgb2YgYnVpbHQtaW4gZWFzZSBmdW5jdGlvbnMuXG5cdCAqIEByZXR1cm4ge1R3ZWVufSBUaGlzIHR3ZWVuIGluc3RhbmNlIChmb3IgY2hhaW5pbmcgY2FsbHMpLlxuXHQgKi9cblx0cC50byA9IGZ1bmN0aW9uKHByb3BzLCBkdXJhdGlvbiwgZWFzZSkge1xuXHRcdGlmIChpc05hTihkdXJhdGlvbikgfHwgZHVyYXRpb24gPCAwKSB7IGR1cmF0aW9uID0gMDsgfVxuXHRcdHJldHVybiB0aGlzLl9hZGRTdGVwKHtkOmR1cmF0aW9ufHwwLCBwMDp0aGlzLl9jbG9uZVByb3BzKHRoaXMuX2N1clF1ZXVlUHJvcHMpLCBlOmVhc2UsIHAxOnRoaXMuX2Nsb25lUHJvcHModGhpcy5fYXBwZW5kUXVldWVQcm9wcyhwcm9wcykpfSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFF1ZXVlcyBhbiBhY3Rpb24gdG8gY2FsbCB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgXHQvL3dvdWxkIGNhbGwgbXlGdW5jdGlvbigpIGFmdGVyIDEgc2Vjb25kLlxuXHQgKiAgIFx0bXlUd2Vlbi53YWl0KDEwMDApLmNhbGwobXlGdW5jdGlvbik7XG5cdCAqXG5cdCAqIEBtZXRob2QgY2FsbFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cblx0ICogQHBhcmFtIHtBcnJheX0gW3BhcmFtc10uIFRoZSBwYXJhbWV0ZXJzIHRvIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGguIElmIHRoaXMgaXMgb21pdHRlZCwgdGhlbiB0aGUgZnVuY3Rpb25cblx0ICogICAgICB3aWxsIGJlIGNhbGxlZCB3aXRoIGEgc2luZ2xlIHBhcmFtIHBvaW50aW5nIHRvIHRoaXMgdHdlZW4uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdLiBUaGUgc2NvcGUgdG8gY2FsbCB0aGUgZnVuY3Rpb24gaW4uIElmIG9taXR0ZWQsIGl0IHdpbGwgYmUgY2FsbGVkIGluIHRoZSB0YXJnZXQnc1xuXHQgKiAgICAgIHNjb3BlLlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhpcyB0d2VlbiBpbnN0YW5jZSAoZm9yIGNoYWluaW5nIGNhbGxzKS5cblx0ICovXG5cdHAuY2FsbCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZEFjdGlvbih7ZjpjYWxsYmFjaywgcDpwYXJhbXMgPyBwYXJhbXMgOiBbdGhpc10sIG86c2NvcGUgPyBzY29wZSA6IHRoaXMuX3RhcmdldH0pO1xuXHR9O1xuXG5cdC8vIFRPRE86IGFkZCBjbGFyaWZpY2F0aW9uIGJldHdlZW4gdGhpcyBhbmQgYSAwIGR1cmF0aW9uIC50bzpcblx0LyoqXG5cdCAqIFF1ZXVlcyBhbiBhY3Rpb24gdG8gc2V0IHRoZSBzcGVjaWZpZWQgcHJvcHMgb24gdGhlIHNwZWNpZmllZCB0YXJnZXQuIElmIHRhcmdldCBpcyBudWxsLCBpdCB3aWxsIHVzZSB0aGlzIHR3ZWVuJ3Ncblx0ICogdGFyZ2V0LlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqXHRcdG15VHdlZW4ud2FpdCgxMDAwKS5zZXQoe3Zpc2libGU6ZmFsc2V9LGZvbyk7XG5cdCAqXG5cdCAqIEBtZXRob2Qgc2V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBUaGUgcHJvcGVydGllcyB0byBzZXQgKGV4LiBge3Zpc2libGU6ZmFsc2V9YCkuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbdGFyZ2V0XSBUaGUgdGFyZ2V0IHRvIHNldCB0aGUgcHJvcGVydGllcyBvbi4gSWYgb21pdHRlZCwgdGhleSB3aWxsIGJlIHNldCBvbiB0aGUgdHdlZW4ncyB0YXJnZXQuXG5cdCAqIEByZXR1cm4ge1R3ZWVufSBUaGlzIHR3ZWVuIGluc3RhbmNlIChmb3IgY2hhaW5pbmcgY2FsbHMpLlxuXHQgKi9cblx0cC5zZXQgPSBmdW5jdGlvbihwcm9wcywgdGFyZ2V0KSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZEFjdGlvbih7Zjp0aGlzLl9zZXQsIG86dGhpcywgcDpbcHJvcHMsIHRhcmdldCA/IHRhcmdldCA6IHRoaXMuX3RhcmdldF19KTtcblx0fTtcblxuXHQvKipcblx0ICogUXVldWVzIGFuIGFjdGlvbiB0byBwbGF5ICh1bnBhdXNlKSB0aGUgc3BlY2lmaWVkIHR3ZWVuLiBUaGlzIGVuYWJsZXMgeW91IHRvIHNlcXVlbmNlIG11bHRpcGxlIHR3ZWVucy5cblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKlx0XHRteVR3ZWVuLnRvKHt4OjEwMH0sNTAwKS5wbGF5KG90aGVyVHdlZW4pO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHBsYXlcblx0ICogQHBhcmFtIHtUd2Vlbn0gdHdlZW4gVGhlIHR3ZWVuIHRvIHBsYXkuXG5cdCAqIEByZXR1cm4ge1R3ZWVufSBUaGlzIHR3ZWVuIGluc3RhbmNlIChmb3IgY2hhaW5pbmcgY2FsbHMpLlxuXHQgKi9cblx0cC5wbGF5ID0gZnVuY3Rpb24odHdlZW4pIHtcblx0XHRpZiAoIXR3ZWVuKSB7IHR3ZWVuID0gdGhpczsgfVxuXHRcdHJldHVybiB0aGlzLmNhbGwodHdlZW4uc2V0UGF1c2VkLCBbZmFsc2VdLCB0d2Vlbik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFF1ZXVlcyBhbiBhY3Rpb24gdG8gcGF1c2UgdGhlIHNwZWNpZmllZCB0d2Vlbi5cblx0ICogQG1ldGhvZCBwYXVzZVxuXHQgKiBAcGFyYW0ge1R3ZWVufSB0d2VlbiBUaGUgdHdlZW4gdG8gcGF1c2UuIElmIG51bGwsIGl0IHBhdXNlcyB0aGlzIHR3ZWVuLlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhpcyB0d2VlbiBpbnN0YW5jZSAoZm9yIGNoYWluaW5nIGNhbGxzKVxuXHQgKi9cblx0cC5wYXVzZSA9IGZ1bmN0aW9uKHR3ZWVuKSB7XG5cdFx0aWYgKCF0d2VlbikgeyB0d2VlbiA9IHRoaXM7IH1cblx0XHRyZXR1cm4gdGhpcy5jYWxsKHR3ZWVuLnNldFBhdXNlZCwgW3RydWVdLCB0d2Vlbik7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoZSB0d2VlbiB0byBhIHNwZWNpZmllZCBwb3NpdGlvbi5cblx0ICogQG1ldGhvZCBzZXRQb3NpdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVGhlIHBvc2l0aW9uIHRvIHNlZWsgdG8gaW4gbWlsbGlzZWNvbmRzIChvciB0aWNrcyBpZiB1c2VUaWNrcyBpcyB0cnVlKS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthY3Rpb25zTW9kZT0xXSBTcGVjaWZpZXMgaG93IGFjdGlvbnMgYXJlIGhhbmRsZWQgKGllLiBjYWxsLCBzZXQsIHBsYXksIHBhdXNlKTpcblx0ICogPHVsPlxuXHQgKiAgICAgIDxsaT57eyNjcm9zc0xpbmsgXCJUd2Vlbi9OT05FOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319ICgwKSAtIHJ1biBubyBhY3Rpb25zLjwvbGk+XG5cdCAqICAgICAgPGxpPnt7I2Nyb3NzTGluayBcIlR3ZWVuL0xPT1A6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gKDEpIC0gaWYgbmV3IHBvc2l0aW9uIGlzIGxlc3MgdGhhbiBvbGQsIHRoZW4gcnVuIGFsbFxuXHQgKiAgICAgIGFjdGlvbnMgYmV0d2VlbiBvbGQgYW5kIGR1cmF0aW9uLCB0aGVuIGFsbCBhY3Rpb25zIGJldHdlZW4gMCBhbmQgbmV3LjwvbGk+XG5cdCAqICAgICAgPGxpPnt7I2Nyb3NzTGluayBcIlR3ZWVuL1JFVkVSU0U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gKDIpIC0gaWYgbmV3IHBvc2l0aW9uIGlzIGxlc3MgdGhhbiBvbGQsIHJ1biBhbGxcblx0ICogICAgICBhY3Rpb25zIGJldHdlZW4gdGhlbSBpbiByZXZlcnNlLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB0d2VlbiBpcyBjb21wbGV0ZSAoaWUuIHRoZSBmdWxsIHR3ZWVuIGhhcyBydW4gJiB7eyNjcm9zc0xpbmsgXCJUd2Vlbi9sb29wOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGlzIGBmYWxzZWApLlxuXHQgKi9cblx0cC5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHZhbHVlLCBhY3Rpb25zTW9kZSkge1xuXHRcdGlmICh2YWx1ZSA8IDApIHsgdmFsdWUgPSAwOyB9XG5cdFx0aWYgKGFjdGlvbnNNb2RlID09IG51bGwpIHsgYWN0aW9uc01vZGUgPSAxOyB9XG5cblx0XHQvLyBub3JtYWxpemUgcG9zaXRpb246XG5cdFx0dmFyIHQgPSB2YWx1ZTtcblx0XHR2YXIgZW5kID0gZmFsc2U7XG5cdFx0aWYgKHQgPj0gdGhpcy5kdXJhdGlvbikge1xuXHRcdFx0aWYgKHRoaXMubG9vcCkgeyB0ID0gdCV0aGlzLmR1cmF0aW9uOyB9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dCA9IHRoaXMuZHVyYXRpb247XG5cdFx0XHRcdGVuZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh0ID09IHRoaXMuX3ByZXZQb3MpIHsgcmV0dXJuIGVuZDsgfVxuXG5cblx0XHR2YXIgcHJldlBvcyA9IHRoaXMuX3ByZXZQb3M7XG5cdFx0dGhpcy5wb3NpdGlvbiA9IHRoaXMuX3ByZXZQb3MgPSB0OyAvLyBzZXQgdGhpcyBpbiBhZHZhbmNlIGluIGNhc2UgYW4gYWN0aW9uIG1vZGlmaWVzIHBvc2l0aW9uLlxuXHRcdHRoaXMuX3ByZXZQb3NpdGlvbiA9IHZhbHVlO1xuXG5cdFx0Ly8gaGFuZGxlIHR3ZWVuczpcblx0XHRpZiAodGhpcy5fdGFyZ2V0KSB7XG5cdFx0XHRpZiAoZW5kKSB7XG5cdFx0XHRcdC8vIGFkZHJlc3NlcyBwcm9ibGVtcyB3aXRoIGFuIGVuZGluZyB6ZXJvIGxlbmd0aCBzdGVwLlxuXHRcdFx0XHR0aGlzLl91cGRhdGVUYXJnZXRQcm9wcyhudWxsLDEpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9zdGVwcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdC8vIGZpbmQgb3VyIG5ldyB0d2VlbiBpbmRleDpcblx0XHRcdFx0Zm9yICh2YXIgaT0wLCBsPXRoaXMuX3N0ZXBzLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fc3RlcHNbaV0udCA+IHQpIHsgYnJlYWs7IH1cblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgc3RlcCA9IHRoaXMuX3N0ZXBzW2ktMV07XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVRhcmdldFByb3BzKHN0ZXAsKHRoaXMuX3N0ZXBQb3NpdGlvbiA9IHQtc3RlcC50KS9zdGVwLmQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHJ1biBhY3Rpb25zOlxuXHRcdGlmIChhY3Rpb25zTW9kZSAhPSAwICYmIHRoaXMuX2FjdGlvbnMubGVuZ3RoID4gMCkge1xuXHRcdFx0aWYgKHRoaXMuX3VzZVRpY2tzKSB7XG5cdFx0XHRcdC8vIG9ubHkgcnVuIHRoZSBhY3Rpb25zIHdlIGxhbmRlZCBvbi5cblx0XHRcdFx0dGhpcy5fcnVuQWN0aW9ucyh0LHQpO1xuXHRcdFx0fSBlbHNlIGlmIChhY3Rpb25zTW9kZSA9PSAxICYmIHQ8cHJldlBvcykge1xuXHRcdFx0XHRpZiAocHJldlBvcyAhPSB0aGlzLmR1cmF0aW9uKSB7IHRoaXMuX3J1bkFjdGlvbnMocHJldlBvcywgdGhpcy5kdXJhdGlvbik7IH1cblx0XHRcdFx0dGhpcy5fcnVuQWN0aW9ucygwLCB0LCB0cnVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3J1bkFjdGlvbnMocHJldlBvcywgdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGVuZCkgeyB0aGlzLnNldFBhdXNlZCh0cnVlKTsgfVxuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcImNoYW5nZVwiKTtcblx0XHRyZXR1cm4gZW5kO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZHZhbmNlcyB0aGlzIHR3ZWVuIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50IG9mIHRpbWUgaW4gbWlsbGlzZWNvbmRzIChvciB0aWNrcyBpZmB1c2VUaWNrc2AgaXMgYHRydWVgKS5cblx0ICogVGhpcyBpcyBub3JtYWxseSBjYWxsZWQgYXV0b21hdGljYWxseSBieSB0aGUgVHdlZW4gZW5naW5lICh2aWEge3sjY3Jvc3NMaW5rIFwiVHdlZW4vdGlja1wifX17ey9jcm9zc0xpbmt9fSksIGJ1dCBpc1xuXHQgKiBleHBvc2VkIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIHRpY2tcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhIFRoZSB0aW1lIHRvIGFkdmFuY2UgaW4gbWlsbGlzZWNvbmRzIChvciB0aWNrcyBpZiBgdXNlVGlja3NgIGlzIGB0cnVlYCkuXG5cdCAqL1xuXHRwLnRpY2sgPSBmdW5jdGlvbihkZWx0YSkge1xuXHRcdGlmICh0aGlzLl9wYXVzZWQpIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5zZXRQb3NpdGlvbih0aGlzLl9wcmV2UG9zaXRpb24rZGVsdGEpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXVzZXMgb3IgcGxheXMgdGhpcyB0d2Vlbi5cblx0ICogQG1ldGhvZCBzZXRQYXVzZWRcblx0ICogQHBhcmFtIHtCb29sZWFufSBbdmFsdWU9dHJ1ZV0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHR3ZWVuIHNob3VsZCBiZSBwYXVzZWQgKGB0cnVlYCkgb3IgcGxheWVkIChgZmFsc2VgKS5cblx0ICogQHJldHVybiB7VHdlZW59IFRoaXMgdHdlZW4gaW5zdGFuY2UgKGZvciBjaGFpbmluZyBjYWxscylcblx0ICovXG5cdHAuc2V0UGF1c2VkID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAodGhpcy5fcGF1c2VkID09PSAhIXZhbHVlKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fcGF1c2VkID0gISF2YWx1ZTtcblx0XHRUd2Vlbi5fcmVnaXN0ZXIodGhpcywgIXZhbHVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvLyB0aW55IGFwaSAocHJpbWFyaWx5IGZvciB0b29sIG91dHB1dCk6XG5cdHAudyA9IHAud2FpdDtcblx0cC50ID0gcC50bztcblx0cC5jID0gcC5jYWxsO1xuXHRwLnMgPSBwLnNldDtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbVHdlZW5dXCI7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRocm93KFwiVHdlZW4gY2FuIG5vdCBiZSBjbG9uZWQuXCIpXG5cdH07XG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX3VwZGF0ZVRhcmdldFByb3BzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdGVwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYXRpb1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl91cGRhdGVUYXJnZXRQcm9wcyA9IGZ1bmN0aW9uKHN0ZXAsIHJhdGlvKSB7XG5cdFx0dmFyIHAwLHAxLHYsdjAsdjEsYXJyO1xuXHRcdGlmICghc3RlcCAmJiByYXRpbyA9PSAxKSB7XG5cdFx0XHQvLyBHRFM6IHdoZW4gZG9lcyB0aGlzIHJ1bj8gSnVzdCBhdCB0aGUgdmVyeSBlbmQ/IFNob3VsZG4ndC5cblx0XHRcdHRoaXMucGFzc2l2ZSA9IGZhbHNlO1xuXHRcdFx0cDAgPSBwMSA9IHRoaXMuX2N1clF1ZXVlUHJvcHM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucGFzc2l2ZSA9ICEhc3RlcC52O1xuXHRcdFx0aWYgKHRoaXMucGFzc2l2ZSkgeyByZXR1cm47IH0gLy8gZG9uJ3QgdXBkYXRlIHByb3BzLlxuXHRcdFx0Ly8gYXBwbHkgZWFzZSB0byByYXRpby5cblx0XHRcdGlmIChzdGVwLmUpIHsgcmF0aW8gPSBzdGVwLmUocmF0aW8sMCwxLDEpOyB9XG5cdFx0XHRwMCA9IHN0ZXAucDA7XG5cdFx0XHRwMSA9IHN0ZXAucDE7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgbiBpbiB0aGlzLl9pbml0UXVldWVQcm9wcykge1xuXHRcdFx0aWYgKCh2MCA9IHAwW25dKSA9PSBudWxsKSB7IHAwW25dID0gdjAgPSB0aGlzLl9pbml0UXVldWVQcm9wc1tuXTsgfVxuXHRcdFx0aWYgKCh2MSA9IHAxW25dKSA9PSBudWxsKSB7IHAxW25dID0gdjEgPSB2MDsgfVxuXHRcdFx0aWYgKHYwID09IHYxIHx8IHJhdGlvID09IDAgfHwgcmF0aW8gPT0gMSB8fCAodHlwZW9mKHYwKSAhPSBcIm51bWJlclwiKSkge1xuXHRcdFx0XHQvLyBubyBpbnRlcnBvbGF0aW9uIC0gZWl0aGVyIGF0IHN0YXJ0LCBlbmQsIHZhbHVlcyBkb24ndCBjaGFuZ2UsIG9yIHRoZSB2YWx1ZSBpcyBub24tbnVtZXJpYy5cblx0XHRcdFx0diA9IHJhdGlvID09IDEgPyB2MSA6IHYwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0diA9IHYwKyh2MS12MCkqcmF0aW87XG5cdFx0XHR9XG5cblx0XHRcdHZhciBpZ25vcmUgPSBmYWxzZTtcblx0XHRcdGlmIChhcnIgPSBUd2Vlbi5fcGx1Z2luc1tuXSkge1xuXHRcdFx0XHRmb3IgKHZhciBpPTAsbD1hcnIubGVuZ3RoO2k8bDtpKyspIHtcblx0XHRcdFx0XHR2YXIgdjIgPSBhcnJbaV0udHdlZW4odGhpcywgbiwgdiwgcDAsIHAxLCByYXRpbywgISFzdGVwJiZwMD09cDEsICFzdGVwKTtcblx0XHRcdFx0XHRpZiAodjIgPT0gVHdlZW4uSUdOT1JFKSB7IGlnbm9yZSA9IHRydWU7IH1cblx0XHRcdFx0XHRlbHNlIHsgdiA9IHYyOyB9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghaWdub3JlKSB7IHRoaXMuX3RhcmdldFtuXSA9IHY7IH1cblx0XHR9XG5cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfcnVuQWN0aW9uc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRQb3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IGVuZFBvc1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGluY2x1ZGVTdGFydFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9ydW5BY3Rpb25zID0gZnVuY3Rpb24oc3RhcnRQb3MsIGVuZFBvcywgaW5jbHVkZVN0YXJ0KSB7XG5cdFx0dmFyIHNQb3MgPSBzdGFydFBvcztcblx0XHR2YXIgZVBvcyA9IGVuZFBvcztcblx0XHR2YXIgaSA9IC0xO1xuXHRcdHZhciBqID0gdGhpcy5fYWN0aW9ucy5sZW5ndGg7XG5cdFx0dmFyIGsgPSAxO1xuXHRcdGlmIChzdGFydFBvcyA+IGVuZFBvcykge1xuXHRcdFx0Ly8gcnVubmluZyBiYWNrd2FyZHMsIGZsaXAgZXZlcnl0aGluZzpcblx0XHRcdHNQb3MgPSBlbmRQb3M7XG5cdFx0XHRlUG9zID0gc3RhcnRQb3M7XG5cdFx0XHRpID0gajtcblx0XHRcdGogPSBrID0gLTE7XG5cdFx0fVxuXHRcdHdoaWxlICgoaSs9aykgIT0gaikge1xuXHRcdFx0dmFyIGFjdGlvbiA9IHRoaXMuX2FjdGlvbnNbaV07XG5cdFx0XHR2YXIgcG9zID0gYWN0aW9uLnQ7XG5cdFx0XHRpZiAocG9zID09IGVQb3MgfHwgKHBvcyA+IHNQb3MgJiYgcG9zIDwgZVBvcykgfHwgKGluY2x1ZGVTdGFydCAmJiBwb3MgPT0gc3RhcnRQb3MpICkge1xuXHRcdFx0XHRhY3Rpb24uZi5hcHBseShhY3Rpb24ubywgYWN0aW9uLnApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfYXBwZW5kUXVldWVQcm9wc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9hcHBlbmRRdWV1ZVByb3BzID0gZnVuY3Rpb24obykge1xuXHRcdHZhciBhcnIsb2xkVmFsdWUsaSwgbCwgaW5qZWN0UHJvcHM7XG5cdFx0Zm9yICh2YXIgbiBpbiBvKSB7XG5cdFx0XHRpZiAodGhpcy5faW5pdFF1ZXVlUHJvcHNbbl0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRvbGRWYWx1ZSA9IHRoaXMuX3RhcmdldFtuXTtcblxuXHRcdFx0XHQvLyBpbml0IHBsdWdpbnM6XG5cdFx0XHRcdGlmIChhcnIgPSBUd2Vlbi5fcGx1Z2luc1tuXSkge1xuXHRcdFx0XHRcdGZvciAoaT0wLGw9YXJyLmxlbmd0aDtpPGw7aSsrKSB7XG5cdFx0XHRcdFx0XHRvbGRWYWx1ZSA9IGFycltpXS5pbml0KHRoaXMsIG4sIG9sZFZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5faW5pdFF1ZXVlUHJvcHNbbl0gPSB0aGlzLl9jdXJRdWV1ZVByb3BzW25dID0gKG9sZFZhbHVlPT09dW5kZWZpbmVkKSA/IG51bGwgOiBvbGRWYWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9sZFZhbHVlID0gdGhpcy5fY3VyUXVldWVQcm9wc1tuXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBuIGluIG8pIHtcblx0XHRcdG9sZFZhbHVlID0gdGhpcy5fY3VyUXVldWVQcm9wc1tuXTtcblx0XHRcdGlmIChhcnIgPSBUd2Vlbi5fcGx1Z2luc1tuXSkge1xuXHRcdFx0XHRpbmplY3RQcm9wcyA9IGluamVjdFByb3BzfHx7fTtcblx0XHRcdFx0Zm9yIChpPTAsIGw9YXJyLmxlbmd0aDtpPGw7aSsrKSB7XG5cdFx0XHRcdFx0Ly8gVE9ETzogcmVtb3ZlIHRoZSBjaGVjayBmb3IgLnN0ZXAgaW4gdGhlIG5leHQgdmVyc2lvbi4gSXQncyBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblx0XHRcdFx0XHRpZiAoYXJyW2ldLnN0ZXApIHsgYXJyW2ldLnN0ZXAodGhpcywgbiwgb2xkVmFsdWUsIG9bbl0sIGluamVjdFByb3BzKTsgfVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jdXJRdWV1ZVByb3BzW25dID0gb1tuXTtcblx0XHR9XG5cdFx0aWYgKGluamVjdFByb3BzKSB7IHRoaXMuX2FwcGVuZFF1ZXVlUHJvcHMoaW5qZWN0UHJvcHMpOyB9XG5cdFx0cmV0dXJuIHRoaXMuX2N1clF1ZXVlUHJvcHM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2Nsb25lUHJvcHNcblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2Nsb25lUHJvcHMgPSBmdW5jdGlvbihwcm9wcykge1xuXHRcdHZhciBvID0ge307XG5cdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykge1xuXHRcdFx0b1tuXSA9IHByb3BzW25dO1xuXHRcdH1cblx0XHRyZXR1cm4gbztcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfYWRkU3RlcFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9hZGRTdGVwID0gZnVuY3Rpb24obykge1xuXHRcdGlmIChvLmQgPiAwKSB7XG5cdFx0XHR0aGlzLl9zdGVwcy5wdXNoKG8pO1xuXHRcdFx0by50ID0gdGhpcy5kdXJhdGlvbjtcblx0XHRcdHRoaXMuZHVyYXRpb24gKz0gby5kO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfYWRkQWN0aW9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2FkZEFjdGlvbiA9IGZ1bmN0aW9uKG8pIHtcblx0XHRvLnQgPSB0aGlzLmR1cmF0aW9uO1xuXHRcdHRoaXMuX2FjdGlvbnMucHVzaChvKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfc2V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9zZXQgPSBmdW5jdGlvbihwcm9wcywgbykge1xuXHRcdGZvciAodmFyIG4gaW4gcHJvcHMpIHtcblx0XHRcdG9bbl0gPSBwcm9wc1tuXTtcblx0XHR9XG5cdH07XG5cblx0Y3JlYXRlanMuVHdlZW4gPSBjcmVhdGVqcy5wcm9tb3RlKFR3ZWVuLCBcIkV2ZW50RGlzcGF0Y2hlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFRpbWVsaW5lLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRcblxuLy8gY29uc3RydWN0b3JcdFxuXHQvKipcblx0ICogVGhlIFRpbWVsaW5lIGNsYXNzIHN5bmNocm9uaXplcyBtdWx0aXBsZSB0d2VlbnMgYW5kIGFsbG93cyB0aGVtIHRvIGJlIGNvbnRyb2xsZWQgYXMgYSBncm91cC4gUGxlYXNlIG5vdGUgdGhhdCBpZiBhXG5cdCAqIHRpbWVsaW5lIGlzIGxvb3BpbmcsIHRoZSB0d2VlbnMgb24gaXQgbWF5IGFwcGVhciB0byBsb29wIGV2ZW4gaWYgdGhlIFwibG9vcFwiIHByb3BlcnR5IG9mIHRoZSB0d2VlbiBpcyBmYWxzZS5cblx0ICogQGNsYXNzIFRpbWVsaW5lXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHR3ZWVucyBBbiBhcnJheSBvZiBUd2VlbnMgdG8gYWRkIHRvIHRoaXMgdGltZWxpbmUuIFNlZSB7eyNjcm9zc0xpbmsgXCJUaW1lbGluZS9hZGRUd2VlblwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgbW9yZSBpbmZvLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gbGFiZWxzIEFuIG9iamVjdCBkZWZpbmluZyBsYWJlbHMgZm9yIHVzaW5nIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2dvdG9BbmRQbGF5XCJ9fXt7L2Nyb3NzTGlua319L3t7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2dvdG9BbmRTdG9wXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvc2V0TGFiZWxzXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgVGhlIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyB0byBhcHBseSB0byB0aGlzIHR3ZWVuIGluc3RhbmNlIChleC4gYHtsb29wOnRydWV9YCkuIEFsbCBwcm9wZXJ0aWVzXG5cdCAqIGRlZmF1bHQgdG8gZmFsc2UuIFN1cHBvcnRlZCBwcm9wcyBhcmU6PFVMPlxuXHQgKiAgICA8TEk+IGxvb3A6IHNldHMgdGhlIGxvb3AgcHJvcGVydHkgb24gdGhpcyB0d2Vlbi48L0xJPlxuXHQgKiAgICA8TEk+IHVzZVRpY2tzOiB1c2VzIHRpY2tzIGZvciBhbGwgZHVyYXRpb25zIGluc3RlYWQgb2YgbWlsbGlzZWNvbmRzLjwvTEk+XG5cdCAqICAgIDxMST4gaWdub3JlR2xvYmFsUGF1c2U6IHNldHMgdGhlIGlnbm9yZUdsb2JhbFBhdXNlIHByb3BlcnR5IG9uIHRoaXMgdHdlZW4uPC9MST5cblx0ICogICAgPExJPiBwYXVzZWQ6IGluZGljYXRlcyB3aGV0aGVyIHRvIHN0YXJ0IHRoZSB0d2VlbiBwYXVzZWQuPC9MST5cblx0ICogICAgPExJPiBwb3NpdGlvbjogaW5kaWNhdGVzIHRoZSBpbml0aWFsIHBvc2l0aW9uIGZvciB0aGlzIHRpbWVsaW5lLjwvTEk+XG5cdCAqICAgIDxMST4gb25DaGFuZ2U6IHNwZWNpZmllcyBhIGxpc3RlbmVyIHRvIGFkZCBmb3IgdGhlIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2NoYW5nZTpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudC48L0xJPlxuXHQgKiA8L1VMPlxuXHQgKiBAZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gVGltZWxpbmUodHdlZW5zLCBsYWJlbHMsIHByb3BzKSB7XG5cdFx0dGhpcy5FdmVudERpc3BhdGNoZXJfY29uc3RydWN0b3IoKTtcblxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBDYXVzZXMgdGhpcyB0aW1lbGluZSB0byBjb250aW51ZSBwbGF5aW5nIHdoZW4gYSBnbG9iYWwgcGF1c2UgaXMgYWN0aXZlLlxuXHRcdCAqIEBwcm9wZXJ0eSBpZ25vcmVHbG9iYWxQYXVzZVxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiovXG5cdFx0dGhpcy5pZ25vcmVHbG9iYWxQYXVzZSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRvdGFsIGR1cmF0aW9uIG9mIHRoaXMgdGltZWxpbmUgaW4gbWlsbGlzZWNvbmRzIChvciB0aWNrcyBpZiBgdXNlVGlja3MgYGlzIGB0cnVlYCkuIFRoaXMgdmFsdWUgaXMgdXN1YWxseVxuXHRcdCAqIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCBhcyB5b3UgbW9kaWZ5IHRoZSB0aW1lbGluZS4gU2VlIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lL3VwZGF0ZUR1cmF0aW9uXCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdFx0ICogQHByb3BlcnR5IGR1cmF0aW9uXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLmR1cmF0aW9uID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIElmIHRydWUsIHRoZSB0aW1lbGluZSB3aWxsIGxvb3Agd2hlbiBpdCByZWFjaGVzIHRoZSBlbmQuIENhbiBiZSBzZXQgdmlhIHRoZSBwcm9wcyBwYXJhbS5cblx0XHQgKiBAcHJvcGVydHkgbG9vcFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiovXG5cdFx0dGhpcy5sb29wID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgY3VycmVudCBub3JtYWxpemVkIHBvc2l0aW9uIG9mIHRoZSB0aW1lbGluZS4gVGhpcyB3aWxsIGFsd2F5cyBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmRcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJUaW1lbGluZS9kdXJhdGlvbjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBDaGFuZ2luZyB0aGlzIHByb3BlcnR5IGRpcmVjdGx5IHdpbGwgaGF2ZSBubyBlZmZlY3QuXG5cdFx0ICogQHByb3BlcnR5IHBvc2l0aW9uXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMucG9zaXRpb24gPSBudWxsO1xuXG5cdFx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfcGF1c2VkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiovXG5cdFx0dGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3R3ZWVuc1xuXHRcdCAqIEB0eXBlIEFycmF5W1R3ZWVuXVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiovXG5cdFx0dGhpcy5fdHdlZW5zID0gW107XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2xhYmVsc1xuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiovXG5cdFx0dGhpcy5fbGFiZWxzID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfbGFiZWxMaXN0XG5cdFx0ICogQHR5cGUgQXJyYXlbT2JqZWN0XVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiovXG5cdFx0dGhpcy5fbGFiZWxMaXN0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfcHJldlBvc2l0aW9uXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiovXG5cdFx0dGhpcy5fcHJldlBvc2l0aW9uID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfcHJldlBvc1xuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IC0xXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9wcmV2UG9zID0gLTE7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3VzZVRpY2tzXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl91c2VUaWNrcyA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0aW1lbGluZSBpcyBjdXJyZW50bHkgcmVnaXN0ZXJlZCB3aXRoIFR3ZWVuLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmVnaXN0ZXJlZFxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3JlZ2lzdGVyZWQgPSBmYWxzZTtcblxuXG5cdFx0aWYgKHByb3BzKSB7XG5cdFx0XHR0aGlzLl91c2VUaWNrcyA9IHByb3BzLnVzZVRpY2tzO1xuXHRcdFx0dGhpcy5sb29wID0gcHJvcHMubG9vcDtcblx0XHRcdHRoaXMuaWdub3JlR2xvYmFsUGF1c2UgPSBwcm9wcy5pZ25vcmVHbG9iYWxQYXVzZTtcblx0XHRcdHByb3BzLm9uQ2hhbmdlJiZ0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgcHJvcHMub25DaGFuZ2UpO1xuXHRcdH1cblx0XHRpZiAodHdlZW5zKSB7IHRoaXMuYWRkVHdlZW4uYXBwbHkodGhpcywgdHdlZW5zKTsgfVxuXHRcdHRoaXMuc2V0TGFiZWxzKGxhYmVscyk7XG5cdFx0aWYgKHByb3BzJiZwcm9wcy5wYXVzZWQpIHsgdGhpcy5fcGF1c2VkPXRydWU7IH1cblx0XHRlbHNlIHsgY3JlYXRlanMuVHdlZW4uX3JlZ2lzdGVyKHRoaXMsdHJ1ZSk7IH1cblx0XHRpZiAocHJvcHMmJnByb3BzLnBvc2l0aW9uIT1udWxsKSB7IHRoaXMuc2V0UG9zaXRpb24ocHJvcHMucG9zaXRpb24sIGNyZWF0ZWpzLlR3ZWVuLk5PTkUpOyB9XG5cdFx0XG5cdH07XG5cdFxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChUaW1lbGluZSwgY3JlYXRlanMuRXZlbnREaXNwYXRjaGVyKTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXHRcbi8vIGV2ZW50czpcblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuZXZlciB0aGUgdGltZWxpbmUncyBwb3NpdGlvbiBjaGFuZ2VzLlxuXHQgKiBAZXZlbnQgY2hhbmdlXG5cdCAqIEBzaW5jZSAwLjUuMFxuXHQgKiovXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBBZGRzIG9uZSBvciBtb3JlIHR3ZWVucyAob3IgdGltZWxpbmVzKSB0byB0aGlzIHRpbWVsaW5lLiBUaGUgdHdlZW5zIHdpbGwgYmUgcGF1c2VkICh0byByZW1vdmUgdGhlbSBmcm9tIHRoZVxuXHQgKiBub3JtYWwgdGlja2luZyBzeXN0ZW0pIGFuZCBtYW5hZ2VkIGJ5IHRoaXMgdGltZWxpbmUuIEFkZGluZyBhIHR3ZWVuIHRvIG11bHRpcGxlIHRpbWVsaW5lcyB3aWxsIHJlc3VsdCBpblxuXHQgKiB1bmV4cGVjdGVkIGJlaGF2aW91ci5cblx0ICogQG1ldGhvZCBhZGRUd2VlblxuXHQgKiBAcGFyYW0ge1R3ZWVufSAuLi50d2VlbiBUaGUgdHdlZW4ocykgdG8gYWRkLiBBY2NlcHRzIG11bHRpcGxlIGFyZ3VtZW50cy5cblx0ICogQHJldHVybiB7VHdlZW59IFRoZSBmaXJzdCB0d2VlbiB0aGF0IHdhcyBwYXNzZWQgaW4uXG5cdCAqKi9cblx0cC5hZGRUd2VlbiA9IGZ1bmN0aW9uKHR3ZWVuKSB7XG5cdFx0dmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdGlmIChsID4gMSkge1xuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykgeyB0aGlzLmFkZFR3ZWVuKGFyZ3VtZW50c1tpXSk7IH1cblx0XHRcdHJldHVybiBhcmd1bWVudHNbMF07XG5cdFx0fSBlbHNlIGlmIChsID09IDApIHsgcmV0dXJuIG51bGw7IH1cblx0XHR0aGlzLnJlbW92ZVR3ZWVuKHR3ZWVuKTtcblx0XHR0aGlzLl90d2VlbnMucHVzaCh0d2Vlbik7XG5cdFx0dHdlZW4uc2V0UGF1c2VkKHRydWUpO1xuXHRcdHR3ZWVuLl9wYXVzZWQgPSBmYWxzZTtcblx0XHR0d2Vlbi5fdXNlVGlja3MgPSB0aGlzLl91c2VUaWNrcztcblx0XHRpZiAodHdlZW4uZHVyYXRpb24gPiB0aGlzLmR1cmF0aW9uKSB7IHRoaXMuZHVyYXRpb24gPSB0d2Vlbi5kdXJhdGlvbjsgfVxuXHRcdGlmICh0aGlzLl9wcmV2UG9zID49IDApIHsgdHdlZW4uc2V0UG9zaXRpb24odGhpcy5fcHJldlBvcywgY3JlYXRlanMuVHdlZW4uTk9ORSk7IH1cblx0XHRyZXR1cm4gdHdlZW47XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgb25lIG9yIG1vcmUgdHdlZW5zIGZyb20gdGhpcyB0aW1lbGluZS5cblx0ICogQG1ldGhvZCByZW1vdmVUd2VlblxuXHQgKiBAcGFyYW0ge1R3ZWVufSAuLi50d2VlbiBUaGUgdHdlZW4ocykgdG8gcmVtb3ZlLiBBY2NlcHRzIG11bHRpcGxlIGFyZ3VtZW50cy5cblx0ICogQHJldHVybiBCb29sZWFuIFJldHVybnMgYHRydWVgIGlmIGFsbCBvZiB0aGUgdHdlZW5zIHdlcmUgc3VjY2Vzc2Z1bGx5IHJlbW92ZWQuXG5cdCAqKi9cblx0cC5yZW1vdmVUd2VlbiA9IGZ1bmN0aW9uKHR3ZWVuKSB7XG5cdFx0dmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdGlmIChsID4gMSkge1xuXHRcdFx0dmFyIGdvb2QgPSB0cnVlO1xuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykgeyBnb29kID0gZ29vZCAmJiB0aGlzLnJlbW92ZVR3ZWVuKGFyZ3VtZW50c1tpXSk7IH1cblx0XHRcdHJldHVybiBnb29kO1xuXHRcdH0gZWxzZSBpZiAobCA9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0dmFyIHR3ZWVucyA9IHRoaXMuX3R3ZWVucztcblx0XHR2YXIgaSA9IHR3ZWVucy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0aWYgKHR3ZWVuc1tpXSA9PSB0d2Vlbikge1xuXHRcdFx0XHR0d2VlbnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRpZiAodHdlZW4uZHVyYXRpb24gPj0gdGhpcy5kdXJhdGlvbikgeyB0aGlzLnVwZGF0ZUR1cmF0aW9uKCk7IH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHQvKipcblx0ICogQWRkcyBhIGxhYmVsIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCB7eyNjcm9zc0xpbmsgXCJUaW1lbGluZS9nb3RvQW5kUGxheVwifX17ey9jcm9zc0xpbmt9fS97eyNjcm9zc0xpbmsgXCJUaW1lbGluZS9nb3RvQW5kU3RvcFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBhZGRMYWJlbFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbGFiZWwgVGhlIGxhYmVsIG5hbWUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gdGhpcyBsYWJlbCByZXByZXNlbnRzLlxuXHQgKiovXG5cdHAuYWRkTGFiZWwgPSBmdW5jdGlvbihsYWJlbCwgcG9zaXRpb24pIHtcblx0XHR0aGlzLl9sYWJlbHNbbGFiZWxdID0gcG9zaXRpb247XG5cdFx0dmFyIGxpc3QgPSB0aGlzLl9sYWJlbExpc3Q7XG5cdFx0aWYgKGxpc3QpIHtcblx0XHRcdGZvciAodmFyIGk9IDAsbD1saXN0Lmxlbmd0aDsgaTxsOyBpKyspIHsgaWYgKHBvc2l0aW9uIDwgbGlzdFtpXS5wb3NpdGlvbikgeyBicmVhazsgfSB9XG5cdFx0XHRsaXN0LnNwbGljZShpLCAwLCB7bGFiZWw6bGFiZWwsIHBvc2l0aW9uOnBvc2l0aW9ufSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZWZpbmVzIGxhYmVscyBmb3IgdXNlIHdpdGggZ290b0FuZFBsYXkvU3RvcC4gT3ZlcndyaXRlcyBhbnkgcHJldmlvdXNseSBzZXQgbGFiZWxzLlxuXHQgKiBAbWV0aG9kIHNldExhYmVsc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gbyBBbiBvYmplY3QgZGVmaW5pbmcgbGFiZWxzIGZvciB1c2luZyB7eyNjcm9zc0xpbmsgXCJUaW1lbGluZS9nb3RvQW5kUGxheVwifX17ey9jcm9zc0xpbmt9fS97eyNjcm9zc0xpbmsgXCJUaW1lbGluZS9nb3RvQW5kU3RvcFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBpbiB0aGUgZm9ybSBge2xhYmVsTmFtZTp0aW1lfWAgd2hlcmUgdGltZSBpcyBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgYHRydWVgKS5cblx0ICoqL1xuXHRwLnNldExhYmVscyA9IGZ1bmN0aW9uKG8pIHtcblx0XHR0aGlzLl9sYWJlbHMgPSBvID8gIG8gOiB7fTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHNvcnRlZCBsaXN0IG9mIHRoZSBsYWJlbHMgZGVmaW5lZCBvbiB0aGlzIHRpbWVsaW5lLlxuXHQgKiBAbWV0aG9kIGdldExhYmVsc1xuXHQgKiBAcmV0dXJuIHtBcnJheVtPYmplY3RdfSBBIHNvcnRlZCBhcnJheSBvZiBvYmplY3RzIHdpdGggbGFiZWwgYW5kIHBvc2l0aW9uIHByb3BlcnRpZXMuXG5cdCAqKi9cblx0cC5nZXRMYWJlbHMgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGlzdCA9IHRoaXMuX2xhYmVsTGlzdDtcblx0XHRpZiAoIWxpc3QpIHtcblx0XHRcdGxpc3QgPSB0aGlzLl9sYWJlbExpc3QgPSBbXTtcblx0XHRcdHZhciBsYWJlbHMgPSB0aGlzLl9sYWJlbHM7XG5cdFx0XHRmb3IgKHZhciBuIGluIGxhYmVscykge1xuXHRcdFx0XHRsaXN0LnB1c2goe2xhYmVsOm4sIHBvc2l0aW9uOmxhYmVsc1tuXX0pO1xuXHRcdFx0fVxuXHRcdFx0bGlzdC5zb3J0KGZ1bmN0aW9uIChhLGIpIHsgcmV0dXJuIGEucG9zaXRpb24tIGIucG9zaXRpb247IH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gbGlzdDtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgbGFiZWwgb24gb3IgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBjdXJyZW50IHBvc2l0aW9uLiBGb3IgZXhhbXBsZSwgZ2l2ZW4gYSB0aW1lbGluZSB3aXRoXG5cdCAqIHR3byBsYWJlbHMsIFwiZmlyc3RcIiBvbiBmcmFtZSBpbmRleCA0LCBhbmQgXCJzZWNvbmRcIiBvbiBmcmFtZSA4LCBnZXRDdXJyZW50TGFiZWwgd291bGQgcmV0dXJuOlxuXHQgKiA8VUw+XG5cdCAqIFx0XHQ8TEk+bnVsbCBpZiB0aGUgY3VycmVudCBwb3NpdGlvbiBpcyAyLjwvTEk+XG5cdCAqIFx0XHQ8TEk+XCJmaXJzdFwiIGlmIHRoZSBjdXJyZW50IHBvc2l0aW9uIGlzIDQuPC9MST5cblx0ICogXHRcdDxMST5cImZpcnN0XCIgaWYgdGhlIGN1cnJlbnQgcG9zaXRpb24gaXMgNy48L0xJPlxuXHQgKiBcdFx0PExJPlwic2Vjb25kXCIgaWYgdGhlIGN1cnJlbnQgcG9zaXRpb24gaXMgMTUuPC9MST5cblx0ICogPC9VTD5cblx0ICogQG1ldGhvZCBnZXRDdXJyZW50TGFiZWxcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgY3VycmVudCBsYWJlbCBvciBudWxsIGlmIHRoZXJlIGlzIG5vIGxhYmVsXG5cdCAqKi9cblx0cC5nZXRDdXJyZW50TGFiZWwgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcblx0XHR2YXIgcG9zID0gdGhpcy5wb3NpdGlvbjtcblx0XHR2YXIgbCA9IGxhYmVscy5sZW5ndGg7XG5cdFx0aWYgKGwpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpPGw7IGkrKykgeyBpZiAocG9zIDwgbGFiZWxzW2ldLnBvc2l0aW9uKSB7IGJyZWFrOyB9IH1cblx0XHRcdHJldHVybiAoaT09MCkgPyBudWxsIDogbGFiZWxzW2ktMV0ubGFiZWw7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVbnBhdXNlcyB0aGlzIHRpbWVsaW5lIGFuZCBqdW1wcyB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIG9yIGxhYmVsLlxuXHQgKiBAbWV0aG9kIGdvdG9BbmRQbGF5XG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gcG9zaXRpb25PckxhYmVsIFRoZSBwb3NpdGlvbiBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgYHRydWVgKVxuXHQgKiBvciBsYWJlbCB0byBqdW1wIHRvLlxuXHQgKiovXG5cdHAuZ290b0FuZFBsYXkgPSBmdW5jdGlvbihwb3NpdGlvbk9yTGFiZWwpIHtcblx0XHR0aGlzLnNldFBhdXNlZChmYWxzZSk7XG5cdFx0dGhpcy5fZ290byhwb3NpdGlvbk9yTGFiZWwpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXVzZXMgdGhpcyB0aW1lbGluZSBhbmQganVtcHMgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbiBvciBsYWJlbC5cblx0ICogQG1ldGhvZCBnb3RvQW5kU3RvcFxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHBvc2l0aW9uT3JMYWJlbCBUaGUgcG9zaXRpb24gaW4gbWlsbGlzZWNvbmRzIChvciB0aWNrcyBpZiBgdXNlVGlja3NgIGlzIGB0cnVlYCkgb3IgbGFiZWxcblx0ICogdG8ganVtcCB0by5cblx0ICoqL1xuXHRwLmdvdG9BbmRTdG9wID0gZnVuY3Rpb24ocG9zaXRpb25PckxhYmVsKSB7XG5cdFx0dGhpcy5zZXRQYXVzZWQodHJ1ZSk7XG5cdFx0dGhpcy5fZ290byhwb3NpdGlvbk9yTGFiZWwpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZHZhbmNlcyB0aGUgdGltZWxpbmUgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbi5cblx0ICogQG1ldGhvZCBzZXRQb3NpdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVGhlIHBvc2l0aW9uIHRvIHNlZWsgdG8gaW4gbWlsbGlzZWNvbmRzIChvciB0aWNrcyBpZiBgdXNlVGlja3NgIGlzIGB0cnVlYCkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYWN0aW9uc01vZGVdIHBhcmFtZXRlciBzcGVjaWZ5aW5nIGhvdyBhY3Rpb25zIGFyZSBoYW5kbGVkLiBTZWUgdGhlIFR3ZWVuIHt7I2Nyb3NzTGluayBcIlR3ZWVuL3NldFBvc2l0aW9uXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZCBmb3IgbW9yZSBkZXRhaWxzLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdGltZWxpbmUgaXMgY29tcGxldGUgKGllLiB0aGUgZnVsbCB0aW1lbGluZSBoYXMgcnVuICYge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvbG9vcDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBpcyBgZmFsc2VgKS5cblx0ICoqL1xuXHRwLnNldFBvc2l0aW9uID0gZnVuY3Rpb24odmFsdWUsIGFjdGlvbnNNb2RlKSB7XG5cdFx0dmFyIHQgPSB0aGlzLl9jYWxjUG9zaXRpb24odmFsdWUpO1xuXHRcdHZhciBlbmQgPSAhdGhpcy5sb29wICYmIHZhbHVlID49IHRoaXMuZHVyYXRpb247XG5cdFx0aWYgKHQgPT0gdGhpcy5fcHJldlBvcykgeyByZXR1cm4gZW5kOyB9XG5cdFx0dGhpcy5fcHJldlBvc2l0aW9uID0gdmFsdWU7XG5cdFx0dGhpcy5wb3NpdGlvbiA9IHRoaXMuX3ByZXZQb3MgPSB0OyAvLyBpbiBjYXNlIGFuIGFjdGlvbiBjaGFuZ2VzIHRoZSBjdXJyZW50IGZyYW1lLlxuXHRcdGZvciAodmFyIGk9MCwgbD10aGlzLl90d2VlbnMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0dGhpcy5fdHdlZW5zW2ldLnNldFBvc2l0aW9uKHQsIGFjdGlvbnNNb2RlKTtcblx0XHRcdGlmICh0ICE9IHRoaXMuX3ByZXZQb3MpIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGFuIGFjdGlvbiBjaGFuZ2VkIHRoaXMgdGltZWxpbmUncyBwb3NpdGlvbi5cblx0XHR9XG5cdFx0aWYgKGVuZCkgeyB0aGlzLnNldFBhdXNlZCh0cnVlKTsgfVxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcImNoYW5nZVwiKTtcblx0XHRyZXR1cm4gZW5kO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXVzZXMgb3IgcGxheXMgdGhpcyB0aW1lbGluZS5cblx0ICogQG1ldGhvZCBzZXRQYXVzZWRcblx0ICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdHdlZW4gc2hvdWxkIGJlIHBhdXNlZCAoYHRydWVgKSBvciBwbGF5ZWQgKGBmYWxzZWApLlxuXHQgKiovXG5cdHAuc2V0UGF1c2VkID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzLl9wYXVzZWQgPSAhIXZhbHVlOyBcblx0XHRjcmVhdGVqcy5Ud2Vlbi5fcmVnaXN0ZXIodGhpcywgIXZhbHVlKTtcblx0fTtcblxuXHQvKipcblx0ICogUmVjYWxjdWxhdGVzIHRoZSBkdXJhdGlvbiBvZiB0aGUgdGltZWxpbmUuIFRoZSBkdXJhdGlvbiBpcyBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgd2hlbiB0d2VlbnMgYXJlIGFkZGVkIG9yIHJlbW92ZWQsXG5cdCAqIGJ1dCB0aGlzIG1ldGhvZCBpcyB1c2VmdWwgaWYgeW91IG1vZGlmeSBhIHR3ZWVuIGFmdGVyIGl0IHdhcyBhZGRlZCB0byB0aGUgdGltZWxpbmUuXG5cdCAqIEBtZXRob2QgdXBkYXRlRHVyYXRpb25cblx0ICoqL1xuXHRwLnVwZGF0ZUR1cmF0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5kdXJhdGlvbiA9IDA7XG5cdFx0Zm9yICh2YXIgaT0wLGw9dGhpcy5fdHdlZW5zLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX3R3ZWVuc1tpXTtcblx0XHRcdGlmICh0d2Vlbi5kdXJhdGlvbiA+IHRoaXMuZHVyYXRpb24pIHsgdGhpcy5kdXJhdGlvbiA9IHR3ZWVuLmR1cmF0aW9uOyB9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZHZhbmNlcyB0aGlzIHRpbWVsaW5lIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50IG9mIHRpbWUgaW4gbWlsbGlzZWNvbmRzIChvciB0aWNrcyBpZiBgdXNlVGlja3NgIGlzIGB0cnVlYCkuXG5cdCAqIFRoaXMgaXMgbm9ybWFsbHkgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIFR3ZWVuIGVuZ2luZSAodmlhIHRoZSB7eyNjcm9zc0xpbmsgXCJUd2Vlbi90aWNrOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50KSwgYnV0IGlzIGV4cG9zZWQgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgdGlja1xuXHQgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEgVGhlIHRpbWUgdG8gYWR2YW5jZSBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIHVzZVRpY2tzIGlzIHRydWUpLlxuXHQgKiovXG5cdHAudGljayA9IGZ1bmN0aW9uKGRlbHRhKSB7XG5cdFx0dGhpcy5zZXRQb3NpdGlvbih0aGlzLl9wcmV2UG9zaXRpb24rZGVsdGEpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJZiBhIG51bWVyaWMgcG9zaXRpb24gaXMgcGFzc2VkLCBpdCBpcyByZXR1cm5lZCB1bmNoYW5nZWQuIElmIGEgc3RyaW5nIGlzIHBhc3NlZCwgdGhlIHBvc2l0aW9uIG9mIHRoZVxuXHQgKiBjb3JyZXNwb25kaW5nIGZyYW1lIGxhYmVsIHdpbGwgYmUgcmV0dXJuZWQsIG9yIGBudWxsYCBpZiBhIG1hdGNoaW5nIGxhYmVsIGlzIG5vdCBkZWZpbmVkLlxuXHQgKiBAbWV0aG9kIHJlc29sdmVcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBwb3NpdGlvbk9yTGFiZWwgQSBudW1lcmljIHBvc2l0aW9uIHZhbHVlIG9yIGxhYmVsIHN0cmluZy5cblx0ICoqL1xuXHRwLnJlc29sdmUgPSBmdW5jdGlvbihwb3NpdGlvbk9yTGFiZWwpIHtcblx0XHR2YXIgcG9zID0gTnVtYmVyKHBvc2l0aW9uT3JMYWJlbCk7XG5cdFx0aWYgKGlzTmFOKHBvcykpIHsgcG9zID0gdGhpcy5fbGFiZWxzW3Bvc2l0aW9uT3JMYWJlbF07IH1cblx0XHRyZXR1cm4gcG9zO1xuXHR9O1xuXG5cdC8qKlxuXHQqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCogQG1ldGhvZCB0b1N0cmluZ1xuXHQqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltUaW1lbGluZV1cIjtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRocm93KFwiVGltZWxpbmUgY2FuIG5vdCBiZSBjbG9uZWQuXCIpXG5cdH07XG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX2dvdG9cblx0ICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IHBvc2l0aW9uT3JMYWJlbFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ290byA9IGZ1bmN0aW9uKHBvc2l0aW9uT3JMYWJlbCkge1xuXHRcdHZhciBwb3MgPSB0aGlzLnJlc29sdmUocG9zaXRpb25PckxhYmVsKTtcblx0XHRpZiAocG9zICE9IG51bGwpIHsgdGhpcy5zZXRQb3NpdGlvbihwb3MpOyB9XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfY2FsY1Bvc2l0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9jYWxjUG9zaXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA8IDApIHsgcmV0dXJuIDA7IH1cblx0XHRpZiAodmFsdWUgPCB0aGlzLmR1cmF0aW9uKSB7IHJldHVybiB2YWx1ZTsgfVxuXHRcdHJldHVybiB0aGlzLmxvb3AgPyB2YWx1ZSV0aGlzLmR1cmF0aW9uIDogdGhpcy5kdXJhdGlvbjtcblx0fTtcblxuXHRjcmVhdGVqcy5UaW1lbGluZSA9IGNyZWF0ZWpzLnByb21vdGUoVGltZWxpbmUsIFwiRXZlbnREaXNwYXRjaGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRWFzZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogVGhlIEVhc2UgY2xhc3MgcHJvdmlkZXMgYSBjb2xsZWN0aW9uIG9mIGVhc2luZyBmdW5jdGlvbnMgZm9yIHVzZSB3aXRoIFR3ZWVuSlMuIEl0IGRvZXMgbm90IHVzZSB0aGUgc3RhbmRhcmQgNCBwYXJhbVxuXHQgKiBlYXNpbmcgc2lnbmF0dXJlLiBJbnN0ZWFkIGl0IHVzZXMgYSBzaW5nbGUgcGFyYW0gd2hpY2ggaW5kaWNhdGVzIHRoZSBjdXJyZW50IGxpbmVhciByYXRpbyAoMCB0byAxKSBvZiB0aGUgdHdlZW4uXG5cdCAqXG5cdCAqIE1vc3QgbWV0aG9kcyBvbiBFYXNlIGNhbiBiZSBwYXNzZWQgZGlyZWN0bHkgYXMgZWFzaW5nIGZ1bmN0aW9uczpcblx0ICpcblx0ICogICAgICBUd2Vlbi5nZXQodGFyZ2V0KS50byh7eDoxMDB9LCA1MDAsIEVhc2UubGluZWFyKTtcblx0ICpcblx0ICogSG93ZXZlciwgbWV0aG9kcyBiZWdpbm5pbmcgd2l0aCBcImdldFwiIHdpbGwgcmV0dXJuIGFuIGVhc2luZyBmdW5jdGlvbiBiYXNlZCBvbiBwYXJhbWV0ZXIgdmFsdWVzOlxuXHQgKlxuXHQgKiAgICAgIFR3ZWVuLmdldCh0YXJnZXQpLnRvKHt5OjIwMH0sIDUwMCwgRWFzZS5nZXRQb3dJbigyLjIpKTtcblx0ICpcblx0ICogUGxlYXNlIHNlZSB0aGUgPGEgaHJlZj1cImh0dHA6Ly93d3cuY3JlYXRlanMuY29tL0RlbW9zL1R3ZWVuSlMvVHdlZW5fU3BhcmtUYWJsZVwiPnNwYXJrIHRhYmxlIGRlbW88L2E+IGZvciBhblxuXHQgKiBvdmVydmlldyBvZiB0aGUgZGlmZmVyZW50IGVhc2UgdHlwZXMgb24gPGEgaHJlZj1cImh0dHA6Ly90d2VlbmpzLmNvbVwiPlR3ZWVuSlMuY29tPC9hPi5cblx0ICpcblx0ICogPGVtPkVxdWF0aW9ucyBkZXJpdmVkIGZyb20gd29yayBieSBSb2JlcnQgUGVubmVyLjwvZW0+XG5cdCAqIEBjbGFzcyBFYXNlXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRmdW5jdGlvbiBFYXNlKCkge1xuXHRcdHRocm93IFwiRWFzZSBjYW5ub3QgYmUgaW5zdGFudGlhdGVkLlwiO1xuXHR9XG5cblxuLy8gc3RhdGljIG1ldGhvZHMgYW5kIHByb3BlcnRpZXNcblx0LyoqXG5cdCAqIEBtZXRob2QgbGluZWFyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UubGluZWFyID0gZnVuY3Rpb24odCkgeyByZXR1cm4gdDsgfTtcblxuXHQvKipcblx0ICogSWRlbnRpY2FsIHRvIGxpbmVhci5cblx0ICogQG1ldGhvZCBub25lXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2Uubm9uZSA9IEVhc2UubGluZWFyO1xuXG5cdC8qKlxuXHQgKiBNaW1pY3MgdGhlIHNpbXBsZSAtMTAwIHRvIDEwMCBlYXNpbmcgaW4gRmxhc2ggUHJvLlxuXHQgKiBAbWV0aG9kIGdldFxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IEEgdmFsdWUgZnJvbSAtMSAoZWFzZSBpbikgdG8gMSAoZWFzZSBvdXQpIGluZGljYXRpbmcgdGhlIHN0cmVuZ3RoIGFuZCBkaXJlY3Rpb24gb2YgdGhlIGVhc2UuXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXQgPSBmdW5jdGlvbihhbW91bnQpIHtcblx0XHRpZiAoYW1vdW50IDwgLTEpIHsgYW1vdW50ID0gLTE7IH1cblx0XHRpZiAoYW1vdW50ID4gMSkgeyBhbW91bnQgPSAxOyB9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdGlmIChhbW91bnQ9PTApIHsgcmV0dXJuIHQ7IH1cblx0XHRcdGlmIChhbW91bnQ8MCkgeyByZXR1cm4gdCoodCotYW1vdW50KzErYW1vdW50KTsgfVxuXHRcdFx0cmV0dXJuIHQqKCgyLXQpKmFtb3VudCsoMS1hbW91bnQpKTtcblx0XHR9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb25maWd1cmFibGUgZXhwb25lbnRpYWwgZWFzZS5cblx0ICogQG1ldGhvZCBnZXRQb3dJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gcG93IFRoZSBleHBvbmVudCB0byB1c2UgKGV4LiAzIHdvdWxkIHJldHVybiBhIGN1YmljIGVhc2UpLlxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0UG93SW4gPSBmdW5jdGlvbihwb3cpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0cmV0dXJuIE1hdGgucG93KHQscG93KTtcblx0XHR9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb25maWd1cmFibGUgZXhwb25lbnRpYWwgZWFzZS5cblx0ICogQG1ldGhvZCBnZXRQb3dPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvdyBUaGUgZXhwb25lbnQgdG8gdXNlIChleC4gMyB3b3VsZCByZXR1cm4gYSBjdWJpYyBlYXNlKS5cblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldFBvd091dCA9IGZ1bmN0aW9uKHBvdykge1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRyZXR1cm4gMS1NYXRoLnBvdygxLXQscG93KTtcblx0XHR9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb25maWd1cmFibGUgZXhwb25lbnRpYWwgZWFzZS5cblx0ICogQG1ldGhvZCBnZXRQb3dJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcG93IFRoZSBleHBvbmVudCB0byB1c2UgKGV4LiAzIHdvdWxkIHJldHVybiBhIGN1YmljIGVhc2UpLlxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0UG93SW5PdXQgPSBmdW5jdGlvbihwb3cpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0aWYgKCh0Kj0yKTwxKSByZXR1cm4gMC41Kk1hdGgucG93KHQscG93KTtcblx0XHRcdHJldHVybiAxLTAuNSpNYXRoLmFicyhNYXRoLnBvdygyLXQscG93KSk7XG5cdFx0fTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBxdWFkSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWFkSW4gPSBFYXNlLmdldFBvd0luKDIpO1xuXHQvKipcblx0ICogQG1ldGhvZCBxdWFkT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVhZE91dCA9IEVhc2UuZ2V0UG93T3V0KDIpO1xuXHQvKipcblx0ICogQG1ldGhvZCBxdWFkSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWFkSW5PdXQgPSBFYXNlLmdldFBvd0luT3V0KDIpO1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGN1YmljSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5jdWJpY0luID0gRWFzZS5nZXRQb3dJbigzKTtcblx0LyoqXG5cdCAqIEBtZXRob2QgY3ViaWNPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5jdWJpY091dCA9IEVhc2UuZ2V0UG93T3V0KDMpO1xuXHQvKipcblx0ICogQG1ldGhvZCBjdWJpY0luT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuY3ViaWNJbk91dCA9IEVhc2UuZ2V0UG93SW5PdXQoMyk7XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgcXVhcnRJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1YXJ0SW4gPSBFYXNlLmdldFBvd0luKDQpO1xuXHQvKipcblx0ICogQG1ldGhvZCBxdWFydE91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1YXJ0T3V0ID0gRWFzZS5nZXRQb3dPdXQoNCk7XG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1YXJ0SW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWFydEluT3V0ID0gRWFzZS5nZXRQb3dJbk91dCg0KTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBxdWludEluXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVpbnRJbiA9IEVhc2UuZ2V0UG93SW4oNSk7XG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1aW50T3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVpbnRPdXQgPSBFYXNlLmdldFBvd091dCg1KTtcblx0LyoqXG5cdCAqIEBtZXRob2QgcXVpbnRJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1aW50SW5PdXQgPSBFYXNlLmdldFBvd0luT3V0KDUpO1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHNpbmVJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnNpbmVJbiA9IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gMS1NYXRoLmNvcyh0Kk1hdGguUEkvMik7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2Qgc2luZU91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnNpbmVPdXQgPSBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIE1hdGguc2luKHQqTWF0aC5QSS8yKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBzaW5lSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5zaW5lSW5PdXQgPSBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIC0wLjUqKE1hdGguY29zKE1hdGguUEkqdCkgLSAxKTtcblx0fTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIFwiYmFjayBpblwiIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0QmFja0luXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgVGhlIHN0cmVuZ3RoIG9mIHRoZSBlYXNlLlxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0QmFja0luID0gZnVuY3Rpb24oYW1vdW50KSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiB0KnQqKChhbW91bnQrMSkqdC1hbW91bnQpO1xuXHRcdH07XG5cdH07XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGJhY2tJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmJhY2tJbiA9IEVhc2UuZ2V0QmFja0luKDEuNyk7XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBcImJhY2sgb3V0XCIgZWFzZS5cblx0ICogQG1ldGhvZCBnZXRCYWNrT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgVGhlIHN0cmVuZ3RoIG9mIHRoZSBlYXNlLlxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0QmFja091dCA9IGZ1bmN0aW9uKGFtb3VudCkge1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRyZXR1cm4gKC0tdCp0KigoYW1vdW50KzEpKnQgKyBhbW91bnQpICsgMSk7XG5cdFx0fTtcblx0fTtcblx0LyoqXG5cdCAqIEBtZXRob2QgYmFja091dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmJhY2tPdXQgPSBFYXNlLmdldEJhY2tPdXQoMS43KTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIFwiYmFjayBpbiBvdXRcIiBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldEJhY2tJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IFRoZSBzdHJlbmd0aCBvZiB0aGUgZWFzZS5cblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldEJhY2tJbk91dCA9IGZ1bmN0aW9uKGFtb3VudCkge1xuXHRcdGFtb3VudCo9MS41MjU7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdGlmICgodCo9Mik8MSkgcmV0dXJuIDAuNSoodCp0KigoYW1vdW50KzEpKnQtYW1vdW50KSk7XG5cdFx0XHRyZXR1cm4gMC41KigodC09MikqdCooKGFtb3VudCsxKSp0K2Ftb3VudCkrMik7XG5cdFx0fTtcblx0fTtcblx0LyoqXG5cdCAqIEBtZXRob2QgYmFja0luT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuYmFja0luT3V0ID0gRWFzZS5nZXRCYWNrSW5PdXQoMS43KTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBjaXJjSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5jaXJjSW4gPSBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIC0oTWF0aC5zcXJ0KDEtdCp0KS0gMSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgY2lyY091dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmNpcmNPdXQgPSBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydCgxLSgtLXQpKnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGNpcmNJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmNpcmNJbk91dCA9IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAoKHQqPTIpIDwgMSkgcmV0dXJuIC0wLjUqKE1hdGguc3FydCgxLXQqdCktMSk7XG5cdFx0cmV0dXJuIDAuNSooTWF0aC5zcXJ0KDEtKHQtPTIpKnQpKzEpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGJvdW5jZUluXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuYm91bmNlSW4gPSBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIDEtRWFzZS5ib3VuY2VPdXQoMS10KTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBib3VuY2VPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5ib3VuY2VPdXQgPSBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKHQgPCAxLzIuNzUpIHtcblx0XHRcdHJldHVybiAoNy41NjI1KnQqdCk7XG5cdFx0fSBlbHNlIGlmICh0IDwgMi8yLjc1KSB7XG5cdFx0XHRyZXR1cm4gKDcuNTYyNSoodC09MS41LzIuNzUpKnQrMC43NSk7XG5cdFx0fSBlbHNlIGlmICh0IDwgMi41LzIuNzUpIHtcblx0XHRcdHJldHVybiAoNy41NjI1Kih0LT0yLjI1LzIuNzUpKnQrMC45Mzc1KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuICg3LjU2MjUqKHQtPTIuNjI1LzIuNzUpKnQgKzAuOTg0Mzc1KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgYm91bmNlSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5ib3VuY2VJbk91dCA9IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAodDwwLjUpIHJldHVybiBFYXNlLmJvdW5jZUluICh0KjIpICogLjU7XG5cdFx0cmV0dXJuIEVhc2UuYm91bmNlT3V0KHQqMi0xKSowLjUrMC41O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb25maWd1cmFibGUgZWxhc3RpYyBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldEVsYXN0aWNJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW1wbGl0dWRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwZXJpb2Rcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldEVsYXN0aWNJbiA9IGZ1bmN0aW9uKGFtcGxpdHVkZSxwZXJpb2QpIHtcblx0XHR2YXIgcGkyID0gTWF0aC5QSSoyO1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRpZiAodD09MCB8fCB0PT0xKSByZXR1cm4gdDtcblx0XHRcdHZhciBzID0gcGVyaW9kL3BpMipNYXRoLmFzaW4oMS9hbXBsaXR1ZGUpO1xuXHRcdFx0cmV0dXJuIC0oYW1wbGl0dWRlKk1hdGgucG93KDIsMTAqKHQtPTEpKSpNYXRoLnNpbigodC1zKSpwaTIvcGVyaW9kKSk7XG5cdFx0fTtcblx0fTtcblx0LyoqXG5cdCAqIEBtZXRob2QgZWxhc3RpY0luXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuZWxhc3RpY0luID0gRWFzZS5nZXRFbGFzdGljSW4oMSwwLjMpO1xuXG5cdC8qKlxuXHQgKiBDb25maWd1cmFibGUgZWxhc3RpYyBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldEVsYXN0aWNPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFtcGxpdHVkZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcGVyaW9kXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRFbGFzdGljT3V0ID0gZnVuY3Rpb24oYW1wbGl0dWRlLHBlcmlvZCkge1xuXHRcdHZhciBwaTIgPSBNYXRoLlBJKjI7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdGlmICh0PT0wIHx8IHQ9PTEpIHJldHVybiB0O1xuXHRcdFx0dmFyIHMgPSBwZXJpb2QvcGkyICogTWF0aC5hc2luKDEvYW1wbGl0dWRlKTtcblx0XHRcdHJldHVybiAoYW1wbGl0dWRlKk1hdGgucG93KDIsLTEwKnQpKk1hdGguc2luKCh0LXMpKnBpMi9wZXJpb2QgKSsxKTtcblx0XHR9O1xuXHR9O1xuXHQvKipcblx0ICogQG1ldGhvZCBlbGFzdGljT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuZWxhc3RpY091dCA9IEVhc2UuZ2V0RWxhc3RpY091dCgxLDAuMyk7XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBlbGFzdGljIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0RWxhc3RpY0luT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbXBsaXR1ZGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBlcmlvZFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0RWxhc3RpY0luT3V0ID0gZnVuY3Rpb24oYW1wbGl0dWRlLHBlcmlvZCkge1xuXHRcdHZhciBwaTIgPSBNYXRoLlBJKjI7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdHZhciBzID0gcGVyaW9kL3BpMiAqIE1hdGguYXNpbigxL2FtcGxpdHVkZSk7XG5cdFx0XHRpZiAoKHQqPTIpPDEpIHJldHVybiAtMC41KihhbXBsaXR1ZGUqTWF0aC5wb3coMiwxMCoodC09MSkpKk1hdGguc2luKCAodC1zKSpwaTIvcGVyaW9kICkpO1xuXHRcdFx0cmV0dXJuIGFtcGxpdHVkZSpNYXRoLnBvdygyLC0xMCoodC09MSkpKk1hdGguc2luKCh0LXMpKnBpMi9wZXJpb2QpKjAuNSsxO1xuXHRcdH07XG5cdH07XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGVsYXN0aWNJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmVsYXN0aWNJbk91dCA9IEVhc2UuZ2V0RWxhc3RpY0luT3V0KDEsMC4zKjEuNSk7XG5cblx0Y3JlYXRlanMuRWFzZSA9IEVhc2U7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBNb3Rpb25HdWlkZVBsdWdpbi5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogQSBUd2VlbkpTIHBsdWdpbiBmb3Igd29ya2luZyB3aXRoIG1vdGlvbiBndWlkZXMuXG5cdCAqXG5cdCAqIFRvIHVzZSwgaW5zdGFsbCB0aGUgcGx1Z2luIGFmdGVyIFR3ZWVuSlMgaGFzIGxvYWRlZC4gTmV4dCB0d2VlbiB0aGUgJ2d1aWRlJyBwcm9wZXJ0eSB3aXRoIGFuIG9iamVjdCBhcyBkZXRhaWxlZCBiZWxvdy5cblx0ICpcblx0ICogICAgICAgY3JlYXRlanMuTW90aW9uR3VpZGVQbHVnaW4uaW5zdGFsbCgpO1xuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgLy8gVXNpbmcgYSBNb3Rpb24gR3VpZGVcblx0ICpcdCAgICBjcmVhdGVqcy5Ud2Vlbi5nZXQodGFyZ2V0KS50byh7Z3VpZGU6eyBwYXRoOlswLDAsIDAsMjAwLDIwMCwyMDAsIDIwMCwwLDAsMF0gfX0sNzAwMCk7XG5cdCAqXHQgICAgLy8gVmlzdWFsaXppbmcgdGhlIGxpbmVcblx0ICpcdCAgICBncmFwaGljcy5tb3ZlVG8oMCwwKS5jdXJ2ZVRvKDAsMjAwLDIwMCwyMDApLmN1cnZlVG8oMjAwLDAsMCwwKTtcblx0ICpcblx0ICogRWFjaCBwYXRoIG5lZWRzIHByZS1jb21wdXRhdGlvbiB0byBlbnN1cmUgdGhlcmUncyBmYXN0IHBlcmZvcm1hbmNlLiBCZWNhdXNlIG9mIHRoZSBwcmUtY29tcHV0YXRpb24gdGhlcmUncyBub1xuXHQgKiBidWlsdCBpbiBzdXBwb3J0IGZvciBwYXRoIGNoYW5nZXMgbWlkIHR3ZWVuLiBUaGVzZSBhcmUgdGhlIEd1aWRlIE9iamVjdCdzIHByb3BlcnRpZXM6PFVMPlxuXHQgKiAgICAgIDxMST4gcGF0aDogUmVxdWlyZWQsIEFycmF5IDogVGhlIHgveSBwb2ludHMgdXNlZCB0byBkcmF3IHRoZSBwYXRoIHdpdGggYSBtb3ZlVG8gYW5kIDEgdG8gbiBjdXJ2ZVRvIGNhbGxzLjwvTEk+XG5cdCAqICAgICAgPExJPiBzdGFydDogT3B0aW9uYWwsIDAtMSA6IEluaXRpYWwgcG9zaXRpb24sIGRlZmF1bHQgMCBleGNlcHQgZm9yIHdoZW4gY29udGludWluZyBhbG9uZyB0aGUgc2FtZSBwYXRoLjwvTEk+XG5cdCAqICAgICAgPExJPiBlbmQ6IE9wdGlvbmFsLCAwLTEgOiBGaW5hbCBwb3NpdGlvbiwgZGVmYXVsdCAxIGlmIG5vdCBzcGVjaWZpZWQuPC9MST5cblx0ICogICAgICA8TEk+IG9yaWVudDogT3B0aW9uYWwsIHN0cmluZyA6IFwiZml4ZWRcIi9cImF1dG9cIi9cImN3XCIvXCJjY3dcIjxVTD5cblx0ICpcdFx0XHRcdDxMST5cImZpeGVkXCIgZm9yY2VzIHRoZSBvYmplY3QgdG8gZmFjZSBkb3duIHRoZSBwYXRoIGFsbCBtb3ZlbWVudCAocmVsYXRpdmUgdG8gc3RhcnQgcm90YXRpb24pLDwvTEk+XG5cdCAqICAgICAgXHRcdDxMST5cImF1dG9cIiByb3RhdGVzIHRoZSBvYmplY3QgYWxvbmcgdGhlIHBhdGggcmVsYXRpdmUgdG8gdGhlIGxpbmUuPC9MST5cblx0ICogICAgICBcdFx0PExJPlwiY3dcIi9cImNjd1wiIGZvcmNlIGNsb2Nrd2lzZSBvciBjb3VudGVyIGNsb2Nrd2lzZSByb3RhdGlvbnMgaW5jbHVkaW5nIGZsYXNoIGxpa2UgYmVoYXZpb3VyPC9MST5cblx0ICogXHRcdDwvVUw+PC9MST5cblx0ICogPC9VTD5cblx0ICogR3VpZGUgb2JqZWN0cyBzaG91bGQgbm90IGJlIHNoYXJlZCBiZXR3ZWVuIHR3ZWVucyBldmVuIGlmIGFsbCBwcm9wZXJ0aWVzIGFyZSBpZGVudGljYWwsIHRoZSBsaWJyYXJ5IHN0b3Jlc1xuXHQgKiBpbmZvcm1hdGlvbiBvbiB0aGVzZSBvYmplY3RzIGluIHRoZSBiYWNrZ3JvdW5kIGFuZCBzaGFyaW5nIHRoZW0gY2FuIGNhdXNlIHVuZXhwZWN0ZWQgYmVoYXZpb3VyLiBWYWx1ZXNcblx0ICogb3V0c2lkZSAwLTEgcmFuZ2Ugb2YgdHdlZW5zIHdpbGwgYmUgYSBcImJlc3QgZ3Vlc3NcIiBmcm9tIHRoZSBhcHByb3ByaWF0ZSBwYXJ0IG9mIHRoZSBkZWZpbmVkIGN1cnZlLlxuXHQgKlxuXHQgKiBAY2xhc3MgTW90aW9uR3VpZGVQbHVnaW5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gTW90aW9uR3VpZGVQbHVnaW4oKSB7XG5cdFx0dGhyb3coXCJNb3Rpb25HdWlkZVBsdWdpbiBjYW5ub3QgYmUgaW5zdGFudGlhdGVkLlwiKVxuXHR9O1xuXG5cbi8vIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQHByb3BlcnR5IHByaW9yaXR5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLnByaW9yaXR5ID0gMDsgLy8gaGlnaCBwcmlvcml0eSwgc2hvdWxkIHJ1biBzb29uZXJcblxuXHQvKipcblx0ICogQHByb3BlcnR5IHRlbXBvcmFyeSB2YXJpYWJsZSBzdG9yYWdlXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLl9yb3RPZmZTO1xuXHQvKipcblx0ICogQHByb3BlcnR5IHRlbXBvcmFyeSB2YXJpYWJsZSBzdG9yYWdlXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLl9yb3RPZmZFO1xuXHQvKipcblx0ICogQHByb3BlcnR5IHRlbXBvcmFyeSB2YXJpYWJsZSBzdG9yYWdlXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLl9yb3ROb3JtUztcblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB0ZW1wb3JhcnkgdmFyaWFibGUgc3RvcmFnZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRNb3Rpb25HdWlkZVBsdWdpbi5fcm90Tm9ybUU7XG5cblxuLy8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIEluc3RhbGxzIHRoaXMgcGx1Z2luIGZvciB1c2Ugd2l0aCBUd2VlbkpTLiBDYWxsIHRoaXMgb25jZSBhZnRlciBUd2VlbkpTIGlzIGxvYWRlZCB0byBlbmFibGUgdGhpcyBwbHVnaW4uXG5cdCAqIEBtZXRob2QgaW5zdGFsbFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0TW90aW9uR3VpZGVQbHVnaW4uaW5zdGFsbCA9IGZ1bmN0aW9uKCkge1xuXHRcdGNyZWF0ZWpzLlR3ZWVuLmluc3RhbGxQbHVnaW4oTW90aW9uR3VpZGVQbHVnaW4sIFtcImd1aWRlXCIsIFwieFwiLCBcInlcIiwgXCJyb3RhdGlvblwiXSk7XG5cdFx0cmV0dXJuIGNyZWF0ZWpzLlR3ZWVuLklHTk9SRTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBpbml0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLmluaXQgPSBmdW5jdGlvbih0d2VlbiwgcHJvcCwgdmFsdWUpIHtcblx0XHR2YXIgdGFyZ2V0ID0gdHdlZW4udGFyZ2V0O1xuXHRcdGlmKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoXCJ4XCIpKXsgdGFyZ2V0LnggPSAwOyB9XG5cdFx0aWYoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShcInlcIikpeyB0YXJnZXQueSA9IDA7IH1cblx0XHRpZighdGFyZ2V0Lmhhc093blByb3BlcnR5KFwicm90YXRpb25cIikpeyB0YXJnZXQucm90YXRpb24gPSAwOyB9XG5cblx0XHRpZihwcm9wPT1cInJvdGF0aW9uXCIpeyB0d2Vlbi5fX25lZWRzUm90ID0gdHJ1ZTsgfVxuXHRcdHJldHVybiBwcm9wPT1cImd1aWRlXCI/bnVsbDp2YWx1ZTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBzdGVwXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLnN0ZXAgPSBmdW5jdGlvbih0d2VlbiwgcHJvcCwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGluamVjdFByb3BzKSB7XG5cdFx0Ly8gb3RoZXIgcHJvcHNcblx0XHRpZihwcm9wID09IFwicm90YXRpb25cIil7XG5cdFx0XHR0d2Vlbi5fX3JvdEdsb2JhbFMgPSBzdGFydFZhbHVlO1xuXHRcdFx0dHdlZW4uX19yb3RHbG9iYWxFID0gZW5kVmFsdWU7XG5cdFx0XHRNb3Rpb25HdWlkZVBsdWdpbi50ZXN0Um90RGF0YSh0d2VlbiwgaW5qZWN0UHJvcHMpO1xuXHRcdH1cblx0XHRpZihwcm9wICE9IFwiZ3VpZGVcIil7IHJldHVybiBlbmRWYWx1ZTsgfVxuXG5cdFx0Ly8gZ3VpZGUgb25seSBpbmZvcm1hdGlvbiAtIFN0YXJ0IC1cblx0XHR2YXIgdGVtcCwgZGF0YSA9IGVuZFZhbHVlO1xuXHRcdGlmKCFkYXRhLmhhc093blByb3BlcnR5KFwicGF0aFwiKSl7IGRhdGEucGF0aCA9IFtdOyB9XG5cdFx0dmFyIHBhdGggPSBkYXRhLnBhdGg7XG5cdFx0aWYoIWRhdGEuaGFzT3duUHJvcGVydHkoXCJlbmRcIikpeyBkYXRhLmVuZCA9IDE7IH1cblx0XHRpZighZGF0YS5oYXNPd25Qcm9wZXJ0eShcInN0YXJ0XCIpKXtcblx0XHRcdGRhdGEuc3RhcnQgPSAoc3RhcnRWYWx1ZSYmc3RhcnRWYWx1ZS5oYXNPd25Qcm9wZXJ0eShcImVuZFwiKSYmc3RhcnRWYWx1ZS5wYXRoPT09cGF0aCk/c3RhcnRWYWx1ZS5lbmQ6MDtcblx0XHR9XG5cblx0XHQvLyBGaWd1cmUgb3V0IHN1YmxpbmUgaW5mb3JtYXRpb25cblx0XHRpZihkYXRhLmhhc093blByb3BlcnR5KFwiX3NlZ21lbnRzXCIpICYmIGRhdGEuX2xlbmd0aCl7IHJldHVybiBlbmRWYWx1ZTsgfVxuXHRcdHZhciBsID0gcGF0aC5sZW5ndGg7XG5cdFx0dmFyIGFjY3VyYWN5ID0gMTA7XHRcdC8vIEFkanVzdCB0byBpbXByb3ZlIGxpbmUgZm9sbG93aW5nIHByZWNpc2lvbiBidXQgc2FjcmlmaWNlIHBlcmZvcm1hbmNlICgjIG9mIHNlZylcblx0XHRpZihsID49IDYgJiYgKGwtMikgJSA0ID09IDApe1x0Ly8gRW5vdWdoIHBvaW50cyAmJiBjb250YWlucyBjb3JyZWN0IG51bWJlciBwZXIgZW50cnkgaWdub3Jpbmcgc3RhcnRcblx0XHRcdGRhdGEuX3NlZ21lbnRzID0gW107XG5cdFx0XHRkYXRhLl9sZW5ndGggPSAwO1xuXHRcdFx0Zm9yKHZhciBpPTI7IGk8bDsgaSs9NCl7XG5cdFx0XHRcdHZhciBzeCA9IHBhdGhbaS0yXSwgc3kgPSBwYXRoW2ktMV07XG5cdFx0XHRcdHZhciBjeCA9IHBhdGhbaSswXSwgY3kgPSBwYXRoW2krMV07XG5cdFx0XHRcdHZhciBleCA9IHBhdGhbaSsyXSwgZXkgPSBwYXRoW2krM107XG5cdFx0XHRcdHZhciBvbGRYID0gc3gsIG9sZFkgPSBzeTtcblx0XHRcdFx0dmFyIHRlbXBYLCB0ZW1wWSwgdG90YWwgPSAwO1xuXHRcdFx0XHR2YXIgc3VibGluZXMgPSBbXTtcblx0XHRcdFx0Zm9yKHZhciBqPTE7IGo8PWFjY3VyYWN5OyBqKyspe1xuXHRcdFx0XHRcdHZhciB0ID0gai9hY2N1cmFjeTtcblx0XHRcdFx0XHR2YXIgaW52ID0gMSAtIHQ7XG5cdFx0XHRcdFx0dGVtcFggPSBpbnYqaW52ICogc3ggKyAyICogaW52ICogdCAqIGN4ICsgdCp0ICogZXg7XG5cdFx0XHRcdFx0dGVtcFkgPSBpbnYqaW52ICogc3kgKyAyICogaW52ICogdCAqIGN5ICsgdCp0ICogZXk7XG5cdFx0XHRcdFx0dG90YWwgKz0gc3VibGluZXNbc3VibGluZXMucHVzaChNYXRoLnNxcnQoKHRlbXA9dGVtcFgtb2xkWCkqdGVtcCArICh0ZW1wPXRlbXBZLW9sZFkpKnRlbXApKS0xXTtcblx0XHRcdFx0XHRvbGRYID0gdGVtcFg7XG5cdFx0XHRcdFx0b2xkWSA9IHRlbXBZO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGEuX3NlZ21lbnRzLnB1c2godG90YWwpO1xuXHRcdFx0XHRkYXRhLl9zZWdtZW50cy5wdXNoKHN1YmxpbmVzKTtcblx0XHRcdFx0ZGF0YS5fbGVuZ3RoICs9IHRvdGFsO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyhcImludmFsaWQgJ3BhdGgnIGRhdGEsIHBsZWFzZSBzZWUgZG9jdW1lbnRhdGlvbiBmb3IgdmFsaWQgcGF0aHNcIik7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0dXAgeC95IHR3ZWVuc1xuXHRcdHRlbXAgPSBkYXRhLm9yaWVudDtcblx0XHRkYXRhLm9yaWVudCA9IHRydWU7XG5cdFx0dmFyIG8gPSB7fTtcblx0XHRNb3Rpb25HdWlkZVBsdWdpbi5jYWxjKGRhdGEsIGRhdGEuc3RhcnQsIG8pO1xuXHRcdHR3ZWVuLl9fcm90UGF0aFMgPSBOdW1iZXIoby5yb3RhdGlvbi50b0ZpeGVkKDUpKTtcblx0XHRNb3Rpb25HdWlkZVBsdWdpbi5jYWxjKGRhdGEsIGRhdGEuZW5kLCBvKTtcblx0XHR0d2Vlbi5fX3JvdFBhdGhFID0gTnVtYmVyKG8ucm90YXRpb24udG9GaXhlZCg1KSk7XG5cdFx0ZGF0YS5vcmllbnQgPSBmYWxzZTtcdC8vaGVyZSBhbmQgbm93IHdlIGRvbid0IGtub3cgaWYgd2UgbmVlZCB0b1xuXHRcdE1vdGlvbkd1aWRlUGx1Z2luLmNhbGMoZGF0YSwgZGF0YS5lbmQsIGluamVjdFByb3BzKTtcblx0XHRkYXRhLm9yaWVudCA9IHRlbXA7XG5cblx0XHQvLyBTZXR1cCByb3RhdGlvbiBwcm9wZXJ0aWVzXG5cdFx0aWYoIWRhdGEub3JpZW50KXsgcmV0dXJuIGVuZFZhbHVlOyB9XG5cdFx0dHdlZW4uX19ndWlkZURhdGEgPSBkYXRhO1xuXHRcdE1vdGlvbkd1aWRlUGx1Z2luLnRlc3RSb3REYXRhKHR3ZWVuLCBpbmplY3RQcm9wcyk7XG5cdFx0cmV0dXJuIGVuZFZhbHVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHRlc3RSb3REYXRhXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLnRlc3RSb3REYXRhID0gZnVuY3Rpb24odHdlZW4sIGluamVjdFByb3BzKXtcblxuXHRcdC8vIG5vIHJvdGF0aW9uIGluZm9ybWF0PyBpZiB3ZSBuZWVkIGl0IGNvbWUgYmFjaywgaWYgd2UgZG9uJ3QgdXNlIDAgJiBlbnN1cmUgd2UgaGF2ZSBndWlkZSBkYXRhXG5cdFx0aWYodHdlZW4uX19yb3RHbG9iYWxTID09PSB1bmRlZmluZWQgfHwgdHdlZW4uX19yb3RHbG9iYWxFID09PSB1bmRlZmluZWQpe1xuXHRcdFx0aWYodHdlZW4uX19uZWVkc1JvdCl7IHJldHVybjsgfVxuXHRcdFx0aWYodHdlZW4uX2N1clF1ZXVlUHJvcHMucm90YXRpb24gIT09IHVuZGVmaW5lZCl7XG5cdFx0XHRcdHR3ZWVuLl9fcm90R2xvYmFsUyA9IHR3ZWVuLl9fcm90R2xvYmFsRSA9IHR3ZWVuLl9jdXJRdWV1ZVByb3BzLnJvdGF0aW9uO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uX19yb3RHbG9iYWxTID0gdHdlZW4uX19yb3RHbG9iYWxFID0gaW5qZWN0UHJvcHMucm90YXRpb24gPSB0d2Vlbi50YXJnZXQucm90YXRpb24gfHwgMDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYodHdlZW4uX19ndWlkZURhdGEgPT09IHVuZGVmaW5lZCl7IHJldHVybjsgfVxuXG5cdFx0Ly8gUHJvY2VzcyByb3RhdGlvbiBwcm9wZXJ0aWVzXG5cdFx0dmFyIGRhdGEgPSB0d2Vlbi5fX2d1aWRlRGF0YTtcblx0XHR2YXIgcm90R2xvYmFsRCA9IHR3ZWVuLl9fcm90R2xvYmFsRSAtIHR3ZWVuLl9fcm90R2xvYmFsUztcblx0XHR2YXIgcm90UGF0aEQgPSB0d2Vlbi5fX3JvdFBhdGhFIC0gdHdlZW4uX19yb3RQYXRoUztcblx0XHR2YXIgcm90ID0gcm90R2xvYmFsRCAtIHJvdFBhdGhEO1xuXG5cdFx0aWYoZGF0YS5vcmllbnQgPT0gXCJhdXRvXCIpe1xuXHRcdFx0aWYocm90ID4gMTgwKXtcdFx0XHRyb3QgLT0gMzYwOyB9XG5cdFx0XHRlbHNlIGlmKHJvdCA8IC0xODApe1x0cm90ICs9IDM2MDsgfVxuXG5cdFx0fSBlbHNlIGlmKGRhdGEub3JpZW50ID09IFwiY3dcIil7XG5cdFx0XHR3aGlsZShyb3QgPCAwKXsgcm90ICs9IDM2MDsgfVxuXHRcdFx0aWYocm90ID09IDAgJiYgcm90R2xvYmFsRCA+IDAgJiYgcm90R2xvYmFsRCAhPSAxODApeyByb3QgKz0gMzYwOyB9XG5cblx0XHR9IGVsc2UgaWYoZGF0YS5vcmllbnQgPT0gXCJjY3dcIil7XG5cdFx0XHRyb3QgPSByb3RHbG9iYWxEIC0gKChyb3RQYXRoRCA+IDE4MCk/KDM2MC1yb3RQYXRoRCk6KHJvdFBhdGhEKSk7XHQvLyBzaWduIGZsaXBwaW5nIG9uIHBhdGhcblx0XHRcdHdoaWxlKHJvdCA+IDApeyByb3QgLT0gMzYwOyB9XG5cdFx0XHRpZihyb3QgPT0gMCAmJiByb3RHbG9iYWxEIDwgMCAmJiByb3RHbG9iYWxEICE9IC0xODApeyByb3QgLT0gMzYwOyB9XG5cdFx0fVxuXG5cdFx0ZGF0YS5yb3REZWx0YSA9IHJvdDtcblx0XHRkYXRhLnJvdE9mZlMgPSB0d2Vlbi5fX3JvdEdsb2JhbFMgLSB0d2Vlbi5fX3JvdFBhdGhTO1xuXG5cdFx0Ly8gcmVzZXRcblx0XHR0d2Vlbi5fX3JvdEdsb2JhbFMgPSB0d2Vlbi5fX3JvdEdsb2JhbEUgPSB0d2Vlbi5fX2d1aWRlRGF0YSA9IHR3ZWVuLl9fbmVlZHNSb3QgPSB1bmRlZmluZWQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgdHdlZW5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0TW90aW9uR3VpZGVQbHVnaW4udHdlZW4gPSBmdW5jdGlvbih0d2VlbiwgcHJvcCwgdmFsdWUsIHN0YXJ0VmFsdWVzLCBlbmRWYWx1ZXMsIHJhdGlvLCB3YWl0LCBlbmQpIHtcblx0XHR2YXIgZGF0YSA9IGVuZFZhbHVlcy5ndWlkZTtcblx0XHRpZihkYXRhID09IHVuZGVmaW5lZCB8fCBkYXRhID09PSBzdGFydFZhbHVlcy5ndWlkZSl7IHJldHVybiB2YWx1ZTsgfVxuXHRcdGlmKGRhdGEubGFzdFJhdGlvICE9IHJhdGlvKXtcblx0XHRcdC8vIGZpcnN0IHRpbWUgdGhyb3VnaCBzbyBjYWxjdWxhdGUgd2hhdCBJIG5lZWQgdG9cblx0XHRcdHZhciB0ID0gKChkYXRhLmVuZC1kYXRhLnN0YXJ0KSood2FpdD9kYXRhLmVuZDpyYXRpbykrZGF0YS5zdGFydCk7XG5cdFx0XHRNb3Rpb25HdWlkZVBsdWdpbi5jYWxjKGRhdGEsIHQsIHR3ZWVuLnRhcmdldCk7XG5cdFx0XHRzd2l0Y2goZGF0YS5vcmllbnQpe1xuXHRcdFx0XHRjYXNlIFwiY3dcIjpcdFx0Ly8gbWl4IGluIHRoZSBvcmlnaW5hbCByb3RhdGlvblxuXHRcdFx0XHRjYXNlIFwiY2N3XCI6XG5cdFx0XHRcdGNhc2UgXCJhdXRvXCI6IHR3ZWVuLnRhcmdldC5yb3RhdGlvbiArPSBkYXRhLnJvdE9mZlMgKyBkYXRhLnJvdERlbHRhKnJhdGlvOyBicmVhaztcblx0XHRcdFx0Y2FzZSBcImZpeGVkXCI6XHQvLyBmb2xsb3cgZml4ZWQgYmVoYXZpb3VyIHRvIHNvbHZlIHBvdGVudGlhbCBpc3N1ZXNcblx0XHRcdFx0ZGVmYXVsdDogdHdlZW4udGFyZ2V0LnJvdGF0aW9uICs9IGRhdGEucm90T2ZmUzsgYnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRkYXRhLmxhc3RSYXRpbyA9IHJhdGlvO1xuXHRcdH1cblx0XHRpZihwcm9wID09IFwicm90YXRpb25cIiAmJiAoKCFkYXRhLm9yaWVudCkgfHwgZGF0YS5vcmllbnQgPT0gXCJmYWxzZVwiKSl7IHJldHVybiB2YWx1ZTsgfVxuXHRcdHJldHVybiB0d2Vlbi50YXJnZXRbcHJvcF07XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSB0aGUgYXBwcm9wcmlhdGUgeC95L3JvdGF0aW9uIGluZm9ybWF0aW9uIGFib3V0IGEgcGF0aCBmb3IgYSBnaXZlbiByYXRpbyBhbG9uZyB0aGUgcGF0aC5cblx0ICogQXNzdW1lcyBhIHBhdGggb2JqZWN0IHdpdGggYWxsIG9wdGlvbmFsIHBhcmFtZXRlcnMgc3BlY2lmaWVkLlxuXHQgKiBAcGFyYW0gZGF0YSBEYXRhIG9iamVjdCB5b3Ugd291bGQgcGFzcyB0byB0aGUgXCJndWlkZTpcIiBwcm9wZXJ0eSBpbiBhIFR3ZWVuXG5cdCAqIEBwYXJhbSByYXRpbyAwLTEgRGlzdGFuY2UgYWxvbmcgcGF0aCwgdmFsdWVzIG91dHNpZGUgMC0xIGFyZSBcImJlc3QgZ3Vlc3NcIlxuXHQgKiBAcGFyYW0gdGFyZ2V0IE9iamVjdCB0byBjb3B5IHRoZSByZXN1bHRzIG9udG8sIHdpbGwgdXNlIGEgbmV3IG9iamVjdCBpZiBub3Qgc3VwcGxpZWQuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIHRhcmdldCBvYmplY3Qgb3IgYSBuZXcgb2JqZWN0IHcvIHRoZSB0d2VlbmVkIHByb3BlcnRpZXNcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0TW90aW9uR3VpZGVQbHVnaW4uY2FsYyA9IGZ1bmN0aW9uKGRhdGEsIHJhdGlvLCB0YXJnZXQpIHtcblx0XHRpZihkYXRhLl9zZWdtZW50cyA9PSB1bmRlZmluZWQpeyB0aHJvdyhcIk1pc3NpbmcgY3JpdGljYWwgcHJlLWNhbGN1bGF0ZWQgaW5mb3JtYXRpb24sIHBsZWFzZSBmaWxlIGEgYnVnXCIpOyB9XG5cdFx0aWYodGFyZ2V0ID09IHVuZGVmaW5lZCl7IHRhcmdldCA9IHt4OjAsIHk6MCwgcm90YXRpb246MH07IH1cblx0XHR2YXIgc2VnID0gZGF0YS5fc2VnbWVudHM7XG5cdFx0dmFyIHBhdGggPSBkYXRhLnBhdGg7XG5cblx0XHQvLyBmaW5kIHNlZ21lbnRcblx0XHR2YXIgcG9zID0gZGF0YS5fbGVuZ3RoICogcmF0aW87XG5cdFx0dmFyIGNhcCA9IHNlZy5sZW5ndGggLSAyO1xuXHRcdHZhciBuID0gMDtcblx0XHR3aGlsZShwb3MgPiBzZWdbbl0gJiYgbiA8IGNhcCl7XG5cdFx0XHRwb3MgLT0gc2VnW25dO1xuXHRcdFx0bis9Mjtcblx0XHR9XG5cblx0XHQvLyBmaW5kIHN1YmxpbmVcblx0XHR2YXIgc3VibGluZXMgPSBzZWdbbisxXTtcblx0XHR2YXIgaSA9IDA7XG5cdFx0Y2FwID0gc3VibGluZXMubGVuZ3RoLTE7XG5cdFx0d2hpbGUocG9zID4gc3VibGluZXNbaV0gJiYgaSA8IGNhcCl7XG5cdFx0XHRwb3MgLT0gc3VibGluZXNbaV07XG5cdFx0XHRpKys7XG5cdFx0fVxuXHRcdHZhciB0ID0gKGkvKytjYXApKyhwb3MvKGNhcCpzdWJsaW5lc1tpXSkpO1xuXG5cdFx0Ly8gZmluZCB4L3lcblx0XHRuID0gKG4qMikrMjtcblx0XHR2YXIgaW52ID0gMSAtIHQ7XG5cdFx0dGFyZ2V0LnggPSBpbnYqaW52ICogcGF0aFtuLTJdICsgMiAqIGludiAqIHQgKiBwYXRoW24rMF0gKyB0KnQgKiBwYXRoW24rMl07XG5cdFx0dGFyZ2V0LnkgPSBpbnYqaW52ICogcGF0aFtuLTFdICsgMiAqIGludiAqIHQgKiBwYXRoW24rMV0gKyB0KnQgKiBwYXRoW24rM107XG5cblx0XHQvLyBvcmllbnRhdGlvblxuXHRcdGlmKGRhdGEub3JpZW50KXtcblx0XHRcdHRhcmdldC5yb3RhdGlvbiA9IDU3LjI5NTc3OTUgKiBNYXRoLmF0YW4yKFxuXHRcdFx0XHQocGF0aFtuKzFdLXBhdGhbbi0xXSkqaW52ICsgKHBhdGhbbiszXS1wYXRoW24rMV0pKnQsXG5cdFx0XHRcdChwYXRoW24rMF0tcGF0aFtuLTJdKSppbnYgKyAocGF0aFtuKzJdLXBhdGhbbiswXSkqdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fTtcblxuXHRjcmVhdGVqcy5Nb3Rpb25HdWlkZVBsdWdpbiA9IE1vdGlvbkd1aWRlUGx1Z2luO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gdmVyc2lvbi5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogU3RhdGljIGNsYXNzIGhvbGRpbmcgbGlicmFyeSBzcGVjaWZpYyBpbmZvcm1hdGlvbiBzdWNoIGFzIHRoZSB2ZXJzaW9uIGFuZCBidWlsZERhdGUgb2Zcblx0ICogdGhlIGxpYnJhcnkuXG5cdCAqIEBjbGFzcyBUd2VlbkpTXG5cdCAqKi9cblx0dmFyIHMgPSBjcmVhdGVqcy5Ud2VlbkpTID0gY3JlYXRlanMuVHdlZW5KUyB8fCB7fTtcblxuXHQvKipcblx0ICogVGhlIHZlcnNpb24gc3RyaW5nIGZvciB0aGlzIHJlbGVhc2UuXG5cdCAqIEBwcm9wZXJ0eSB2ZXJzaW9uXG5cdCAqIEB0eXBlIFN0cmluZ1xuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0cy52ZXJzaW9uID0gLyo9dmVyc2lvbiovXCIwLjYuMlwiOyAvLyBpbmplY3RlZCBieSBidWlsZCBwcm9jZXNzXG5cblx0LyoqXG5cdCAqIFRoZSBidWlsZCBkYXRlIGZvciB0aGlzIHJlbGVhc2UgaW4gVVRDIGZvcm1hdC5cblx0ICogQHByb3BlcnR5IGJ1aWxkRGF0ZVxuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdHMuYnVpbGREYXRlID0gLyo9ZGF0ZSovXCJUaHUsIDI2IE5vdiAyMDE1IDIwOjQ0OjMxIEdNVFwiOyAvLyBpbmplY3RlZCBieSBidWlsZCBwcm9jZXNzXG5cbn0pKCk7XG5pZih0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikgbW9kdWxlLmV4cG9ydHMgPSB0aGlzLmNyZWF0ZWpzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jcmVhdGVqcy1tb2R1bGUvY3JlYXRlanMuanNcbi8vIG1vZHVsZSBpZCA9IDEzNDNcbi8vIG1vZHVsZSBjaHVua3MgPSA4Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1343\n");

/***/ })

});